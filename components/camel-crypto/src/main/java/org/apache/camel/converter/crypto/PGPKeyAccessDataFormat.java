begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.converter.crypto
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|converter
operator|.
name|crypto
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|SecureRandom
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|Security
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|SignatureException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|DataFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|DataFormatName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|ExchangeHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|builder
operator|.
name|OutputStreamBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|service
operator|.
name|ServiceSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|IOHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|bcpg
operator|.
name|ArmoredOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|bcpg
operator|.
name|CompressionAlgorithmTags
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|bcpg
operator|.
name|HashAlgorithmTags
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|bcpg
operator|.
name|SymmetricKeyAlgorithmTags
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|jce
operator|.
name|provider
operator|.
name|BouncyCastleProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|PGPCompressedData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|PGPCompressedDataGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|PGPEncryptedDataGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|PGPEncryptedDataList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|PGPException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|PGPLiteralData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|PGPLiteralDataGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|PGPObjectFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|PGPOnePassSignature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|PGPOnePassSignatureList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|PGPPrivateKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|PGPPublicKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|PGPPublicKeyEncryptedData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|PGPSignature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|PGPSignatureGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|PGPSignatureList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|PGPSignatureSubpacketGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|PGPUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|operator
operator|.
name|bc
operator|.
name|BcKeyFingerprintCalculator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|operator
operator|.
name|jcajce
operator|.
name|JcaPGPContentSignerBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|operator
operator|.
name|jcajce
operator|.
name|JcaPGPContentVerifierBuilderProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|operator
operator|.
name|jcajce
operator|.
name|JcePGPDataEncryptorBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|operator
operator|.
name|jcajce
operator|.
name|JcePublicKeyDataDecryptorFactoryBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|operator
operator|.
name|jcajce
operator|.
name|JcePublicKeyKeyEncryptionMethodGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * This PGP Data Format uses the interfaces {@link PGPPublicKeyAccessor} and  * {@link PGPSecretKeyAccessor} to access the keys for encryption/signing and  * decryption/signature verification. These interfaces allow caching of the keys  * which can improve the performance.  *<p>  * If you want to provide the key access via keyrings in the format of a byte  * array or file, then you should use the class {@link PGPDataFormat}.  */
end_comment

begin_class
DECL|class|PGPKeyAccessDataFormat
specifier|public
class|class
name|PGPKeyAccessDataFormat
extends|extends
name|ServiceSupport
implements|implements
name|DataFormat
implements|,
name|DataFormatName
block|{
DECL|field|KEY_USERID
specifier|public
specifier|static
specifier|final
name|String
name|KEY_USERID
init|=
literal|"CamelPGPDataFormatKeyUserid"
decl_stmt|;
DECL|field|KEY_USERIDS
specifier|public
specifier|static
specifier|final
name|String
name|KEY_USERIDS
init|=
literal|"CamelPGPDataFormatKeyUserids"
decl_stmt|;
DECL|field|SIGNATURE_KEY_USERID
specifier|public
specifier|static
specifier|final
name|String
name|SIGNATURE_KEY_USERID
init|=
literal|"CamelPGPDataFormatSignatureKeyUserid"
decl_stmt|;
DECL|field|SIGNATURE_KEY_USERIDS
specifier|public
specifier|static
specifier|final
name|String
name|SIGNATURE_KEY_USERIDS
init|=
literal|"CamelPGPDataFormatSignatureKeyUserids"
decl_stmt|;
DECL|field|ENCRYPTION_ALGORITHM
specifier|public
specifier|static
specifier|final
name|String
name|ENCRYPTION_ALGORITHM
init|=
literal|"CamelPGPDataFormatEncryptionAlgorithm"
decl_stmt|;
DECL|field|SIGNATURE_HASH_ALGORITHM
specifier|public
specifier|static
specifier|final
name|String
name|SIGNATURE_HASH_ALGORITHM
init|=
literal|"CamelPGPDataFormatSignatureHashAlgorithm"
decl_stmt|;
DECL|field|COMPRESSION_ALGORITHM
specifier|public
specifier|static
specifier|final
name|String
name|COMPRESSION_ALGORITHM
init|=
literal|"CamelPGPDataFormatCompressionAlgorithm"
decl_stmt|;
comment|/**      * Signature verification option "optional": Used during unmarshaling. The      * PGP message can or cannot contain signatures. If it does contain      * signatures then one of them is verified. This is the default option.      */
DECL|field|SIGNATURE_VERIFICATION_OPTION_OPTIONAL
specifier|public
specifier|static
specifier|final
name|String
name|SIGNATURE_VERIFICATION_OPTION_OPTIONAL
init|=
literal|"optional"
decl_stmt|;
comment|/**      * Signature verification option "required": Used during unmarshaling. It is      * checked that the PGP message does contain at least one signature. If this      * is not the case a {@link PGPException} is thrown. One of the contained       * signatures is verified.      */
DECL|field|SIGNATURE_VERIFICATION_OPTION_REQUIRED
specifier|public
specifier|static
specifier|final
name|String
name|SIGNATURE_VERIFICATION_OPTION_REQUIRED
init|=
literal|"required"
decl_stmt|;
comment|/**      * Signature verification option "required": Used during unmarshaling. If       * the PGP message contains signatures then they are ignored. No       * verification takes place.      */
DECL|field|SIGNATURE_VERIFICATION_OPTION_IGNORE
specifier|public
specifier|static
specifier|final
name|String
name|SIGNATURE_VERIFICATION_OPTION_IGNORE
init|=
literal|"ignore"
decl_stmt|;
comment|/**      * Signature verification option "no signature allowed": Used during      * unmarshaling. It is checked that the PGP message does contain not any      * signatures. If this is not the case a {@link PGPException} is thrown.      */
DECL|field|SIGNATURE_VERIFICATION_OPTION_NO_SIGNATURE_ALLOWED
specifier|public
specifier|static
specifier|final
name|String
name|SIGNATURE_VERIFICATION_OPTION_NO_SIGNATURE_ALLOWED
init|=
literal|"no_signature_allowed"
decl_stmt|;
comment|/**      * During encryption the number of asymmetric encryption keys is set to this      * header parameter. The Value is of type Integer.      */
DECL|field|NUMBER_OF_ENCRYPTION_KEYS
specifier|public
specifier|static
specifier|final
name|String
name|NUMBER_OF_ENCRYPTION_KEYS
init|=
literal|"CamelPGPDataFormatNumberOfEncryptionKeys"
decl_stmt|;
comment|/**      * During signing the number of signing keys is set to this header      * parameter. This corresponds to the number of signatures. The Value is of      * type Integer.      */
DECL|field|NUMBER_OF_SIGNING_KEYS
specifier|public
specifier|static
specifier|final
name|String
name|NUMBER_OF_SIGNING_KEYS
init|=
literal|"CamelPGPDataFormatNumberOfSigningKeys"
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|PGPKeyAccessDataFormat
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|SIGNATURE_VERIFICATION_OPTIONS
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|SIGNATURE_VERIFICATION_OPTIONS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|String
index|[]
block|{
name|SIGNATURE_VERIFICATION_OPTION_OPTIONAL
block|,
name|SIGNATURE_VERIFICATION_OPTION_REQUIRED
block|,
name|SIGNATURE_VERIFICATION_OPTION_IGNORE
block|,
name|SIGNATURE_VERIFICATION_OPTION_NO_SIGNATURE_ALLOWED
block|}
argument_list|)
decl_stmt|;
DECL|field|BC
specifier|private
specifier|static
specifier|final
name|String
name|BC
init|=
literal|"BC"
decl_stmt|;
DECL|field|BUFFER_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|BUFFER_SIZE
init|=
literal|16
operator|*
literal|1024
decl_stmt|;
DECL|field|publicKeyAccessor
name|PGPPublicKeyAccessor
name|publicKeyAccessor
decl_stmt|;
DECL|field|secretKeyAccessor
name|PGPSecretKeyAccessor
name|secretKeyAccessor
decl_stmt|;
comment|// Java Cryptography Extension provider, default is Bouncy Castle
DECL|field|provider
specifier|private
name|String
name|provider
init|=
name|BC
decl_stmt|;
comment|// encryption / decryption key info (required)
DECL|field|keyUserid
specifier|private
name|String
name|keyUserid
decl_stmt|;
comment|// only for encryption
comment|//in addition you can specify further User IDs, in this case the symmetric key is encrypted by several public keys corresponding to the User Ids
DECL|field|keyUserids
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|keyUserids
decl_stmt|;
comment|//only for encryption;
comment|// signature / verification key info (optional)
DECL|field|signatureKeyUserid
specifier|private
name|String
name|signatureKeyUserid
decl_stmt|;
comment|// for signing and verification (optional for verification)
comment|//For verification you can specify further User IDs in addition
DECL|field|signatureKeyUserids
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|signatureKeyUserids
decl_stmt|;
comment|//only for signing with several keys and verifying;
DECL|field|armored
specifier|private
name|boolean
name|armored
decl_stmt|;
comment|// for encryption
DECL|field|integrity
specifier|private
name|boolean
name|integrity
init|=
literal|true
decl_stmt|;
comment|// for encryption
DECL|field|hashAlgorithm
specifier|private
name|int
name|hashAlgorithm
init|=
name|HashAlgorithmTags
operator|.
name|SHA1
decl_stmt|;
comment|// for signature
DECL|field|algorithm
specifier|private
name|int
name|algorithm
init|=
name|SymmetricKeyAlgorithmTags
operator|.
name|CAST5
decl_stmt|;
comment|// for encryption
DECL|field|compressionAlgorithm
specifier|private
name|int
name|compressionAlgorithm
init|=
name|CompressionAlgorithmTags
operator|.
name|ZIP
decl_stmt|;
comment|// for encryption
DECL|field|withCompressedDataPacket
specifier|private
name|boolean
name|withCompressedDataPacket
init|=
literal|true
decl_stmt|;
comment|// for encryption
DECL|field|signatureVerificationOption
specifier|private
name|String
name|signatureVerificationOption
init|=
literal|"optional"
decl_stmt|;
comment|/*      * The default value "_CONSOLE" marks the file as For Your Eyes Only... may      * cause problems for the receiver if they use an automated process to      * decrypt as the filename is appended with _CONSOLE      */
DECL|field|fileName
specifier|private
name|String
name|fileName
init|=
name|PGPLiteralData
operator|.
name|CONSOLE
decl_stmt|;
DECL|method|PGPKeyAccessDataFormat ()
specifier|public
name|PGPKeyAccessDataFormat
parameter_list|()
block|{     }
annotation|@
name|Override
DECL|method|getDataFormatName ()
specifier|public
name|String
name|getDataFormatName
parameter_list|()
block|{
return|return
literal|"pgp"
return|;
block|}
DECL|method|findKeyUserid (Exchange exchange)
specifier|protected
name|String
name|findKeyUserid
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|KEY_USERID
argument_list|,
name|getKeyUserid
argument_list|()
argument_list|,
name|String
operator|.
name|class
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|findKeyUserids (Exchange exchange)
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|findKeyUserids
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|KEY_USERIDS
argument_list|,
name|getKeyUserids
argument_list|()
argument_list|,
name|List
operator|.
name|class
argument_list|)
return|;
block|}
DECL|method|findSignatureKeyUserid (Exchange exchange)
specifier|protected
name|String
name|findSignatureKeyUserid
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|SIGNATURE_KEY_USERID
argument_list|,
name|getSignatureKeyUserid
argument_list|()
argument_list|,
name|String
operator|.
name|class
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|findSignatureKeyUserids (Exchange exchange)
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|findSignatureKeyUserids
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|SIGNATURE_KEY_USERIDS
argument_list|,
name|getSignatureKeyUserids
argument_list|()
argument_list|,
name|List
operator|.
name|class
argument_list|)
return|;
block|}
DECL|method|findCompressionAlgorithm (Exchange exchange)
specifier|protected
name|int
name|findCompressionAlgorithm
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|COMPRESSION_ALGORITHM
argument_list|,
name|getCompressionAlgorithm
argument_list|()
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
return|;
block|}
DECL|method|findAlgorithm (Exchange exchange)
specifier|protected
name|int
name|findAlgorithm
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|ENCRYPTION_ALGORITHM
argument_list|,
name|getAlgorithm
argument_list|()
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
return|;
block|}
DECL|method|findHashAlgorithm (Exchange exchange)
specifier|protected
name|int
name|findHashAlgorithm
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|SIGNATURE_HASH_ALGORITHM
argument_list|,
name|getHashAlgorithm
argument_list|()
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
return|;
block|}
DECL|method|findFileName (Exchange exchange)
specifier|protected
name|String
name|findFileName
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|Exchange
operator|.
name|FILE_NAME
argument_list|,
name|getFileName
argument_list|()
argument_list|,
name|String
operator|.
name|class
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|marshal (Exchange exchange, Object graph, OutputStream outputStream)
specifier|public
name|void
name|marshal
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|graph
parameter_list|,
name|OutputStream
name|outputStream
parameter_list|)
throws|throws
name|Exception
block|{
comment|//NOPMD
name|List
argument_list|<
name|String
argument_list|>
name|userids
init|=
name|determineEncryptionUserIds
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|PGPPublicKey
argument_list|>
name|keys
init|=
name|publicKeyAccessor
operator|.
name|getEncryptionKeys
argument_list|(
name|exchange
argument_list|,
name|userids
argument_list|)
decl_stmt|;
if|if
condition|(
name|keys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot PGP encrypt message. No public encryption key found for the User Ids "
operator|+
name|userids
operator|+
literal|" in the public keyring. Either specify other User IDs or add correct public keys to the keyring."
argument_list|)
throw|;
block|}
name|exchange
operator|.
name|getOut
argument_list|()
operator|.
name|setHeader
argument_list|(
name|NUMBER_OF_ENCRYPTION_KEYS
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|keys
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|InputStream
name|input
init|=
name|ExchangeHelper
operator|.
name|convertToMandatoryType
argument_list|(
name|exchange
argument_list|,
name|InputStream
operator|.
name|class
argument_list|,
name|graph
argument_list|)
decl_stmt|;
if|if
condition|(
name|armored
condition|)
block|{
name|outputStream
operator|=
operator|new
name|ArmoredOutputStream
argument_list|(
name|outputStream
argument_list|)
expr_stmt|;
block|}
name|PGPEncryptedDataGenerator
name|encGen
init|=
operator|new
name|PGPEncryptedDataGenerator
argument_list|(
operator|new
name|JcePGPDataEncryptorBuilder
argument_list|(
name|findAlgorithm
argument_list|(
name|exchange
argument_list|)
argument_list|)
operator|.
name|setWithIntegrityPacket
argument_list|(
name|integrity
argument_list|)
operator|.
name|setSecureRandom
argument_list|(
operator|new
name|SecureRandom
argument_list|()
argument_list|)
operator|.
name|setProvider
argument_list|(
name|getProvider
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// several keys can be added
for|for
control|(
name|PGPPublicKey
name|key
range|:
name|keys
control|)
block|{
name|encGen
operator|.
name|addMethod
argument_list|(
operator|new
name|JcePublicKeyKeyEncryptionMethodGenerator
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OutputStream
name|encOut
init|=
name|encGen
operator|.
name|open
argument_list|(
name|outputStream
argument_list|,
operator|new
name|byte
index|[
name|BUFFER_SIZE
index|]
argument_list|)
decl_stmt|;
name|OutputStream
name|comOut
decl_stmt|;
if|if
condition|(
name|withCompressedDataPacket
condition|)
block|{
name|PGPCompressedDataGenerator
name|comData
init|=
operator|new
name|PGPCompressedDataGenerator
argument_list|(
name|findCompressionAlgorithm
argument_list|(
name|exchange
argument_list|)
argument_list|)
decl_stmt|;
name|comOut
operator|=
operator|new
name|BufferedOutputStream
argument_list|(
name|comData
operator|.
name|open
argument_list|(
name|encOut
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|comOut
operator|=
name|encOut
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"No Compressed Data packet is added"
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|PGPSignatureGenerator
argument_list|>
name|sigGens
init|=
name|createSignatureGenerator
argument_list|(
name|exchange
argument_list|,
name|comOut
argument_list|)
decl_stmt|;
name|PGPLiteralDataGenerator
name|litData
init|=
operator|new
name|PGPLiteralDataGenerator
argument_list|()
decl_stmt|;
name|String
name|fileName
init|=
name|findFileName
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
name|OutputStream
name|litOut
init|=
name|litData
operator|.
name|open
argument_list|(
name|comOut
argument_list|,
name|PGPLiteralData
operator|.
name|BINARY
argument_list|,
name|fileName
argument_list|,
operator|new
name|Date
argument_list|()
argument_list|,
operator|new
name|byte
index|[
name|BUFFER_SIZE
index|]
argument_list|)
decl_stmt|;
try|try
block|{
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
name|BUFFER_SIZE
index|]
decl_stmt|;
name|int
name|bytesRead
decl_stmt|;
while|while
condition|(
operator|(
name|bytesRead
operator|=
name|input
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|litOut
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|bytesRead
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigGens
operator|!=
literal|null
operator|&&
operator|!
name|sigGens
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|PGPSignatureGenerator
name|sigGen
range|:
name|sigGens
control|)
block|{
comment|// not nested therefore it is the same for all
comment|// can this be improved that we only do it for one sigGen and set the result on the others?
name|sigGen
operator|.
name|update
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|bytesRead
argument_list|)
expr_stmt|;
block|}
block|}
name|litOut
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|IOHelper
operator|.
name|close
argument_list|(
name|litOut
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigGens
operator|!=
literal|null
operator|&&
operator|!
name|sigGens
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// reverse order
for|for
control|(
name|int
name|i
init|=
name|sigGens
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>
operator|-
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|PGPSignatureGenerator
name|sigGen
init|=
name|sigGens
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|sigGen
operator|.
name|generate
argument_list|()
operator|.
name|encode
argument_list|(
name|comOut
argument_list|)
expr_stmt|;
block|}
block|}
name|IOHelper
operator|.
name|close
argument_list|(
name|comOut
argument_list|,
name|encOut
argument_list|,
name|outputStream
argument_list|,
name|input
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|determineEncryptionUserIds (Exchange exchange)
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|determineEncryptionUserIds
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|String
name|userid
init|=
name|findKeyUserid
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|userids
init|=
name|findKeyUserids
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
comment|// merge them together
name|List
argument_list|<
name|String
argument_list|>
name|result
decl_stmt|;
if|if
condition|(
name|userid
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|userids
operator|==
literal|null
operator|||
name|userids
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|result
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
name|userid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|userids
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
name|userid
argument_list|)
expr_stmt|;
name|result
operator|.
name|addAll
argument_list|(
name|userids
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|userids
operator|==
literal|null
operator|||
name|userids
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cannot PGP encrypt message. No User ID of the public key specified."
argument_list|)
throw|;
block|}
name|result
operator|=
name|userids
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|determineSignaturenUserIds (Exchange exchange)
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|determineSignaturenUserIds
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|String
name|userid
init|=
name|findSignatureKeyUserid
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|userids
init|=
name|findSignatureKeyUserids
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
comment|// merge them together
name|List
argument_list|<
name|String
argument_list|>
name|result
decl_stmt|;
if|if
condition|(
name|userid
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|userids
operator|==
literal|null
operator|||
name|userids
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|result
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
name|userid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|userids
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
name|userid
argument_list|)
expr_stmt|;
name|result
operator|.
name|addAll
argument_list|(
name|userids
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// userids can be empty or null!
name|result
operator|=
name|userids
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|createSignatureGenerator (Exchange exchange, OutputStream out)
specifier|protected
name|List
argument_list|<
name|PGPSignatureGenerator
argument_list|>
name|createSignatureGenerator
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|OutputStream
name|out
parameter_list|)
throws|throws
name|Exception
block|{
comment|//NOPMD
if|if
condition|(
name|secretKeyAccessor
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|sigKeyUserids
init|=
name|determineSignaturenUserIds
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|PGPSecretKeyAndPrivateKeyAndUserId
argument_list|>
name|sigSecretKeysWithPrivateKeyAndUserId
init|=
name|secretKeyAccessor
operator|.
name|getSignerKeys
argument_list|(
name|exchange
argument_list|,
name|sigKeyUserids
argument_list|)
decl_stmt|;
if|if
condition|(
name|sigSecretKeysWithPrivateKeyAndUserId
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|exchange
operator|.
name|getOut
argument_list|()
operator|.
name|setHeader
argument_list|(
name|NUMBER_OF_SIGNING_KEYS
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|sigSecretKeysWithPrivateKeyAndUserId
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|PGPSignatureGenerator
argument_list|>
name|sigGens
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|PGPSecretKeyAndPrivateKeyAndUserId
name|sigSecretKeyWithPrivateKeyAndUserId
range|:
name|sigSecretKeysWithPrivateKeyAndUserId
control|)
block|{
name|PGPPrivateKey
name|sigPrivateKey
init|=
name|sigSecretKeyWithPrivateKeyAndUserId
operator|.
name|getPrivateKey
argument_list|()
decl_stmt|;
name|PGPSignatureSubpacketGenerator
name|spGen
init|=
operator|new
name|PGPSignatureSubpacketGenerator
argument_list|()
decl_stmt|;
name|spGen
operator|.
name|setSignerUserID
argument_list|(
literal|false
argument_list|,
name|sigSecretKeyWithPrivateKeyAndUserId
operator|.
name|getUserId
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|algorithm
init|=
name|sigSecretKeyWithPrivateKeyAndUserId
operator|.
name|getSecretKey
argument_list|()
operator|.
name|getPublicKey
argument_list|()
operator|.
name|getAlgorithm
argument_list|()
decl_stmt|;
name|PGPSignatureGenerator
name|sigGen
init|=
operator|new
name|PGPSignatureGenerator
argument_list|(
operator|new
name|JcaPGPContentSignerBuilder
argument_list|(
name|algorithm
argument_list|,
name|findHashAlgorithm
argument_list|(
name|exchange
argument_list|)
argument_list|)
operator|.
name|setProvider
argument_list|(
name|getProvider
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|sigGen
operator|.
name|init
argument_list|(
name|PGPSignature
operator|.
name|BINARY_DOCUMENT
argument_list|,
name|sigPrivateKey
argument_list|)
expr_stmt|;
name|sigGen
operator|.
name|setHashedSubpackets
argument_list|(
name|spGen
operator|.
name|generate
argument_list|()
argument_list|)
expr_stmt|;
name|sigGen
operator|.
name|generateOnePassVersion
argument_list|(
literal|false
argument_list|)
operator|.
name|encode
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|sigGens
operator|.
name|add
argument_list|(
name|sigGen
argument_list|)
expr_stmt|;
block|}
return|return
name|sigGens
return|;
block|}
annotation|@
name|Override
DECL|method|unmarshal (Exchange exchange, InputStream encryptedStream)
specifier|public
name|Object
name|unmarshal
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|InputStream
name|encryptedStream
parameter_list|)
throws|throws
name|Exception
block|{
comment|//NOPMD
if|if
condition|(
name|encryptedStream
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|InputStream
name|in
init|=
literal|null
decl_stmt|;
name|InputStream
name|encData
init|=
literal|null
decl_stmt|;
name|InputStream
name|uncompressedData
init|=
literal|null
decl_stmt|;
name|InputStream
name|litData
init|=
literal|null
decl_stmt|;
name|OutputStreamBuilder
name|osb
init|=
literal|null
decl_stmt|;
try|try
block|{
name|in
operator|=
name|PGPUtil
operator|.
name|getDecoderStream
argument_list|(
name|encryptedStream
argument_list|)
expr_stmt|;
name|DecryptedDataAndPPublicKeyEncryptedData
name|encDataAndPbe
init|=
name|getDecryptedData
argument_list|(
name|exchange
argument_list|,
name|in
argument_list|)
decl_stmt|;
name|encData
operator|=
name|encDataAndPbe
operator|.
name|getDecryptedData
argument_list|()
expr_stmt|;
name|PGPObjectFactory
name|pgpFactory
init|=
operator|new
name|PGPObjectFactory
argument_list|(
name|encData
argument_list|,
operator|new
name|BcKeyFingerprintCalculator
argument_list|()
argument_list|)
decl_stmt|;
name|Object
name|object
init|=
name|pgpFactory
operator|.
name|nextObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|object
operator|instanceof
name|PGPCompressedData
condition|)
block|{
name|PGPCompressedData
name|comData
init|=
operator|(
name|PGPCompressedData
operator|)
name|object
decl_stmt|;
name|uncompressedData
operator|=
name|comData
operator|.
name|getDataStream
argument_list|()
expr_stmt|;
name|pgpFactory
operator|=
operator|new
name|PGPObjectFactory
argument_list|(
name|uncompressedData
argument_list|,
operator|new
name|BcKeyFingerprintCalculator
argument_list|()
argument_list|)
expr_stmt|;
name|object
operator|=
name|pgpFactory
operator|.
name|nextObject
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"PGP Message does not contain a Compressed Data Packet"
argument_list|)
expr_stmt|;
block|}
name|PGPOnePassSignature
name|signature
decl_stmt|;
if|if
condition|(
name|object
operator|instanceof
name|PGPOnePassSignatureList
condition|)
block|{
name|signature
operator|=
name|getSignature
argument_list|(
name|exchange
argument_list|,
operator|(
name|PGPOnePassSignatureList
operator|)
name|object
argument_list|)
expr_stmt|;
name|object
operator|=
name|pgpFactory
operator|.
name|nextObject
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// no signature contained in PGP message
name|signature
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|SIGNATURE_VERIFICATION_OPTION_REQUIRED
operator|.
name|equals
argument_list|(
name|getSignatureVerificationOption
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PGPException
argument_list|(
literal|"PGP message does not contain any signatures although a signature is expected. Either send a PGP message with signature or change the configuration of the PGP decryptor."
argument_list|)
throw|;
block|}
block|}
name|PGPLiteralData
name|ld
decl_stmt|;
if|if
condition|(
name|object
operator|instanceof
name|PGPLiteralData
condition|)
block|{
name|ld
operator|=
operator|(
name|PGPLiteralData
operator|)
name|object
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|getFormatException
argument_list|()
throw|;
block|}
name|litData
operator|=
name|ld
operator|.
name|getInputStream
argument_list|()
expr_stmt|;
name|osb
operator|=
name|OutputStreamBuilder
operator|.
name|withExchange
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
name|BUFFER_SIZE
index|]
decl_stmt|;
name|int
name|bytesRead
decl_stmt|;
while|while
condition|(
operator|(
name|bytesRead
operator|=
name|litData
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|osb
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|bytesRead
argument_list|)
expr_stmt|;
if|if
condition|(
name|signature
operator|!=
literal|null
condition|)
block|{
name|signature
operator|.
name|update
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|bytesRead
argument_list|)
expr_stmt|;
block|}
name|osb
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
name|verifySignature
argument_list|(
name|pgpFactory
argument_list|,
name|signature
argument_list|)
expr_stmt|;
name|PGPPublicKeyEncryptedData
name|pbe
init|=
name|encDataAndPbe
operator|.
name|getPbe
argument_list|()
decl_stmt|;
if|if
condition|(
name|pbe
operator|.
name|isIntegrityProtected
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|pbe
operator|.
name|verify
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PGPException
argument_list|(
literal|"Message failed integrity check"
argument_list|)
throw|;
block|}
block|}
block|}
finally|finally
block|{
name|IOHelper
operator|.
name|close
argument_list|(
name|osb
argument_list|,
name|litData
argument_list|,
name|uncompressedData
argument_list|,
name|encData
argument_list|,
name|in
argument_list|,
name|encryptedStream
argument_list|)
expr_stmt|;
block|}
return|return
name|osb
operator|.
name|build
argument_list|()
return|;
block|}
DECL|method|getDecryptedData (Exchange exchange, InputStream encryptedStream)
specifier|private
name|DecryptedDataAndPPublicKeyEncryptedData
name|getDecryptedData
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|InputStream
name|encryptedStream
parameter_list|)
throws|throws
name|Exception
throws|,
name|PGPException
block|{
name|PGPObjectFactory
name|pgpFactory
init|=
operator|new
name|PGPObjectFactory
argument_list|(
name|encryptedStream
argument_list|,
operator|new
name|BcKeyFingerprintCalculator
argument_list|()
argument_list|)
decl_stmt|;
name|Object
name|firstObject
init|=
name|pgpFactory
operator|.
name|nextObject
argument_list|()
decl_stmt|;
comment|// the first object might be a PGP marker packet
name|PGPEncryptedDataList
name|enc
init|=
name|getEcryptedDataList
argument_list|(
name|pgpFactory
argument_list|,
name|firstObject
argument_list|)
decl_stmt|;
if|if
condition|(
name|enc
operator|==
literal|null
condition|)
block|{
throw|throw
name|getFormatException
argument_list|()
throw|;
block|}
name|PGPPublicKeyEncryptedData
name|pbe
init|=
literal|null
decl_stmt|;
name|PGPPrivateKey
name|key
init|=
literal|null
decl_stmt|;
comment|// find encrypted data for which a private key exists in the secret key ring
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|enc
operator|.
name|size
argument_list|()
operator|&&
name|key
operator|==
literal|null
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|encryptedData
init|=
name|enc
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|encryptedData
operator|instanceof
name|PGPPublicKeyEncryptedData
operator|)
condition|)
block|{
throw|throw
name|getFormatException
argument_list|()
throw|;
block|}
name|pbe
operator|=
operator|(
name|PGPPublicKeyEncryptedData
operator|)
name|encryptedData
expr_stmt|;
name|key
operator|=
name|secretKeyAccessor
operator|.
name|getPrivateKey
argument_list|(
name|exchange
argument_list|,
name|pbe
operator|.
name|getKeyID
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
block|{
comment|// take the first key
break|break;
block|}
block|}
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|PGPException
argument_list|(
literal|"PGP message is encrypted with a key which could not be found in the Secret Keyring."
argument_list|)
throw|;
block|}
name|InputStream
name|encData
init|=
name|pbe
operator|.
name|getDataStream
argument_list|(
operator|new
name|JcePublicKeyDataDecryptorFactoryBuilder
argument_list|()
operator|.
name|setProvider
argument_list|(
name|getProvider
argument_list|()
argument_list|)
operator|.
name|build
argument_list|(
name|key
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|DecryptedDataAndPPublicKeyEncryptedData
argument_list|(
name|encData
argument_list|,
name|pbe
argument_list|)
return|;
block|}
DECL|method|getEcryptedDataList (PGPObjectFactory pgpFactory, Object firstObject)
specifier|private
name|PGPEncryptedDataList
name|getEcryptedDataList
parameter_list|(
name|PGPObjectFactory
name|pgpFactory
parameter_list|,
name|Object
name|firstObject
parameter_list|)
throws|throws
name|IOException
block|{
name|PGPEncryptedDataList
name|enc
decl_stmt|;
if|if
condition|(
name|firstObject
operator|instanceof
name|PGPEncryptedDataList
condition|)
block|{
name|enc
operator|=
operator|(
name|PGPEncryptedDataList
operator|)
name|firstObject
expr_stmt|;
block|}
else|else
block|{
name|Object
name|secondObject
init|=
name|pgpFactory
operator|.
name|nextObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|secondObject
operator|instanceof
name|PGPEncryptedDataList
condition|)
block|{
name|enc
operator|=
operator|(
name|PGPEncryptedDataList
operator|)
name|secondObject
expr_stmt|;
block|}
else|else
block|{
name|enc
operator|=
literal|null
expr_stmt|;
block|}
block|}
return|return
name|enc
return|;
block|}
DECL|method|verifySignature (PGPObjectFactory pgpFactory, PGPOnePassSignature signature)
specifier|private
name|void
name|verifySignature
parameter_list|(
name|PGPObjectFactory
name|pgpFactory
parameter_list|,
name|PGPOnePassSignature
name|signature
parameter_list|)
throws|throws
name|IOException
throws|,
name|PGPException
throws|,
name|SignatureException
block|{
if|if
condition|(
name|signature
operator|!=
literal|null
condition|)
block|{
name|PGPSignatureList
name|sigList
init|=
operator|(
name|PGPSignatureList
operator|)
name|pgpFactory
operator|.
name|nextObject
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|signature
operator|.
name|verify
argument_list|(
name|getSignatureWithKeyId
argument_list|(
name|signature
operator|.
name|getKeyID
argument_list|()
argument_list|,
name|sigList
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SignatureException
argument_list|(
literal|"Verification of the PGP signature with the key ID "
operator|+
name|signature
operator|.
name|getKeyID
argument_list|()
operator|+
literal|" failed. The PGP message may have been tampered."
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|getFormatException ()
specifier|private
name|IllegalArgumentException
name|getFormatException
parameter_list|()
block|{
return|return
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The input message body has an invalid format. The PGP decryption/verification processor expects a sequence of PGP packets of the form "
operator|+
literal|"(entries in brackets are optional and ellipses indicate repetition, comma represents  sequential composition, and vertical bar separates alternatives): "
operator|+
literal|"Public Key Encrypted Session Key ..., Symmetrically Encrypted Data | Sym. Encrypted and Integrity Protected Data, (Compressed Data,) (One Pass Signature ...,) "
operator|+
literal|"Literal Data, (Signature ...,)"
argument_list|)
return|;
block|}
DECL|method|getSignatureWithKeyId (long keyID, PGPSignatureList sigList)
specifier|protected
name|PGPSignature
name|getSignatureWithKeyId
parameter_list|(
name|long
name|keyID
parameter_list|,
name|PGPSignatureList
name|sigList
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sigList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|PGPSignature
name|signature
init|=
name|sigList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyID
operator|==
name|signature
operator|.
name|getKeyID
argument_list|()
condition|)
block|{
return|return
name|signature
return|;
block|}
block|}
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"PGP signature is inconsistent"
argument_list|)
throw|;
block|}
DECL|method|getSignature (Exchange exchange, PGPOnePassSignatureList signatureList)
specifier|protected
name|PGPOnePassSignature
name|getSignature
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|PGPOnePassSignatureList
name|signatureList
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|SIGNATURE_VERIFICATION_OPTION_IGNORE
operator|.
name|equals
argument_list|(
name|getSignatureVerificationOption
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|SIGNATURE_VERIFICATION_OPTION_NO_SIGNATURE_ALLOWED
operator|.
name|equals
argument_list|(
name|getSignatureVerificationOption
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|PGPException
argument_list|(
literal|"PGP message contains a signature although a signature is not expected. Either change the configuration of the PGP decryptor or send a PGP message with no signature."
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|allowedUserIds
init|=
name|determineSignaturenUserIds
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|signatureList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|PGPOnePassSignature
name|signature
init|=
name|signatureList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Determine public key from signature keyId
name|PGPPublicKey
name|sigPublicKey
init|=
name|publicKeyAccessor
operator|.
name|getPublicKey
argument_list|(
name|exchange
argument_list|,
name|signature
operator|.
name|getKeyID
argument_list|()
argument_list|,
name|allowedUserIds
argument_list|)
decl_stmt|;
if|if
condition|(
name|sigPublicKey
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
comment|// choose that signature for which a public key exists!
name|signature
operator|.
name|init
argument_list|(
operator|new
name|JcaPGPContentVerifierBuilderProvider
argument_list|()
operator|.
name|setProvider
argument_list|(
name|getProvider
argument_list|()
argument_list|)
argument_list|,
name|sigPublicKey
argument_list|)
expr_stmt|;
return|return
name|signature
return|;
block|}
if|if
condition|(
name|signatureList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot verify the PGP signature: No public key found for the key ID(s) contained in the PGP signature(s). "
operator|+
literal|"Either the received PGP message contains a signature from an unexpected sender or the Public Keyring does not contain the public key of the sender."
argument_list|)
throw|;
block|}
block|}
comment|/**      * Sets if the encrypted file should be written in ascii visible text (for      * marshaling).      */
DECL|method|setArmored (boolean armored)
specifier|public
name|void
name|setArmored
parameter_list|(
name|boolean
name|armored
parameter_list|)
block|{
name|this
operator|.
name|armored
operator|=
name|armored
expr_stmt|;
block|}
DECL|method|getArmored ()
specifier|public
name|boolean
name|getArmored
parameter_list|()
block|{
return|return
name|this
operator|.
name|armored
return|;
block|}
comment|/**      * Whether or not to add an integrity check/sign to the encrypted file for      * marshaling.      */
DECL|method|setIntegrity (boolean integrity)
specifier|public
name|void
name|setIntegrity
parameter_list|(
name|boolean
name|integrity
parameter_list|)
block|{
name|this
operator|.
name|integrity
operator|=
name|integrity
expr_stmt|;
block|}
DECL|method|getIntegrity ()
specifier|public
name|boolean
name|getIntegrity
parameter_list|()
block|{
return|return
name|this
operator|.
name|integrity
return|;
block|}
comment|/**      * User ID, or more precisely user ID part, of the key used for encryption.      * See also {@link #setKeyUserids(List<String>)}.      */
DECL|method|setKeyUserid (String keyUserid)
specifier|public
name|void
name|setKeyUserid
parameter_list|(
name|String
name|keyUserid
parameter_list|)
block|{
name|this
operator|.
name|keyUserid
operator|=
name|keyUserid
expr_stmt|;
block|}
DECL|method|getKeyUserid ()
specifier|public
name|String
name|getKeyUserid
parameter_list|()
block|{
return|return
name|keyUserid
return|;
block|}
DECL|method|getKeyUserids ()
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getKeyUserids
parameter_list|()
block|{
return|return
name|keyUserids
return|;
block|}
comment|/**      * Keys User IDs, or more precisely user ID parts, used for determining the      * public keys for encryption. If you just have one User ID, then you can      * also use the method {@link #setKeyUserid(String)}. The User ID specified      * in {@link #setKeyUserid(String)} and in this method will be merged      * together and the public keys which have a User ID which contain a value      * of the specified User IDs the will be used for the encryption. Be aware      * that you may get several public keys even if you specify only one User      * Id, because there can be several public keys which have a User ID which      * contains the specified User ID.      */
DECL|method|setKeyUserids (List<String> keyUserids)
specifier|public
name|void
name|setKeyUserids
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|keyUserids
parameter_list|)
block|{
name|this
operator|.
name|keyUserids
operator|=
name|keyUserids
expr_stmt|;
block|}
comment|/**      * Userid, or more precisely user ID part, of the signature key used for      * signing (marshal) and verifying (unmarshal). See also      * {@link #setSignatureKeyUserids(List)}.      */
DECL|method|setSignatureKeyUserid (String signatureKeyUserid)
specifier|public
name|void
name|setSignatureKeyUserid
parameter_list|(
name|String
name|signatureKeyUserid
parameter_list|)
block|{
name|this
operator|.
name|signatureKeyUserid
operator|=
name|signatureKeyUserid
expr_stmt|;
block|}
DECL|method|getSignatureKeyUserid ()
specifier|public
name|String
name|getSignatureKeyUserid
parameter_list|()
block|{
return|return
name|signatureKeyUserid
return|;
block|}
DECL|method|getSignatureKeyUserids ()
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getSignatureKeyUserids
parameter_list|()
block|{
return|return
name|signatureKeyUserids
return|;
block|}
comment|/**      * User IDs, or more precisely user ID parts, used for signing and      * verification.      *<p>      * In the signing case, the User IDs specify the private keys which are used      * for signing. If the result are several private keys then several      * signatures will be created. If you just have one signature User ID, then      * you can also use the method {@link #setSignatureKeyUserid(String)} or      * this method. The User ID specified in      * {@link #setSignatureKeyUserid(String)} and in this method will be merged      * together and the private keys which have a User Id which contain one      * value out of the specified UserIds will be used for the signature      * creation. Be aware that you may get several private keys even if you      * specify only one User Id, because there can be several private keys which      * have a User ID which contains the specified User ID.      *<p>      * In the verification case the User IDs restrict the set of public keys      * which can be used for verification. The public keys used for verification      * must contain a User ID which contain one value of the User ID list. If      * you neither specify in this method and nor specify in the method      * {@link #setSignatureKeyUserid(String)} any value then any public key in      * the public key ring will be taken into consideration for the      * verification.      *<p>      * If you just have one User ID, then you can also use the method      * {@link #setSignatureKeyUserid(String)}. The User ID specified in      * {@link #setSignatureKeyUserid(String)} and in this method will be merged      * together and the corresponding public keys represent the potential keys      * for the verification of the message.      */
DECL|method|setSignatureKeyUserids (List<String> signatureKeyUserids)
specifier|public
name|void
name|setSignatureKeyUserids
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|signatureKeyUserids
parameter_list|)
block|{
name|this
operator|.
name|signatureKeyUserids
operator|=
name|signatureKeyUserids
expr_stmt|;
block|}
DECL|method|getProvider ()
specifier|public
name|String
name|getProvider
parameter_list|()
block|{
return|return
name|provider
return|;
block|}
comment|/**      * Java Cryptography Extension (JCE) provider, default is Bouncy Castle      * ("BC"). Alternatively you can use, for example, the IAIK JCE provider; in      * this case the provider must be registered beforehand and the Bouncy      * Castle provider must not be registered beforehand. The Sun JCE provider      * does not work.      */
DECL|method|setProvider (String provider)
specifier|public
name|void
name|setProvider
parameter_list|(
name|String
name|provider
parameter_list|)
block|{
name|this
operator|.
name|provider
operator|=
name|provider
expr_stmt|;
block|}
DECL|method|getCompressionAlgorithm ()
specifier|public
name|int
name|getCompressionAlgorithm
parameter_list|()
block|{
return|return
name|compressionAlgorithm
return|;
block|}
comment|/**      * Compression algorithm used during marshaling. Possible values are defined      * in {@link CompressionAlgorithmTags}. Default value is ZIP.      */
DECL|method|setCompressionAlgorithm (int compressionAlgorithm)
specifier|public
name|void
name|setCompressionAlgorithm
parameter_list|(
name|int
name|compressionAlgorithm
parameter_list|)
block|{
name|this
operator|.
name|compressionAlgorithm
operator|=
name|compressionAlgorithm
expr_stmt|;
block|}
DECL|method|getHashAlgorithm ()
specifier|public
name|int
name|getHashAlgorithm
parameter_list|()
block|{
return|return
name|hashAlgorithm
return|;
block|}
comment|/**      * Digest algorithm for signing (marshaling). Possible values are defined in      * {@link HashAlgorithmTags}. Default value is SHA1.      */
DECL|method|setHashAlgorithm (int hashAlgorithm)
specifier|public
name|void
name|setHashAlgorithm
parameter_list|(
name|int
name|hashAlgorithm
parameter_list|)
block|{
name|this
operator|.
name|hashAlgorithm
operator|=
name|hashAlgorithm
expr_stmt|;
block|}
DECL|method|getAlgorithm ()
specifier|public
name|int
name|getAlgorithm
parameter_list|()
block|{
return|return
name|algorithm
return|;
block|}
comment|/**      * Symmetric key algorithm for encryption (marshaling). Possible values are      * defined in {@link SymmetricKeyAlgorithmTags}. Default value is CAST5.      */
DECL|method|setAlgorithm (int algorithm)
specifier|public
name|void
name|setAlgorithm
parameter_list|(
name|int
name|algorithm
parameter_list|)
block|{
name|this
operator|.
name|algorithm
operator|=
name|algorithm
expr_stmt|;
block|}
DECL|method|getPublicKeyAccessor ()
specifier|public
name|PGPPublicKeyAccessor
name|getPublicKeyAccessor
parameter_list|()
block|{
return|return
name|publicKeyAccessor
return|;
block|}
DECL|method|setPublicKeyAccessor (PGPPublicKeyAccessor publicKeyAccessor)
specifier|public
name|void
name|setPublicKeyAccessor
parameter_list|(
name|PGPPublicKeyAccessor
name|publicKeyAccessor
parameter_list|)
block|{
name|this
operator|.
name|publicKeyAccessor
operator|=
name|publicKeyAccessor
expr_stmt|;
block|}
DECL|method|getSecretKeyAccessor ()
specifier|public
name|PGPSecretKeyAccessor
name|getSecretKeyAccessor
parameter_list|()
block|{
return|return
name|secretKeyAccessor
return|;
block|}
DECL|method|setSecretKeyAccessor (PGPSecretKeyAccessor secretKeyAccessor)
specifier|public
name|void
name|setSecretKeyAccessor
parameter_list|(
name|PGPSecretKeyAccessor
name|secretKeyAccessor
parameter_list|)
block|{
name|this
operator|.
name|secretKeyAccessor
operator|=
name|secretKeyAccessor
expr_stmt|;
block|}
DECL|method|getSignatureVerificationOption ()
specifier|public
name|String
name|getSignatureVerificationOption
parameter_list|()
block|{
return|return
name|signatureVerificationOption
return|;
block|}
DECL|method|isWithCompressedDataPacket ()
specifier|public
name|boolean
name|isWithCompressedDataPacket
parameter_list|()
block|{
return|return
name|withCompressedDataPacket
return|;
block|}
comment|/** Indicator that Compressed Data packet shall be added during encryption.      * The default value is true.      * If<tt>false</tt> then the compression algorithm (see {@link #setCompressionAlgorithm(int)} is ignored.       */
DECL|method|setWithCompressedDataPacket (boolean withCompressedDataPacket)
specifier|public
name|void
name|setWithCompressedDataPacket
parameter_list|(
name|boolean
name|withCompressedDataPacket
parameter_list|)
block|{
name|this
operator|.
name|withCompressedDataPacket
operator|=
name|withCompressedDataPacket
expr_stmt|;
block|}
comment|/**      * Signature verification option. Controls the behavior for the signature      * verification during unmarshaling. Possible values are      * {@link #SIGNATURE_VERIFICATION_OPTION_OPTIONAL},      * {@link #SIGNATURE_VERIFICATION_OPTION_REQUIRED},      * {@link #SIGNATURE_VERIFICATION_OPTION_NO_SIGNATURE_ALLOWED}, and      * {@link #SIGNATURE_VERIFICATION_OPTION_IGNORE}. The default      * value is {@link #SIGNATURE_VERIFICATION_OPTION_OPTIONAL}      *       * @param signatureVerificationOption      *            signature verification option      * @throws IllegalArgumentException      *            if an invalid value is entered      */
DECL|method|setSignatureVerificationOption (String signatureVerificationOption)
specifier|public
name|void
name|setSignatureVerificationOption
parameter_list|(
name|String
name|signatureVerificationOption
parameter_list|)
block|{
if|if
condition|(
name|SIGNATURE_VERIFICATION_OPTIONS
operator|.
name|contains
argument_list|(
name|signatureVerificationOption
argument_list|)
condition|)
block|{
name|this
operator|.
name|signatureVerificationOption
operator|=
name|signatureVerificationOption
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|signatureVerificationOption
operator|+
literal|" is not a valid signature verification option"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns the file name for the literal packet. Cannot be<code>null</code>      * .      *       */
DECL|method|getFileName ()
specifier|public
name|String
name|getFileName
parameter_list|()
block|{
return|return
name|fileName
return|;
block|}
comment|/**      * Sets the file name for the literal data packet. Can be overwritten by the      * header {@link Exchange#FILE_NAME}. The default value is "_CONSOLE".      * "_CONSOLE" indicates that the message is considered to be      * "for your eyes only". This advises that the message data is unusually      * sensitive, and the receiving program should process it more carefully,      * perhaps avoiding storing the received data to disk, for example.      *<p>      * Only used for marshaling.      *       * @param fileName      * @throws IllegalArgumentException      *             if<tt>fileName</tt> is<code>null</code>      */
DECL|method|setFileName (String fileName)
specifier|public
name|void
name|setFileName
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
if|if
condition|(
name|fileName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parameter 'fileName' is null"
argument_list|)
throw|;
block|}
name|this
operator|.
name|fileName
operator|=
name|fileName
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStart ()
specifier|protected
name|void
name|doStart
parameter_list|()
throws|throws
name|Exception
block|{
comment|//NOPMD
if|if
condition|(
name|Security
operator|.
name|getProvider
argument_list|(
name|BC
argument_list|)
operator|==
literal|null
operator|&&
name|BC
operator|.
name|equals
argument_list|(
name|getProvider
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding BouncyCastleProvider as security provider"
argument_list|)
expr_stmt|;
name|Security
operator|.
name|addProvider
argument_list|(
operator|new
name|BouncyCastleProvider
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using custom provider {} which is expected to be enlisted manually."
argument_list|,
name|getProvider
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|doStop ()
specifier|protected
name|void
name|doStop
parameter_list|()
throws|throws
name|Exception
block|{
comment|//NOPMD
comment|// noop
block|}
DECL|class|DecryptedDataAndPPublicKeyEncryptedData
specifier|private
specifier|static
class|class
name|DecryptedDataAndPPublicKeyEncryptedData
block|{
DECL|field|decryptedData
specifier|private
specifier|final
name|InputStream
name|decryptedData
decl_stmt|;
DECL|field|pbe
specifier|private
specifier|final
name|PGPPublicKeyEncryptedData
name|pbe
decl_stmt|;
DECL|method|DecryptedDataAndPPublicKeyEncryptedData (InputStream decryptedData, PGPPublicKeyEncryptedData pbe)
name|DecryptedDataAndPPublicKeyEncryptedData
parameter_list|(
name|InputStream
name|decryptedData
parameter_list|,
name|PGPPublicKeyEncryptedData
name|pbe
parameter_list|)
block|{
name|this
operator|.
name|decryptedData
operator|=
name|decryptedData
expr_stmt|;
name|this
operator|.
name|pbe
operator|=
name|pbe
expr_stmt|;
block|}
DECL|method|getDecryptedData ()
specifier|public
name|InputStream
name|getDecryptedData
parameter_list|()
block|{
return|return
name|decryptedData
return|;
block|}
DECL|method|getPbe ()
specifier|public
name|PGPPublicKeyEncryptedData
name|getPbe
parameter_list|()
block|{
return|return
name|pbe
return|;
block|}
block|}
block|}
end_class

end_unit

