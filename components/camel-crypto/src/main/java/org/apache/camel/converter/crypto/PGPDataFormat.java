begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.converter.crypto
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|converter
operator|.
name|crypto
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchProviderException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|annotations
operator|.
name|Dataformat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|PGPException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|PGPPrivateKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|PGPPublicKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|openpgp
operator|.
name|PGPPublicKeyRingCollection
import|;
end_import

begin_comment
comment|/**  *<code>PGPDataFormat</code> uses the<a  * href="http://www.bouncycastle.org/java.htm">bouncy castle</a> libraries to  * enable encryption and decryption in the PGP format.  *<p>  * See also {@link PGPKeyAccessDataFormat}.  */
end_comment

begin_class
annotation|@
name|Dataformat
argument_list|(
literal|"pgp"
argument_list|)
DECL|class|PGPDataFormat
specifier|public
class|class
name|PGPDataFormat
extends|extends
name|PGPKeyAccessDataFormat
implements|implements
name|PGPPublicKeyAccessor
implements|,
name|PGPSecretKeyAccessor
block|{
DECL|field|KEY_FILE_NAME
specifier|public
specifier|static
specifier|final
name|String
name|KEY_FILE_NAME
init|=
literal|"CamelPGPDataFormatKeyFileName"
decl_stmt|;
DECL|field|ENCRYPTION_KEY_RING
specifier|public
specifier|static
specifier|final
name|String
name|ENCRYPTION_KEY_RING
init|=
literal|"CamelPGPDataFormatEncryptionKeyRing"
decl_stmt|;
DECL|field|KEY_PASSWORD
specifier|public
specifier|static
specifier|final
name|String
name|KEY_PASSWORD
init|=
literal|"CamelPGPDataFormatKeyPassword"
decl_stmt|;
DECL|field|SIGNATURE_KEY_FILE_NAME
specifier|public
specifier|static
specifier|final
name|String
name|SIGNATURE_KEY_FILE_NAME
init|=
literal|"CamelPGPDataFormatSignatureKeyFileName"
decl_stmt|;
DECL|field|SIGNATURE_KEY_RING
specifier|public
specifier|static
specifier|final
name|String
name|SIGNATURE_KEY_RING
init|=
literal|"CamelPGPDataFormatSignatureKeyRing"
decl_stmt|;
DECL|field|SIGNATURE_KEY_PASSWORD
specifier|public
specifier|static
specifier|final
name|String
name|SIGNATURE_KEY_PASSWORD
init|=
literal|"CamelPGPDataFormatSignatureKeyPassword"
decl_stmt|;
comment|//private static final Logger log = LoggerFactory.getLogger(PGPDataFormatChanged.class);
DECL|field|password
specifier|private
name|String
name|password
decl_stmt|;
comment|// only for decryption
DECL|field|keyFileName
specifier|private
name|String
name|keyFileName
decl_stmt|;
comment|// alternatively to the file name you can specify the key ring as byte array
DECL|field|encryptionKeyRing
specifier|private
name|byte
index|[]
name|encryptionKeyRing
decl_stmt|;
DECL|field|signaturePassword
specifier|private
name|String
name|signaturePassword
decl_stmt|;
comment|//only for signing, optional if you have several signature keys, then you should use passphaseAccessor
DECL|field|signatureKeyFileName
specifier|private
name|String
name|signatureKeyFileName
decl_stmt|;
comment|// alternatively to the signature key file name you can specify the signature key ring as byte array
DECL|field|signatureKeyRing
specifier|private
name|byte
index|[]
name|signatureKeyRing
decl_stmt|;
DECL|field|passphraseAccessor
specifier|private
name|PGPPassphraseAccessor
name|passphraseAccessor
decl_stmt|;
comment|// for signing and decryption with multiple keys
DECL|method|PGPDataFormat ()
specifier|public
name|PGPDataFormat
parameter_list|()
block|{
name|publicKeyAccessor
operator|=
name|this
expr_stmt|;
name|secretKeyAccessor
operator|=
name|this
expr_stmt|;
block|}
DECL|method|findKeyFileName (Exchange exchange)
specifier|protected
name|String
name|findKeyFileName
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|KEY_FILE_NAME
argument_list|,
name|getKeyFileName
argument_list|()
argument_list|,
name|String
operator|.
name|class
argument_list|)
return|;
block|}
DECL|method|findEncryptionKeyRing (Exchange exchange)
specifier|protected
name|byte
index|[]
name|findEncryptionKeyRing
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|ENCRYPTION_KEY_RING
argument_list|,
name|getEncryptionKeyRing
argument_list|()
argument_list|,
name|byte
index|[]
operator|.
expr|class
argument_list|)
return|;
block|}
DECL|method|findKeyPassword (Exchange exchange)
specifier|protected
name|String
name|findKeyPassword
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|KEY_PASSWORD
argument_list|,
name|getPassword
argument_list|()
argument_list|,
name|String
operator|.
name|class
argument_list|)
return|;
comment|// the following lines are not needed because the passphrase accessor is taken into account later in the decryption case
comment|//        if (passphraseAccessor != null) {
comment|//            return passphraseAccessor.getPassphrase(findKeyUserid(exchange));
comment|//        } else {
comment|//            return null;
comment|//        }
block|}
DECL|method|findSignatureKeyFileName (Exchange exchange)
specifier|protected
name|String
name|findSignatureKeyFileName
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|SIGNATURE_KEY_FILE_NAME
argument_list|,
name|getSignatureKeyFileName
argument_list|()
argument_list|,
name|String
operator|.
name|class
argument_list|)
return|;
block|}
DECL|method|findSignatureKeyRing (Exchange exchange)
specifier|protected
name|byte
index|[]
name|findSignatureKeyRing
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|SIGNATURE_KEY_RING
argument_list|,
name|getSignatureKeyRing
argument_list|()
argument_list|,
name|byte
index|[]
operator|.
expr|class
argument_list|)
return|;
block|}
DECL|method|findSignatureKeyPassword (Exchange exchange)
specifier|protected
name|String
name|findSignatureKeyPassword
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|String
name|sigPassword
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|SIGNATURE_KEY_PASSWORD
argument_list|,
name|getSignaturePassword
argument_list|()
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|sigPassword
operator|!=
literal|null
condition|)
block|{
return|return
name|sigPassword
return|;
block|}
if|if
condition|(
name|passphraseAccessor
operator|!=
literal|null
condition|)
block|{
return|return
name|passphraseAccessor
operator|.
name|getPassphrase
argument_list|(
name|findSignatureKeyUserid
argument_list|(
name|exchange
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
DECL|method|determineSecretKeysWithPrivateKeyAndUserId (Exchange exchange, String sigKeyFileName, List<String> sigKeyUserids, String sigKeyPassword, byte[] sigKeyRing)
specifier|public
name|List
argument_list|<
name|PGPSecretKeyAndPrivateKeyAndUserId
argument_list|>
name|determineSecretKeysWithPrivateKeyAndUserId
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|sigKeyFileName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|sigKeyUserids
parameter_list|,
name|String
name|sigKeyPassword
parameter_list|,
name|byte
index|[]
name|sigKeyRing
parameter_list|)
throws|throws
name|IOException
throws|,
name|PGPException
throws|,
name|NoSuchProviderException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|sigKeyUserId2Password
init|=
name|determineSignatureKeyUserId2Password
argument_list|(
name|sigKeyUserids
argument_list|,
name|sigKeyPassword
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|PGPSecretKeyAndPrivateKeyAndUserId
argument_list|>
name|sigSecretKeysWithPrivateKeyAndUserId
init|=
name|PGPDataFormatUtil
operator|.
name|findSecretKeysWithPrivateKeyAndUserId
argument_list|(
name|exchange
operator|.
name|getContext
argument_list|()
argument_list|,
name|sigKeyFileName
argument_list|,
name|sigKeyRing
argument_list|,
name|sigKeyUserId2Password
argument_list|,
name|getProvider
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|sigSecretKeysWithPrivateKeyAndUserId
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Cannot PGP sign message. No secret key found for User IDs %s. Either add keys with this User IDs to the secret keyring or change the configured User IDs."
argument_list|,
name|sigKeyUserids
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|sigSecretKeysWithPrivateKeyAndUserId
return|;
block|}
DECL|method|determineSignatureKeyUserId2Password (List<String> sigKeyUserids, String sigKeyPassword)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|determineSignatureKeyUserId2Password
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|sigKeyUserids
parameter_list|,
name|String
name|sigKeyPassword
parameter_list|)
block|{
comment|// we want to keep the order of the entries, therefore we use LinkedHashMap
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|sigKeyUserId2Password
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|(
name|sigKeyUserids
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|sigKeyUserid
range|:
name|sigKeyUserids
control|)
block|{
if|if
condition|(
name|sigKeyPassword
operator|==
literal|null
condition|)
block|{
name|sigKeyPassword
operator|=
name|passphraseAccessor
operator|.
name|getPassphrase
argument_list|(
name|sigKeyUserid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sigKeyPassword
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"No passphrase specified for signature key user ID %s. Either specify a passphrase or remove this user ID from the configuration."
argument_list|,
name|sigKeyUserid
argument_list|)
argument_list|)
throw|;
block|}
name|sigKeyUserId2Password
operator|.
name|put
argument_list|(
name|sigKeyUserid
argument_list|,
name|sigKeyPassword
argument_list|)
expr_stmt|;
block|}
return|return
name|sigKeyUserId2Password
return|;
block|}
comment|/**      * Filename of the keyring that will be used for the encryption/decryption,      * classpathResource. Alternatively you can provide the keyring also as byte      * array; see method {@link #setEncryptionKeyRing(byte[])}.      */
DECL|method|setKeyFileName (String keyFileName)
specifier|public
name|void
name|setKeyFileName
parameter_list|(
name|String
name|keyFileName
parameter_list|)
block|{
name|this
operator|.
name|keyFileName
operator|=
name|keyFileName
expr_stmt|;
block|}
DECL|method|getKeyFileName ()
specifier|public
name|String
name|getKeyFileName
parameter_list|()
block|{
return|return
name|keyFileName
return|;
block|}
comment|/**      * Password used to open the private key in secret keyring for decryption      * (unmarshaling). See also      * {@link #setPassphraseAccessor(PGPPassphraseAccessor)}.      */
DECL|method|setPassword (String password)
specifier|public
name|void
name|setPassword
parameter_list|(
name|String
name|password
parameter_list|)
block|{
name|this
operator|.
name|password
operator|=
name|password
expr_stmt|;
block|}
DECL|method|getPassword ()
specifier|public
name|String
name|getPassword
parameter_list|()
block|{
return|return
name|password
return|;
block|}
comment|/**      * Filename of the signature keyring that will be used, classpathResource.      */
DECL|method|setSignatureKeyFileName (String signatureKeyFileName)
specifier|public
name|void
name|setSignatureKeyFileName
parameter_list|(
name|String
name|signatureKeyFileName
parameter_list|)
block|{
name|this
operator|.
name|signatureKeyFileName
operator|=
name|signatureKeyFileName
expr_stmt|;
block|}
DECL|method|getSignatureKeyFileName ()
specifier|public
name|String
name|getSignatureKeyFileName
parameter_list|()
block|{
return|return
name|signatureKeyFileName
return|;
block|}
comment|/**      * Password used to open the signature private key during marshaling.      */
DECL|method|setSignaturePassword (String signaturePassword)
specifier|public
name|void
name|setSignaturePassword
parameter_list|(
name|String
name|signaturePassword
parameter_list|)
block|{
name|this
operator|.
name|signaturePassword
operator|=
name|signaturePassword
expr_stmt|;
block|}
DECL|method|getSignaturePassword ()
specifier|public
name|String
name|getSignaturePassword
parameter_list|()
block|{
return|return
name|signaturePassword
return|;
block|}
DECL|method|getEncryptionKeyRing ()
specifier|public
name|byte
index|[]
name|getEncryptionKeyRing
parameter_list|()
block|{
return|return
name|encryptionKeyRing
return|;
block|}
comment|/**      * Keyring used for encryption/decryption as byte array. Alternatively you      * can also provide the keyring as a file; see method      * {@link #setKeyFileName(String)}.      */
DECL|method|setEncryptionKeyRing (byte[] encryptionKeyRing)
specifier|public
name|void
name|setEncryptionKeyRing
parameter_list|(
name|byte
index|[]
name|encryptionKeyRing
parameter_list|)
block|{
name|this
operator|.
name|encryptionKeyRing
operator|=
name|encryptionKeyRing
expr_stmt|;
block|}
DECL|method|getSignatureKeyRing ()
specifier|public
name|byte
index|[]
name|getSignatureKeyRing
parameter_list|()
block|{
return|return
name|signatureKeyRing
return|;
block|}
comment|/**      * Keyring used for signing/verifying as byte array. Alternatively you can      * also provide the keyring as a file; see method      * {@link #setSignatureKeyFileName(String)}.      */
DECL|method|setSignatureKeyRing (byte[] signatureKeyRing)
specifier|public
name|void
name|setSignatureKeyRing
parameter_list|(
name|byte
index|[]
name|signatureKeyRing
parameter_list|)
block|{
name|this
operator|.
name|signatureKeyRing
operator|=
name|signatureKeyRing
expr_stmt|;
block|}
DECL|method|getPassphraseAccessor ()
specifier|public
name|PGPPassphraseAccessor
name|getPassphraseAccessor
parameter_list|()
block|{
return|return
name|passphraseAccessor
return|;
block|}
comment|/**      * Alternative way to provide the passphrases. Especially useful for the      * unmarshal (decryption) case . If no passphrase can be found from the      * parameter<tt>password</tt> or<tt>signaturePassword</tt> or from the      * header {@link #SIGNATURE_KEY_PASSWORD} or {@link #KEY_PASSWORD} then we      * try to get the password from the passphrase accessor. This is especially      * useful in the decrypt case, where we chose the private key according to      * the key Id stored in the encrypted data.      */
DECL|method|setPassphraseAccessor (PGPPassphraseAccessor passphraseAccessor)
specifier|public
name|void
name|setPassphraseAccessor
parameter_list|(
name|PGPPassphraseAccessor
name|passphraseAccessor
parameter_list|)
block|{
name|this
operator|.
name|passphraseAccessor
operator|=
name|passphraseAccessor
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getEncryptionKeys (Exchange exchange, List<String> useridParts)
specifier|public
name|List
argument_list|<
name|PGPPublicKey
argument_list|>
name|getEncryptionKeys
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|useridParts
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|PGPDataFormatUtil
operator|.
name|findPublicKeys
argument_list|(
name|exchange
operator|.
name|getContext
argument_list|()
argument_list|,
name|findKeyFileName
argument_list|(
name|exchange
argument_list|)
argument_list|,
name|findEncryptionKeyRing
argument_list|(
name|exchange
argument_list|)
argument_list|,
name|useridParts
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getSignerKeys (Exchange exchange, List<String> useridParts)
specifier|public
name|List
argument_list|<
name|PGPSecretKeyAndPrivateKeyAndUserId
argument_list|>
name|getSignerKeys
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|useridParts
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|sigKeyFileName
init|=
name|findSignatureKeyFileName
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
name|String
name|sigKeyPassword
init|=
name|findSignatureKeyPassword
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
name|byte
index|[]
name|sigKeyRing
init|=
name|findSignatureKeyRing
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|sigKeyFileName
operator|==
literal|null
operator|&&
name|sigKeyRing
operator|==
literal|null
operator|)
operator|||
name|useridParts
operator|==
literal|null
operator|||
name|useridParts
operator|.
name|isEmpty
argument_list|()
operator|||
operator|(
name|sigKeyPassword
operator|==
literal|null
operator|&&
name|passphraseAccessor
operator|==
literal|null
operator|)
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
return|return
name|determineSecretKeysWithPrivateKeyAndUserId
argument_list|(
name|exchange
argument_list|,
name|sigKeyFileName
argument_list|,
name|useridParts
argument_list|,
name|sigKeyPassword
argument_list|,
name|sigKeyRing
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getPrivateKey (Exchange exchange, long keyId)
specifier|public
name|PGPPrivateKey
name|getPrivateKey
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|long
name|keyId
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|PGPDataFormatUtil
operator|.
name|findPrivateKeyWithKeyId
argument_list|(
name|exchange
operator|.
name|getContext
argument_list|()
argument_list|,
name|findKeyFileName
argument_list|(
name|exchange
argument_list|)
argument_list|,
name|findEncryptionKeyRing
argument_list|(
name|exchange
argument_list|)
argument_list|,
name|keyId
argument_list|,
name|findKeyPassword
argument_list|(
name|exchange
argument_list|)
argument_list|,
name|getPassphraseAccessor
argument_list|()
argument_list|,
name|getProvider
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getPublicKey (Exchange exchange, long keyId, List<String> userIdParts)
specifier|public
name|PGPPublicKey
name|getPublicKey
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|long
name|keyId
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|userIdParts
parameter_list|)
throws|throws
name|Exception
block|{
name|PGPPublicKeyRingCollection
name|publicKeyringCollection
init|=
name|PGPDataFormatUtil
operator|.
name|getPublicKeyRingCollection
argument_list|(
name|exchange
operator|.
name|getContext
argument_list|()
argument_list|,
name|findSignatureKeyFileName
argument_list|(
name|exchange
argument_list|)
argument_list|,
name|findSignatureKeyRing
argument_list|(
name|exchange
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|PGPDataFormatUtil
operator|.
name|getPublicKeyWithKeyIdAndUserID
argument_list|(
name|keyId
argument_list|,
name|userIdParts
argument_list|,
name|publicKeyringCollection
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setPublicKeyAccessor (PGPPublicKeyAccessor publicKeyAccessor)
specifier|public
name|void
name|setPublicKeyAccessor
parameter_list|(
name|PGPPublicKeyAccessor
name|publicKeyAccessor
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Use PGPKeyAccessDataFormat if you want to set the public key access"
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|setSecretKeyAccessor (PGPSecretKeyAccessor secretKeyAccessor)
specifier|public
name|void
name|setSecretKeyAccessor
parameter_list|(
name|PGPSecretKeyAccessor
name|secretKeyAccessor
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Use PGPKeyAccessDataFormat if you want to set the secret key access"
argument_list|)
throw|;
block|}
block|}
end_class

end_unit

