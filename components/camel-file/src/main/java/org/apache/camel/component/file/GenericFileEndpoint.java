begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.component.file
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|file
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Expression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|ExpressionIllegalSyntaxException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|LoggingLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Processor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|RuntimeCamelException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|file
operator|.
name|strategy
operator|.
name|FileMoveExistingStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|BrowsableEndpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|ExceptionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|FactoryFinder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|IdempotentRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|Language
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|UriParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|ObjectHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|ScheduledPollEndpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|processor
operator|.
name|idempotent
operator|.
name|MemoryIdempotentRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|service
operator|.
name|ServiceHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|IOHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|StringHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Base class for file endpoints  */
end_comment

begin_class
DECL|class|GenericFileEndpoint
specifier|public
specifier|abstract
class|class
name|GenericFileEndpoint
parameter_list|<
name|T
parameter_list|>
extends|extends
name|ScheduledPollEndpoint
implements|implements
name|BrowsableEndpoint
block|{
DECL|field|DEFAULT_STRATEGYFACTORY_CLASS
specifier|protected
specifier|static
specifier|final
name|String
name|DEFAULT_STRATEGYFACTORY_CLASS
init|=
literal|"org.apache.camel.component.file.strategy.GenericFileProcessStrategyFactory"
decl_stmt|;
DECL|field|DEFAULT_IDEMPOTENT_CACHE_SIZE
specifier|protected
specifier|static
specifier|final
name|int
name|DEFAULT_IDEMPOTENT_CACHE_SIZE
init|=
literal|1000
decl_stmt|;
DECL|field|DEFAULT_IN_PROGRESS_CACHE_SIZE
specifier|protected
specifier|static
specifier|final
name|int
name|DEFAULT_IN_PROGRESS_CACHE_SIZE
init|=
literal|50000
decl_stmt|;
DECL|field|log
specifier|protected
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
comment|// common options
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"advanced"
argument_list|,
name|defaultValue
operator|=
literal|"true"
argument_list|)
DECL|field|autoCreate
specifier|protected
name|boolean
name|autoCreate
init|=
literal|true
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"advanced"
argument_list|,
name|defaultValue
operator|=
literal|""
operator|+
name|FileUtil
operator|.
name|BUFFER_SIZE
argument_list|)
DECL|field|bufferSize
specifier|protected
name|int
name|bufferSize
init|=
name|FileUtil
operator|.
name|BUFFER_SIZE
decl_stmt|;
annotation|@
name|UriParam
DECL|field|charset
specifier|protected
name|String
name|charset
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|javaType
operator|=
literal|"java.lang.String"
argument_list|)
DECL|field|fileName
specifier|protected
name|Expression
name|fileName
decl_stmt|;
annotation|@
name|UriParam
DECL|field|doneFileName
specifier|protected
name|String
name|doneFileName
decl_stmt|;
comment|// producer options
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|)
DECL|field|flatten
specifier|protected
name|boolean
name|flatten
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"Override"
argument_list|)
DECL|field|fileExist
specifier|protected
name|GenericFileExist
name|fileExist
init|=
name|GenericFileExist
operator|.
name|Override
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|)
DECL|field|tempPrefix
specifier|protected
name|String
name|tempPrefix
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|javaType
operator|=
literal|"java.lang.String"
argument_list|)
DECL|field|tempFileName
specifier|protected
name|Expression
name|tempFileName
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer,advanced"
argument_list|,
name|defaultValue
operator|=
literal|"true"
argument_list|)
DECL|field|eagerDeleteTargetFile
specifier|protected
name|boolean
name|eagerDeleteTargetFile
init|=
literal|true
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer,advanced"
argument_list|)
DECL|field|keepLastModified
specifier|protected
name|boolean
name|keepLastModified
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer,advanced"
argument_list|)
DECL|field|allowNullBody
specifier|protected
name|boolean
name|allowNullBody
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"true"
argument_list|)
DECL|field|jailStartingDirectory
specifier|protected
name|boolean
name|jailStartingDirectory
init|=
literal|true
decl_stmt|;
comment|// consumer options
annotation|@
name|UriParam
DECL|field|configuration
specifier|protected
name|GenericFileConfiguration
name|configuration
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,advanced"
argument_list|)
DECL|field|processStrategy
specifier|protected
name|GenericFileProcessStrategy
argument_list|<
name|T
argument_list|>
name|processStrategy
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,advanced"
argument_list|)
DECL|field|inProgressRepository
specifier|protected
name|IdempotentRepository
name|inProgressRepository
init|=
name|MemoryIdempotentRepository
operator|.
name|memoryIdempotentRepository
argument_list|(
name|DEFAULT_IN_PROGRESS_CACHE_SIZE
argument_list|)
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,advanced"
argument_list|)
DECL|field|localWorkDirectory
specifier|protected
name|String
name|localWorkDirectory
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,advanced"
argument_list|)
DECL|field|startingDirectoryMustExist
specifier|protected
name|boolean
name|startingDirectoryMustExist
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,advanced"
argument_list|)
DECL|field|directoryMustExist
specifier|protected
name|boolean
name|directoryMustExist
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|)
DECL|field|noop
specifier|protected
name|boolean
name|noop
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|)
DECL|field|recursive
specifier|protected
name|boolean
name|recursive
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|)
DECL|field|delete
specifier|protected
name|boolean
name|delete
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|)
DECL|field|preSort
specifier|protected
name|boolean
name|preSort
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,filter"
argument_list|)
DECL|field|maxMessagesPerPoll
specifier|protected
name|int
name|maxMessagesPerPoll
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,filter"
argument_list|,
name|defaultValue
operator|=
literal|"true"
argument_list|)
DECL|field|eagerMaxMessagesPerPoll
specifier|protected
name|boolean
name|eagerMaxMessagesPerPoll
init|=
literal|true
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,filter"
argument_list|,
name|defaultValue
operator|=
literal|""
operator|+
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
DECL|field|maxDepth
specifier|protected
name|int
name|maxDepth
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,filter"
argument_list|)
DECL|field|minDepth
specifier|protected
name|int
name|minDepth
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,filter"
argument_list|)
DECL|field|include
specifier|protected
name|String
name|include
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,filter"
argument_list|)
DECL|field|exclude
specifier|protected
name|String
name|exclude
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,filter"
argument_list|,
name|javaType
operator|=
literal|"java.lang.String"
argument_list|)
DECL|field|move
specifier|protected
name|Expression
name|move
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|javaType
operator|=
literal|"java.lang.String"
argument_list|)
DECL|field|moveFailed
specifier|protected
name|Expression
name|moveFailed
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|javaType
operator|=
literal|"java.lang.String"
argument_list|)
DECL|field|preMove
specifier|protected
name|Expression
name|preMove
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|javaType
operator|=
literal|"java.lang.String"
argument_list|)
DECL|field|moveExisting
specifier|protected
name|Expression
name|moveExisting
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer,advanced"
argument_list|)
DECL|field|moveExistingFileStrategy
specifier|protected
name|FileMoveExistingStrategy
name|moveExistingFileStrategy
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,filter"
argument_list|,
name|defaultValue
operator|=
literal|"false"
argument_list|)
DECL|field|idempotent
specifier|protected
name|Boolean
name|idempotent
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,filter"
argument_list|,
name|javaType
operator|=
literal|"java.lang.String"
argument_list|)
DECL|field|idempotentKey
specifier|protected
name|Expression
name|idempotentKey
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,filter"
argument_list|)
DECL|field|idempotentRepository
specifier|protected
name|IdempotentRepository
name|idempotentRepository
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,filter"
argument_list|)
DECL|field|filter
specifier|protected
name|GenericFileFilter
argument_list|<
name|T
argument_list|>
name|filter
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,filter"
argument_list|,
name|javaType
operator|=
literal|"java.lang.String"
argument_list|)
DECL|field|filterDirectory
specifier|protected
name|Predicate
name|filterDirectory
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,filter"
argument_list|,
name|javaType
operator|=
literal|"java.lang.String"
argument_list|)
DECL|field|filterFile
specifier|protected
name|Predicate
name|filterFile
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,filter"
argument_list|,
name|defaultValue
operator|=
literal|"true"
argument_list|)
DECL|field|antFilterCaseSensitive
specifier|protected
name|boolean
name|antFilterCaseSensitive
init|=
literal|true
decl_stmt|;
DECL|field|antFilter
specifier|protected
specifier|volatile
name|AntPathMatcherGenericFileFilter
argument_list|<
name|T
argument_list|>
name|antFilter
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,filter"
argument_list|)
DECL|field|antInclude
specifier|protected
name|String
name|antInclude
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,filter"
argument_list|)
DECL|field|antExclude
specifier|protected
name|String
name|antExclude
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,sort"
argument_list|)
DECL|field|sorter
specifier|protected
name|Comparator
argument_list|<
name|GenericFile
argument_list|<
name|T
argument_list|>
argument_list|>
name|sorter
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,sort"
argument_list|,
name|javaType
operator|=
literal|"java.lang.String"
argument_list|)
DECL|field|sortBy
specifier|protected
name|Comparator
argument_list|<
name|Exchange
argument_list|>
name|sortBy
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,sort"
argument_list|)
DECL|field|shuffle
specifier|protected
name|boolean
name|shuffle
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,lock"
argument_list|,
name|defaultValue
operator|=
literal|"none"
argument_list|,
name|enums
operator|=
literal|"none,markerFile,fileLock,rename,changed,idempotent,idempotent-changed,idempotent-rename"
argument_list|)
DECL|field|readLock
specifier|protected
name|String
name|readLock
init|=
literal|"none"
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,lock"
argument_list|,
name|defaultValue
operator|=
literal|"1000"
argument_list|)
DECL|field|readLockCheckInterval
specifier|protected
name|long
name|readLockCheckInterval
init|=
literal|1000
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,lock"
argument_list|,
name|defaultValue
operator|=
literal|"10000"
argument_list|)
DECL|field|readLockTimeout
specifier|protected
name|long
name|readLockTimeout
init|=
literal|10000
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,lock"
argument_list|,
name|defaultValue
operator|=
literal|"true"
argument_list|)
DECL|field|readLockMarkerFile
specifier|protected
name|boolean
name|readLockMarkerFile
init|=
literal|true
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,lock"
argument_list|,
name|defaultValue
operator|=
literal|"true"
argument_list|)
DECL|field|readLockDeleteOrphanLockFiles
specifier|protected
name|boolean
name|readLockDeleteOrphanLockFiles
init|=
literal|true
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,lock"
argument_list|,
name|defaultValue
operator|=
literal|"DEBUG"
argument_list|)
DECL|field|readLockLoggingLevel
specifier|protected
name|LoggingLevel
name|readLockLoggingLevel
init|=
name|LoggingLevel
operator|.
name|DEBUG
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,lock"
argument_list|,
name|defaultValue
operator|=
literal|"1"
argument_list|)
DECL|field|readLockMinLength
specifier|protected
name|long
name|readLockMinLength
init|=
literal|1
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,lock"
argument_list|,
name|defaultValue
operator|=
literal|"0"
argument_list|)
DECL|field|readLockMinAge
specifier|protected
name|long
name|readLockMinAge
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,lock"
argument_list|,
name|defaultValue
operator|=
literal|"true"
argument_list|)
DECL|field|readLockRemoveOnRollback
specifier|protected
name|boolean
name|readLockRemoveOnRollback
init|=
literal|true
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,lock"
argument_list|)
DECL|field|readLockRemoveOnCommit
specifier|protected
name|boolean
name|readLockRemoveOnCommit
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,lock"
argument_list|)
DECL|field|readLockIdempotentReleaseDelay
specifier|protected
name|int
name|readLockIdempotentReleaseDelay
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,lock"
argument_list|)
DECL|field|readLockIdempotentReleaseAsync
specifier|protected
name|boolean
name|readLockIdempotentReleaseAsync
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,lock"
argument_list|)
DECL|field|readLockIdempotentReleaseAsyncPoolSize
specifier|protected
name|int
name|readLockIdempotentReleaseAsyncPoolSize
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,lock"
argument_list|)
DECL|field|readLockIdempotentReleaseExecutorService
specifier|protected
name|ScheduledExecutorService
name|readLockIdempotentReleaseExecutorService
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,lock"
argument_list|)
DECL|field|exclusiveReadLockStrategy
specifier|protected
name|GenericFileExclusiveReadLockStrategy
argument_list|<
name|T
argument_list|>
name|exclusiveReadLockStrategy
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer,advanced"
argument_list|)
DECL|field|onCompletionExceptionHandler
specifier|protected
name|ExceptionHandler
name|onCompletionExceptionHandler
decl_stmt|;
DECL|field|includePattern
specifier|private
name|Pattern
name|includePattern
decl_stmt|;
DECL|field|excludePattern
specifier|private
name|Pattern
name|excludePattern
decl_stmt|;
DECL|method|GenericFileEndpoint ()
specifier|public
name|GenericFileEndpoint
parameter_list|()
block|{     }
DECL|method|GenericFileEndpoint (String endpointUri, Component component)
specifier|public
name|GenericFileEndpoint
parameter_list|(
name|String
name|endpointUri
parameter_list|,
name|Component
name|component
parameter_list|)
block|{
name|super
argument_list|(
name|endpointUri
argument_list|,
name|component
argument_list|)
expr_stmt|;
block|}
DECL|method|isSingleton ()
specifier|public
name|boolean
name|isSingleton
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
DECL|method|createConsumer (Processor processor)
specifier|public
specifier|abstract
name|GenericFileConsumer
argument_list|<
name|T
argument_list|>
name|createConsumer
parameter_list|(
name|Processor
name|processor
parameter_list|)
throws|throws
name|Exception
function_decl|;
DECL|method|createProducer ()
specifier|public
specifier|abstract
name|GenericFileProducer
argument_list|<
name|T
argument_list|>
name|createProducer
parameter_list|()
throws|throws
name|Exception
function_decl|;
DECL|method|createExchange (GenericFile<T> file)
specifier|public
specifier|abstract
name|Exchange
name|createExchange
parameter_list|(
name|GenericFile
argument_list|<
name|T
argument_list|>
name|file
parameter_list|)
function_decl|;
DECL|method|getScheme ()
specifier|public
specifier|abstract
name|String
name|getScheme
parameter_list|()
function_decl|;
DECL|method|getFileSeparator ()
specifier|public
specifier|abstract
name|char
name|getFileSeparator
parameter_list|()
function_decl|;
DECL|method|isAbsolute (String name)
specifier|public
specifier|abstract
name|boolean
name|isAbsolute
parameter_list|(
name|String
name|name
parameter_list|)
function_decl|;
comment|/**      * Return the file name that will be auto-generated for the given message if      * none is provided      */
DECL|method|getGeneratedFileName (Message message)
specifier|public
name|String
name|getGeneratedFileName
parameter_list|(
name|Message
name|message
parameter_list|)
block|{
return|return
name|StringHelper
operator|.
name|sanitize
argument_list|(
name|message
operator|.
name|getMessageId
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This implementation will<b>not</b> load the file content.      * Any file locking is neither in use by this implementation..      */
annotation|@
name|Override
DECL|method|getExchanges ()
specifier|public
name|List
argument_list|<
name|Exchange
argument_list|>
name|getExchanges
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|Exchange
argument_list|>
name|answer
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|GenericFileConsumer
argument_list|<
name|?
argument_list|>
name|consumer
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// create a new consumer which can poll the exchanges we want to browse
comment|// do not provide a processor as we do some custom processing
name|consumer
operator|=
name|createConsumer
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|consumer
operator|.
name|setCustomProcessor
argument_list|(
operator|new
name|Processor
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|process
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
name|answer
operator|.
name|add
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// do not start scheduler, as we invoke the poll manually
name|consumer
operator|.
name|setStartScheduler
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// start consumer
name|ServiceHelper
operator|.
name|startService
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
comment|// invoke poll which performs the custom processing, so we can browse the exchanges
name|consumer
operator|.
name|poll
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|RuntimeCamelException
operator|.
name|wrapRuntimeCamelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
try|try
block|{
name|ServiceHelper
operator|.
name|stopService
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Error stopping consumer used for browsing exchanges. This exception will be ignored"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
comment|/**      * A strategy method to lazily create the file strategy      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|createGenericFileStrategy ()
specifier|protected
name|GenericFileProcessStrategy
argument_list|<
name|T
argument_list|>
name|createGenericFileStrategy
parameter_list|()
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|factory
init|=
literal|null
decl_stmt|;
try|try
block|{
name|FactoryFinder
name|finder
init|=
name|getCamelContext
argument_list|()
operator|.
name|getFactoryFinder
argument_list|(
literal|"META-INF/services/org/apache/camel/component/"
argument_list|)
decl_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"Using FactoryFinder: {}"
argument_list|,
name|finder
argument_list|)
expr_stmt|;
name|factory
operator|=
name|finder
operator|.
name|findClass
argument_list|(
name|getScheme
argument_list|()
argument_list|,
literal|"strategy.factory."
argument_list|,
name|CamelContext
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"'strategy.factory.class' not found"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"No strategy factory defined in 'META-INF/services/org/apache/camel/component/'"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|factory
operator|==
literal|null
condition|)
block|{
comment|// use default
try|try
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Using ClassResolver to resolve class: {}"
argument_list|,
name|DEFAULT_STRATEGYFACTORY_CLASS
argument_list|)
expr_stmt|;
name|factory
operator|=
name|this
operator|.
name|getCamelContext
argument_list|()
operator|.
name|getClassResolver
argument_list|()
operator|.
name|resolveClass
argument_list|(
name|DEFAULT_STRATEGYFACTORY_CLASS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Cannot load class: {}"
argument_list|,
name|DEFAULT_STRATEGYFACTORY_CLASS
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// fallback and us this class loader
try|try
block|{
if|if
condition|(
name|log
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Using classloader: {} to resolve class: {}"
argument_list|,
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getClassLoader
argument_list|()
argument_list|,
name|DEFAULT_STRATEGYFACTORY_CLASS
argument_list|)
expr_stmt|;
block|}
name|factory
operator|=
name|this
operator|.
name|getCamelContext
argument_list|()
operator|.
name|getClassResolver
argument_list|()
operator|.
name|resolveClass
argument_list|(
name|DEFAULT_STRATEGYFACTORY_CLASS
argument_list|,
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getClassLoader
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|log
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Cannot load class: {} using classloader: "
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getClassLoader
argument_list|()
argument_list|,
name|DEFAULT_STRATEGYFACTORY_CLASS
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|factory
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|TypeNotPresentException
argument_list|(
name|DEFAULT_STRATEGYFACTORY_CLASS
operator|+
literal|" class not found"
argument_list|,
literal|null
argument_list|)
throw|;
block|}
block|}
try|try
block|{
name|Method
name|factoryMethod
init|=
name|factory
operator|.
name|getMethod
argument_list|(
literal|"createGenericFileProcessStrategy"
argument_list|,
name|CamelContext
operator|.
name|class
argument_list|,
name|Map
operator|.
name|class
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|params
init|=
name|getParamsAsMap
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Parameters for Generic file process strategy {}"
argument_list|,
name|params
argument_list|)
expr_stmt|;
return|return
operator|(
name|GenericFileProcessStrategy
argument_list|<
name|T
argument_list|>
operator|)
name|ObjectHelper
operator|.
name|invokeMethod
argument_list|(
name|factoryMethod
argument_list|,
literal|null
argument_list|,
name|getCamelContext
argument_list|()
argument_list|,
name|params
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|TypeNotPresentException
argument_list|(
name|factory
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|".createGenericFileProcessStrategy method not found"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|isNoop ()
specifier|public
name|boolean
name|isNoop
parameter_list|()
block|{
return|return
name|noop
return|;
block|}
comment|/**      * If true, the file is not moved or deleted in any way.      * This option is good for readonly data, or for ETL type requirements.      * If noop=true, Camel will set idempotent=true as well, to avoid consuming the same files over and over again.      */
DECL|method|setNoop (boolean noop)
specifier|public
name|void
name|setNoop
parameter_list|(
name|boolean
name|noop
parameter_list|)
block|{
name|this
operator|.
name|noop
operator|=
name|noop
expr_stmt|;
block|}
DECL|method|isRecursive ()
specifier|public
name|boolean
name|isRecursive
parameter_list|()
block|{
return|return
name|recursive
return|;
block|}
comment|/**      * If a directory, will look for files in all the sub-directories as well.      */
DECL|method|setRecursive (boolean recursive)
specifier|public
name|void
name|setRecursive
parameter_list|(
name|boolean
name|recursive
parameter_list|)
block|{
name|this
operator|.
name|recursive
operator|=
name|recursive
expr_stmt|;
block|}
DECL|method|getInclude ()
specifier|public
name|String
name|getInclude
parameter_list|()
block|{
return|return
name|include
return|;
block|}
comment|/**      * Is used to include files, if filename matches the regex pattern (matching is case in-sensitive).      *<p/>      * Notice if you use symbols such as plus sign and others you would need to configure      * this using the RAW() syntax if configuring this as an endpoint uri.      * See more details at<a href="http://camel.apache.org/how-do-i-configure-endpoints.html">configuring endpoint uris</a>      */
DECL|method|setInclude (String include)
specifier|public
name|void
name|setInclude
parameter_list|(
name|String
name|include
parameter_list|)
block|{
name|this
operator|.
name|include
operator|=
name|include
expr_stmt|;
name|this
operator|.
name|includePattern
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
name|include
argument_list|,
name|Pattern
operator|.
name|CASE_INSENSITIVE
argument_list|)
expr_stmt|;
block|}
DECL|method|getIncludePattern ()
specifier|public
name|Pattern
name|getIncludePattern
parameter_list|()
block|{
return|return
name|includePattern
return|;
block|}
DECL|method|getExclude ()
specifier|public
name|String
name|getExclude
parameter_list|()
block|{
return|return
name|exclude
return|;
block|}
comment|/**      * Is used to exclude files, if filename matches the regex pattern (matching is case in-senstive).      *<p/>      * Notice if you use symbols such as plus sign and others you would need to configure      * this using the RAW() syntax if configuring this as an endpoint uri.      * See more details at<a href="http://camel.apache.org/how-do-i-configure-endpoints.html">configuring endpoint uris</a>      */
DECL|method|setExclude (String exclude)
specifier|public
name|void
name|setExclude
parameter_list|(
name|String
name|exclude
parameter_list|)
block|{
name|this
operator|.
name|exclude
operator|=
name|exclude
expr_stmt|;
name|this
operator|.
name|excludePattern
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
name|exclude
argument_list|,
name|Pattern
operator|.
name|CASE_INSENSITIVE
argument_list|)
expr_stmt|;
block|}
DECL|method|getExcludePattern ()
specifier|public
name|Pattern
name|getExcludePattern
parameter_list|()
block|{
return|return
name|this
operator|.
name|excludePattern
return|;
block|}
DECL|method|getAntInclude ()
specifier|public
name|String
name|getAntInclude
parameter_list|()
block|{
return|return
name|antInclude
return|;
block|}
comment|/**      * Ant style filter inclusion.      * Multiple inclusions may be specified in comma-delimited format.      */
DECL|method|setAntInclude (String antInclude)
specifier|public
name|void
name|setAntInclude
parameter_list|(
name|String
name|antInclude
parameter_list|)
block|{
name|this
operator|.
name|antInclude
operator|=
name|antInclude
expr_stmt|;
block|}
DECL|method|getAntExclude ()
specifier|public
name|String
name|getAntExclude
parameter_list|()
block|{
return|return
name|antExclude
return|;
block|}
comment|/**      * Ant style filter exclusion. If both antInclude and antExclude are used, antExclude takes precedence over antInclude.      * Multiple exclusions may be specified in comma-delimited format.      */
DECL|method|setAntExclude (String antExclude)
specifier|public
name|void
name|setAntExclude
parameter_list|(
name|String
name|antExclude
parameter_list|)
block|{
name|this
operator|.
name|antExclude
operator|=
name|antExclude
expr_stmt|;
block|}
DECL|method|isAntFilterCaseSensitive ()
specifier|public
name|boolean
name|isAntFilterCaseSensitive
parameter_list|()
block|{
return|return
name|antFilterCaseSensitive
return|;
block|}
comment|/**      * Sets case sensitive flag on ant filter      */
DECL|method|setAntFilterCaseSensitive (boolean antFilterCaseSensitive)
specifier|public
name|void
name|setAntFilterCaseSensitive
parameter_list|(
name|boolean
name|antFilterCaseSensitive
parameter_list|)
block|{
name|this
operator|.
name|antFilterCaseSensitive
operator|=
name|antFilterCaseSensitive
expr_stmt|;
block|}
DECL|method|getAntFilter ()
specifier|public
name|GenericFileFilter
argument_list|<
name|T
argument_list|>
name|getAntFilter
parameter_list|()
block|{
return|return
name|antFilter
return|;
block|}
DECL|method|isPreSort ()
specifier|public
name|boolean
name|isPreSort
parameter_list|()
block|{
return|return
name|preSort
return|;
block|}
comment|/**      * When pre-sort is enabled then the consumer will sort the file and directory names during polling,       * that was retrieved from the file system. You may want to do this in case you need to operate on the files       * in a sorted order. The pre-sort is executed before the consumer starts to filter, and accept files       * to process by Camel. This option is default=false meaning disabled.      */
DECL|method|setPreSort (boolean preSort)
specifier|public
name|void
name|setPreSort
parameter_list|(
name|boolean
name|preSort
parameter_list|)
block|{
name|this
operator|.
name|preSort
operator|=
name|preSort
expr_stmt|;
block|}
DECL|method|isDelete ()
specifier|public
name|boolean
name|isDelete
parameter_list|()
block|{
return|return
name|delete
return|;
block|}
comment|/**      * If true, the file will be deleted after it is processed successfully.      */
DECL|method|setDelete (boolean delete)
specifier|public
name|void
name|setDelete
parameter_list|(
name|boolean
name|delete
parameter_list|)
block|{
name|this
operator|.
name|delete
operator|=
name|delete
expr_stmt|;
block|}
DECL|method|isFlatten ()
specifier|public
name|boolean
name|isFlatten
parameter_list|()
block|{
return|return
name|flatten
return|;
block|}
comment|/**      * Flatten is used to flatten the file name path to strip any leading paths, so it's just the file name.      * This allows you to consume recursively into sub-directories, but when you eg write the files to another directory      * they will be written in a single directory.      * Setting this to true on the producer enforces that any file name in CamelFileName header      * will be stripped for any leading paths.      */
DECL|method|setFlatten (boolean flatten)
specifier|public
name|void
name|setFlatten
parameter_list|(
name|boolean
name|flatten
parameter_list|)
block|{
name|this
operator|.
name|flatten
operator|=
name|flatten
expr_stmt|;
block|}
DECL|method|getMove ()
specifier|public
name|Expression
name|getMove
parameter_list|()
block|{
return|return
name|move
return|;
block|}
comment|/**      * Expression (such as Simple Language) used to dynamically set the filename when moving it after processing.      * To move files into a .done subdirectory just enter .done.      */
DECL|method|setMove (Expression move)
specifier|public
name|void
name|setMove
parameter_list|(
name|Expression
name|move
parameter_list|)
block|{
name|this
operator|.
name|move
operator|=
name|move
expr_stmt|;
block|}
comment|/**      * @see #setMove(org.apache.camel.Expression)      */
DECL|method|setMove (String fileLanguageExpression)
specifier|public
name|void
name|setMove
parameter_list|(
name|String
name|fileLanguageExpression
parameter_list|)
block|{
name|String
name|expression
init|=
name|configureMoveOrPreMoveExpression
argument_list|(
name|fileLanguageExpression
argument_list|)
decl_stmt|;
name|this
operator|.
name|move
operator|=
name|createFileLanguageExpression
argument_list|(
name|expression
argument_list|)
expr_stmt|;
block|}
DECL|method|getMoveFailed ()
specifier|public
name|Expression
name|getMoveFailed
parameter_list|()
block|{
return|return
name|moveFailed
return|;
block|}
comment|/**      * Sets the move failure expression based on Simple language.      * For example, to move files into a .error subdirectory use: .error.      * Note: When moving the files to the fail location Camel will handle the error and will not pick up the file again.      */
DECL|method|setMoveFailed (Expression moveFailed)
specifier|public
name|void
name|setMoveFailed
parameter_list|(
name|Expression
name|moveFailed
parameter_list|)
block|{
name|this
operator|.
name|moveFailed
operator|=
name|moveFailed
expr_stmt|;
block|}
DECL|method|setMoveFailed (String fileLanguageExpression)
specifier|public
name|void
name|setMoveFailed
parameter_list|(
name|String
name|fileLanguageExpression
parameter_list|)
block|{
name|String
name|expression
init|=
name|configureMoveOrPreMoveExpression
argument_list|(
name|fileLanguageExpression
argument_list|)
decl_stmt|;
name|this
operator|.
name|moveFailed
operator|=
name|createFileLanguageExpression
argument_list|(
name|expression
argument_list|)
expr_stmt|;
block|}
DECL|method|getFilterDirectory ()
specifier|public
name|Predicate
name|getFilterDirectory
parameter_list|()
block|{
return|return
name|filterDirectory
return|;
block|}
comment|/**      * Filters the directory based on Simple language.      * For example to filter on current date, you can use a simple date pattern such as ${date:now:yyyMMdd}      */
DECL|method|setFilterDirectory (Predicate filterDirectory)
specifier|public
name|void
name|setFilterDirectory
parameter_list|(
name|Predicate
name|filterDirectory
parameter_list|)
block|{
name|this
operator|.
name|filterDirectory
operator|=
name|filterDirectory
expr_stmt|;
block|}
comment|/**      * Filters the directory based on Simple language.      * For example to filter on current date, you can use a simple date pattern such as ${date:now:yyyMMdd}      * @see #setFilterDirectory(Predicate)      */
DECL|method|setFilterDirectory (String expression)
specifier|public
name|void
name|setFilterDirectory
parameter_list|(
name|String
name|expression
parameter_list|)
block|{
name|this
operator|.
name|filterDirectory
operator|=
name|createFileLanguagePredicate
argument_list|(
name|expression
argument_list|)
expr_stmt|;
block|}
DECL|method|getFilterFile ()
specifier|public
name|Predicate
name|getFilterFile
parameter_list|()
block|{
return|return
name|filterFile
return|;
block|}
comment|/**      * Filters the file based on Simple language.      * For example to filter on file size, you can use ${file:size}> 5000      */
DECL|method|setFilterFile (Predicate filterFile)
specifier|public
name|void
name|setFilterFile
parameter_list|(
name|Predicate
name|filterFile
parameter_list|)
block|{
name|this
operator|.
name|filterFile
operator|=
name|filterFile
expr_stmt|;
block|}
comment|/**      * Filters the file based on Simple language.      * For example to filter on file size, you can use ${file:size}> 5000      * @see #setFilterFile(Predicate)      */
DECL|method|setFilterFile (String expression)
specifier|public
name|void
name|setFilterFile
parameter_list|(
name|String
name|expression
parameter_list|)
block|{
name|this
operator|.
name|filterFile
operator|=
name|createFileLanguagePredicate
argument_list|(
name|expression
argument_list|)
expr_stmt|;
block|}
DECL|method|getPreMove ()
specifier|public
name|Expression
name|getPreMove
parameter_list|()
block|{
return|return
name|preMove
return|;
block|}
comment|/**      * Expression (such as File Language) used to dynamically set the filename when moving it before processing.      * For example to move in-progress files into the order directory set this value to order.      */
DECL|method|setPreMove (Expression preMove)
specifier|public
name|void
name|setPreMove
parameter_list|(
name|Expression
name|preMove
parameter_list|)
block|{
name|this
operator|.
name|preMove
operator|=
name|preMove
expr_stmt|;
block|}
DECL|method|setPreMove (String fileLanguageExpression)
specifier|public
name|void
name|setPreMove
parameter_list|(
name|String
name|fileLanguageExpression
parameter_list|)
block|{
name|String
name|expression
init|=
name|configureMoveOrPreMoveExpression
argument_list|(
name|fileLanguageExpression
argument_list|)
decl_stmt|;
name|this
operator|.
name|preMove
operator|=
name|createFileLanguageExpression
argument_list|(
name|expression
argument_list|)
expr_stmt|;
block|}
DECL|method|getMoveExisting ()
specifier|public
name|Expression
name|getMoveExisting
parameter_list|()
block|{
return|return
name|moveExisting
return|;
block|}
comment|/**      * Expression (such as File Language) used to compute file name to use when fileExist=Move is configured.      * To move files into a backup subdirectory just enter backup.      * This option only supports the following File Language tokens: "file:name", "file:name.ext", "file:name.noext", "file:onlyname",      * "file:onlyname.noext", "file:ext", and "file:parent". Notice the "file:parent" is not supported by the FTP component,      * as the FTP component can only move any existing files to a relative directory based on current dir as base.      */
DECL|method|setMoveExisting (Expression moveExisting)
specifier|public
name|void
name|setMoveExisting
parameter_list|(
name|Expression
name|moveExisting
parameter_list|)
block|{
name|this
operator|.
name|moveExisting
operator|=
name|moveExisting
expr_stmt|;
block|}
DECL|method|getMoveExistingFileStrategy ()
specifier|public
name|FileMoveExistingStrategy
name|getMoveExistingFileStrategy
parameter_list|()
block|{
return|return
name|moveExistingFileStrategy
return|;
block|}
comment|/**      * Strategy (Custom Strategy) used to move file with special naming token to use when fileExist=Move is configured.      * By default, there is an implementation used if no custom strategy is provided      */
DECL|method|setMoveExistingFileStrategy (FileMoveExistingStrategy moveExistingFileStrategy)
specifier|public
name|void
name|setMoveExistingFileStrategy
parameter_list|(
name|FileMoveExistingStrategy
name|moveExistingFileStrategy
parameter_list|)
block|{
name|this
operator|.
name|moveExistingFileStrategy
operator|=
name|moveExistingFileStrategy
expr_stmt|;
block|}
DECL|method|setMoveExisting (String fileLanguageExpression)
specifier|public
name|void
name|setMoveExisting
parameter_list|(
name|String
name|fileLanguageExpression
parameter_list|)
block|{
name|String
name|expression
init|=
name|configureMoveOrPreMoveExpression
argument_list|(
name|fileLanguageExpression
argument_list|)
decl_stmt|;
name|this
operator|.
name|moveExisting
operator|=
name|createFileLanguageExpression
argument_list|(
name|expression
argument_list|)
expr_stmt|;
block|}
DECL|method|getFileName ()
specifier|public
name|Expression
name|getFileName
parameter_list|()
block|{
return|return
name|fileName
return|;
block|}
comment|/**      * Use Expression such as File Language to dynamically set the filename.      * For consumers, it's used as a filename filter.      * For producers, it's used to evaluate the filename to write.      * If an expression is set, it take precedence over the CamelFileName header. (Note: The header itself can also be an Expression).      * The expression options support both String and Expression types.      * If the expression is a String type, it is always evaluated using the File Language.      * If the expression is an Expression type, the specified Expression type is used - this allows you,      * for instance, to use OGNL expressions. For the consumer, you can use it to filter filenames,      * so you can for instance consume today's file using the File Language syntax: mydata-${date:now:yyyyMMdd}.txt.      * The producers support the CamelOverruleFileName header which takes precedence over any existing CamelFileName header;      * the CamelOverruleFileName is a header that is used only once, and makes it easier as this avoids to temporary      * store CamelFileName and have to restore it afterwards.      */
DECL|method|setFileName (Expression fileName)
specifier|public
name|void
name|setFileName
parameter_list|(
name|Expression
name|fileName
parameter_list|)
block|{
name|this
operator|.
name|fileName
operator|=
name|fileName
expr_stmt|;
block|}
DECL|method|setFileName (String fileLanguageExpression)
specifier|public
name|void
name|setFileName
parameter_list|(
name|String
name|fileLanguageExpression
parameter_list|)
block|{
name|this
operator|.
name|fileName
operator|=
name|createFileLanguageExpression
argument_list|(
name|fileLanguageExpression
argument_list|)
expr_stmt|;
block|}
DECL|method|getDoneFileName ()
specifier|public
name|String
name|getDoneFileName
parameter_list|()
block|{
return|return
name|doneFileName
return|;
block|}
comment|/**      * Producer: If provided, then Camel will write a 2nd done file when the original file has been written.      * The done file will be empty. This option configures what file name to use.      * Either you can specify a fixed name. Or you can use dynamic placeholders.      * The done file will always be written in the same folder as the original file.      *<p/>      * Consumer: If provided, Camel will only consume files if a done file exists.      * This option configures what file name to use. Either you can specify a fixed name.      * Or you can use dynamic placeholders.The done file is always expected in the same folder      * as the original file.      *<p/>      * Only ${file.name} and ${file.name.noext} is supported as dynamic placeholders.      */
DECL|method|setDoneFileName (String doneFileName)
specifier|public
name|void
name|setDoneFileName
parameter_list|(
name|String
name|doneFileName
parameter_list|)
block|{
name|this
operator|.
name|doneFileName
operator|=
name|doneFileName
expr_stmt|;
block|}
DECL|method|isIdempotent ()
specifier|public
name|Boolean
name|isIdempotent
parameter_list|()
block|{
return|return
name|idempotent
operator|!=
literal|null
condition|?
name|idempotent
else|:
literal|false
return|;
block|}
DECL|method|getCharset ()
specifier|public
name|String
name|getCharset
parameter_list|()
block|{
return|return
name|charset
return|;
block|}
comment|/**      * This option is used to specify the encoding of the file.      * You can use this on the consumer, to specify the encodings of the files, which allow Camel to know the charset      * it should load the file content in case the file content is being accessed.      * Likewise when writing a file, you can use this option to specify which charset to write the file as well.      * Do mind that when writing the file Camel may have to read the message content into memory to be able to      * convert the data into the configured charset, so do not use this if you have big messages.      */
DECL|method|setCharset (String charset)
specifier|public
name|void
name|setCharset
parameter_list|(
name|String
name|charset
parameter_list|)
block|{
name|IOHelper
operator|.
name|validateCharset
argument_list|(
name|charset
argument_list|)
expr_stmt|;
name|this
operator|.
name|charset
operator|=
name|charset
expr_stmt|;
block|}
DECL|method|isIdempotentSet ()
specifier|protected
name|boolean
name|isIdempotentSet
parameter_list|()
block|{
return|return
name|idempotent
operator|!=
literal|null
return|;
block|}
comment|/**      * Option to use the Idempotent Consumer EIP pattern to let Camel skip already processed files.      * Will by default use a memory based LRUCache that holds 1000 entries. If noop=true then idempotent will be enabled      * as well to avoid consuming the same files over and over again.      */
DECL|method|setIdempotent (Boolean idempotent)
specifier|public
name|void
name|setIdempotent
parameter_list|(
name|Boolean
name|idempotent
parameter_list|)
block|{
name|this
operator|.
name|idempotent
operator|=
name|idempotent
expr_stmt|;
block|}
DECL|method|getIdempotentKey ()
specifier|public
name|Expression
name|getIdempotentKey
parameter_list|()
block|{
return|return
name|idempotentKey
return|;
block|}
comment|/**      * To use a custom idempotent key. By default the absolute path of the file is used.      * You can use the File Language, for example to use the file name and file size, you can do:      * idempotentKey=${file:name}-${file:size}      */
DECL|method|setIdempotentKey (Expression idempotentKey)
specifier|public
name|void
name|setIdempotentKey
parameter_list|(
name|Expression
name|idempotentKey
parameter_list|)
block|{
name|this
operator|.
name|idempotentKey
operator|=
name|idempotentKey
expr_stmt|;
block|}
DECL|method|setIdempotentKey (String expression)
specifier|public
name|void
name|setIdempotentKey
parameter_list|(
name|String
name|expression
parameter_list|)
block|{
name|this
operator|.
name|idempotentKey
operator|=
name|createFileLanguageExpression
argument_list|(
name|expression
argument_list|)
expr_stmt|;
block|}
DECL|method|getIdempotentRepository ()
specifier|public
name|IdempotentRepository
name|getIdempotentRepository
parameter_list|()
block|{
return|return
name|idempotentRepository
return|;
block|}
comment|/**      * A pluggable repository org.apache.camel.spi.IdempotentRepository which by default use MemoryMessageIdRepository      * if none is specified and idempotent is true.      */
DECL|method|setIdempotentRepository (IdempotentRepository idempotentRepository)
specifier|public
name|void
name|setIdempotentRepository
parameter_list|(
name|IdempotentRepository
name|idempotentRepository
parameter_list|)
block|{
name|this
operator|.
name|idempotentRepository
operator|=
name|idempotentRepository
expr_stmt|;
block|}
DECL|method|getFilter ()
specifier|public
name|GenericFileFilter
argument_list|<
name|T
argument_list|>
name|getFilter
parameter_list|()
block|{
return|return
name|filter
return|;
block|}
comment|/**      * Pluggable filter as a org.apache.camel.component.file.GenericFileFilter class.      * Will skip files if filter returns false in its accept() method.      */
DECL|method|setFilter (GenericFileFilter<T> filter)
specifier|public
name|void
name|setFilter
parameter_list|(
name|GenericFileFilter
argument_list|<
name|T
argument_list|>
name|filter
parameter_list|)
block|{
name|this
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
block|}
DECL|method|getSorter ()
specifier|public
name|Comparator
argument_list|<
name|GenericFile
argument_list|<
name|T
argument_list|>
argument_list|>
name|getSorter
parameter_list|()
block|{
return|return
name|sorter
return|;
block|}
comment|/**      * Pluggable sorter as a java.util.Comparator<org.apache.camel.component.file.GenericFile> class.      */
DECL|method|setSorter (Comparator<GenericFile<T>> sorter)
specifier|public
name|void
name|setSorter
parameter_list|(
name|Comparator
argument_list|<
name|GenericFile
argument_list|<
name|T
argument_list|>
argument_list|>
name|sorter
parameter_list|)
block|{
name|this
operator|.
name|sorter
operator|=
name|sorter
expr_stmt|;
block|}
DECL|method|getSortBy ()
specifier|public
name|Comparator
argument_list|<
name|Exchange
argument_list|>
name|getSortBy
parameter_list|()
block|{
return|return
name|sortBy
return|;
block|}
comment|/**      * Built-in sort by using the File Language.      * Supports nested sorts, so you can have a sort by file name and as a 2nd group sort by modified date.      */
DECL|method|setSortBy (Comparator<Exchange> sortBy)
specifier|public
name|void
name|setSortBy
parameter_list|(
name|Comparator
argument_list|<
name|Exchange
argument_list|>
name|sortBy
parameter_list|)
block|{
name|this
operator|.
name|sortBy
operator|=
name|sortBy
expr_stmt|;
block|}
DECL|method|setSortBy (String expression)
specifier|public
name|void
name|setSortBy
parameter_list|(
name|String
name|expression
parameter_list|)
block|{
name|setSortBy
argument_list|(
name|expression
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|setSortBy (String expression, boolean reverse)
specifier|public
name|void
name|setSortBy
parameter_list|(
name|String
name|expression
parameter_list|,
name|boolean
name|reverse
parameter_list|)
block|{
name|setSortBy
argument_list|(
name|GenericFileDefaultSorter
operator|.
name|sortByFileLanguage
argument_list|(
name|getCamelContext
argument_list|()
argument_list|,
name|expression
argument_list|,
name|reverse
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|isShuffle ()
specifier|public
name|boolean
name|isShuffle
parameter_list|()
block|{
return|return
name|shuffle
return|;
block|}
comment|/**      * To shuffle the list of files (sort in random order)      */
DECL|method|setShuffle (boolean shuffle)
specifier|public
name|void
name|setShuffle
parameter_list|(
name|boolean
name|shuffle
parameter_list|)
block|{
name|this
operator|.
name|shuffle
operator|=
name|shuffle
expr_stmt|;
block|}
DECL|method|getTempPrefix ()
specifier|public
name|String
name|getTempPrefix
parameter_list|()
block|{
return|return
name|tempPrefix
return|;
block|}
comment|/**      * This option is used to write the file using a temporary name and then, after the write is complete,      * rename it to the real name. Can be used to identify files being written and also avoid consumers      * (not using exclusive read locks) reading in progress files. Is often used by FTP when uploading big files.      */
DECL|method|setTempPrefix (String tempPrefix)
specifier|public
name|void
name|setTempPrefix
parameter_list|(
name|String
name|tempPrefix
parameter_list|)
block|{
name|this
operator|.
name|tempPrefix
operator|=
name|tempPrefix
expr_stmt|;
comment|// use only name as we set a prefix in from on the name
name|setTempFileName
argument_list|(
name|tempPrefix
operator|+
literal|"${file:onlyname}"
argument_list|)
expr_stmt|;
block|}
DECL|method|getTempFileName ()
specifier|public
name|Expression
name|getTempFileName
parameter_list|()
block|{
return|return
name|tempFileName
return|;
block|}
comment|/**      * The same as tempPrefix option but offering a more fine grained control on the naming of the temporary filename as it uses the File Language.      * The location for tempFilename is relative to the final file location in the option 'fileName', not the target directory in the base uri.      * For example if option fileName includes a directory prefix: dir/finalFilename then tempFileName is relative to that subdirectory dir.      */
DECL|method|setTempFileName (Expression tempFileName)
specifier|public
name|void
name|setTempFileName
parameter_list|(
name|Expression
name|tempFileName
parameter_list|)
block|{
name|this
operator|.
name|tempFileName
operator|=
name|tempFileName
expr_stmt|;
block|}
DECL|method|setTempFileName (String tempFileNameExpression)
specifier|public
name|void
name|setTempFileName
parameter_list|(
name|String
name|tempFileNameExpression
parameter_list|)
block|{
name|this
operator|.
name|tempFileName
operator|=
name|createFileLanguageExpression
argument_list|(
name|tempFileNameExpression
argument_list|)
expr_stmt|;
block|}
DECL|method|isEagerDeleteTargetFile ()
specifier|public
name|boolean
name|isEagerDeleteTargetFile
parameter_list|()
block|{
return|return
name|eagerDeleteTargetFile
return|;
block|}
comment|/**      * Whether or not to eagerly delete any existing target file.      * This option only applies when you use fileExists=Override and the tempFileName option as well.      * You can use this to disable (set it to false) deleting the target file before the temp file is written.      * For example you may write big files and want the target file to exists during the temp file is being written.      * This ensure the target file is only deleted until the very last moment, just before the temp file is being      * renamed to the target filename. This option is also used to control whether to delete any existing files when      * fileExist=Move is enabled, and an existing file exists.      * If this option copyAndDeleteOnRenameFails false, then an exception will be thrown if an existing file existed,      * if its true, then the existing file is deleted before the move operation.      */
DECL|method|setEagerDeleteTargetFile (boolean eagerDeleteTargetFile)
specifier|public
name|void
name|setEagerDeleteTargetFile
parameter_list|(
name|boolean
name|eagerDeleteTargetFile
parameter_list|)
block|{
name|this
operator|.
name|eagerDeleteTargetFile
operator|=
name|eagerDeleteTargetFile
expr_stmt|;
block|}
DECL|method|getConfiguration ()
specifier|public
name|GenericFileConfiguration
name|getConfiguration
parameter_list|()
block|{
if|if
condition|(
name|configuration
operator|==
literal|null
condition|)
block|{
name|configuration
operator|=
operator|new
name|GenericFileConfiguration
argument_list|()
expr_stmt|;
block|}
return|return
name|configuration
return|;
block|}
DECL|method|setConfiguration (GenericFileConfiguration configuration)
specifier|public
name|void
name|setConfiguration
parameter_list|(
name|GenericFileConfiguration
name|configuration
parameter_list|)
block|{
name|this
operator|.
name|configuration
operator|=
name|configuration
expr_stmt|;
block|}
DECL|method|getExclusiveReadLockStrategy ()
specifier|public
name|GenericFileExclusiveReadLockStrategy
argument_list|<
name|T
argument_list|>
name|getExclusiveReadLockStrategy
parameter_list|()
block|{
return|return
name|exclusiveReadLockStrategy
return|;
block|}
comment|/**      * Pluggable read-lock as a org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy implementation.      */
DECL|method|setExclusiveReadLockStrategy (GenericFileExclusiveReadLockStrategy<T> exclusiveReadLockStrategy)
specifier|public
name|void
name|setExclusiveReadLockStrategy
parameter_list|(
name|GenericFileExclusiveReadLockStrategy
argument_list|<
name|T
argument_list|>
name|exclusiveReadLockStrategy
parameter_list|)
block|{
name|this
operator|.
name|exclusiveReadLockStrategy
operator|=
name|exclusiveReadLockStrategy
expr_stmt|;
block|}
DECL|method|getReadLock ()
specifier|public
name|String
name|getReadLock
parameter_list|()
block|{
return|return
name|readLock
return|;
block|}
comment|/**      * Used by consumer, to only poll the files if it has exclusive read-lock on the file (i.e. the file is not in-progress or being written).      * Camel will wait until the file lock is granted.      *<p/>      * This option provides the build in strategies:      *<ul>      *<li>none - No read lock is in use      *<li>markerFile - Camel creates a marker file (fileName.camelLock) and then holds a lock on it. This option is not available for the FTP component      *<li>changed - Changed is using file length/modification timestamp to detect whether the file is currently being copied or not. Will at least use 1 sec      *     to determine this, so this option cannot consume files as fast as the others, but can be more reliable as the JDK IO API cannot      *     always determine whether a file is currently being used by another process. The option readLockCheckInterval can be used to set the check frequency.</li>      *<li>fileLock - is for using java.nio.channels.FileLock. This option is not avail for the FTP component. This approach should be avoided when accessing      *     a remote file system via a mount/share unless that file system supports distributed file locks.</li>      *<li>rename - rename is for using a try to rename the file as a test if we can get exclusive read-lock.</li>      *<li>idempotent - (only for file component) idempotent is for using a idempotentRepository as the read-lock.      *     This allows to use read locks that supports clustering if the idempotent repository implementation supports that.</li>      *<li>idempotent-changed - (only for file component) idempotent-changed is for using a idempotentRepository and changed as the combined read-lock.      *     This allows to use read locks that supports clustering if the idempotent repository implementation supports that.</li>      *<li>idempotent-rename - (only for file component) idempotent-rename is for using a idempotentRepository and rename as the combined read-lock.      *     This allows to use read locks that supports clustering if the idempotent repository implementation supports that.</li>      *</ul>      * Notice: The various read locks is not all suited to work in clustered mode, where concurrent consumers on different nodes is competing      * for the same files on a shared file system. The markerFile using a close to atomic operation to create the empty marker file,      * but its not guaranteed to work in a cluster. The fileLock may work better but then the file system need to support distributed file locks, and so on.      * Using the idempotent read lock can support clustering if the idempotent repository supports clustering, such as Hazelcast Component or Infinispan.      */
DECL|method|setReadLock (String readLock)
specifier|public
name|void
name|setReadLock
parameter_list|(
name|String
name|readLock
parameter_list|)
block|{
name|this
operator|.
name|readLock
operator|=
name|readLock
expr_stmt|;
block|}
DECL|method|getReadLockCheckInterval ()
specifier|public
name|long
name|getReadLockCheckInterval
parameter_list|()
block|{
return|return
name|readLockCheckInterval
return|;
block|}
comment|/**      * Interval in millis for the read-lock, if supported by the read lock.      * This interval is used for sleeping between attempts to acquire the read lock.      * For example when using the changed read lock, you can set a higher interval period to cater for slow writes.      * The default of 1 sec. may be too fast if the producer is very slow writing the file.      *<p/>      * Notice: For FTP the default readLockCheckInterval is 5000.      *<p/>      * The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout      * that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that amble      * time is allowed for the read lock process to try to grab the lock before the timeout was hit.      */
DECL|method|setReadLockCheckInterval (long readLockCheckInterval)
specifier|public
name|void
name|setReadLockCheckInterval
parameter_list|(
name|long
name|readLockCheckInterval
parameter_list|)
block|{
name|this
operator|.
name|readLockCheckInterval
operator|=
name|readLockCheckInterval
expr_stmt|;
block|}
DECL|method|getReadLockTimeout ()
specifier|public
name|long
name|getReadLockTimeout
parameter_list|()
block|{
return|return
name|readLockTimeout
return|;
block|}
comment|/**      * Optional timeout in millis for the read-lock, if supported by the read-lock.      * If the read-lock could not be granted and the timeout triggered, then Camel will skip the file.      * At next poll Camel, will try the file again, and this time maybe the read-lock could be granted.      * Use a value of 0 or lower to indicate forever. Currently fileLock, changed and rename support the timeout.      *<p/>      * Notice: For FTP the default readLockTimeout value is 20000 instead of 10000.      *<p/>      * The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout      * that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that amble      * time is allowed for the read lock process to try to grab the lock before the timeout was hit.      */
DECL|method|setReadLockTimeout (long readLockTimeout)
specifier|public
name|void
name|setReadLockTimeout
parameter_list|(
name|long
name|readLockTimeout
parameter_list|)
block|{
name|this
operator|.
name|readLockTimeout
operator|=
name|readLockTimeout
expr_stmt|;
block|}
DECL|method|isReadLockMarkerFile ()
specifier|public
name|boolean
name|isReadLockMarkerFile
parameter_list|()
block|{
return|return
name|readLockMarkerFile
return|;
block|}
comment|/**      * Whether to use marker file with the changed, rename, or exclusive read lock types.      * By default a marker file is used as well to guard against other processes picking up the same files.      * This behavior can be turned off by setting this option to false.      * For example if you do not want to write marker files to the file systems by the Camel application.      */
DECL|method|setReadLockMarkerFile (boolean readLockMarkerFile)
specifier|public
name|void
name|setReadLockMarkerFile
parameter_list|(
name|boolean
name|readLockMarkerFile
parameter_list|)
block|{
name|this
operator|.
name|readLockMarkerFile
operator|=
name|readLockMarkerFile
expr_stmt|;
block|}
DECL|method|isReadLockDeleteOrphanLockFiles ()
specifier|public
name|boolean
name|isReadLockDeleteOrphanLockFiles
parameter_list|()
block|{
return|return
name|readLockDeleteOrphanLockFiles
return|;
block|}
comment|/**      * Whether or not read lock with marker files should upon startup delete any orphan read lock files, which may      * have been left on the file system, if Camel was not properly shutdown (such as a JVM crash).      *<p/>      * If turning this option to<tt>false</tt> then any orphaned lock file will cause Camel to not attempt to pickup      * that file, this could also be due another node is concurrently reading files from the same shared directory.      */
DECL|method|setReadLockDeleteOrphanLockFiles (boolean readLockDeleteOrphanLockFiles)
specifier|public
name|void
name|setReadLockDeleteOrphanLockFiles
parameter_list|(
name|boolean
name|readLockDeleteOrphanLockFiles
parameter_list|)
block|{
name|this
operator|.
name|readLockDeleteOrphanLockFiles
operator|=
name|readLockDeleteOrphanLockFiles
expr_stmt|;
block|}
DECL|method|getReadLockLoggingLevel ()
specifier|public
name|LoggingLevel
name|getReadLockLoggingLevel
parameter_list|()
block|{
return|return
name|readLockLoggingLevel
return|;
block|}
comment|/**      * Logging level used when a read lock could not be acquired.      * By default a DEBUG is logged.      * You can change this level, for example to OFF to not have any logging.      * This option is only applicable for readLock of types: changed, fileLock, idempotent, idempotent-changed, idempotent-rename, rename.      */
DECL|method|setReadLockLoggingLevel (LoggingLevel readLockLoggingLevel)
specifier|public
name|void
name|setReadLockLoggingLevel
parameter_list|(
name|LoggingLevel
name|readLockLoggingLevel
parameter_list|)
block|{
name|this
operator|.
name|readLockLoggingLevel
operator|=
name|readLockLoggingLevel
expr_stmt|;
block|}
DECL|method|getReadLockMinLength ()
specifier|public
name|long
name|getReadLockMinLength
parameter_list|()
block|{
return|return
name|readLockMinLength
return|;
block|}
comment|/**      * This option is applied only for readLock=changed. It allows you to configure a minimum file length.      * By default Camel expects the file to contain data, and thus the default value is 1.      * You can set this option to zero, to allow consuming zero-length files.      */
DECL|method|setReadLockMinLength (long readLockMinLength)
specifier|public
name|void
name|setReadLockMinLength
parameter_list|(
name|long
name|readLockMinLength
parameter_list|)
block|{
name|this
operator|.
name|readLockMinLength
operator|=
name|readLockMinLength
expr_stmt|;
block|}
DECL|method|getReadLockMinAge ()
specifier|public
name|long
name|getReadLockMinAge
parameter_list|()
block|{
return|return
name|readLockMinAge
return|;
block|}
comment|/**      * This option is applied only for readLock=changed.      * It allows to specify a minimum age the file must be before attempting to acquire the read lock.      * For example use readLockMinAge=300s to require the file is at last 5 minutes old.      * This can speedup the changed read lock as it will only attempt to acquire files which are at least that given age.      */
DECL|method|setReadLockMinAge (long readLockMinAge)
specifier|public
name|void
name|setReadLockMinAge
parameter_list|(
name|long
name|readLockMinAge
parameter_list|)
block|{
name|this
operator|.
name|readLockMinAge
operator|=
name|readLockMinAge
expr_stmt|;
block|}
DECL|method|isReadLockRemoveOnRollback ()
specifier|public
name|boolean
name|isReadLockRemoveOnRollback
parameter_list|()
block|{
return|return
name|readLockRemoveOnRollback
return|;
block|}
comment|/**      * This option is applied only for readLock=idempotent.      * It allows to specify whether to remove the file name entry from the idempotent repository      * when processing the file failed and a rollback happens.      * If this option is false, then the file name entry is confirmed (as if the file did a commit).      */
DECL|method|setReadLockRemoveOnRollback (boolean readLockRemoveOnRollback)
specifier|public
name|void
name|setReadLockRemoveOnRollback
parameter_list|(
name|boolean
name|readLockRemoveOnRollback
parameter_list|)
block|{
name|this
operator|.
name|readLockRemoveOnRollback
operator|=
name|readLockRemoveOnRollback
expr_stmt|;
block|}
DECL|method|isReadLockRemoveOnCommit ()
specifier|public
name|boolean
name|isReadLockRemoveOnCommit
parameter_list|()
block|{
return|return
name|readLockRemoveOnCommit
return|;
block|}
comment|/**      * This option is applied only for readLock=idempotent.      * It allows to specify whether to remove the file name entry from the idempotent repository      * when processing the file is succeeded and a commit happens.      *<p/>      * By default the file is not removed which ensures that any race-condition do not occur so another active      * node may attempt to grab the file. Instead the idempotent repository may support eviction strategies      * that you can configure to evict the file name entry after X minutes - this ensures no problems with race conditions.      *<p/>      * See more details at the readLockIdempotentReleaseDelay option.      */
DECL|method|setReadLockRemoveOnCommit (boolean readLockRemoveOnCommit)
specifier|public
name|void
name|setReadLockRemoveOnCommit
parameter_list|(
name|boolean
name|readLockRemoveOnCommit
parameter_list|)
block|{
name|this
operator|.
name|readLockRemoveOnCommit
operator|=
name|readLockRemoveOnCommit
expr_stmt|;
block|}
comment|/**      * Whether to delay the release task for a period of millis.      *<p/>      * This can be used to delay the release tasks to expand the window when a file is regarded as read-locked,      * in an active/active cluster scenario with a shared idempotent repository, to ensure other nodes cannot potentially scan and acquire      * the same file, due to race-conditions. By expanding the time-window of the release tasks helps prevents these situations.      * Note delaying is only needed if you have configured readLockRemoveOnCommit to true.      */
DECL|method|setReadLockIdempotentReleaseDelay (int readLockIdempotentReleaseDelay)
specifier|public
name|void
name|setReadLockIdempotentReleaseDelay
parameter_list|(
name|int
name|readLockIdempotentReleaseDelay
parameter_list|)
block|{
name|this
operator|.
name|readLockIdempotentReleaseDelay
operator|=
name|readLockIdempotentReleaseDelay
expr_stmt|;
block|}
DECL|method|isReadLockIdempotentReleaseAsync ()
specifier|public
name|boolean
name|isReadLockIdempotentReleaseAsync
parameter_list|()
block|{
return|return
name|readLockIdempotentReleaseAsync
return|;
block|}
comment|/**      * Whether the delayed release task should be synchronous or asynchronous.      *<p/>      * See more details at the readLockIdempotentReleaseDelay option.      */
DECL|method|setReadLockIdempotentReleaseAsync (boolean readLockIdempotentReleaseAsync)
specifier|public
name|void
name|setReadLockIdempotentReleaseAsync
parameter_list|(
name|boolean
name|readLockIdempotentReleaseAsync
parameter_list|)
block|{
name|this
operator|.
name|readLockIdempotentReleaseAsync
operator|=
name|readLockIdempotentReleaseAsync
expr_stmt|;
block|}
DECL|method|getReadLockIdempotentReleaseAsyncPoolSize ()
specifier|public
name|int
name|getReadLockIdempotentReleaseAsyncPoolSize
parameter_list|()
block|{
return|return
name|readLockIdempotentReleaseAsyncPoolSize
return|;
block|}
comment|/**      * The number of threads in the scheduled thread pool when using asynchronous release tasks.      * Using a default of 1 core threads should be sufficient in almost all use-cases, only set this to a higher value      * if either updating the idempotent repository is slow, or there are a lot of files to process.      * This option is not in-use if you use a shared thread pool by configuring the readLockIdempotentReleaseExecutorService option.      *<p/>      * See more details at the readLockIdempotentReleaseDelay option.      */
DECL|method|setReadLockIdempotentReleaseAsyncPoolSize (int readLockIdempotentReleaseAsyncPoolSize)
specifier|public
name|void
name|setReadLockIdempotentReleaseAsyncPoolSize
parameter_list|(
name|int
name|readLockIdempotentReleaseAsyncPoolSize
parameter_list|)
block|{
name|this
operator|.
name|readLockIdempotentReleaseAsyncPoolSize
operator|=
name|readLockIdempotentReleaseAsyncPoolSize
expr_stmt|;
block|}
DECL|method|getReadLockIdempotentReleaseExecutorService ()
specifier|public
name|ScheduledExecutorService
name|getReadLockIdempotentReleaseExecutorService
parameter_list|()
block|{
return|return
name|readLockIdempotentReleaseExecutorService
return|;
block|}
comment|/**      * To use a custom and shared thread pool for asynchronous release tasks.      *<p/>      * See more details at the readLockIdempotentReleaseDelay option.      */
DECL|method|setReadLockIdempotentReleaseExecutorService (ScheduledExecutorService readLockIdempotentReleaseExecutorService)
specifier|public
name|void
name|setReadLockIdempotentReleaseExecutorService
parameter_list|(
name|ScheduledExecutorService
name|readLockIdempotentReleaseExecutorService
parameter_list|)
block|{
name|this
operator|.
name|readLockIdempotentReleaseExecutorService
operator|=
name|readLockIdempotentReleaseExecutorService
expr_stmt|;
block|}
DECL|method|getBufferSize ()
specifier|public
name|int
name|getBufferSize
parameter_list|()
block|{
return|return
name|bufferSize
return|;
block|}
comment|/**      * Write buffer sized in bytes.      */
DECL|method|setBufferSize (int bufferSize)
specifier|public
name|void
name|setBufferSize
parameter_list|(
name|int
name|bufferSize
parameter_list|)
block|{
if|if
condition|(
name|bufferSize
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"BufferSize must be a positive value, was "
operator|+
name|bufferSize
argument_list|)
throw|;
block|}
name|this
operator|.
name|bufferSize
operator|=
name|bufferSize
expr_stmt|;
block|}
DECL|method|getFileExist ()
specifier|public
name|GenericFileExist
name|getFileExist
parameter_list|()
block|{
return|return
name|fileExist
return|;
block|}
comment|/**      * What to do if a file already exists with the same name.      *      * Override, which is the default, replaces the existing file.      *<ul>      *<li>Append - adds content to the existing file.</li>      *<li>Fail - throws a GenericFileOperationException, indicating that there is already an existing file.</li>      *<li>Ignore - silently ignores the problem and does not override the existing file, but assumes everything is okay.</li>      *<li>Move - option requires to use the moveExisting option to be configured as well.      *   The option eagerDeleteTargetFile can be used to control what to do if an moving the file, and there exists already an existing file,      *   otherwise causing the move operation to fail.      *   The Move option will move any existing files, before writing the target file.</li>      *<li>TryRename is only applicable if tempFileName option is in use. This allows to try renaming the file from the temporary name to the actual name,      *   without doing any exists check. This check may be faster on some file systems and especially FTP servers.</li>      *</ul>      */
DECL|method|setFileExist (GenericFileExist fileExist)
specifier|public
name|void
name|setFileExist
parameter_list|(
name|GenericFileExist
name|fileExist
parameter_list|)
block|{
name|this
operator|.
name|fileExist
operator|=
name|fileExist
expr_stmt|;
block|}
DECL|method|isAutoCreate ()
specifier|public
name|boolean
name|isAutoCreate
parameter_list|()
block|{
return|return
name|autoCreate
return|;
block|}
comment|/**      * Automatically create missing directories in the file's pathname. For the file consumer, that means creating the starting directory.      * For the file producer, it means the directory the files should be written to.      */
DECL|method|setAutoCreate (boolean autoCreate)
specifier|public
name|void
name|setAutoCreate
parameter_list|(
name|boolean
name|autoCreate
parameter_list|)
block|{
name|this
operator|.
name|autoCreate
operator|=
name|autoCreate
expr_stmt|;
block|}
DECL|method|isStartingDirectoryMustExist ()
specifier|public
name|boolean
name|isStartingDirectoryMustExist
parameter_list|()
block|{
return|return
name|startingDirectoryMustExist
return|;
block|}
comment|/**      * Whether the starting directory must exist. Mind that the autoCreate option is default enabled,      * which means the starting directory is normally auto created if it doesn't exist.      * You can disable autoCreate and enable this to ensure the starting directory must exist. Will thrown an exception if the directory doesn't exist.      */
DECL|method|setStartingDirectoryMustExist (boolean startingDirectoryMustExist)
specifier|public
name|void
name|setStartingDirectoryMustExist
parameter_list|(
name|boolean
name|startingDirectoryMustExist
parameter_list|)
block|{
name|this
operator|.
name|startingDirectoryMustExist
operator|=
name|startingDirectoryMustExist
expr_stmt|;
block|}
DECL|method|isDirectoryMustExist ()
specifier|public
name|boolean
name|isDirectoryMustExist
parameter_list|()
block|{
return|return
name|directoryMustExist
return|;
block|}
comment|/**      * Similar to the startingDirectoryMustExist option but this applies during polling (after starting the consumer).      */
DECL|method|setDirectoryMustExist (boolean directoryMustExist)
specifier|public
name|void
name|setDirectoryMustExist
parameter_list|(
name|boolean
name|directoryMustExist
parameter_list|)
block|{
name|this
operator|.
name|directoryMustExist
operator|=
name|directoryMustExist
expr_stmt|;
block|}
DECL|method|getProcessStrategy ()
specifier|public
name|GenericFileProcessStrategy
argument_list|<
name|T
argument_list|>
name|getProcessStrategy
parameter_list|()
block|{
return|return
name|processStrategy
return|;
block|}
comment|/**      * A pluggable org.apache.camel.component.file.GenericFileProcessStrategy allowing you to implement your own readLock option or similar.      * Can also be used when special conditions must be met before a file can be consumed, such as a special ready file exists.      * If this option is set then the readLock option does not apply.      */
DECL|method|setProcessStrategy (GenericFileProcessStrategy<T> processStrategy)
specifier|public
name|void
name|setProcessStrategy
parameter_list|(
name|GenericFileProcessStrategy
argument_list|<
name|T
argument_list|>
name|processStrategy
parameter_list|)
block|{
name|this
operator|.
name|processStrategy
operator|=
name|processStrategy
expr_stmt|;
block|}
DECL|method|getLocalWorkDirectory ()
specifier|public
name|String
name|getLocalWorkDirectory
parameter_list|()
block|{
return|return
name|localWorkDirectory
return|;
block|}
comment|/**      * When consuming, a local work directory can be used to store the remote file content directly in local files,      * to avoid loading the content into memory. This is beneficial, if you consume a very big remote file and thus can conserve memory.      */
DECL|method|setLocalWorkDirectory (String localWorkDirectory)
specifier|public
name|void
name|setLocalWorkDirectory
parameter_list|(
name|String
name|localWorkDirectory
parameter_list|)
block|{
name|this
operator|.
name|localWorkDirectory
operator|=
name|localWorkDirectory
expr_stmt|;
block|}
DECL|method|getMaxMessagesPerPoll ()
specifier|public
name|int
name|getMaxMessagesPerPoll
parameter_list|()
block|{
return|return
name|maxMessagesPerPoll
return|;
block|}
comment|/**      * To define a maximum messages to gather per poll.      * By default no maximum is set. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files.      * Set a value of 0 or negative to disabled it.      * Notice: If this option is in use then the File and FTP components will limit before any sorting.      * For example if you have 100000 files and use maxMessagesPerPoll=500, then only the first 500 files will be picked up, and then sorted.      * You can use the eagerMaxMessagesPerPoll option and set this to false to allow to scan all files first and then sort afterwards.      */
DECL|method|setMaxMessagesPerPoll (int maxMessagesPerPoll)
specifier|public
name|void
name|setMaxMessagesPerPoll
parameter_list|(
name|int
name|maxMessagesPerPoll
parameter_list|)
block|{
name|this
operator|.
name|maxMessagesPerPoll
operator|=
name|maxMessagesPerPoll
expr_stmt|;
block|}
DECL|method|isEagerMaxMessagesPerPoll ()
specifier|public
name|boolean
name|isEagerMaxMessagesPerPoll
parameter_list|()
block|{
return|return
name|eagerMaxMessagesPerPoll
return|;
block|}
comment|/**      * Allows for controlling whether the limit from maxMessagesPerPoll is eager or not.      * If eager then the limit is during the scanning of files. Where as false would scan all files, and then perform sorting.      * Setting this option to false allows for sorting all files first, and then limit the poll. Mind that this requires a      * higher memory usage as all file details are in memory to perform the sorting.      */
DECL|method|setEagerMaxMessagesPerPoll (boolean eagerMaxMessagesPerPoll)
specifier|public
name|void
name|setEagerMaxMessagesPerPoll
parameter_list|(
name|boolean
name|eagerMaxMessagesPerPoll
parameter_list|)
block|{
name|this
operator|.
name|eagerMaxMessagesPerPoll
operator|=
name|eagerMaxMessagesPerPoll
expr_stmt|;
block|}
DECL|method|getMaxDepth ()
specifier|public
name|int
name|getMaxDepth
parameter_list|()
block|{
return|return
name|maxDepth
return|;
block|}
comment|/**      * The maximum depth to traverse when recursively processing a directory.      */
DECL|method|setMaxDepth (int maxDepth)
specifier|public
name|void
name|setMaxDepth
parameter_list|(
name|int
name|maxDepth
parameter_list|)
block|{
name|this
operator|.
name|maxDepth
operator|=
name|maxDepth
expr_stmt|;
block|}
DECL|method|getMinDepth ()
specifier|public
name|int
name|getMinDepth
parameter_list|()
block|{
return|return
name|minDepth
return|;
block|}
comment|/**      * The minimum depth to start processing when recursively processing a directory.      * Using minDepth=1 means the base directory. Using minDepth=2 means the first sub directory.      */
DECL|method|setMinDepth (int minDepth)
specifier|public
name|void
name|setMinDepth
parameter_list|(
name|int
name|minDepth
parameter_list|)
block|{
name|this
operator|.
name|minDepth
operator|=
name|minDepth
expr_stmt|;
block|}
DECL|method|getInProgressRepository ()
specifier|public
name|IdempotentRepository
name|getInProgressRepository
parameter_list|()
block|{
return|return
name|inProgressRepository
return|;
block|}
comment|/**      * A pluggable in-progress repository org.apache.camel.spi.IdempotentRepository.      * The in-progress repository is used to account the current in progress files being consumed. By default a memory based repository is used.      */
DECL|method|setInProgressRepository (IdempotentRepository inProgressRepository)
specifier|public
name|void
name|setInProgressRepository
parameter_list|(
name|IdempotentRepository
name|inProgressRepository
parameter_list|)
block|{
name|this
operator|.
name|inProgressRepository
operator|=
name|inProgressRepository
expr_stmt|;
block|}
DECL|method|isKeepLastModified ()
specifier|public
name|boolean
name|isKeepLastModified
parameter_list|()
block|{
return|return
name|keepLastModified
return|;
block|}
comment|/**      * Will keep the last modified timestamp from the source file (if any).      * Will use the Exchange.FILE_LAST_MODIFIED header to located the timestamp.      * This header can contain either a java.util.Date or long with the timestamp.      * If the timestamp exists and the option is enabled it will set this timestamp on the written file.      * Note: This option only applies to the file producer. You cannot use this option with any of the ftp producers.      */
DECL|method|setKeepLastModified (boolean keepLastModified)
specifier|public
name|void
name|setKeepLastModified
parameter_list|(
name|boolean
name|keepLastModified
parameter_list|)
block|{
name|this
operator|.
name|keepLastModified
operator|=
name|keepLastModified
expr_stmt|;
block|}
DECL|method|isAllowNullBody ()
specifier|public
name|boolean
name|isAllowNullBody
parameter_list|()
block|{
return|return
name|allowNullBody
return|;
block|}
comment|/**      * Used to specify if a null body is allowed during file writing.      * If set to true then an empty file will be created, when set to false, and attempting to send a null body to the file component,      * a GenericFileWriteException of 'Cannot write null body to file.' will be thrown.      * If the `fileExist` option is set to 'Override', then the file will be truncated, and if set to `append` the file will remain unchanged.      */
DECL|method|setAllowNullBody (boolean allowNullBody)
specifier|public
name|void
name|setAllowNullBody
parameter_list|(
name|boolean
name|allowNullBody
parameter_list|)
block|{
name|this
operator|.
name|allowNullBody
operator|=
name|allowNullBody
expr_stmt|;
block|}
DECL|method|isJailStartingDirectory ()
specifier|public
name|boolean
name|isJailStartingDirectory
parameter_list|()
block|{
return|return
name|jailStartingDirectory
return|;
block|}
comment|/**      * Used for jailing (restricting) writing files to the starting directory (and sub) only.      * This is enabled by default to not allow Camel to write files to outside directories (to be more secured out of the box).      * You can turn this off to allow writing files to directories outside the starting directory, such as parent or root folders.      */
DECL|method|setJailStartingDirectory (boolean jailStartingDirectory)
specifier|public
name|void
name|setJailStartingDirectory
parameter_list|(
name|boolean
name|jailStartingDirectory
parameter_list|)
block|{
name|this
operator|.
name|jailStartingDirectory
operator|=
name|jailStartingDirectory
expr_stmt|;
block|}
DECL|method|getOnCompletionExceptionHandler ()
specifier|public
name|ExceptionHandler
name|getOnCompletionExceptionHandler
parameter_list|()
block|{
return|return
name|onCompletionExceptionHandler
return|;
block|}
comment|/**      * To use a custom {@link org.apache.camel.spi.ExceptionHandler} to handle any thrown exceptions that happens      * during the file on completion process where the consumer does either a commit or rollback. The default      * implementation will log any exception at WARN level and ignore.      */
DECL|method|setOnCompletionExceptionHandler (ExceptionHandler onCompletionExceptionHandler)
specifier|public
name|void
name|setOnCompletionExceptionHandler
parameter_list|(
name|ExceptionHandler
name|onCompletionExceptionHandler
parameter_list|)
block|{
name|this
operator|.
name|onCompletionExceptionHandler
operator|=
name|onCompletionExceptionHandler
expr_stmt|;
block|}
comment|/**      * Configures the given message with the file which sets the body to the      * file object.      */
DECL|method|configureMessage (GenericFile<T> file, Message message)
specifier|public
name|void
name|configureMessage
parameter_list|(
name|GenericFile
argument_list|<
name|T
argument_list|>
name|file
parameter_list|,
name|Message
name|message
parameter_list|)
block|{
name|message
operator|.
name|setBody
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|flatten
condition|)
block|{
comment|// when flatten the file name should not contain any paths
name|message
operator|.
name|setHeader
argument_list|(
name|Exchange
operator|.
name|FILE_NAME
argument_list|,
name|file
operator|.
name|getFileNameOnly
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// compute name to set on header that should be relative to starting directory
name|String
name|name
init|=
name|file
operator|.
name|isAbsolute
argument_list|()
condition|?
name|file
operator|.
name|getAbsoluteFilePath
argument_list|()
else|:
name|file
operator|.
name|getRelativeFilePath
argument_list|()
decl_stmt|;
comment|// skip leading endpoint configured directory
name|String
name|endpointPath
init|=
name|getConfiguration
argument_list|()
operator|.
name|getDirectory
argument_list|()
operator|+
name|getFileSeparator
argument_list|()
decl_stmt|;
comment|// need to normalize paths to ensure we can match using startsWith
name|endpointPath
operator|=
name|FileUtil
operator|.
name|normalizePath
argument_list|(
name|endpointPath
argument_list|)
expr_stmt|;
name|String
name|copyOfName
init|=
name|FileUtil
operator|.
name|normalizePath
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ObjectHelper
operator|.
name|isNotEmpty
argument_list|(
name|endpointPath
argument_list|)
operator|&&
name|copyOfName
operator|.
name|startsWith
argument_list|(
name|endpointPath
argument_list|)
condition|)
block|{
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
name|endpointPath
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// adjust filename
name|message
operator|.
name|setHeader
argument_list|(
name|Exchange
operator|.
name|FILE_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Set up the exchange properties with the options of the file endpoint      */
DECL|method|configureExchange (Exchange exchange)
specifier|public
name|void
name|configureExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
comment|// Now we just set the charset property here
if|if
condition|(
name|getCharset
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|CHARSET_NAME
argument_list|,
name|getCharset
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Strategy to configure the move, preMove, or moveExisting option based on a String input.      *      * @param expression the original string input      * @return configured string or the original if no modifications is needed      */
DECL|method|configureMoveOrPreMoveExpression (String expression)
specifier|protected
name|String
name|configureMoveOrPreMoveExpression
parameter_list|(
name|String
name|expression
parameter_list|)
block|{
comment|// if the expression already have ${ } placeholders then pass it unmodified
if|if
condition|(
name|StringHelper
operator|.
name|hasStartToken
argument_list|(
name|expression
argument_list|,
literal|"simple"
argument_list|)
condition|)
block|{
return|return
name|expression
return|;
block|}
comment|// remove trailing slash
name|expression
operator|=
name|FileUtil
operator|.
name|stripTrailingSeparator
argument_list|(
name|expression
argument_list|)
expr_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// if relative then insert start with the parent folder
if|if
condition|(
operator|!
name|isAbsolute
argument_list|(
name|expression
argument_list|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"${file:parent}"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getFileSeparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// insert the directory the end user provided
name|sb
operator|.
name|append
argument_list|(
name|expression
argument_list|)
expr_stmt|;
comment|// append only the filename (file:name can contain a relative path, so we must use onlyname)
name|sb
operator|.
name|append
argument_list|(
name|getFileSeparator
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"${file:onlyname}"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|getParamsAsMap ()
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getParamsAsMap
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|params
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|isNoop
argument_list|()
condition|)
block|{
name|params
operator|.
name|put
argument_list|(
literal|"noop"
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isDelete
argument_list|()
condition|)
block|{
name|params
operator|.
name|put
argument_list|(
literal|"delete"
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|move
operator|!=
literal|null
condition|)
block|{
name|params
operator|.
name|put
argument_list|(
literal|"move"
argument_list|,
name|move
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|moveFailed
operator|!=
literal|null
condition|)
block|{
name|params
operator|.
name|put
argument_list|(
literal|"moveFailed"
argument_list|,
name|moveFailed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|preMove
operator|!=
literal|null
condition|)
block|{
name|params
operator|.
name|put
argument_list|(
literal|"preMove"
argument_list|,
name|preMove
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exclusiveReadLockStrategy
operator|!=
literal|null
condition|)
block|{
name|params
operator|.
name|put
argument_list|(
literal|"exclusiveReadLockStrategy"
argument_list|,
name|exclusiveReadLockStrategy
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|readLock
operator|!=
literal|null
condition|)
block|{
name|params
operator|.
name|put
argument_list|(
literal|"readLock"
argument_list|,
name|readLock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|"idempotent"
operator|.
name|equals
argument_list|(
name|readLock
argument_list|)
operator|||
literal|"idempotent-changed"
operator|.
name|equals
argument_list|(
name|readLock
argument_list|)
operator|||
literal|"idempotent-rename"
operator|.
name|equals
argument_list|(
name|readLock
argument_list|)
condition|)
block|{
name|params
operator|.
name|put
argument_list|(
literal|"readLockIdempotentRepository"
argument_list|,
name|idempotentRepository
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|readLockCheckInterval
operator|>
literal|0
condition|)
block|{
name|params
operator|.
name|put
argument_list|(
literal|"readLockCheckInterval"
argument_list|,
name|readLockCheckInterval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|readLockTimeout
operator|>
literal|0
condition|)
block|{
name|params
operator|.
name|put
argument_list|(
literal|"readLockTimeout"
argument_list|,
name|readLockTimeout
argument_list|)
expr_stmt|;
block|}
name|params
operator|.
name|put
argument_list|(
literal|"readLockMarkerFile"
argument_list|,
name|readLockMarkerFile
argument_list|)
expr_stmt|;
name|params
operator|.
name|put
argument_list|(
literal|"readLockDeleteOrphanLockFiles"
argument_list|,
name|readLockDeleteOrphanLockFiles
argument_list|)
expr_stmt|;
name|params
operator|.
name|put
argument_list|(
literal|"readLockMinLength"
argument_list|,
name|readLockMinLength
argument_list|)
expr_stmt|;
name|params
operator|.
name|put
argument_list|(
literal|"readLockLoggingLevel"
argument_list|,
name|readLockLoggingLevel
argument_list|)
expr_stmt|;
name|params
operator|.
name|put
argument_list|(
literal|"readLockMinAge"
argument_list|,
name|readLockMinAge
argument_list|)
expr_stmt|;
name|params
operator|.
name|put
argument_list|(
literal|"readLockRemoveOnRollback"
argument_list|,
name|readLockRemoveOnRollback
argument_list|)
expr_stmt|;
name|params
operator|.
name|put
argument_list|(
literal|"readLockRemoveOnCommit"
argument_list|,
name|readLockRemoveOnCommit
argument_list|)
expr_stmt|;
if|if
condition|(
name|readLockIdempotentReleaseDelay
operator|>
literal|0
condition|)
block|{
name|params
operator|.
name|put
argument_list|(
literal|"readLockIdempotentReleaseDelay"
argument_list|,
name|readLockIdempotentReleaseDelay
argument_list|)
expr_stmt|;
block|}
name|params
operator|.
name|put
argument_list|(
literal|"readLockIdempotentReleaseAsync"
argument_list|,
name|readLockIdempotentReleaseAsync
argument_list|)
expr_stmt|;
if|if
condition|(
name|readLockIdempotentReleaseAsyncPoolSize
operator|>
literal|0
condition|)
block|{
name|params
operator|.
name|put
argument_list|(
literal|"readLockIdempotentReleaseAsyncPoolSize"
argument_list|,
name|readLockIdempotentReleaseAsyncPoolSize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|readLockIdempotentReleaseExecutorService
operator|!=
literal|null
condition|)
block|{
name|params
operator|.
name|put
argument_list|(
literal|"readLockIdempotentReleaseExecutorService"
argument_list|,
name|readLockIdempotentReleaseExecutorService
argument_list|)
expr_stmt|;
block|}
return|return
name|params
return|;
block|}
DECL|method|createFileLanguageExpression (String expression)
specifier|private
name|Expression
name|createFileLanguageExpression
parameter_list|(
name|String
name|expression
parameter_list|)
block|{
name|Language
name|language
decl_stmt|;
comment|// only use file language if the name is complex (eg. using $)
if|if
condition|(
name|expression
operator|.
name|contains
argument_list|(
literal|"$"
argument_list|)
condition|)
block|{
name|language
operator|=
name|getCamelContext
argument_list|()
operator|.
name|resolveLanguage
argument_list|(
literal|"file"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|language
operator|=
name|getCamelContext
argument_list|()
operator|.
name|resolveLanguage
argument_list|(
literal|"constant"
argument_list|)
expr_stmt|;
block|}
return|return
name|language
operator|.
name|createExpression
argument_list|(
name|expression
argument_list|)
return|;
block|}
DECL|method|createFileLanguagePredicate (String expression)
specifier|private
name|Predicate
name|createFileLanguagePredicate
parameter_list|(
name|String
name|expression
parameter_list|)
block|{
name|Language
name|language
init|=
name|getCamelContext
argument_list|()
operator|.
name|resolveLanguage
argument_list|(
literal|"file"
argument_list|)
decl_stmt|;
return|return
name|language
operator|.
name|createPredicate
argument_list|(
name|expression
argument_list|)
return|;
block|}
comment|/**      * Creates the associated name of the done file based on the given file name.      *<p/>      * This method should only be invoked if a done filename property has been set on this endpoint.      *      * @param fileName the file name      * @return name of the associated done file name      */
DECL|method|createDoneFileName (String fileName)
specifier|protected
name|String
name|createDoneFileName
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
name|String
name|pattern
init|=
name|getDoneFileName
argument_list|()
decl_stmt|;
name|StringHelper
operator|.
name|notEmpty
argument_list|(
name|pattern
argument_list|,
literal|"doneFileName"
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
comment|// we only support ${file:name} or ${file:name.noext} as dynamic placeholders for done files
name|String
name|path
init|=
name|FileUtil
operator|.
name|onlyPath
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|String
name|onlyName
init|=
name|Matcher
operator|.
name|quoteReplacement
argument_list|(
name|FileUtil
operator|.
name|stripPath
argument_list|(
name|fileName
argument_list|)
argument_list|)
decl_stmt|;
name|pattern
operator|=
name|pattern
operator|.
name|replaceFirst
argument_list|(
literal|"\\$\\{file:name\\}"
argument_list|,
name|onlyName
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|pattern
operator|.
name|replaceFirst
argument_list|(
literal|"\\$simple\\{file:name\\}"
argument_list|,
name|onlyName
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|pattern
operator|.
name|replaceFirst
argument_list|(
literal|"\\$\\{file:name.noext\\}"
argument_list|,
name|FileUtil
operator|.
name|stripExt
argument_list|(
name|onlyName
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|pattern
operator|.
name|replaceFirst
argument_list|(
literal|"\\$simple\\{file:name.noext\\}"
argument_list|,
name|FileUtil
operator|.
name|stripExt
argument_list|(
name|onlyName
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// must be able to resolve all placeholders supported
if|if
condition|(
name|StringHelper
operator|.
name|hasStartToken
argument_list|(
name|pattern
argument_list|,
literal|"simple"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ExpressionIllegalSyntaxException
argument_list|(
name|fileName
operator|+
literal|". Cannot resolve reminder: "
operator|+
name|pattern
argument_list|)
throw|;
block|}
name|String
name|answer
init|=
name|pattern
decl_stmt|;
if|if
condition|(
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ObjectHelper
operator|.
name|isNotEmpty
argument_list|(
name|path
argument_list|)
operator|&&
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ObjectHelper
operator|.
name|isNotEmpty
argument_list|(
name|pattern
argument_list|)
condition|)
block|{
comment|// done file must always be in same directory as the real file name
name|answer
operator|=
name|path
operator|+
name|getFileSeparator
argument_list|()
operator|+
name|pattern
expr_stmt|;
block|}
if|if
condition|(
name|getConfiguration
argument_list|()
operator|.
name|needToNormalize
argument_list|()
condition|)
block|{
comment|// must normalize path to cater for Windows and other OS
name|answer
operator|=
name|FileUtil
operator|.
name|normalizePath
argument_list|(
name|answer
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Is the given file a done file?      *<p/>      * This method should only be invoked if a done filename property has been set on this endpoint.      *      * @param fileName the file name      * @return<tt>true</tt> if its a done file,<tt>false</tt> otherwise      */
DECL|method|isDoneFile (String fileName)
specifier|protected
name|boolean
name|isDoneFile
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
name|String
name|pattern
init|=
name|getDoneFileName
argument_list|()
decl_stmt|;
name|StringHelper
operator|.
name|notEmpty
argument_list|(
name|pattern
argument_list|,
literal|"doneFileName"
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|StringHelper
operator|.
name|hasStartToken
argument_list|(
name|pattern
argument_list|,
literal|"simple"
argument_list|)
condition|)
block|{
comment|// no tokens, so just match names directly
return|return
name|pattern
operator|.
name|equals
argument_list|(
name|fileName
argument_list|)
return|;
block|}
comment|// the static part of the pattern, is that a prefix or suffix?
comment|// its a prefix if ${ start token is not at the start of the pattern
name|boolean
name|prefix
init|=
name|pattern
operator|.
name|indexOf
argument_list|(
literal|"${"
argument_list|)
operator|>
literal|0
decl_stmt|;
comment|// remove dynamic parts of the pattern so we only got the static part left
name|pattern
operator|=
name|pattern
operator|.
name|replaceFirst
argument_list|(
literal|"\\$\\{file:name\\}"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|pattern
operator|.
name|replaceFirst
argument_list|(
literal|"\\$simple\\{file:name\\}"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|pattern
operator|.
name|replaceFirst
argument_list|(
literal|"\\$\\{file:name.noext\\}"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|pattern
operator|.
name|replaceFirst
argument_list|(
literal|"\\$simple\\{file:name.noext\\}"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|// must be able to resolve all placeholders supported
if|if
condition|(
name|StringHelper
operator|.
name|hasStartToken
argument_list|(
name|pattern
argument_list|,
literal|"simple"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ExpressionIllegalSyntaxException
argument_list|(
name|fileName
operator|+
literal|". Cannot resolve reminder: "
operator|+
name|pattern
argument_list|)
throw|;
block|}
if|if
condition|(
name|prefix
condition|)
block|{
return|return
name|fileName
operator|.
name|startsWith
argument_list|(
name|pattern
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|fileName
operator|.
name|endsWith
argument_list|(
name|pattern
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|doStart ()
specifier|protected
name|void
name|doStart
parameter_list|()
throws|throws
name|Exception
block|{
comment|// validate that the read lock options is valid for the process strategy
if|if
condition|(
operator|!
literal|"none"
operator|.
name|equals
argument_list|(
name|readLock
argument_list|)
operator|&&
operator|!
literal|"off"
operator|.
name|equals
argument_list|(
name|readLock
argument_list|)
condition|)
block|{
if|if
condition|(
name|readLockTimeout
operator|>
literal|0
operator|&&
name|readLockTimeout
operator|<=
name|readLockCheckInterval
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The option readLockTimeout must be higher than readLockCheckInterval"
operator|+
literal|", was readLockTimeout="
operator|+
name|readLockTimeout
operator|+
literal|", readLockCheckInterval="
operator|+
name|readLockCheckInterval
operator|+
literal|". A good practice is to let the readLockTimeout be at least 3 times higher than the readLockCheckInterval"
operator|+
literal|" to ensure that the read lock procedure has enough time to acquire the lock."
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
literal|"idempotent"
operator|.
name|equals
argument_list|(
name|readLock
argument_list|)
operator|&&
name|idempotentRepository
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"IdempotentRepository must be configured when using readLock=idempotent"
argument_list|)
throw|;
block|}
if|if
condition|(
name|antInclude
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|antFilter
operator|==
literal|null
condition|)
block|{
name|antFilter
operator|=
operator|new
name|AntPathMatcherGenericFileFilter
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|antFilter
operator|.
name|setIncludes
argument_list|(
name|antInclude
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|antExclude
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|antFilter
operator|==
literal|null
condition|)
block|{
name|antFilter
operator|=
operator|new
name|AntPathMatcherGenericFileFilter
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|antFilter
operator|.
name|setExcludes
argument_list|(
name|antExclude
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|antFilter
operator|!=
literal|null
condition|)
block|{
name|antFilter
operator|.
name|setCaseSensitive
argument_list|(
name|antFilterCaseSensitive
argument_list|)
expr_stmt|;
block|}
comment|// idempotent repository may be used by others, so add it as a service so its stopped when CamelContext stops
if|if
condition|(
name|idempotentRepository
operator|!=
literal|null
condition|)
block|{
name|getCamelContext
argument_list|()
operator|.
name|addService
argument_list|(
name|idempotentRepository
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|ServiceHelper
operator|.
name|startService
argument_list|(
name|inProgressRepository
argument_list|)
expr_stmt|;
name|super
operator|.
name|doStart
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStop ()
specifier|protected
name|void
name|doStop
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|doStop
argument_list|()
expr_stmt|;
name|ServiceHelper
operator|.
name|stopService
argument_list|(
name|inProgressRepository
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

