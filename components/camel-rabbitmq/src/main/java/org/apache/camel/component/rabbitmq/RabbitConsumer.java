begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.component.rabbitmq
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|rabbitmq
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Semaphore
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|rabbitmq
operator|.
name|client
operator|.
name|AMQP
import|;
end_import

begin_import
import|import
name|com
operator|.
name|rabbitmq
operator|.
name|client
operator|.
name|Channel
import|;
end_import

begin_import
import|import
name|com
operator|.
name|rabbitmq
operator|.
name|client
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|com
operator|.
name|rabbitmq
operator|.
name|client
operator|.
name|Consumer
import|;
end_import

begin_import
import|import
name|com
operator|.
name|rabbitmq
operator|.
name|client
operator|.
name|Envelope
import|;
end_import

begin_import
import|import
name|com
operator|.
name|rabbitmq
operator|.
name|client
operator|.
name|ShutdownSignalException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|ExchangePattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|RuntimeCamelException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|service
operator|.
name|ServiceSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
DECL|class|RabbitConsumer
class|class
name|RabbitConsumer
extends|extends
name|ServiceSupport
implements|implements
name|com
operator|.
name|rabbitmq
operator|.
name|client
operator|.
name|Consumer
block|{
DECL|field|log
specifier|private
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|consumer
specifier|private
specifier|final
name|RabbitMQConsumer
name|consumer
decl_stmt|;
DECL|field|channel
specifier|private
name|Channel
name|channel
decl_stmt|;
DECL|field|tag
specifier|private
name|String
name|tag
decl_stmt|;
comment|/** Consumer tag for this consumer. */
DECL|field|consumerTag
specifier|private
specifier|volatile
name|String
name|consumerTag
decl_stmt|;
DECL|field|stopping
specifier|private
specifier|volatile
name|boolean
name|stopping
decl_stmt|;
DECL|field|lock
specifier|private
specifier|final
name|Semaphore
name|lock
init|=
operator|new
name|Semaphore
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/**      * Constructs a new instance and records its association to the passed-in      * channel.      */
DECL|method|RabbitConsumer (RabbitMQConsumer consumer)
name|RabbitConsumer
parameter_list|(
name|RabbitMQConsumer
name|consumer
parameter_list|)
block|{
comment|// super(channel);
name|this
operator|.
name|consumer
operator|=
name|consumer
expr_stmt|;
try|try
block|{
name|Connection
name|conn
init|=
name|consumer
operator|.
name|getConnection
argument_list|()
decl_stmt|;
name|this
operator|.
name|channel
operator|=
name|openChannel
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|TimeoutException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to open channel for RabbitMQConsumer. Continuing and will try again"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|handleDelivery (String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body)
specifier|public
name|void
name|handleDelivery
parameter_list|(
name|String
name|consumerTag
parameter_list|,
name|Envelope
name|envelope
parameter_list|,
name|AMQP
operator|.
name|BasicProperties
name|properties
parameter_list|,
name|byte
index|[]
name|body
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
operator|!
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|isAutoAck
argument_list|()
condition|)
block|{
name|lock
operator|.
name|acquire
argument_list|()
expr_stmt|;
block|}
comment|//Channel might be open because while we were waiting for the lock, stop() has been succesfully called.
if|if
condition|(
operator|!
name|channel
operator|.
name|isOpen
argument_list|()
condition|)
block|{
comment|// we could not open the channel so release the lock
if|if
condition|(
operator|!
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|isAutoAck
argument_list|()
condition|)
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
try|try
block|{
name|doHandleDelivery
argument_list|(
name|consumerTag
argument_list|,
name|envelope
argument_list|,
name|properties
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|isAutoAck
argument_list|()
condition|)
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Thread Interrupted!"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doHandleDelivery (String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body)
specifier|public
name|void
name|doHandleDelivery
parameter_list|(
name|String
name|consumerTag
parameter_list|,
name|Envelope
name|envelope
parameter_list|,
name|AMQP
operator|.
name|BasicProperties
name|properties
parameter_list|,
name|byte
index|[]
name|body
parameter_list|)
throws|throws
name|IOException
block|{
name|Exchange
name|exchange
init|=
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|createRabbitExchange
argument_list|(
name|envelope
argument_list|,
name|properties
argument_list|,
name|body
argument_list|)
decl_stmt|;
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|getMessageConverter
argument_list|()
operator|.
name|mergeAmqpProperties
argument_list|(
name|exchange
argument_list|,
name|properties
argument_list|)
expr_stmt|;
name|boolean
name|sendReply
init|=
name|properties
operator|.
name|getReplyTo
argument_list|()
operator|!=
literal|null
decl_stmt|;
if|if
condition|(
name|sendReply
operator|&&
operator|!
name|exchange
operator|.
name|getPattern
argument_list|()
operator|.
name|isOutCapable
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"In an inOut capable route"
argument_list|)
expr_stmt|;
name|exchange
operator|.
name|setPattern
argument_list|(
name|ExchangePattern
operator|.
name|InOut
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|trace
argument_list|(
literal|"Created exchange [exchange={}]"
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
name|long
name|deliveryTag
init|=
name|envelope
operator|.
name|getDeliveryTag
argument_list|()
decl_stmt|;
try|try
block|{
name|consumer
operator|.
name|getProcessor
argument_list|()
operator|.
name|process
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|exchange
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|// obtain the message after processing
name|Message
name|msg
decl_stmt|;
if|if
condition|(
name|exchange
operator|.
name|hasOut
argument_list|()
condition|)
block|{
name|msg
operator|=
name|exchange
operator|.
name|getOut
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|=
name|exchange
operator|.
name|getIn
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|exchange
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|consumer
operator|.
name|getExceptionHandler
argument_list|()
operator|.
name|handleException
argument_list|(
literal|"Error processing exchange"
argument_list|,
name|exchange
argument_list|,
name|exchange
operator|.
name|getException
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|exchange
operator|.
name|isFailed
argument_list|()
condition|)
block|{
comment|// processing success
if|if
condition|(
name|sendReply
operator|&&
name|exchange
operator|.
name|getPattern
argument_list|()
operator|.
name|isOutCapable
argument_list|()
condition|)
block|{
try|try
block|{
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|publishExchangeToChannel
argument_list|(
name|exchange
argument_list|,
name|channel
argument_list|,
name|properties
operator|.
name|getReplyTo
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeCamelException
name|e
parameter_list|)
block|{
comment|// set the exception on the exchange so it can send the
comment|// exception back to the producer
name|exchange
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|consumer
operator|.
name|getExceptionHandler
argument_list|()
operator|.
name|handleException
argument_list|(
literal|"Error processing exchange"
argument_list|,
name|exchange
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|isAutoAck
argument_list|()
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Acknowledging receipt [delivery_tag={}]"
argument_list|,
name|deliveryTag
argument_list|)
expr_stmt|;
name|channel
operator|.
name|basicAck
argument_list|(
name|deliveryTag
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|// The exchange could have failed when sending the above message
if|if
condition|(
name|exchange
operator|.
name|isFailed
argument_list|()
condition|)
block|{
if|if
condition|(
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|isTransferException
argument_list|()
operator|&&
name|exchange
operator|.
name|getPattern
argument_list|()
operator|.
name|isOutCapable
argument_list|()
condition|)
block|{
comment|// the inOut exchange failed so put the exception in the body
comment|// and send back
name|msg
operator|.
name|setBody
argument_list|(
name|exchange
operator|.
name|getException
argument_list|()
argument_list|)
expr_stmt|;
name|exchange
operator|.
name|setOut
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|exchange
operator|.
name|getOut
argument_list|()
operator|.
name|setHeader
argument_list|(
name|RabbitMQConstants
operator|.
name|CORRELATIONID
argument_list|,
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|RabbitMQConstants
operator|.
name|CORRELATIONID
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|publishExchangeToChannel
argument_list|(
name|exchange
argument_list|,
name|channel
argument_list|,
name|properties
operator|.
name|getReplyTo
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeCamelException
name|e
parameter_list|)
block|{
name|consumer
operator|.
name|getExceptionHandler
argument_list|()
operator|.
name|handleException
argument_list|(
literal|"Error processing exchange"
argument_list|,
name|exchange
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|isAutoAck
argument_list|()
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Acknowledging receipt when transferring exception [delivery_tag={}]"
argument_list|,
name|deliveryTag
argument_list|)
expr_stmt|;
name|channel
operator|.
name|basicAck
argument_list|(
name|deliveryTag
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|boolean
name|isRequeueHeaderSet
init|=
name|msg
operator|.
name|getHeader
argument_list|(
name|RabbitMQConstants
operator|.
name|REQUEUE
argument_list|,
literal|false
argument_list|,
name|boolean
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// processing failed, then reject and handle the exception
if|if
condition|(
name|deliveryTag
operator|!=
literal|0
operator|&&
operator|!
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|isAutoAck
argument_list|()
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Rejecting receipt [delivery_tag={}] with requeue={}"
argument_list|,
name|deliveryTag
argument_list|,
name|isRequeueHeaderSet
argument_list|)
expr_stmt|;
if|if
condition|(
name|isRequeueHeaderSet
condition|)
block|{
name|channel
operator|.
name|basicReject
argument_list|(
name|deliveryTag
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|channel
operator|.
name|basicReject
argument_list|(
name|deliveryTag
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|doStart ()
specifier|protected
name|void
name|doStart
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|channel
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The RabbitMQ channel is not open"
argument_list|)
throw|;
block|}
name|tag
operator|=
name|channel
operator|.
name|basicConsume
argument_list|(
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|getQueue
argument_list|()
argument_list|,
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|isAutoAck
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|,
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|isExclusiveConsumer
argument_list|()
argument_list|,
literal|null
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStop ()
specifier|protected
name|void
name|doStop
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|channel
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|tag
operator|!=
literal|null
operator|&&
name|isChannelOpen
argument_list|()
condition|)
block|{
name|channel
operator|.
name|basicCancel
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|lock
operator|.
name|acquire
argument_list|()
expr_stmt|;
if|if
condition|(
name|isChannelOpen
argument_list|()
condition|)
block|{
name|channel
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|TimeoutException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Timeout occured"
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e1
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Thread Interrupted!"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Stores the most recently passed-in consumerTag - semantically, there      * should be only one.      *      * @see Consumer#handleConsumeOk      */
annotation|@
name|Override
DECL|method|handleConsumeOk (String consumerTag)
specifier|public
name|void
name|handleConsumeOk
parameter_list|(
name|String
name|consumerTag
parameter_list|)
block|{
name|this
operator|.
name|consumerTag
operator|=
name|consumerTag
expr_stmt|;
block|}
comment|/**      * Retrieve the consumer tag.      *      * @return the most recently notified consumer tag.      */
DECL|method|getConsumerTag ()
specifier|public
name|String
name|getConsumerTag
parameter_list|()
block|{
return|return
name|consumerTag
return|;
block|}
comment|/**      * No-op implementation of {@link Consumer#handleCancelOk}.      *      * @param consumerTag      *            the defined consumer tag (client- or server-generated)      */
annotation|@
name|Override
DECL|method|handleCancelOk (String consumerTag)
specifier|public
name|void
name|handleCancelOk
parameter_list|(
name|String
name|consumerTag
parameter_list|)
block|{
comment|// no work to do
name|log
operator|.
name|debug
argument_list|(
literal|"Received cancelOk signal on the rabbitMQ channel"
argument_list|)
expr_stmt|;
block|}
comment|/**      * No-op implementation of {@link Consumer#handleCancel(String)}      *      * @param consumerTag      *            the defined consumer tag (client- or server-generated)      */
annotation|@
name|Override
DECL|method|handleCancel (String consumerTag)
specifier|public
name|void
name|handleCancel
parameter_list|(
name|String
name|consumerTag
parameter_list|)
throws|throws
name|IOException
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Received cancel signal on the rabbitMQ channel."
argument_list|)
expr_stmt|;
try|try
block|{
name|channel
operator|.
name|basicCancel
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|//no-op
block|}
name|this
operator|.
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|declareExchangeAndQueue
argument_list|(
name|channel
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error starting consumer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * No-op implementation of {@link Consumer#handleShutdownSignal}.      */
annotation|@
name|Override
DECL|method|handleShutdownSignal (String consumerTag, ShutdownSignalException sig)
specifier|public
name|void
name|handleShutdownSignal
parameter_list|(
name|String
name|consumerTag
parameter_list|,
name|ShutdownSignalException
name|sig
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Received shutdown signal on the rabbitMQ channel"
argument_list|)
expr_stmt|;
comment|// Check if the consumer closed the connection or something else
if|if
condition|(
operator|!
name|sig
operator|.
name|isInitiatedByApplication
argument_list|()
condition|)
block|{
comment|// Something else closed the connection so reconnect
name|boolean
name|connected
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|connected
operator|&&
operator|!
name|isStopping
argument_list|()
condition|)
block|{
try|try
block|{
name|reconnect
argument_list|()
expr_stmt|;
name|connected
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to obtain a RabbitMQ channel. Will try again. Caused by: {}. Stacktrace logged at DEBUG logging level."
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
comment|// include stacktrace in DEBUG logging
name|log
operator|.
name|debug
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Integer
name|networkRecoveryInterval
init|=
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|getNetworkRecoveryInterval
argument_list|()
decl_stmt|;
specifier|final
name|long
name|connectionRetryInterval
init|=
name|networkRecoveryInterval
operator|!=
literal|null
operator|&&
name|networkRecoveryInterval
operator|>
literal|0
condition|?
name|networkRecoveryInterval
else|:
literal|100L
decl_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|connectionRetryInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e1
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * No-op implementation of {@link Consumer#handleRecoverOk}.      */
annotation|@
name|Override
DECL|method|handleRecoverOk (String consumerTag)
specifier|public
name|void
name|handleRecoverOk
parameter_list|(
name|String
name|consumerTag
parameter_list|)
block|{
comment|// no work to do
name|log
operator|.
name|debug
argument_list|(
literal|"Received recover ok signal on the rabbitMQ channel"
argument_list|)
expr_stmt|;
block|}
comment|/**      * If the RabbitMQ connection is good this returns without changing      * anything. If the connection is down it will attempt to reconnect      */
DECL|method|reconnect ()
specifier|public
name|void
name|reconnect
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|isChannelOpen
argument_list|()
condition|)
block|{
comment|// ensure we are started
name|start
argument_list|()
expr_stmt|;
comment|// The connection is good, so nothing to do
return|return;
block|}
elseif|else
if|if
condition|(
name|channel
operator|!=
literal|null
operator|&&
operator|!
name|channel
operator|.
name|isOpen
argument_list|()
operator|&&
name|isAutomaticRecoveryEnabled
argument_list|()
condition|)
block|{
comment|// Still need to wait for channel to re-open
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Waiting for channel to re-open."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|channel
operator|==
literal|null
operator|||
operator|!
name|isAutomaticRecoveryEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Attempting to open a new rabbitMQ channel"
argument_list|)
expr_stmt|;
name|Connection
name|conn
init|=
name|consumer
operator|.
name|getConnection
argument_list|()
decl_stmt|;
name|channel
operator|=
name|openChannel
argument_list|(
name|conn
argument_list|)
expr_stmt|;
comment|// Register the channel to the tag
name|start
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|isAutomaticRecoveryEnabled ()
specifier|private
name|boolean
name|isAutomaticRecoveryEnabled
parameter_list|()
block|{
return|return
name|this
operator|.
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|getAutomaticRecoveryEnabled
argument_list|()
operator|!=
literal|null
operator|&&
name|this
operator|.
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|getAutomaticRecoveryEnabled
argument_list|()
return|;
block|}
DECL|method|isChannelOpen ()
specifier|private
name|boolean
name|isChannelOpen
parameter_list|()
block|{
return|return
name|channel
operator|!=
literal|null
operator|&&
name|channel
operator|.
name|isOpen
argument_list|()
return|;
block|}
comment|/**      * Open channel      */
DECL|method|openChannel (Connection conn)
specifier|private
name|Channel
name|openChannel
parameter_list|(
name|Connection
name|conn
parameter_list|)
throws|throws
name|IOException
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Creating channel..."
argument_list|)
expr_stmt|;
name|Channel
name|channel
init|=
name|conn
operator|.
name|createChannel
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Created channel: {}"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
comment|// setup the basicQos
if|if
condition|(
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|isPrefetchEnabled
argument_list|()
condition|)
block|{
name|channel
operator|.
name|basicQos
argument_list|(
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|getPrefetchSize
argument_list|()
argument_list|,
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|getPrefetchCount
argument_list|()
argument_list|,
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|isPrefetchGlobal
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// This really only needs to be called on the first consumer or on
comment|// reconnections.
if|if
condition|(
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|isDeclare
argument_list|()
condition|)
block|{
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|declareExchangeAndQueue
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
return|return
name|channel
return|;
block|}
block|}
end_class

end_unit

