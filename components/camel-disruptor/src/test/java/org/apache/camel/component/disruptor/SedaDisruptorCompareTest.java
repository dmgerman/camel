begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.component.disruptor
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|disruptor
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentLinkedQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|HdrHistogram
operator|.
name|Histogram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Endpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|ExchangePattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Processor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Produce
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|ProducerTemplate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|RouteBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|seda
operator|.
name|SedaEndpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|test
operator|.
name|junit4
operator|.
name|CamelTestSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Ignore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|RunWith
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|Parameterized
import|;
end_import

begin_comment
comment|/**  * This class does not perform any functional test, but instead makes a comparison between the performance of the  * Disruptor and SEDA component in several use cases.  *<p/>  * As memory management may have great impact on the results, it is adviced to run this test with a large, fixed heap (e.g. run with -Xmx1024m -Xms1024m JVM parameters)  */
end_comment

begin_class
annotation|@
name|Ignore
annotation|@
name|RunWith
argument_list|(
name|value
operator|=
name|Parameterized
operator|.
name|class
argument_list|)
DECL|class|SedaDisruptorCompareTest
specifier|public
class|class
name|SedaDisruptorCompareTest
extends|extends
name|CamelTestSupport
block|{
comment|// Use '0' for default value, '1'+ for specific value to be used by both SEDA and DISRUPTOR.
DECL|field|SIZE_PARAMETER_VALUE
specifier|private
specifier|static
specifier|final
name|int
name|SIZE_PARAMETER_VALUE
init|=
literal|1024
decl_stmt|;
DECL|field|SPEED_TEST_EXCHANGE_COUNT
specifier|private
specifier|static
specifier|final
name|int
name|SPEED_TEST_EXCHANGE_COUNT
init|=
literal|80000
decl_stmt|;
DECL|field|LATENCY_HISTOGRAM_BOUNDS
specifier|private
specifier|static
specifier|final
name|long
index|[]
name|LATENCY_HISTOGRAM_BOUNDS
init|=
operator|new
name|long
index|[]
block|{
literal|1
block|,
literal|2
block|,
literal|5
block|,
literal|10
block|,
literal|20
block|,
literal|50
block|,
literal|100
block|,
literal|200
block|,
literal|500
block|,
literal|1000
block|,
literal|2000
block|,
literal|5000
block|}
decl_stmt|;
DECL|field|DISRUPTOR_SIZE_HISTOGRAM_BOUNDS
specifier|private
specifier|static
specifier|final
name|long
index|[]
name|DISRUPTOR_SIZE_HISTOGRAM_BOUNDS
init|=
name|generateLinearHistogramBounds
argument_list|(
name|SIZE_PARAMETER_VALUE
operator|==
literal|0
condition|?
literal|1024
else|:
name|SIZE_PARAMETER_VALUE
argument_list|,
literal|8
argument_list|)
decl_stmt|;
DECL|field|SEDA_SIZE_HISTOGRAM_BOUNDS
specifier|private
specifier|static
specifier|final
name|long
index|[]
name|SEDA_SIZE_HISTOGRAM_BOUNDS
init|=
name|generateLinearHistogramBounds
argument_list|(
name|SIZE_PARAMETER_VALUE
operator|==
literal|0
condition|?
name|SPEED_TEST_EXCHANGE_COUNT
else|:
name|SIZE_PARAMETER_VALUE
argument_list|,
literal|10
argument_list|)
decl_stmt|;
annotation|@
name|Produce
DECL|field|producerTemplate
specifier|protected
name|ProducerTemplate
name|producerTemplate
decl_stmt|;
DECL|field|exchangeAwaiters
specifier|private
specifier|final
name|ExchangeAwaiter
index|[]
name|exchangeAwaiters
decl_stmt|;
DECL|field|componentName
specifier|private
specifier|final
name|String
name|componentName
decl_stmt|;
DECL|field|endpointUri
specifier|private
specifier|final
name|String
name|endpointUri
decl_stmt|;
DECL|field|amountProducers
specifier|private
specifier|final
name|int
name|amountProducers
decl_stmt|;
DECL|field|sizeHistogramBounds
specifier|private
specifier|final
name|long
index|[]
name|sizeHistogramBounds
decl_stmt|;
DECL|field|endpointSizeQueue
specifier|private
specifier|final
name|Queue
argument_list|<
name|Integer
argument_list|>
name|endpointSizeQueue
init|=
operator|new
name|ConcurrentLinkedQueue
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|SedaDisruptorCompareTest (final String componentName, final String endpointUri, final int amountProducers, final int amountConsumers, final int concurrentConsumerThreads, final long[] sizeHistogramBounds)
specifier|public
name|SedaDisruptorCompareTest
parameter_list|(
specifier|final
name|String
name|componentName
parameter_list|,
specifier|final
name|String
name|endpointUri
parameter_list|,
specifier|final
name|int
name|amountProducers
parameter_list|,
specifier|final
name|int
name|amountConsumers
parameter_list|,
specifier|final
name|int
name|concurrentConsumerThreads
parameter_list|,
specifier|final
name|long
index|[]
name|sizeHistogramBounds
parameter_list|)
block|{
name|this
operator|.
name|componentName
operator|=
name|componentName
expr_stmt|;
name|this
operator|.
name|endpointUri
operator|=
name|endpointUri
expr_stmt|;
name|this
operator|.
name|amountProducers
operator|=
name|amountProducers
expr_stmt|;
name|this
operator|.
name|sizeHistogramBounds
operator|=
name|sizeHistogramBounds
expr_stmt|;
name|exchangeAwaiters
operator|=
operator|new
name|ExchangeAwaiter
index|[
name|amountConsumers
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|amountConsumers
condition|;
operator|++
name|i
control|)
block|{
name|exchangeAwaiters
index|[
name|i
index|]
operator|=
operator|new
name|ExchangeAwaiter
argument_list|(
name|SPEED_TEST_EXCHANGE_COUNT
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|BeforeClass
DECL|method|legend ()
specifier|public
specifier|static
name|void
name|legend
parameter_list|()
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"-----------------------"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"- Tests output legend -"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"-----------------------"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"P: Number of concurrent Producer(s) sharing the load for publishing exchanges to the disruptor."
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"C: Number of Consumer(s) receiving a copy of each exchange from the disruptor (pub/sub)."
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"CCT: Number of ConcurrentConsumerThreads sharing the load for consuming exchanges from the disruptor."
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"SIZE: Maximum number of elements a SEDA or disruptor endpoint can have in memory before blocking the Producer thread(s)."
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"      0 means default value, so unbounded for SEDA and 1024 for disruptor."
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Each test is creating "
operator|+
name|SPEED_TEST_EXCHANGE_COUNT
operator|+
literal|" exchanges."
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
DECL|method|generateLinearHistogramBounds (final int maxValue, final int nbSlots)
specifier|private
specifier|static
name|long
index|[]
name|generateLinearHistogramBounds
parameter_list|(
specifier|final
name|int
name|maxValue
parameter_list|,
specifier|final
name|int
name|nbSlots
parameter_list|)
block|{
specifier|final
name|long
name|slotSize
init|=
name|maxValue
operator|/
name|nbSlots
decl_stmt|;
specifier|final
name|long
index|[]
name|bounds
init|=
operator|new
name|long
index|[
name|nbSlots
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nbSlots
condition|;
name|i
operator|++
control|)
block|{
name|bounds
index|[
name|i
index|]
operator|=
name|slotSize
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
block|}
return|return
name|bounds
return|;
block|}
DECL|method|singleProducer ()
specifier|private
specifier|static
name|int
name|singleProducer
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
DECL|method|multipleProducers ()
specifier|private
specifier|static
name|int
name|multipleProducers
parameter_list|()
block|{
return|return
literal|4
return|;
block|}
DECL|method|singleConsumer ()
specifier|private
specifier|static
name|int
name|singleConsumer
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
DECL|method|multipleConsumers ()
specifier|private
specifier|static
name|int
name|multipleConsumers
parameter_list|()
block|{
return|return
literal|4
return|;
block|}
DECL|method|singleConcurrentConsumerThread ()
specifier|private
specifier|static
name|int
name|singleConcurrentConsumerThread
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
DECL|method|multipleConcurrentConsumerThreads ()
specifier|private
specifier|static
name|int
name|multipleConcurrentConsumerThreads
parameter_list|()
block|{
return|return
literal|2
return|;
block|}
annotation|@
name|Parameterized
operator|.
name|Parameters
argument_list|(
name|name
operator|=
literal|"{index}: {0}"
argument_list|)
DECL|method|parameters ()
specifier|public
specifier|static
name|Collection
argument_list|<
name|Object
index|[]
argument_list|>
name|parameters
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|parameters
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// This parameter set can be compared to the next and shows the impact of a 'long' endpoint name
comment|// It defines all parameters to the same values as the default, so the result should be the same as
comment|// 'seda:speedtest'. This shows that disruptor has a slight disadvantage as its name is longer than 'seda' :)
comment|// The reason why this test takes so long is because Camel has a SLF4J call in ProducerCache:
comment|// log.debug(">>>> {} {}", endpoint, exchange);
comment|// and the DefaultEndpoint.toString() method will use a Matcher to sanitize the URI.  There should be a guard
comment|// before the debug() call to only evaluate the args when required: if(log.isDebugEnabled())...
if|if
condition|(
name|SIZE_PARAMETER_VALUE
operator|==
literal|0
condition|)
block|{
name|parameters
operator|.
name|add
argument_list|(
operator|new
name|Object
index|[]
block|{
literal|"SEDA LONG {P=1, C=1, CCT=1, SIZE=0}"
block|,
literal|"seda:speedtest?concurrentConsumers=1&waitForTaskToComplete=IfReplyExpected&timeout=30000&multipleConsumers=false&limitConcurrentConsumers=true&blockWhenFull=false"
block|,
name|singleProducer
argument_list|()
block|,
name|singleConsumer
argument_list|()
block|,
name|singleConcurrentConsumerThread
argument_list|()
block|,
name|SEDA_SIZE_HISTOGRAM_BOUNDS
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parameters
operator|.
name|add
argument_list|(
operator|new
name|Object
index|[]
block|{
literal|"SEDA LONG {P=1, C=1, CCT=1, SIZE="
operator|+
name|SIZE_PARAMETER_VALUE
operator|+
literal|"}"
block|,
literal|"seda:speedtest?concurrentConsumers=1&waitForTaskToComplete=IfReplyExpected&timeout=30000&multipleConsumers=false&limitConcurrentConsumers=true&blockWhenFull=true&size="
operator|+
name|SIZE_PARAMETER_VALUE
block|,
name|singleProducer
argument_list|()
block|,
name|singleConsumer
argument_list|()
block|,
name|singleConcurrentConsumerThread
argument_list|()
block|,
name|SEDA_SIZE_HISTOGRAM_BOUNDS
block|}
argument_list|)
expr_stmt|;
block|}
name|addParameterPair
argument_list|(
name|parameters
argument_list|,
name|singleProducer
argument_list|()
argument_list|,
name|singleConsumer
argument_list|()
argument_list|,
name|singleConcurrentConsumerThread
argument_list|()
argument_list|)
expr_stmt|;
name|addParameterPair
argument_list|(
name|parameters
argument_list|,
name|singleProducer
argument_list|()
argument_list|,
name|singleConsumer
argument_list|()
argument_list|,
name|multipleConcurrentConsumerThreads
argument_list|()
argument_list|)
expr_stmt|;
name|addParameterPair
argument_list|(
name|parameters
argument_list|,
name|singleProducer
argument_list|()
argument_list|,
name|multipleConsumers
argument_list|()
argument_list|,
name|singleConcurrentConsumerThread
argument_list|()
argument_list|)
expr_stmt|;
name|addParameterPair
argument_list|(
name|parameters
argument_list|,
name|singleProducer
argument_list|()
argument_list|,
name|multipleConsumers
argument_list|()
argument_list|,
name|multipleConcurrentConsumerThreads
argument_list|()
argument_list|)
expr_stmt|;
name|addParameterPair
argument_list|(
name|parameters
argument_list|,
name|multipleProducers
argument_list|()
argument_list|,
name|singleConsumer
argument_list|()
argument_list|,
name|singleConcurrentConsumerThread
argument_list|()
argument_list|)
expr_stmt|;
name|addParameterPair
argument_list|(
name|parameters
argument_list|,
name|multipleProducers
argument_list|()
argument_list|,
name|singleConsumer
argument_list|()
argument_list|,
name|multipleConcurrentConsumerThreads
argument_list|()
argument_list|)
expr_stmt|;
name|addParameterPair
argument_list|(
name|parameters
argument_list|,
name|multipleProducers
argument_list|()
argument_list|,
name|multipleConsumers
argument_list|()
argument_list|,
name|singleConcurrentConsumerThread
argument_list|()
argument_list|)
expr_stmt|;
name|addParameterPair
argument_list|(
name|parameters
argument_list|,
name|multipleProducers
argument_list|()
argument_list|,
name|multipleConsumers
argument_list|()
argument_list|,
name|multipleConcurrentConsumerThreads
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|parameters
return|;
block|}
DECL|method|addParameterPair (final List<Object[]> parameters, final int producers, final int consumers, final int parallelConsumerThreads)
specifier|private
specifier|static
name|void
name|addParameterPair
parameter_list|(
specifier|final
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|parameters
parameter_list|,
specifier|final
name|int
name|producers
parameter_list|,
specifier|final
name|int
name|consumers
parameter_list|,
specifier|final
name|int
name|parallelConsumerThreads
parameter_list|)
block|{
specifier|final
name|String
name|multipleConsumerOption
init|=
name|consumers
operator|>
literal|1
condition|?
literal|"multipleConsumers=true"
else|:
literal|""
decl_stmt|;
specifier|final
name|String
name|concurrentConsumerOptions
init|=
name|parallelConsumerThreads
operator|>
literal|1
condition|?
literal|"concurrentConsumers="
operator|+
name|parallelConsumerThreads
else|:
literal|""
decl_stmt|;
specifier|final
name|String
name|sizeOption
init|=
name|SIZE_PARAMETER_VALUE
operator|>
literal|0
condition|?
literal|"size="
operator|+
name|SIZE_PARAMETER_VALUE
else|:
literal|""
decl_stmt|;
specifier|final
name|String
name|sizeOptionSeda
init|=
name|SIZE_PARAMETER_VALUE
operator|>
literal|0
condition|?
literal|"&blockWhenFull=true"
else|:
literal|""
decl_stmt|;
name|String
name|options
init|=
literal|""
decl_stmt|;
if|if
condition|(
operator|!
name|multipleConsumerOption
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|options
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|options
operator|+=
literal|"&"
expr_stmt|;
block|}
name|options
operator|+=
name|multipleConsumerOption
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|concurrentConsumerOptions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|options
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|options
operator|+=
literal|"&"
expr_stmt|;
block|}
name|options
operator|+=
name|concurrentConsumerOptions
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sizeOption
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|options
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|options
operator|+=
literal|"&"
expr_stmt|;
block|}
name|options
operator|+=
name|sizeOption
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|options
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|options
operator|=
literal|"?"
operator|+
name|options
expr_stmt|;
block|}
specifier|final
name|String
name|sedaOptions
init|=
name|sizeOptionSeda
operator|.
name|isEmpty
argument_list|()
condition|?
name|options
else|:
name|options
operator|+
name|sizeOptionSeda
decl_stmt|;
comment|// Using { ... } because there is a bug in JUnit 4.11 and Eclipse: https://bugs.eclipse.org/bugs/show_bug.cgi?id=102512
specifier|final
name|String
name|testDescription
init|=
literal|" { P="
operator|+
name|producers
operator|+
literal|", C="
operator|+
name|consumers
operator|+
literal|", CCT="
operator|+
name|parallelConsumerThreads
operator|+
literal|", SIZE="
operator|+
name|SIZE_PARAMETER_VALUE
operator|+
literal|" }"
decl_stmt|;
name|parameters
operator|.
name|add
argument_list|(
operator|new
name|Object
index|[]
block|{
literal|"SEDA"
operator|+
name|testDescription
block|,
literal|"seda:speedtest"
operator|+
name|sedaOptions
block|,
name|producers
block|,
name|consumers
block|,
name|parallelConsumerThreads
block|,
name|SEDA_SIZE_HISTOGRAM_BOUNDS
block|}
argument_list|)
expr_stmt|;
name|parameters
operator|.
name|add
argument_list|(
operator|new
name|Object
index|[]
block|{
literal|"Disruptor"
operator|+
name|testDescription
block|,
literal|"disruptor:speedtest"
operator|+
name|options
block|,
name|producers
block|,
name|consumers
block|,
name|parallelConsumerThreads
block|,
name|DISRUPTOR_SIZE_HISTOGRAM_BOUNDS
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|speedTestDisruptor ()
specifier|public
name|void
name|speedTestDisruptor
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Warming up for test of: "
operator|+
name|componentName
argument_list|)
expr_stmt|;
name|performTest
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Starting real test of: "
operator|+
name|componentName
argument_list|)
expr_stmt|;
name|forceGC
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|performTest
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|forceGC ()
specifier|private
name|void
name|forceGC
parameter_list|()
block|{
comment|// unfortunately there is no nice API that forces the Garbage collector to run, but it may consider our request
comment|// more seriously if we ask it twice :)
name|System
operator|.
name|gc
argument_list|()
expr_stmt|;
name|System
operator|.
name|gc
argument_list|()
expr_stmt|;
block|}
DECL|method|resetExchangeAwaiters ()
specifier|private
name|void
name|resetExchangeAwaiters
parameter_list|()
block|{
for|for
control|(
specifier|final
name|ExchangeAwaiter
name|exchangeAwaiter
range|:
name|exchangeAwaiters
control|)
block|{
name|exchangeAwaiter
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|awaitExchangeAwaiters ()
specifier|private
name|void
name|awaitExchangeAwaiters
parameter_list|()
throws|throws
name|InterruptedException
block|{
for|for
control|(
specifier|final
name|ExchangeAwaiter
name|exchangeAwaiter
range|:
name|exchangeAwaiters
control|)
block|{
while|while
condition|(
operator|!
name|exchangeAwaiter
operator|.
name|awaitMessagesReceived
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Processing takes longer then expected: "
operator|+
name|componentName
operator|+
literal|" "
operator|+
name|exchangeAwaiter
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|outputExchangeAwaitersResult (final long start)
specifier|private
name|void
name|outputExchangeAwaitersResult
parameter_list|(
specifier|final
name|long
name|start
parameter_list|)
throws|throws
name|InterruptedException
block|{
for|for
control|(
specifier|final
name|ExchangeAwaiter
name|exchangeAwaiter
range|:
name|exchangeAwaiters
control|)
block|{
specifier|final
name|long
name|stop
init|=
name|exchangeAwaiter
operator|.
name|getCountDownReachedTime
argument_list|()
decl_stmt|;
specifier|final
name|Histogram
name|histogram
init|=
name|exchangeAwaiter
operator|.
name|getLatencyHistogram
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|printf
argument_list|(
literal|"%-45s time spent = %5d ms.%n"
argument_list|,
name|componentName
argument_list|,
name|stop
operator|-
name|start
argument_list|)
expr_stmt|;
name|histogram
operator|.
name|outputPercentileDistribution
argument_list|(
name|System
operator|.
name|out
argument_list|,
literal|1
argument_list|,
literal|1000.0
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|performTest (final boolean warmup)
specifier|private
name|void
name|performTest
parameter_list|(
specifier|final
name|boolean
name|warmup
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|resetExchangeAwaiters
argument_list|()
expr_stmt|;
specifier|final
name|ProducerThread
index|[]
name|producerThread
init|=
operator|new
name|ProducerThread
index|[
name|amountProducers
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|producerThread
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|producerThread
index|[
name|i
index|]
operator|=
operator|new
name|ProducerThread
argument_list|(
name|SPEED_TEST_EXCHANGE_COUNT
operator|/
name|amountProducers
argument_list|)
expr_stmt|;
block|}
name|ExecutorService
name|monitoring
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|warmup
condition|)
block|{
name|monitoring
operator|=
name|installSizeMonitoring
argument_list|(
name|context
operator|.
name|getEndpoint
argument_list|(
name|endpointUri
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
for|for
control|(
name|ProducerThread
name|element
range|:
name|producerThread
control|)
block|{
name|element
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|awaitExchangeAwaiters
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|warmup
condition|)
block|{
name|outputExchangeAwaitersResult
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|uninstallSizeMonitoring
argument_list|(
name|monitoring
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|installSizeMonitoring (final Endpoint endpoint)
specifier|private
name|ExecutorService
name|installSizeMonitoring
parameter_list|(
specifier|final
name|Endpoint
name|endpoint
parameter_list|)
block|{
specifier|final
name|ScheduledExecutorService
name|service
init|=
name|context
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|newScheduledThreadPool
argument_list|(
name|this
argument_list|,
literal|"SizeMonitoringThread"
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|endpointSizeQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
specifier|final
name|Runnable
name|monitoring
init|=
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|endpoint
operator|instanceof
name|SedaEndpoint
condition|)
block|{
specifier|final
name|SedaEndpoint
name|sedaEndpoint
init|=
operator|(
name|SedaEndpoint
operator|)
name|endpoint
decl_stmt|;
name|endpointSizeQueue
operator|.
name|offer
argument_list|(
name|sedaEndpoint
operator|.
name|getCurrentQueueSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|endpoint
operator|instanceof
name|DisruptorEndpoint
condition|)
block|{
specifier|final
name|DisruptorEndpoint
name|disruptorEndpoint
init|=
operator|(
name|DisruptorEndpoint
operator|)
name|endpoint
decl_stmt|;
name|long
name|remainingCapacity
init|=
literal|0
decl_stmt|;
try|try
block|{
name|remainingCapacity
operator|=
name|disruptorEndpoint
operator|.
name|getRemainingCapacity
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DisruptorNotStartedException
name|e
parameter_list|)
block|{
comment|//ignore
block|}
name|endpointSizeQueue
operator|.
name|offer
argument_list|(
call|(
name|int
call|)
argument_list|(
name|disruptorEndpoint
operator|.
name|getBufferSize
argument_list|()
operator|-
name|remainingCapacity
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
name|service
operator|.
name|scheduleAtFixedRate
argument_list|(
name|monitoring
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
return|return
name|service
return|;
block|}
DECL|method|uninstallSizeMonitoring (final ExecutorService monitoring)
specifier|private
name|void
name|uninstallSizeMonitoring
parameter_list|(
specifier|final
name|ExecutorService
name|monitoring
parameter_list|)
block|{
if|if
condition|(
name|monitoring
operator|!=
literal|null
condition|)
block|{
name|monitoring
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
specifier|final
name|Histogram
name|histogram
init|=
operator|new
name|Histogram
argument_list|(
name|sizeHistogramBounds
index|[
name|sizeHistogramBounds
operator|.
name|length
operator|-
literal|1
index|]
argument_list|,
literal|4
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|int
name|observation
range|:
name|endpointSizeQueue
control|)
block|{
name|histogram
operator|.
name|recordValue
argument_list|(
name|observation
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|printf
argument_list|(
literal|"%82s %s%n"
argument_list|,
literal|"Endpoint size (# exchanges pending):"
argument_list|,
name|histogram
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createRouteBuilder ()
specifier|protected
name|RouteBuilder
name|createRouteBuilder
parameter_list|()
throws|throws
name|Exception
block|{
return|return
operator|new
name|RouteBuilder
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|configure
parameter_list|()
throws|throws
name|Exception
block|{
for|for
control|(
specifier|final
name|ExchangeAwaiter
name|exchangeAwaiter
range|:
name|exchangeAwaiters
control|)
block|{
name|from
argument_list|(
name|endpointUri
argument_list|)
operator|.
name|process
argument_list|(
name|exchangeAwaiter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|;
block|}
DECL|class|ExchangeAwaiter
specifier|private
specifier|static
specifier|final
class|class
name|ExchangeAwaiter
implements|implements
name|Processor
block|{
DECL|field|latch
specifier|private
name|CountDownLatch
name|latch
decl_stmt|;
DECL|field|count
specifier|private
specifier|final
name|int
name|count
decl_stmt|;
DECL|field|countDownReachedTime
specifier|private
name|long
name|countDownReachedTime
decl_stmt|;
DECL|field|latencyQueue
specifier|private
name|Queue
argument_list|<
name|Long
argument_list|>
name|latencyQueue
init|=
operator|new
name|ConcurrentLinkedQueue
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|ExchangeAwaiter (final int count)
name|ExchangeAwaiter
parameter_list|(
specifier|final
name|int
name|count
parameter_list|)
block|{
name|this
operator|.
name|count
operator|=
name|count
expr_stmt|;
block|}
DECL|method|reset ()
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|latencyQueue
operator|=
operator|new
name|ConcurrentLinkedQueue
argument_list|<>
argument_list|()
expr_stmt|;
name|latch
operator|=
operator|new
name|CountDownLatch
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|countDownReachedTime
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|awaitMessagesReceived (final long timeout, final TimeUnit unit)
specifier|public
name|boolean
name|awaitMessagesReceived
parameter_list|(
specifier|final
name|long
name|timeout
parameter_list|,
specifier|final
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
return|return
name|latch
operator|.
name|await
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
return|;
block|}
DECL|method|getStatus ()
specifier|public
name|String
name|getStatus
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"processed "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|count
operator|-
name|latch
operator|.
name|getCount
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" messages"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|process (final Exchange exchange)
specifier|public
name|void
name|process
parameter_list|(
specifier|final
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|long
name|sentTimeNs
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|(
name|Long
operator|.
name|class
argument_list|)
decl_stmt|;
name|latencyQueue
operator|.
name|offer
argument_list|(
name|Long
operator|.
name|valueOf
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|sentTimeNs
argument_list|)
argument_list|)
expr_stmt|;
name|countDownReachedTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
DECL|method|getCountDownReachedTime ()
specifier|public
name|long
name|getCountDownReachedTime
parameter_list|()
block|{
comment|// Make sure we wait until all exchanges have been processed. Otherwise the time value doesn't make sense.
try|try
block|{
name|latch
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|countDownReachedTime
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|countDownReachedTime
return|;
block|}
DECL|method|getLatencyHistogram ()
specifier|public
name|Histogram
name|getLatencyHistogram
parameter_list|()
block|{
specifier|final
name|Histogram
name|histogram
init|=
operator|new
name|Histogram
argument_list|(
name|LATENCY_HISTOGRAM_BOUNDS
index|[
name|LATENCY_HISTOGRAM_BOUNDS
operator|.
name|length
operator|-
literal|1
index|]
argument_list|,
literal|4
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|Long
name|latencyValue
range|:
name|latencyQueue
control|)
block|{
name|histogram
operator|.
name|recordValue
argument_list|(
name|latencyValue
operator|/
literal|1000000
argument_list|)
expr_stmt|;
block|}
return|return
name|histogram
return|;
block|}
block|}
DECL|class|ProducerThread
specifier|private
specifier|final
class|class
name|ProducerThread
extends|extends
name|Thread
block|{
DECL|field|totalMessageCount
specifier|private
specifier|final
name|int
name|totalMessageCount
decl_stmt|;
DECL|field|producedMessageCount
specifier|private
name|int
name|producedMessageCount
decl_stmt|;
DECL|method|ProducerThread (final int totalMessageCount)
name|ProducerThread
parameter_list|(
specifier|final
name|int
name|totalMessageCount
parameter_list|)
block|{
name|super
argument_list|(
literal|"TestDataProducerThread"
argument_list|)
expr_stmt|;
name|this
operator|.
name|totalMessageCount
operator|=
name|totalMessageCount
expr_stmt|;
block|}
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
specifier|final
name|Endpoint
name|endpoint
init|=
name|context
argument_list|()
operator|.
name|getEndpoint
argument_list|(
name|endpointUri
argument_list|)
decl_stmt|;
while|while
condition|(
name|producedMessageCount
operator|++
operator|<
name|totalMessageCount
condition|)
block|{
name|producerTemplate
operator|.
name|sendBody
argument_list|(
name|endpoint
argument_list|,
name|ExchangePattern
operator|.
name|InOnly
argument_list|,
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

