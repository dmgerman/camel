begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.component.disruptor
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|disruptor
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|WeakHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ArrayBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicMarkableReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|LockSupport
import|;
end_import

begin_import
import|import
name|com
operator|.
name|lmax
operator|.
name|disruptor
operator|.
name|InsufficientCapacityException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|lmax
operator|.
name|disruptor
operator|.
name|RingBuffer
import|;
end_import

begin_import
import|import
name|com
operator|.
name|lmax
operator|.
name|disruptor
operator|.
name|dsl
operator|.
name|Disruptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Holder for Disruptor references.  *<p/>  * This is used to keep track of the usages of the Disruptors, so we know when a Disruptor is no longer in use, and  * can safely be discarded.  */
end_comment

begin_class
DECL|class|DisruptorReference
specifier|public
class|class
name|DisruptorReference
block|{
DECL|field|LOGGER
specifier|private
specifier|static
specifier|final
name|Logger
name|LOGGER
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|DisruptorReference
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|endpoints
specifier|private
specifier|final
name|Set
argument_list|<
name|DisruptorEndpoint
argument_list|>
name|endpoints
init|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|WeakHashMap
argument_list|<
name|DisruptorEndpoint
argument_list|,
name|Boolean
argument_list|>
argument_list|(
literal|4
argument_list|)
argument_list|)
decl_stmt|;
DECL|field|component
specifier|private
specifier|final
name|DisruptorComponent
name|component
decl_stmt|;
DECL|field|uri
specifier|private
specifier|final
name|String
name|uri
decl_stmt|;
comment|//The mark on the reference indicates if we are in the process of reconfiguring the Disruptor:
comment|//(ref,   mark) : Description
comment|//(null, false) : not started or completely shut down
comment|//(null,  true) : in process of reconfiguring
comment|//( x  , false) : normally functioning Disruptor
comment|//( x  ,  true) : never set
DECL|field|disruptor
specifier|private
specifier|final
name|AtomicMarkableReference
argument_list|<
name|Disruptor
argument_list|<
name|ExchangeEvent
argument_list|>
argument_list|>
name|disruptor
init|=
operator|new
name|AtomicMarkableReference
argument_list|<
name|Disruptor
argument_list|<
name|ExchangeEvent
argument_list|>
argument_list|>
argument_list|(
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
DECL|field|delayedExecutor
specifier|private
specifier|final
name|DelayedExecutor
name|delayedExecutor
init|=
operator|new
name|DelayedExecutor
argument_list|()
decl_stmt|;
DECL|field|producerType
specifier|private
specifier|final
name|DisruptorProducerType
name|producerType
decl_stmt|;
DECL|field|size
specifier|private
specifier|final
name|int
name|size
decl_stmt|;
DECL|field|waitStrategy
specifier|private
specifier|final
name|DisruptorWaitStrategy
name|waitStrategy
decl_stmt|;
DECL|field|temporaryExchangeBuffer
specifier|private
specifier|final
name|Queue
argument_list|<
name|Exchange
argument_list|>
name|temporaryExchangeBuffer
decl_stmt|;
comment|//access guarded by this
DECL|field|executor
specifier|private
name|ExecutorService
name|executor
decl_stmt|;
DECL|field|handlers
specifier|private
name|LifecycleAwareExchangeEventHandler
index|[]
name|handlers
init|=
operator|new
name|LifecycleAwareExchangeEventHandler
index|[
literal|0
index|]
decl_stmt|;
DECL|field|uniqueConsumerCount
specifier|private
name|int
name|uniqueConsumerCount
decl_stmt|;
DECL|method|DisruptorReference (final DisruptorComponent component, final String uri, final int size, final DisruptorProducerType producerType, final DisruptorWaitStrategy waitStrategy)
name|DisruptorReference
parameter_list|(
specifier|final
name|DisruptorComponent
name|component
parameter_list|,
specifier|final
name|String
name|uri
parameter_list|,
specifier|final
name|int
name|size
parameter_list|,
specifier|final
name|DisruptorProducerType
name|producerType
parameter_list|,
specifier|final
name|DisruptorWaitStrategy
name|waitStrategy
parameter_list|)
throws|throws
name|Exception
block|{
name|this
operator|.
name|component
operator|=
name|component
expr_stmt|;
name|this
operator|.
name|uri
operator|=
name|uri
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|this
operator|.
name|producerType
operator|=
name|producerType
expr_stmt|;
name|this
operator|.
name|waitStrategy
operator|=
name|waitStrategy
expr_stmt|;
name|temporaryExchangeBuffer
operator|=
operator|new
name|ArrayBlockingQueue
argument_list|<
name|Exchange
argument_list|>
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|reconfigure
argument_list|()
expr_stmt|;
block|}
DECL|method|hasNullReference ()
specifier|public
name|boolean
name|hasNullReference
parameter_list|()
block|{
return|return
name|disruptor
operator|.
name|getReference
argument_list|()
operator|==
literal|null
return|;
block|}
DECL|method|getCurrentDisruptor ()
specifier|private
name|Disruptor
argument_list|<
name|ExchangeEvent
argument_list|>
name|getCurrentDisruptor
parameter_list|()
throws|throws
name|DisruptorNotStartedException
block|{
name|Disruptor
argument_list|<
name|ExchangeEvent
argument_list|>
name|currentDisruptor
init|=
name|disruptor
operator|.
name|getReference
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentDisruptor
operator|==
literal|null
condition|)
block|{
comment|// no current Disruptor reference, we may be reconfiguring or it was not started
comment|// check which by looking at the reference mark...
name|boolean
index|[]
name|changeIsPending
init|=
operator|new
name|boolean
index|[
literal|1
index|]
decl_stmt|;
while|while
condition|(
name|currentDisruptor
operator|==
literal|null
condition|)
block|{
name|currentDisruptor
operator|=
name|disruptor
operator|.
name|get
argument_list|(
name|changeIsPending
argument_list|)
expr_stmt|;
comment|//Check if we are reconfiguring
if|if
condition|(
name|currentDisruptor
operator|==
literal|null
operator|&&
operator|!
name|changeIsPending
index|[
literal|0
index|]
condition|)
block|{
throw|throw
operator|new
name|DisruptorNotStartedException
argument_list|(
literal|"Disruptor is not yet started or already shut down."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|currentDisruptor
operator|==
literal|null
operator|&&
name|changeIsPending
index|[
literal|0
index|]
condition|)
block|{
comment|//We should be back shortly...keep trying but spare CPU resources
name|LockSupport
operator|.
name|parkNanos
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|currentDisruptor
return|;
block|}
DECL|method|tryPublish (final Exchange exchange)
specifier|public
name|void
name|tryPublish
parameter_list|(
specifier|final
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|DisruptorNotStartedException
throws|,
name|InsufficientCapacityException
block|{
name|tryPublishExchangeOnRingBuffer
argument_list|(
name|exchange
argument_list|,
name|getCurrentDisruptor
argument_list|()
operator|.
name|getRingBuffer
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|publish (final Exchange exchange)
specifier|public
name|void
name|publish
parameter_list|(
specifier|final
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|DisruptorNotStartedException
block|{
name|publishExchangeOnRingBuffer
argument_list|(
name|exchange
argument_list|,
name|getCurrentDisruptor
argument_list|()
operator|.
name|getRingBuffer
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|publishExchangeOnRingBuffer (final Exchange exchange, final RingBuffer<ExchangeEvent> ringBuffer)
specifier|private
name|void
name|publishExchangeOnRingBuffer
parameter_list|(
specifier|final
name|Exchange
name|exchange
parameter_list|,
specifier|final
name|RingBuffer
argument_list|<
name|ExchangeEvent
argument_list|>
name|ringBuffer
parameter_list|)
block|{
specifier|final
name|long
name|sequence
init|=
name|ringBuffer
operator|.
name|next
argument_list|()
decl_stmt|;
name|ringBuffer
operator|.
name|get
argument_list|(
name|sequence
argument_list|)
operator|.
name|setExchange
argument_list|(
name|exchange
argument_list|,
name|uniqueConsumerCount
argument_list|)
expr_stmt|;
name|ringBuffer
operator|.
name|publish
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
block|}
DECL|method|tryPublishExchangeOnRingBuffer (final Exchange exchange, final RingBuffer<ExchangeEvent> ringBuffer)
specifier|private
name|void
name|tryPublishExchangeOnRingBuffer
parameter_list|(
specifier|final
name|Exchange
name|exchange
parameter_list|,
specifier|final
name|RingBuffer
argument_list|<
name|ExchangeEvent
argument_list|>
name|ringBuffer
parameter_list|)
throws|throws
name|InsufficientCapacityException
block|{
specifier|final
name|long
name|sequence
init|=
name|ringBuffer
operator|.
name|tryNext
argument_list|()
decl_stmt|;
name|ringBuffer
operator|.
name|get
argument_list|(
name|sequence
argument_list|)
operator|.
name|setExchange
argument_list|(
name|exchange
argument_list|,
name|uniqueConsumerCount
argument_list|)
expr_stmt|;
name|ringBuffer
operator|.
name|publish
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
block|}
DECL|method|reconfigure ()
specifier|public
specifier|synchronized
name|void
name|reconfigure
parameter_list|()
throws|throws
name|Exception
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Reconfiguring disruptor {}"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|shutdownDisruptor
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|start ()
specifier|private
name|void
name|start
parameter_list|()
throws|throws
name|Exception
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Starting disruptor {}"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|Disruptor
argument_list|<
name|ExchangeEvent
argument_list|>
name|newDisruptor
init|=
name|createDisruptor
argument_list|()
decl_stmt|;
name|newDisruptor
operator|.
name|start
argument_list|()
expr_stmt|;
if|if
condition|(
name|executor
operator|!=
literal|null
condition|)
block|{
comment|//and use our delayed executor to really really execute the event handlers now
name|delayedExecutor
operator|.
name|executeDelayedCommands
argument_list|(
name|executor
argument_list|)
expr_stmt|;
block|}
comment|//make sure all event handlers are correctly started before we continue
for|for
control|(
specifier|final
name|LifecycleAwareExchangeEventHandler
name|handler
range|:
name|handlers
control|)
block|{
name|boolean
name|eventHandlerStarted
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|eventHandlerStarted
condition|)
block|{
try|try
block|{
comment|//The disruptor start command executed above should have triggered a start signal to all
comment|//event processors which, in their death, should notify our event handlers. They respond by
comment|//switching a latch and we want to await that latch here to make sure they are started.
if|if
condition|(
operator|!
name|handler
operator|.
name|awaitStarted
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
comment|//we wait for a relatively long, but limited amount of time to prevent an application using
comment|//this component from hanging indefinitely
comment|//Please report a bug if you can reproduce this
name|LOGGER
operator|.
name|error
argument_list|(
literal|"Disruptor/event handler failed to start properly, PLEASE REPORT"
argument_list|)
expr_stmt|;
block|}
name|eventHandlerStarted
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|//just retry
block|}
block|}
block|}
name|publishBufferedExchanges
argument_list|(
name|newDisruptor
argument_list|)
expr_stmt|;
name|disruptor
operator|.
name|set
argument_list|(
name|newDisruptor
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|createDisruptor ()
specifier|private
name|Disruptor
argument_list|<
name|ExchangeEvent
argument_list|>
name|createDisruptor
parameter_list|()
throws|throws
name|Exception
block|{
comment|//create a new Disruptor
specifier|final
name|Disruptor
argument_list|<
name|ExchangeEvent
argument_list|>
name|newDisruptor
init|=
operator|new
name|Disruptor
argument_list|<
name|ExchangeEvent
argument_list|>
argument_list|(
name|ExchangeEventFactory
operator|.
name|INSTANCE
argument_list|,
name|size
argument_list|,
name|delayedExecutor
argument_list|,
name|producerType
operator|.
name|getProducerType
argument_list|()
argument_list|,
name|waitStrategy
operator|.
name|createWaitStrategyInstance
argument_list|()
argument_list|)
decl_stmt|;
comment|//determine the list of eventhandlers to be associated to the Disruptor
specifier|final
name|ArrayList
argument_list|<
name|LifecycleAwareExchangeEventHandler
argument_list|>
name|eventHandlers
init|=
operator|new
name|ArrayList
argument_list|<
name|LifecycleAwareExchangeEventHandler
argument_list|>
argument_list|()
decl_stmt|;
name|uniqueConsumerCount
operator|=
literal|0
expr_stmt|;
for|for
control|(
specifier|final
name|DisruptorEndpoint
name|endpoint
range|:
name|endpoints
control|)
block|{
specifier|final
name|Map
argument_list|<
name|DisruptorConsumer
argument_list|,
name|Collection
argument_list|<
name|LifecycleAwareExchangeEventHandler
argument_list|>
argument_list|>
name|consumerEventHandlers
init|=
name|endpoint
operator|.
name|createConsumerEventHandlers
argument_list|()
decl_stmt|;
if|if
condition|(
name|consumerEventHandlers
operator|!=
literal|null
condition|)
block|{
name|uniqueConsumerCount
operator|+=
name|consumerEventHandlers
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
for|for
control|(
name|Collection
argument_list|<
name|LifecycleAwareExchangeEventHandler
argument_list|>
name|lifecycleAwareExchangeEventHandlers
range|:
name|consumerEventHandlers
operator|.
name|values
argument_list|()
control|)
block|{
name|eventHandlers
operator|.
name|addAll
argument_list|(
name|lifecycleAwareExchangeEventHandlers
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Disruptor created with {} event handlers"
argument_list|,
name|eventHandlers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|handleEventsWith
argument_list|(
name|newDisruptor
argument_list|,
name|eventHandlers
operator|.
name|toArray
argument_list|(
operator|new
name|LifecycleAwareExchangeEventHandler
index|[
name|eventHandlers
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|newDisruptor
return|;
block|}
DECL|method|handleEventsWith (Disruptor<ExchangeEvent> newDisruptor, final LifecycleAwareExchangeEventHandler[] newHandlers)
specifier|private
name|void
name|handleEventsWith
parameter_list|(
name|Disruptor
argument_list|<
name|ExchangeEvent
argument_list|>
name|newDisruptor
parameter_list|,
specifier|final
name|LifecycleAwareExchangeEventHandler
index|[]
name|newHandlers
parameter_list|)
block|{
if|if
condition|(
name|newHandlers
operator|==
literal|null
operator|||
name|newHandlers
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|handlers
operator|=
operator|new
name|LifecycleAwareExchangeEventHandler
index|[
literal|1
index|]
expr_stmt|;
name|handlers
index|[
literal|0
index|]
operator|=
operator|new
name|BlockingExchangeEventHandler
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|handlers
operator|=
name|newHandlers
expr_stmt|;
block|}
name|resizeThreadPoolExecutor
argument_list|(
name|handlers
operator|.
name|length
argument_list|)
expr_stmt|;
name|newDisruptor
operator|.
name|handleEventsWith
argument_list|(
name|handlers
argument_list|)
expr_stmt|;
block|}
DECL|method|publishBufferedExchanges (Disruptor<ExchangeEvent> newDisruptor)
specifier|private
name|void
name|publishBufferedExchanges
parameter_list|(
name|Disruptor
argument_list|<
name|ExchangeEvent
argument_list|>
name|newDisruptor
parameter_list|)
block|{
comment|//now empty out all buffered Exchange if we had any
specifier|final
name|List
argument_list|<
name|Exchange
argument_list|>
name|exchanges
init|=
operator|new
name|ArrayList
argument_list|<
name|Exchange
argument_list|>
argument_list|(
name|temporaryExchangeBuffer
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|temporaryExchangeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|exchanges
operator|.
name|add
argument_list|(
name|temporaryExchangeBuffer
operator|.
name|remove
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|RingBuffer
argument_list|<
name|ExchangeEvent
argument_list|>
name|ringBuffer
init|=
name|newDisruptor
operator|.
name|getRingBuffer
argument_list|()
decl_stmt|;
comment|//and offer them again to our new ringbuffer
for|for
control|(
specifier|final
name|Exchange
name|exchange
range|:
name|exchanges
control|)
block|{
name|publishExchangeOnRingBuffer
argument_list|(
name|exchange
argument_list|,
name|ringBuffer
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|resizeThreadPoolExecutor (final int newSize)
specifier|private
name|void
name|resizeThreadPoolExecutor
parameter_list|(
specifier|final
name|int
name|newSize
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
operator|&&
name|newSize
operator|>
literal|0
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Creating new executor with {} threads"
argument_list|,
name|newSize
argument_list|)
expr_stmt|;
comment|//no thread pool executor yet, create a new one
name|executor
operator|=
name|component
operator|.
name|getCamelContext
argument_list|()
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|newFixedThreadPool
argument_list|(
name|this
argument_list|,
name|uri
argument_list|,
name|newSize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|executor
operator|!=
literal|null
operator|&&
name|newSize
operator|<=
literal|0
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Shutting down executor"
argument_list|)
expr_stmt|;
comment|//we need to shut down our executor
name|component
operator|.
name|getCamelContext
argument_list|()
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|shutdown
argument_list|(
name|executor
argument_list|)
expr_stmt|;
name|executor
operator|=
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|executor
operator|instanceof
name|ThreadPoolExecutor
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Resizing existing executor to {} threads"
argument_list|,
name|newSize
argument_list|)
expr_stmt|;
comment|//our thread pool executor is of type ThreadPoolExecutor, we know how to resize it
specifier|final
name|ThreadPoolExecutor
name|threadPoolExecutor
init|=
operator|(
name|ThreadPoolExecutor
operator|)
name|executor
decl_stmt|;
name|threadPoolExecutor
operator|.
name|setCorePoolSize
argument_list|(
name|newSize
argument_list|)
expr_stmt|;
name|threadPoolExecutor
operator|.
name|setMaximumPoolSize
argument_list|(
name|newSize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newSize
operator|>
literal|0
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Shutting down old and creating new executor with {} threads"
argument_list|,
name|newSize
argument_list|)
expr_stmt|;
comment|//hmmm...no idea what kind of executor this is...just kill it and start fresh
name|component
operator|.
name|getCamelContext
argument_list|()
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|shutdown
argument_list|(
name|executor
argument_list|)
expr_stmt|;
name|executor
operator|=
name|component
operator|.
name|getCamelContext
argument_list|()
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|newFixedThreadPool
argument_list|(
name|this
argument_list|,
name|uri
argument_list|,
name|newSize
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|shutdownDisruptor (boolean isReconfiguring)
specifier|private
specifier|synchronized
name|void
name|shutdownDisruptor
parameter_list|(
name|boolean
name|isReconfiguring
parameter_list|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Shutting down disruptor {}, reconfiguring: {}"
argument_list|,
name|this
argument_list|,
name|isReconfiguring
argument_list|)
expr_stmt|;
name|Disruptor
argument_list|<
name|ExchangeEvent
argument_list|>
name|currentDisruptor
init|=
name|disruptor
operator|.
name|getReference
argument_list|()
decl_stmt|;
name|disruptor
operator|.
name|set
argument_list|(
literal|null
argument_list|,
name|isReconfiguring
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentDisruptor
operator|!=
literal|null
condition|)
block|{
comment|//check if we had a blocking event handler to keep an empty disruptor 'busy'
if|if
condition|(
name|handlers
operator|!=
literal|null
operator|&&
name|handlers
operator|.
name|length
operator|==
literal|1
operator|&&
name|handlers
index|[
literal|0
index|]
operator|instanceof
name|BlockingExchangeEventHandler
condition|)
block|{
comment|// yes we did, unblock it so we can get rid of our backlog,
comment|// The eventhandler will empty its pending exchanges in our temporary buffer
specifier|final
name|BlockingExchangeEventHandler
name|blockingExchangeEventHandler
init|=
operator|(
name|BlockingExchangeEventHandler
operator|)
name|handlers
index|[
literal|0
index|]
decl_stmt|;
name|blockingExchangeEventHandler
operator|.
name|unblock
argument_list|()
expr_stmt|;
block|}
name|currentDisruptor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
comment|//they have already been given a trigger to halt when they are done by shutting down the disruptor
comment|//we do however want to await their completion before they are scheduled to process events from the new
for|for
control|(
specifier|final
name|LifecycleAwareExchangeEventHandler
name|eventHandler
range|:
name|handlers
control|)
block|{
name|boolean
name|eventHandlerFinished
init|=
literal|false
decl_stmt|;
comment|//the disruptor is now empty and all consumers are either done or busy processing their last exchange
while|while
condition|(
operator|!
name|eventHandlerFinished
condition|)
block|{
try|try
block|{
comment|//The disruptor shutdown command executed above should have triggered a halt signal to all
comment|//event processors which, in their death, should notify our event handlers. They respond by
comment|//switching a latch and we want to await that latch here to make sure they are done.
if|if
condition|(
operator|!
name|eventHandler
operator|.
name|awaitStopped
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
comment|//we wait for a relatively long, but limited amount of time to prevent an application using
comment|//this component from hanging indefinitely
comment|//Please report a bug if you can repruduce this
name|LOGGER
operator|.
name|error
argument_list|(
literal|"Disruptor/event handler failed to shut down properly, PLEASE REPORT"
argument_list|)
expr_stmt|;
block|}
name|eventHandlerFinished
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|//just retry
block|}
block|}
block|}
name|handlers
operator|=
operator|new
name|LifecycleAwareExchangeEventHandler
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
DECL|method|shutdownExecutor ()
specifier|private
specifier|synchronized
name|void
name|shutdownExecutor
parameter_list|()
block|{
name|resizeThreadPoolExecutor
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|getRemainingCapacity ()
specifier|public
name|long
name|getRemainingCapacity
parameter_list|()
throws|throws
name|DisruptorNotStartedException
block|{
return|return
name|getCurrentDisruptor
argument_list|()
operator|.
name|getRingBuffer
argument_list|()
operator|.
name|remainingCapacity
argument_list|()
return|;
block|}
DECL|method|getWaitStrategy ()
specifier|public
name|DisruptorWaitStrategy
name|getWaitStrategy
parameter_list|()
block|{
return|return
name|waitStrategy
return|;
block|}
DECL|method|getProducerType ()
name|DisruptorProducerType
name|getProducerType
parameter_list|()
block|{
return|return
name|producerType
return|;
block|}
DECL|method|getBufferSize ()
specifier|public
name|int
name|getBufferSize
parameter_list|()
block|{
return|return
name|size
return|;
block|}
DECL|method|getPendingExchangeCount ()
specifier|public
name|int
name|getPendingExchangeCount
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
operator|!
name|hasNullReference
argument_list|()
condition|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|getBufferSize
argument_list|()
operator|-
name|getRemainingCapacity
argument_list|()
operator|+
name|temporaryExchangeBuffer
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|DisruptorNotStartedException
name|e
parameter_list|)
block|{
comment|//fall through...
block|}
return|return
name|temporaryExchangeBuffer
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|addEndpoint (final DisruptorEndpoint disruptorEndpoint)
specifier|public
specifier|synchronized
name|void
name|addEndpoint
parameter_list|(
specifier|final
name|DisruptorEndpoint
name|disruptorEndpoint
parameter_list|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Adding Endpoint: "
operator|+
name|disruptorEndpoint
argument_list|)
expr_stmt|;
name|endpoints
operator|.
name|add
argument_list|(
name|disruptorEndpoint
argument_list|)
expr_stmt|;
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Endpoint added: {}, new total endpoints {}"
argument_list|,
name|disruptorEndpoint
argument_list|,
name|endpoints
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|removeEndpoint (final DisruptorEndpoint disruptorEndpoint)
specifier|public
specifier|synchronized
name|void
name|removeEndpoint
parameter_list|(
specifier|final
name|DisruptorEndpoint
name|disruptorEndpoint
parameter_list|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Removing Endpoint: "
operator|+
name|disruptorEndpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|getEndpointCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Last Endpoint removed, shutdown disruptor"
argument_list|)
expr_stmt|;
comment|//Shutdown our disruptor
name|shutdownDisruptor
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|//As there are no endpoints dependent on this Disruptor, we may also shutdown our executor
name|shutdownExecutor
argument_list|()
expr_stmt|;
block|}
name|endpoints
operator|.
name|remove
argument_list|(
name|disruptorEndpoint
argument_list|)
expr_stmt|;
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Endpoint removed: {}, new total endpoints {}"
argument_list|,
name|disruptorEndpoint
argument_list|,
name|endpoints
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|getEndpointCount ()
specifier|public
specifier|synchronized
name|int
name|getEndpointCount
parameter_list|()
block|{
return|return
name|endpoints
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"DisruptorReference{"
operator|+
literal|"uri='"
operator|+
name|uri
operator|+
literal|'\''
operator|+
literal|", endpoint count="
operator|+
name|endpoints
operator|.
name|size
argument_list|()
operator|+
literal|", handler count="
operator|+
name|handlers
operator|.
name|length
operator|+
literal|'}'
return|;
block|}
comment|/**      * Implementation of the {@link LifecycleAwareExchangeEventHandler} interface that blocks all calls to the #onEvent      * method until the #unblock method is called.      */
DECL|class|BlockingExchangeEventHandler
specifier|private
class|class
name|BlockingExchangeEventHandler
extends|extends
name|AbstractLifecycleAwareExchangeEventHandler
block|{
DECL|field|blockingLatch
specifier|private
specifier|final
name|CountDownLatch
name|blockingLatch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
annotation|@
name|Override
DECL|method|onEvent (final ExchangeEvent event, final long sequence, final boolean endOfBatch)
specifier|public
name|void
name|onEvent
parameter_list|(
specifier|final
name|ExchangeEvent
name|event
parameter_list|,
specifier|final
name|long
name|sequence
parameter_list|,
specifier|final
name|boolean
name|endOfBatch
parameter_list|)
throws|throws
name|Exception
block|{
name|blockingLatch
operator|.
name|await
argument_list|()
expr_stmt|;
specifier|final
name|Exchange
name|exchange
init|=
name|event
operator|.
name|getSynchronizedExchange
argument_list|()
operator|.
name|cancelAndGetOriginalExchange
argument_list|()
decl_stmt|;
if|if
condition|(
name|exchange
operator|.
name|getProperty
argument_list|(
name|DisruptorEndpoint
operator|.
name|DISRUPTOR_IGNORE_EXCHANGE
argument_list|,
literal|false
argument_list|,
name|boolean
operator|.
name|class
argument_list|)
condition|)
block|{
comment|// Property was set and it was set to true, so don't process Exchange.
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"Ignoring exchange {}"
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temporaryExchangeBuffer
operator|.
name|offer
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|unblock ()
specifier|public
name|void
name|unblock
parameter_list|()
block|{
name|blockingLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * When a consumer is added or removed, we need to create a new Disruptor due to its static configuration. However, we      * would like to reuse our thread pool executor and only add or remove the threads we need. On a reconfiguraion of the      * Disruptor, we need to atomically swap the current RingBuffer with a new and fully configured one in order to keep      * the producers operational without the risk of losing messages. Configuration of a RingBuffer by the Disruptor's      * start method has a side effect that immediately starts execution of the event processors (consumers) on the      * Executor passed as a constructor argument which is stored in a final field. In order to be able to delay actual      * execution of the event processors until the event processors of the previous RingBuffer are done processing and the      * thread pool executor has been resized to match the new consumer count, we delay their execution using this class.      */
DECL|class|DelayedExecutor
specifier|private
specifier|static
class|class
name|DelayedExecutor
implements|implements
name|Executor
block|{
DECL|field|delayedCommands
specifier|private
specifier|final
name|Queue
argument_list|<
name|Runnable
argument_list|>
name|delayedCommands
init|=
operator|new
name|LinkedList
argument_list|<
name|Runnable
argument_list|>
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|execute (final Runnable command)
specifier|public
name|void
name|execute
parameter_list|(
specifier|final
name|Runnable
name|command
parameter_list|)
block|{
name|delayedCommands
operator|.
name|offer
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
DECL|method|executeDelayedCommands (final Executor actualExecutor)
specifier|public
name|void
name|executeDelayedCommands
parameter_list|(
specifier|final
name|Executor
name|actualExecutor
parameter_list|)
block|{
name|Runnable
name|command
decl_stmt|;
while|while
condition|(
operator|(
name|command
operator|=
name|delayedCommands
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|actualExecutor
operator|.
name|execute
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

