begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.dataformat.univocity
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|dataformat
operator|.
name|univocity
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|com
operator|.
name|univocity
operator|.
name|parsers
operator|.
name|common
operator|.
name|AbstractParser
import|;
end_import

begin_import
import|import
name|com
operator|.
name|univocity
operator|.
name|parsers
operator|.
name|common
operator|.
name|AbstractWriter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|univocity
operator|.
name|parsers
operator|.
name|common
operator|.
name|CommonParserSettings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|univocity
operator|.
name|parsers
operator|.
name|common
operator|.
name|CommonSettings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|univocity
operator|.
name|parsers
operator|.
name|common
operator|.
name|CommonWriterSettings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|univocity
operator|.
name|parsers
operator|.
name|common
operator|.
name|Format
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|DataFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|DataFormatName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|service
operator|.
name|ServiceSupport
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|ExchangeHelper
operator|.
name|getCharsetName
import|;
end_import

begin_comment
comment|/**  * This abstract class contains all the common parts for all the uniVocity parsers.  *<p/>  *  * @param<F>   uniVocity format class  * @param<CWS> uniVocity writer settings class  * @param<W>   uniVocity writer class  * @param<CPS> uniVocity parser settings class  * @param<P>   uniVocity parser class  * @param<DF>  the data format class (for providing a fluent API)  */
end_comment

begin_class
DECL|class|AbstractUniVocityDataFormat
specifier|public
specifier|abstract
class|class
name|AbstractUniVocityDataFormat
parameter_list|<
name|F
extends|extends
name|Format
parameter_list|,
name|CWS
extends|extends
name|CommonWriterSettings
parameter_list|<
name|F
parameter_list|>
parameter_list|,
name|W
extends|extends
name|AbstractWriter
parameter_list|<
name|CWS
parameter_list|>
parameter_list|,
name|CPS
extends|extends
name|CommonParserSettings
parameter_list|<
name|F
parameter_list|>
parameter_list|,
name|P
extends|extends
name|AbstractParser
parameter_list|<
name|CPS
parameter_list|>
parameter_list|,
name|DF
extends|extends
name|AbstractUniVocityDataFormat
parameter_list|<
name|F
parameter_list|,
name|CWS
parameter_list|,
name|W
parameter_list|,
name|CPS
parameter_list|,
name|P
parameter_list|,
name|DF
parameter_list|>
parameter_list|>
extends|extends
name|ServiceSupport
implements|implements
name|DataFormat
implements|,
name|DataFormatName
block|{
DECL|field|nullValue
specifier|protected
name|String
name|nullValue
decl_stmt|;
DECL|field|skipEmptyLines
specifier|protected
name|Boolean
name|skipEmptyLines
decl_stmt|;
DECL|field|ignoreTrailingWhitespaces
specifier|protected
name|Boolean
name|ignoreTrailingWhitespaces
decl_stmt|;
DECL|field|ignoreLeadingWhitespaces
specifier|protected
name|Boolean
name|ignoreLeadingWhitespaces
decl_stmt|;
DECL|field|headersDisabled
specifier|protected
name|boolean
name|headersDisabled
decl_stmt|;
DECL|field|headers
specifier|protected
name|String
index|[]
name|headers
decl_stmt|;
DECL|field|headerExtractionEnabled
specifier|protected
name|Boolean
name|headerExtractionEnabled
decl_stmt|;
DECL|field|numberOfRecordsToRead
specifier|protected
name|Integer
name|numberOfRecordsToRead
decl_stmt|;
DECL|field|emptyValue
specifier|protected
name|String
name|emptyValue
decl_stmt|;
DECL|field|lineSeparator
specifier|protected
name|String
name|lineSeparator
decl_stmt|;
DECL|field|normalizedLineSeparator
specifier|protected
name|Character
name|normalizedLineSeparator
decl_stmt|;
DECL|field|comment
specifier|protected
name|Character
name|comment
decl_stmt|;
DECL|field|lazyLoad
specifier|protected
name|boolean
name|lazyLoad
decl_stmt|;
DECL|field|asMap
specifier|protected
name|boolean
name|asMap
decl_stmt|;
DECL|field|writerSettings
specifier|private
specifier|volatile
name|CWS
name|writerSettings
decl_stmt|;
DECL|field|writerSettingsToken
specifier|private
specifier|final
name|Object
name|writerSettingsToken
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|marshaller
specifier|private
specifier|volatile
name|Marshaller
argument_list|<
name|W
argument_list|>
name|marshaller
decl_stmt|;
comment|// We're using a ThreadLocal for the parser settings because in order to retrieve the headers we need to change the
comment|// settings each time we're parsing
DECL|field|parserSettings
specifier|private
specifier|volatile
name|ThreadLocal
argument_list|<
name|CPS
argument_list|>
name|parserSettings
decl_stmt|;
DECL|field|parserSettingsToken
specifier|private
specifier|final
name|Object
name|parserSettingsToken
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|unmarshaller
specifier|private
specifier|volatile
name|Unmarshaller
argument_list|<
name|P
argument_list|>
name|unmarshaller
decl_stmt|;
comment|/**      * {@inheritDoc}      */
annotation|@
name|Override
DECL|method|marshal (Exchange exchange, Object body, OutputStream stream)
specifier|public
name|void
name|marshal
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|body
parameter_list|,
name|OutputStream
name|stream
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|writerSettings
operator|==
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|writerSettingsToken
init|)
block|{
if|if
condition|(
name|writerSettings
operator|==
literal|null
condition|)
block|{
name|writerSettings
operator|=
name|createAndConfigureWriterSettings
argument_list|()
expr_stmt|;
name|marshaller
operator|=
operator|new
name|Marshaller
argument_list|<>
argument_list|(
name|headers
argument_list|,
name|headers
operator|==
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Writer
name|writer
init|=
operator|new
name|OutputStreamWriter
argument_list|(
name|stream
argument_list|,
name|getCharsetName
argument_list|(
name|exchange
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|marshaller
operator|.
name|marshal
argument_list|(
name|exchange
argument_list|,
name|body
argument_list|,
name|createWriter
argument_list|(
name|writer
argument_list|,
name|writerSettings
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * {@inheritDoc}      */
annotation|@
name|Override
DECL|method|unmarshal (Exchange exchange, InputStream stream)
specifier|public
name|Object
name|unmarshal
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|InputStream
name|stream
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|parserSettings
operator|==
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|parserSettingsToken
init|)
block|{
if|if
condition|(
name|parserSettings
operator|==
literal|null
condition|)
block|{
name|parserSettings
operator|=
operator|new
name|ThreadLocal
argument_list|<
name|CPS
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|CPS
name|initialValue
parameter_list|()
block|{
return|return
name|createAndConfigureParserSettings
argument_list|()
return|;
block|}
block|}
expr_stmt|;
name|unmarshaller
operator|=
operator|new
name|Unmarshaller
argument_list|<>
argument_list|(
name|lazyLoad
argument_list|,
name|asMap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|HeaderRowProcessor
name|headerRowProcessor
init|=
operator|new
name|HeaderRowProcessor
argument_list|()
decl_stmt|;
name|CPS
name|settings
init|=
name|parserSettings
operator|.
name|get
argument_list|()
decl_stmt|;
name|settings
operator|.
name|setProcessor
argument_list|(
name|headerRowProcessor
argument_list|)
expr_stmt|;
name|P
name|parser
init|=
name|createParser
argument_list|(
name|settings
argument_list|)
decl_stmt|;
comment|// univocity-parsers is responsible for closing the reader, even in case of error
name|Reader
name|reader
init|=
operator|new
name|InputStreamReader
argument_list|(
name|stream
argument_list|,
name|getCharsetName
argument_list|(
name|exchange
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|unmarshaller
operator|.
name|unmarshal
argument_list|(
name|reader
argument_list|,
name|parser
argument_list|,
name|headerRowProcessor
argument_list|)
return|;
block|}
comment|/**      * Gets the String representation of a null value.      * If {@code null} then the default settings value is used.      *      * @return the String representation of a null value      * @see com.univocity.parsers.common.CommonSettings#getNullValue()      */
DECL|method|getNullValue ()
specifier|public
name|String
name|getNullValue
parameter_list|()
block|{
return|return
name|nullValue
return|;
block|}
comment|/**      * Sets the String representation of a null value.      * If {@code null} then the default settings value is used.      *      * @param nullValue the String representation of a null value      * @return current data format instance, fluent API      * @see com.univocity.parsers.common.CommonSettings#setNullValue(String)      */
DECL|method|setNullValue (String nullValue)
specifier|public
name|DF
name|setNullValue
parameter_list|(
name|String
name|nullValue
parameter_list|)
block|{
name|this
operator|.
name|nullValue
operator|=
name|nullValue
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * Gets whether or not empty lines should be ignored.      * If {@code null} then the default settings value is used.      *      * @return whether or not empty lines should be ignored      * @see com.univocity.parsers.common.CommonSettings#getSkipEmptyLines()      */
DECL|method|getSkipEmptyLines ()
specifier|public
name|Boolean
name|getSkipEmptyLines
parameter_list|()
block|{
return|return
name|skipEmptyLines
return|;
block|}
comment|/**      * Sets whether or not empty lines should be ignored.      * If {@code null} then the default settings value is used.      *      * @param skipEmptyLines whether or not empty lines should be ignored      * @return current data format instance, fluent API      * @see com.univocity.parsers.common.CommonSettings#setSkipEmptyLines(boolean)      */
DECL|method|setSkipEmptyLines (Boolean skipEmptyLines)
specifier|public
name|DF
name|setSkipEmptyLines
parameter_list|(
name|Boolean
name|skipEmptyLines
parameter_list|)
block|{
name|this
operator|.
name|skipEmptyLines
operator|=
name|skipEmptyLines
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * Gets whether or not trailing whitespaces should be ignored.      * If {@code null} then the default settings value is used.      *      * @return whether or not trailing whitespaces should be ignored      * @see com.univocity.parsers.common.CommonSettings#getIgnoreTrailingWhitespaces()      */
DECL|method|getIgnoreTrailingWhitespaces ()
specifier|public
name|Boolean
name|getIgnoreTrailingWhitespaces
parameter_list|()
block|{
return|return
name|ignoreTrailingWhitespaces
return|;
block|}
comment|/**      * Sets whether or not trailing whitespaces should be ignored.      * If {@code null} then the default settings value is used.      *      * @param ignoreTrailingWhitespaces whether or not trailing whitespaces should be ignored      * @return current data format instance, fluent API      * @see com.univocity.parsers.common.CommonSettings#setIgnoreTrailingWhitespaces(boolean)      */
DECL|method|setIgnoreTrailingWhitespaces (Boolean ignoreTrailingWhitespaces)
specifier|public
name|DF
name|setIgnoreTrailingWhitespaces
parameter_list|(
name|Boolean
name|ignoreTrailingWhitespaces
parameter_list|)
block|{
name|this
operator|.
name|ignoreTrailingWhitespaces
operator|=
name|ignoreTrailingWhitespaces
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * Gets whether or not leading whitespaces should be ignored.      * If {@code null} then the default settings value is used.      *      * @return whether or not leading whitespaces should be ignored      * @see com.univocity.parsers.common.CommonSettings#getIgnoreLeadingWhitespaces()      */
DECL|method|getIgnoreLeadingWhitespaces ()
specifier|public
name|Boolean
name|getIgnoreLeadingWhitespaces
parameter_list|()
block|{
return|return
name|ignoreLeadingWhitespaces
return|;
block|}
comment|/**      * Sets whether or not leading whitespaces should be ignored.      * If {@code null} then the default settings value is used.      *      * @param ignoreLeadingWhitespaces whether or not leading whitespaces should be ignored      * @return current data format instance, fluent API      * @see com.univocity.parsers.common.CommonSettings#setIgnoreLeadingWhitespaces(boolean)      */
DECL|method|setIgnoreLeadingWhitespaces (Boolean ignoreLeadingWhitespaces)
specifier|public
name|DF
name|setIgnoreLeadingWhitespaces
parameter_list|(
name|Boolean
name|ignoreLeadingWhitespaces
parameter_list|)
block|{
name|this
operator|.
name|ignoreLeadingWhitespaces
operator|=
name|ignoreLeadingWhitespaces
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * Gets whether or not headers are disabled.      * If {@code true} then it passes {@code null} to      * {@link com.univocity.parsers.common.CommonSettings#setHeaders(String...)} in order to disabled them.      *      * @return whether or not headers are disabled      * @see com.univocity.parsers.common.CommonSettings#getHeaders()      */
DECL|method|isHeadersDisabled ()
specifier|public
name|boolean
name|isHeadersDisabled
parameter_list|()
block|{
return|return
name|headersDisabled
return|;
block|}
comment|/**      * Sets whether or not headers are disabled.      * If {@code true} then it passes {@code null} to      * {@link com.univocity.parsers.common.CommonSettings#setHeaders(String...)} in order to disabled them.      *      * @param headersDisabled whether or not headers are disabled      * @return current data format instance, fluent API      * @see com.univocity.parsers.common.CommonSettings#setHeaders(String...)      */
DECL|method|setHeadersDisabled (boolean headersDisabled)
specifier|public
name|DF
name|setHeadersDisabled
parameter_list|(
name|boolean
name|headersDisabled
parameter_list|)
block|{
name|this
operator|.
name|headersDisabled
operator|=
name|headersDisabled
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * Gets the headers.      * If {@code null} then the default settings value is used.      *      * @return the headers      * @see com.univocity.parsers.common.CommonSettings#getHeaders()      */
DECL|method|getHeaders ()
specifier|public
name|String
index|[]
name|getHeaders
parameter_list|()
block|{
return|return
name|headers
return|;
block|}
comment|/**      * Sets the headers.      * If {@code null} then the default settings value is used.      *      * @param headers the headers      * @return current data format instance, fluent API      * @see com.univocity.parsers.common.CommonSettings#setHeaders(String...)      */
DECL|method|setHeaders (String[] headers)
specifier|public
name|DF
name|setHeaders
parameter_list|(
name|String
index|[]
name|headers
parameter_list|)
block|{
name|this
operator|.
name|headers
operator|=
name|headers
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * Gets whether or not the header extraction is enabled.      * If {@code null} then the default settings value is used.      *      * @return whether or not the header extraction is enabled      * @see com.univocity.parsers.common.CommonParserSettings#isHeaderExtractionEnabled()      */
DECL|method|getHeaderExtractionEnabled ()
specifier|public
name|Boolean
name|getHeaderExtractionEnabled
parameter_list|()
block|{
return|return
name|headerExtractionEnabled
return|;
block|}
comment|/**      * Sets whether or not the header extraction is enabled.      * If {@code null} then the default settings value is used.      *      * @param headerExtractionEnabled whether or not the header extraction is enabled      * @return current data format instance, fluent API      * @see com.univocity.parsers.common.CommonParserSettings#setHeaderExtractionEnabled(boolean)      */
DECL|method|setHeaderExtractionEnabled (Boolean headerExtractionEnabled)
specifier|public
name|DF
name|setHeaderExtractionEnabled
parameter_list|(
name|Boolean
name|headerExtractionEnabled
parameter_list|)
block|{
name|this
operator|.
name|headerExtractionEnabled
operator|=
name|headerExtractionEnabled
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * Gets the number of records to read.      * If {@code null} then the default settings value is used.      *      * @return the number of records to read      * @see com.univocity.parsers.common.CommonParserSettings#getNumberOfRecordsToRead()      */
DECL|method|getNumberOfRecordsToRead ()
specifier|public
name|Integer
name|getNumberOfRecordsToRead
parameter_list|()
block|{
return|return
name|numberOfRecordsToRead
return|;
block|}
comment|/**      * Sets the number of records to read.      * If {@code null} then the default settings value is used.      *      * @param numberOfRecordsToRead the number of records to read      * @return current data format instance, fluent API      * @see com.univocity.parsers.common.CommonParserSettings#setNumberOfRecordsToRead(long)      */
DECL|method|setNumberOfRecordsToRead (Integer numberOfRecordsToRead)
specifier|public
name|DF
name|setNumberOfRecordsToRead
parameter_list|(
name|Integer
name|numberOfRecordsToRead
parameter_list|)
block|{
name|this
operator|.
name|numberOfRecordsToRead
operator|=
name|numberOfRecordsToRead
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * Gets the String representation of an empty value.      * If {@code null} then the default settings value is used.      *      * @return the String representation of an empty value      * @see com.univocity.parsers.common.CommonWriterSettings#getEmptyValue()      */
DECL|method|getEmptyValue ()
specifier|public
name|String
name|getEmptyValue
parameter_list|()
block|{
return|return
name|emptyValue
return|;
block|}
comment|/**      * Sets the String representation of an empty value.      * If {@code null} then the default settings value is used.      *      * @param emptyValue the String representation of an empty value      * @return current data format instance, fluent API      * @see com.univocity.parsers.common.CommonWriterSettings#setEmptyValue(String)      */
DECL|method|setEmptyValue (String emptyValue)
specifier|public
name|DF
name|setEmptyValue
parameter_list|(
name|String
name|emptyValue
parameter_list|)
block|{
name|this
operator|.
name|emptyValue
operator|=
name|emptyValue
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * Gets the line separator.      * If {@code null} then the default format value is used.      *      * @return the line separator      * @see com.univocity.parsers.common.Format#getLineSeparatorString()      */
DECL|method|getLineSeparator ()
specifier|public
name|String
name|getLineSeparator
parameter_list|()
block|{
return|return
name|lineSeparator
return|;
block|}
comment|/**      * Sets the line separator.      * If {@code null} then the default format value is used.      *      * @param lineSeparator the line separator      * @return current data format instance, fluent API      * @see Format#setLineSeparator(String)      */
DECL|method|setLineSeparator (String lineSeparator)
specifier|public
name|DF
name|setLineSeparator
parameter_list|(
name|String
name|lineSeparator
parameter_list|)
block|{
name|this
operator|.
name|lineSeparator
operator|=
name|lineSeparator
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * Gets the normalized line separator.      * If {@code null} then the default format value is used.      *      * @return the normalized line separator      * @see com.univocity.parsers.common.Format#getNormalizedNewline()      */
DECL|method|getNormalizedLineSeparator ()
specifier|public
name|Character
name|getNormalizedLineSeparator
parameter_list|()
block|{
return|return
name|normalizedLineSeparator
return|;
block|}
comment|/**      * Sets the normalized line separator.      * If {@code null} then the default format value is used.      *      * @param normalizedLineSeparator the normalized line separator      * @return current data format instance, fluent API      * @see Format#setNormalizedNewline(char)      */
DECL|method|setNormalizedLineSeparator (Character normalizedLineSeparator)
specifier|public
name|DF
name|setNormalizedLineSeparator
parameter_list|(
name|Character
name|normalizedLineSeparator
parameter_list|)
block|{
name|this
operator|.
name|normalizedLineSeparator
operator|=
name|normalizedLineSeparator
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * Gets the comment symbol.      * If {@code null} then the default format value is used.      *      * @return the comment symbol      * @see com.univocity.parsers.common.Format#getComment()      */
DECL|method|getComment ()
specifier|public
name|Character
name|getComment
parameter_list|()
block|{
return|return
name|comment
return|;
block|}
comment|/**      * Gets the comment symbol.      * If {@code null} then the default format value is used.      *      * @param comment the comment symbol      * @return current data format instance, fluent API      * @see com.univocity.parsers.common.Format#setComment(char)      */
DECL|method|setComment (Character comment)
specifier|public
name|DF
name|setComment
parameter_list|(
name|Character
name|comment
parameter_list|)
block|{
name|this
operator|.
name|comment
operator|=
name|comment
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * Gets whether or not the unmarshalling should read lines lazily.      *      * @return whether or not the unmarshalling should read lines lazily      */
DECL|method|isLazyLoad ()
specifier|public
name|boolean
name|isLazyLoad
parameter_list|()
block|{
return|return
name|lazyLoad
return|;
block|}
comment|/**      * Sets whether or not the unmarshalling should read lines lazily.      *      * @param lazyLoad whether or not the unmarshalling should read lines lazily      * @return current data format instance, fluent API      */
DECL|method|setLazyLoad (boolean lazyLoad)
specifier|public
name|DF
name|setLazyLoad
parameter_list|(
name|boolean
name|lazyLoad
parameter_list|)
block|{
name|this
operator|.
name|lazyLoad
operator|=
name|lazyLoad
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * Gets whether or not the unmarshalling should produces maps instead of lists.      *      * @return whether or not the unmarshalling should produces maps instead of lists      */
DECL|method|isAsMap ()
specifier|public
name|boolean
name|isAsMap
parameter_list|()
block|{
return|return
name|asMap
return|;
block|}
comment|/**      * Sets whether or not the unmarshalling should produces maps instead of lists.      *      * @param asMap whether or not the unmarshalling should produces maps instead of lists      * @return current data format instance, fluent API      */
DECL|method|setAsMap (boolean asMap)
specifier|public
name|DF
name|setAsMap
parameter_list|(
name|boolean
name|asMap
parameter_list|)
block|{
name|this
operator|.
name|asMap
operator|=
name|asMap
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * Creates a new instance of the writer settings.      *      * @return New instance of the writer settings      */
DECL|method|createWriterSettings ()
specifier|protected
specifier|abstract
name|CWS
name|createWriterSettings
parameter_list|()
function_decl|;
comment|/**      * Configures the writer settings.      *      * @param settings Writer settings to configure      */
DECL|method|configureWriterSettings (CWS settings)
specifier|protected
name|void
name|configureWriterSettings
parameter_list|(
name|CWS
name|settings
parameter_list|)
block|{
name|configureCommonSettings
argument_list|(
name|settings
argument_list|)
expr_stmt|;
if|if
condition|(
name|emptyValue
operator|!=
literal|null
condition|)
block|{
name|settings
operator|.
name|setEmptyValue
argument_list|(
name|emptyValue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Creates a new instance of the uniVocity writer.      *      * @param writer   Output writer to use      * @param settings Writer settings to use      * @return New uinstance of the uniVocity writer      */
DECL|method|createWriter (Writer writer, CWS settings)
specifier|protected
specifier|abstract
name|W
name|createWriter
parameter_list|(
name|Writer
name|writer
parameter_list|,
name|CWS
name|settings
parameter_list|)
function_decl|;
comment|/**      * Creates a new instance of the parser settings.      *      * @return New instance of the parser settings      */
DECL|method|createParserSettings ()
specifier|protected
specifier|abstract
name|CPS
name|createParserSettings
parameter_list|()
function_decl|;
comment|/**      * Configure the parser settings.      *      * @param settings Parser settings to configure      */
DECL|method|configureParserSettings (CPS settings)
specifier|protected
name|void
name|configureParserSettings
parameter_list|(
name|CPS
name|settings
parameter_list|)
block|{
name|configureCommonSettings
argument_list|(
name|settings
argument_list|)
expr_stmt|;
if|if
condition|(
name|headerExtractionEnabled
operator|!=
literal|null
condition|)
block|{
name|settings
operator|.
name|setHeaderExtractionEnabled
argument_list|(
name|headerExtractionEnabled
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numberOfRecordsToRead
operator|!=
literal|null
condition|)
block|{
name|settings
operator|.
name|setNumberOfRecordsToRead
argument_list|(
name|numberOfRecordsToRead
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Creates a new instance of the uniVocity parser.      *      * @param settings Parser settings to use      * @return New instance of the uniVocity parser      */
DECL|method|createParser (CPS settings)
specifier|protected
specifier|abstract
name|P
name|createParser
parameter_list|(
name|CPS
name|settings
parameter_list|)
function_decl|;
comment|/**      * Configures the format.      *      * @param format format to configure      */
DECL|method|configureFormat (F format)
specifier|protected
name|void
name|configureFormat
parameter_list|(
name|F
name|format
parameter_list|)
block|{
if|if
condition|(
name|lineSeparator
operator|!=
literal|null
condition|)
block|{
name|format
operator|.
name|setLineSeparator
argument_list|(
name|lineSeparator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|normalizedLineSeparator
operator|!=
literal|null
condition|)
block|{
name|format
operator|.
name|setNormalizedNewline
argument_list|(
name|normalizedLineSeparator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|comment
operator|!=
literal|null
condition|)
block|{
name|format
operator|.
name|setComment
argument_list|(
name|comment
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Creates and configures the writer settings.      *      * @return new configured instance of the writer settings      */
DECL|method|createAndConfigureWriterSettings ()
specifier|final
name|CWS
name|createAndConfigureWriterSettings
parameter_list|()
block|{
name|CWS
name|settings
init|=
name|createWriterSettings
argument_list|()
decl_stmt|;
name|configureWriterSettings
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|configureFormat
argument_list|(
name|settings
operator|.
name|getFormat
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|settings
return|;
block|}
comment|/**      * Creates and configures the parser settings.      *      * @return new configured instance of the parser settings      */
DECL|method|createAndConfigureParserSettings ()
specifier|final
name|CPS
name|createAndConfigureParserSettings
parameter_list|()
block|{
name|CPS
name|settings
init|=
name|createParserSettings
argument_list|()
decl_stmt|;
name|configureParserSettings
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|configureFormat
argument_list|(
name|settings
operator|.
name|getFormat
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|settings
return|;
block|}
comment|/**      * Configures the common settings shared by parser and writer.      *      * @param settings settings to configure      */
DECL|method|configureCommonSettings (CommonSettings<F> settings)
specifier|private
name|void
name|configureCommonSettings
parameter_list|(
name|CommonSettings
argument_list|<
name|F
argument_list|>
name|settings
parameter_list|)
block|{
if|if
condition|(
name|nullValue
operator|!=
literal|null
condition|)
block|{
name|settings
operator|.
name|setNullValue
argument_list|(
name|nullValue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|skipEmptyLines
operator|!=
literal|null
condition|)
block|{
name|settings
operator|.
name|setSkipEmptyLines
argument_list|(
name|skipEmptyLines
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ignoreTrailingWhitespaces
operator|!=
literal|null
condition|)
block|{
name|settings
operator|.
name|setIgnoreTrailingWhitespaces
argument_list|(
name|ignoreTrailingWhitespaces
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ignoreLeadingWhitespaces
operator|!=
literal|null
condition|)
block|{
name|settings
operator|.
name|setIgnoreLeadingWhitespaces
argument_list|(
name|ignoreLeadingWhitespaces
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|headersDisabled
condition|)
block|{
name|settings
operator|.
name|setHeaders
argument_list|(
operator|(
name|String
index|[]
operator|)
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|headers
operator|!=
literal|null
condition|)
block|{
name|settings
operator|.
name|setHeaders
argument_list|(
name|headers
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns {@code this} as the proper data format type. It helps the fluent API with inheritance.      *      * @return {@code this} as the proper data format type      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|self ()
specifier|private
name|DF
name|self
parameter_list|()
block|{
return|return
operator|(
name|DF
operator|)
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|doStart ()
specifier|protected
name|void
name|doStart
parameter_list|()
throws|throws
name|Exception
block|{
name|writerSettings
operator|=
literal|null
expr_stmt|;
name|marshaller
operator|=
literal|null
expr_stmt|;
name|parserSettings
operator|=
literal|null
expr_stmt|;
name|unmarshaller
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStop ()
specifier|protected
name|void
name|doStop
parameter_list|()
throws|throws
name|Exception
block|{
comment|// noop
block|}
block|}
end_class

end_unit

