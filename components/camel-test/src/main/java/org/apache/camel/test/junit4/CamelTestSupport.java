begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.test.junit4
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|test
operator|.
name|junit4
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Annotation
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|AttributeNotFoundException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|InstanceNotFoundException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|MBeanException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|MBeanServer
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|MalformedObjectNameException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|ObjectName
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|ReflectionException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|InitialContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|ConsumerTemplate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Endpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Expression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|ExtendedCamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|FluentProducerTemplate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|NamedNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|NoSuchEndpointException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Processor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|ProducerTemplate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Route
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|RoutesBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|RuntimeCamelException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|ServiceStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|api
operator|.
name|management
operator|.
name|JmxSystemPropertyKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|api
operator|.
name|management
operator|.
name|ManagedCamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|api
operator|.
name|management
operator|.
name|mbean
operator|.
name|ManagedCamelContextMBean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|api
operator|.
name|management
operator|.
name|mbean
operator|.
name|ManagedProcessorMBean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|api
operator|.
name|management
operator|.
name|mbean
operator|.
name|ManagedRouteMBean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|AdviceWithRouteBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|RouteBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|mock
operator|.
name|MockEndpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|properties
operator|.
name|PropertiesComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|impl
operator|.
name|DefaultCamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|impl
operator|.
name|JndiRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|impl
operator|.
name|engine
operator|.
name|InterceptSendToMockEndpointStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|model
operator|.
name|Model
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|model
operator|.
name|ModelCamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|model
operator|.
name|ProcessorDefinition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
operator|.
name|interceptor
operator|.
name|BreakpointSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
operator|.
name|interceptor
operator|.
name|DefaultDebugger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|reifier
operator|.
name|RouteReifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|CamelBeanPostProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|Language
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|Registry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|EndpointHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|IOHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|StopWatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|TimeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|URISupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|ClassRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * A useful base class which creates a {@link org.apache.camel.CamelContext} with some routes  * along with a {@link org.apache.camel.ProducerTemplate} for use in the test case  * Do<tt>not</tt> use this class for Spring Boot testing, instead use<code>@RunWith(CamelSpringBootRunner.class)</code>.  */
end_comment

begin_class
DECL|class|CamelTestSupport
specifier|public
specifier|abstract
class|class
name|CamelTestSupport
extends|extends
name|TestSupport
block|{
comment|/**      * JVM system property which can be set to true to turn on dumping route coverage statistics.      */
DECL|field|ROUTE_COVERAGE_ENABLED
specifier|public
specifier|static
specifier|final
name|String
name|ROUTE_COVERAGE_ENABLED
init|=
literal|"CamelTestRouteCoverage"
decl_stmt|;
comment|// CHECKSTYLE:OFF
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|CamelTestSupport
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|threadCamelContext
specifier|private
specifier|static
name|ThreadLocal
argument_list|<
name|ModelCamelContext
argument_list|>
name|threadCamelContext
init|=
operator|new
name|ThreadLocal
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|threadTemplate
specifier|private
specifier|static
name|ThreadLocal
argument_list|<
name|ProducerTemplate
argument_list|>
name|threadTemplate
init|=
operator|new
name|ThreadLocal
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|threadFluentTemplate
specifier|private
specifier|static
name|ThreadLocal
argument_list|<
name|FluentProducerTemplate
argument_list|>
name|threadFluentTemplate
init|=
operator|new
name|ThreadLocal
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|threadConsumer
specifier|private
specifier|static
name|ThreadLocal
argument_list|<
name|ConsumerTemplate
argument_list|>
name|threadConsumer
init|=
operator|new
name|ThreadLocal
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|threadService
specifier|private
specifier|static
name|ThreadLocal
argument_list|<
name|Service
argument_list|>
name|threadService
init|=
operator|new
name|ThreadLocal
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|extra
specifier|protected
name|Properties
name|extra
decl_stmt|;
DECL|field|context
specifier|protected
specifier|volatile
name|ModelCamelContext
name|context
decl_stmt|;
DECL|field|template
specifier|protected
specifier|volatile
name|ProducerTemplate
name|template
decl_stmt|;
DECL|field|fluentTemplate
specifier|protected
specifier|volatile
name|FluentProducerTemplate
name|fluentTemplate
decl_stmt|;
DECL|field|consumer
specifier|protected
specifier|volatile
name|ConsumerTemplate
name|consumer
decl_stmt|;
DECL|field|camelContextService
specifier|protected
specifier|volatile
name|Service
name|camelContextService
decl_stmt|;
DECL|field|useRouteBuilder
specifier|private
name|boolean
name|useRouteBuilder
init|=
literal|true
decl_stmt|;
DECL|field|breakpoint
specifier|private
specifier|final
name|DebugBreakpoint
name|breakpoint
init|=
operator|new
name|DebugBreakpoint
argument_list|()
decl_stmt|;
DECL|field|watch
specifier|private
specifier|final
name|StopWatch
name|watch
init|=
operator|new
name|StopWatch
argument_list|()
decl_stmt|;
DECL|field|fromEndpoints
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|fromEndpoints
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|TESTS
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|AtomicInteger
argument_list|>
name|TESTS
init|=
operator|new
name|ThreadLocal
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|INSTANCE
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|CamelTestSupport
argument_list|>
name|INSTANCE
init|=
operator|new
name|ThreadLocal
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|camelTestWatcher
specifier|private
name|CamelTestWatcher
name|camelTestWatcher
init|=
operator|new
name|CamelTestWatcher
argument_list|()
decl_stmt|;
annotation|@
name|ClassRule
DECL|field|CAMEL_TEAR_DOWN_RULE
specifier|public
specifier|static
specifier|final
name|CamelTearDownRule
name|CAMEL_TEAR_DOWN_RULE
init|=
operator|new
name|CamelTearDownRule
argument_list|(
name|INSTANCE
argument_list|)
decl_stmt|;
comment|// CHECKSTYLE:ON
comment|/**      * Use the RouteBuilder or not      *      * @return<tt>true</tt> then {@link CamelContext} will be auto started,      *<tt>false</tt> then {@link CamelContext} will<b>not</b> be auto started (you will have to start it manually)      */
DECL|method|isUseRouteBuilder ()
specifier|public
name|boolean
name|isUseRouteBuilder
parameter_list|()
block|{
return|return
name|useRouteBuilder
return|;
block|}
DECL|method|setUseRouteBuilder (boolean useRouteBuilder)
specifier|public
name|void
name|setUseRouteBuilder
parameter_list|(
name|boolean
name|useRouteBuilder
parameter_list|)
block|{
name|this
operator|.
name|useRouteBuilder
operator|=
name|useRouteBuilder
expr_stmt|;
block|}
comment|/**      * Whether to dump route coverage stats at the end of the test.      *<p/>      * This allows tooling or manual inspection of the stats, so you can generate a route trace diagram of which EIPs      * have been in use and which have not. Similar concepts as a code coverage report.      *<p/>      * You can also turn on route coverage globally via setting JVM system property<tt>CamelTestRouteCoverage=true</tt>.      *      * @return<tt>true</tt> to write route coverage status in an xml file in the<tt>target/camel-route-coverage</tt> directory after the test has finished.      */
DECL|method|isDumpRouteCoverage ()
specifier|public
name|boolean
name|isDumpRouteCoverage
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**      * Override when using<a href="http://camel.apache.org/advicewith.html">advice with</a> and return<tt>true</tt>.      * This helps knowing advice with is to be used, and {@link CamelContext} will not be started before      * the advice with takes place. This helps by ensuring the advice with has been property setup before the      * {@link CamelContext} is started      *<p/>      *<b>Important:</b> Its important to start {@link CamelContext} manually from the unit test      * after you are done doing all the advice with.      *      * @return<tt>true</tt> if you use advice with in your unit tests.      */
DECL|method|isUseAdviceWith ()
specifier|public
name|boolean
name|isUseAdviceWith
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**      * Override to control whether {@link CamelContext} should be setup per test or per class.      *<p/>      * By default it will be setup/teardown per test (per test method). If you want to re-use      * {@link CamelContext} between test methods you can override this method and return<tt>true</tt>      *<p/>      *<b>Important:</b> Use this with care as the {@link CamelContext} will carry over state      * from previous tests, such as endpoints, components etc. So you cannot use this in all your tests.      *<p/>      * Setting up {@link CamelContext} uses the {@link #doPreSetup()}, {@link #doSetUp()}, and {@link #doPostSetup()}      * methods in that given order.      *      * @return<tt>true</tt> per class,<tt>false</tt> per test.      */
DECL|method|isCreateCamelContextPerClass ()
specifier|public
name|boolean
name|isCreateCamelContextPerClass
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**      * Override to enable auto mocking endpoints based on the pattern.      *<p/>      * Return<tt>*</tt> to mock all endpoints.      *      * @see EndpointHelper#matchEndpoint(CamelContext, String, String)      */
DECL|method|isMockEndpoints ()
specifier|public
name|String
name|isMockEndpoints
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
comment|/**      * Override to enable auto mocking endpoints based on the pattern, and<b>skip</b> sending      * to original endpoint.      *<p/>      * Return<tt>*</tt> to mock all endpoints.      *      * @see EndpointHelper#matchEndpoint(CamelContext, String, String)      */
DECL|method|isMockEndpointsAndSkip ()
specifier|public
name|String
name|isMockEndpointsAndSkip
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|method|replaceRouteFromWith (String routeId, String fromEndpoint)
specifier|public
name|void
name|replaceRouteFromWith
parameter_list|(
name|String
name|routeId
parameter_list|,
name|String
name|fromEndpoint
parameter_list|)
block|{
name|fromEndpoints
operator|.
name|put
argument_list|(
name|routeId
argument_list|,
name|fromEndpoint
argument_list|)
expr_stmt|;
block|}
comment|/**      * Used for filtering routes routes matching the given pattern, which follows the following rules:      *<p>      * - Match by route id      * - Match by route input endpoint uri      *<p>      * The matching is using exact match, by wildcard and regular expression.      *<p>      * For example to only include routes which starts with foo in their route id's, use: include=foo&#42;      * And to exclude routes which starts from JMS endpoints, use: exclude=jms:&#42;      *<p>      * Multiple patterns can be separated by comma, for example to exclude both foo and bar routes, use: exclude=foo&#42;,bar&#42;      *<p>      * Exclude takes precedence over include.      */
DECL|method|getRouteFilterIncludePattern ()
specifier|public
name|String
name|getRouteFilterIncludePattern
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
comment|/**      * Used for filtering routes routes matching the given pattern, which follows the following rules:      *<p>      * - Match by route id      * - Match by route input endpoint uri      *<p>      * The matching is using exact match, by wildcard and regular expression.      *<p>      * For example to only include routes which starts with foo in their route id's, use: include=foo&#42;      * And to exclude routes which starts from JMS endpoints, use: exclude=jms:&#42;      *<p>      * Multiple patterns can be separated by comma, for example to exclude both foo and bar routes, use: exclude=foo&#42;,bar&#42;      *<p>      * Exclude takes precedence over include.      */
DECL|method|getRouteFilterExcludePattern ()
specifier|public
name|String
name|getRouteFilterExcludePattern
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
comment|/**      * Override to enable debugger      *<p/>      * Is default<tt>false</tt>      */
DECL|method|isUseDebugger ()
specifier|public
name|boolean
name|isUseDebugger
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
DECL|method|getCamelContextService ()
specifier|public
name|Service
name|getCamelContextService
parameter_list|()
block|{
return|return
name|camelContextService
return|;
block|}
DECL|method|camelContextService ()
specifier|public
name|Service
name|camelContextService
parameter_list|()
block|{
return|return
name|camelContextService
return|;
block|}
DECL|method|context ()
specifier|public
name|CamelContext
name|context
parameter_list|()
block|{
return|return
name|context
return|;
block|}
DECL|method|template ()
specifier|public
name|ProducerTemplate
name|template
parameter_list|()
block|{
return|return
name|template
return|;
block|}
DECL|method|fluentTemplate ()
specifier|public
name|FluentProducerTemplate
name|fluentTemplate
parameter_list|()
block|{
return|return
name|fluentTemplate
return|;
block|}
DECL|method|consumer ()
specifier|public
name|ConsumerTemplate
name|consumer
parameter_list|()
block|{
return|return
name|consumer
return|;
block|}
comment|/**      * Allows a service to be registered a separate lifecycle service to start      * and stop the context; such as for Spring when the ApplicationContext is      * started and stopped, rather than directly stopping the CamelContext      */
DECL|method|setCamelContextService (Service service)
specifier|public
name|void
name|setCamelContextService
parameter_list|(
name|Service
name|service
parameter_list|)
block|{
name|camelContextService
operator|=
name|service
expr_stmt|;
name|threadService
operator|.
name|set
argument_list|(
name|camelContextService
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Before
DECL|method|setUp ()
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|log
operator|.
name|info
argument_list|(
literal|"********************************************************************************"
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Testing: "
operator|+
name|getTestMethodName
argument_list|()
operator|+
literal|"("
operator|+
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"********************************************************************************"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isCreateCamelContextPerClass
argument_list|()
condition|)
block|{
name|INSTANCE
operator|.
name|set
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|AtomicInteger
name|v
init|=
name|TESTS
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
name|v
operator|=
operator|new
name|AtomicInteger
argument_list|()
expr_stmt|;
name|TESTS
operator|.
name|set
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|.
name|getAndIncrement
argument_list|()
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Setup CamelContext before running first test"
argument_list|)
expr_stmt|;
comment|// test is per class, so only setup once (the first time)
name|doSpringBootCheck
argument_list|()
expr_stmt|;
name|setupResources
argument_list|()
expr_stmt|;
name|doPreSetup
argument_list|()
expr_stmt|;
name|doSetUp
argument_list|()
expr_stmt|;
name|doPostSetup
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reset between test methods"
argument_list|)
expr_stmt|;
comment|// and in between tests we must do IoC and reset mocks
name|postProcessTest
argument_list|()
expr_stmt|;
name|resetMocks
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// test is per test so always setup
name|doSpringBootCheck
argument_list|()
expr_stmt|;
name|setupResources
argument_list|()
expr_stmt|;
name|doPreSetup
argument_list|()
expr_stmt|;
name|doSetUp
argument_list|()
expr_stmt|;
name|doPostSetup
argument_list|()
expr_stmt|;
block|}
comment|// only start timing after all the setup
name|watch
operator|.
name|restart
argument_list|()
expr_stmt|;
block|}
comment|/**      * Strategy to perform any pre setup, before {@link CamelContext} is created      */
DECL|method|doPreSetup ()
specifier|protected
name|void
name|doPreSetup
parameter_list|()
throws|throws
name|Exception
block|{
comment|// noop
block|}
comment|/**      * Strategy to perform any post setup after {@link CamelContext} is created      */
DECL|method|doPostSetup ()
specifier|protected
name|void
name|doPostSetup
parameter_list|()
throws|throws
name|Exception
block|{
comment|// noop
block|}
comment|/**      * Detects if this is a Spring-Boot test and throws an exception, as these base classes is not intended      * for testing Camel on Spring Boot.      */
DECL|method|doSpringBootCheck ()
specifier|protected
name|void
name|doSpringBootCheck
parameter_list|()
block|{
name|boolean
name|springBoot
init|=
name|hasClassAnnotation
argument_list|(
literal|"org.springframework.boot.test.context.SpringBootTest"
argument_list|)
decl_stmt|;
if|if
condition|(
name|springBoot
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Spring Boot detected: The CamelTestSupport/CamelSpringTestSupport class is not intended for Camel testing with Spring Boot."
operator|+
literal|" Prefer to not extend this class, but use @RunWith(CamelSpringBootRunner.class) instead."
argument_list|)
throw|;
block|}
block|}
DECL|method|doSetUp ()
specifier|private
name|void
name|doSetUp
parameter_list|()
throws|throws
name|Exception
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"setUp test"
argument_list|)
expr_stmt|;
comment|// jmx is enabled if we have configured to use it, or if dump route coverage is enabled (it requires JMX)
name|boolean
name|jmx
init|=
name|useJmx
argument_list|()
operator|||
name|isRouteCoverageEnabled
argument_list|()
decl_stmt|;
if|if
condition|(
name|jmx
condition|)
block|{
name|enableJMX
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|disableJMX
argument_list|()
expr_stmt|;
block|}
name|context
operator|=
operator|(
name|ModelCamelContext
operator|)
name|createCamelContext
argument_list|()
expr_stmt|;
name|threadCamelContext
operator|.
name|set
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"No context found!"
argument_list|,
name|context
argument_list|)
expr_stmt|;
comment|// add custom beans
name|bindToRegistry
argument_list|(
name|context
operator|.
name|getRegistry
argument_list|()
argument_list|)
expr_stmt|;
comment|// reduce default shutdown timeout to avoid waiting for 300 seconds
name|context
operator|.
name|getShutdownStrategy
argument_list|()
operator|.
name|setTimeout
argument_list|(
name|getShutdownTimeout
argument_list|()
argument_list|)
expr_stmt|;
comment|// set debugger if enabled
if|if
condition|(
name|isUseDebugger
argument_list|()
condition|)
block|{
if|if
condition|(
name|context
operator|.
name|getStatus
argument_list|()
operator|.
name|equals
argument_list|(
name|ServiceStatus
operator|.
name|Started
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Cannot setting the Debugger to the starting CamelContext, stop the CamelContext now."
argument_list|)
expr_stmt|;
comment|// we need to stop the context first to setup the debugger
name|context
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
name|context
operator|.
name|setDebugger
argument_list|(
operator|new
name|DefaultDebugger
argument_list|()
argument_list|)
expr_stmt|;
name|context
operator|.
name|getDebugger
argument_list|()
operator|.
name|addBreakpoint
argument_list|(
name|breakpoint
argument_list|)
expr_stmt|;
comment|// note: when stopping CamelContext it will automatic remove the breakpoint
block|}
name|template
operator|=
name|context
operator|.
name|createProducerTemplate
argument_list|()
expr_stmt|;
name|template
operator|.
name|start
argument_list|()
expr_stmt|;
name|fluentTemplate
operator|=
name|context
operator|.
name|createFluentProducerTemplate
argument_list|()
expr_stmt|;
name|fluentTemplate
operator|.
name|start
argument_list|()
expr_stmt|;
name|consumer
operator|=
name|context
operator|.
name|createConsumerTemplate
argument_list|()
expr_stmt|;
name|consumer
operator|.
name|start
argument_list|()
expr_stmt|;
name|threadTemplate
operator|.
name|set
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|threadFluentTemplate
operator|.
name|set
argument_list|(
name|fluentTemplate
argument_list|)
expr_stmt|;
name|threadConsumer
operator|.
name|set
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
comment|// enable auto mocking if enabled
name|String
name|pattern
init|=
name|isMockEndpoints
argument_list|()
decl_stmt|;
if|if
condition|(
name|pattern
operator|!=
literal|null
condition|)
block|{
name|context
operator|.
name|adapt
argument_list|(
name|ExtendedCamelContext
operator|.
name|class
argument_list|)
operator|.
name|registerEndpointCallback
argument_list|(
operator|new
name|InterceptSendToMockEndpointStrategy
argument_list|(
name|pattern
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pattern
operator|=
name|isMockEndpointsAndSkip
argument_list|()
expr_stmt|;
if|if
condition|(
name|pattern
operator|!=
literal|null
condition|)
block|{
name|context
operator|.
name|adapt
argument_list|(
name|ExtendedCamelContext
operator|.
name|class
argument_list|)
operator|.
name|registerEndpointCallback
argument_list|(
operator|new
name|InterceptSendToMockEndpointStrategy
argument_list|(
name|pattern
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// configure properties component (mandatory for testing)
name|PropertiesComponent
name|pc
init|=
name|context
operator|.
name|getComponent
argument_list|(
literal|"properties"
argument_list|,
name|PropertiesComponent
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|extra
operator|==
literal|null
condition|)
block|{
name|extra
operator|=
name|useOverridePropertiesWithPropertiesComponent
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|extra
operator|!=
literal|null
operator|&&
operator|!
name|extra
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|pc
operator|.
name|setOverrideProperties
argument_list|(
name|extra
argument_list|)
expr_stmt|;
block|}
name|Boolean
name|ignore
init|=
name|ignoreMissingLocationWithPropertiesComponent
argument_list|()
decl_stmt|;
if|if
condition|(
name|ignore
operator|!=
literal|null
condition|)
block|{
name|pc
operator|.
name|setIgnoreMissingLocation
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
block|}
name|String
name|include
init|=
name|getRouteFilterIncludePattern
argument_list|()
decl_stmt|;
name|String
name|exclude
init|=
name|getRouteFilterExcludePattern
argument_list|()
decl_stmt|;
if|if
condition|(
name|include
operator|!=
literal|null
operator|||
name|exclude
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Route filtering pattern: include={}, exclude={}"
argument_list|,
name|include
argument_list|,
name|exclude
argument_list|)
expr_stmt|;
name|context
operator|.
name|getExtension
argument_list|(
name|Model
operator|.
name|class
argument_list|)
operator|.
name|setRouteFilterPattern
argument_list|(
name|include
argument_list|,
name|exclude
argument_list|)
expr_stmt|;
block|}
comment|// prepare for in-between tests
name|postProcessTest
argument_list|()
expr_stmt|;
if|if
condition|(
name|isUseRouteBuilder
argument_list|()
condition|)
block|{
name|RoutesBuilder
index|[]
name|builders
init|=
name|createRouteBuilders
argument_list|()
decl_stmt|;
for|for
control|(
name|RoutesBuilder
name|builder
range|:
name|builders
control|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Using created route builder: "
operator|+
name|builder
argument_list|)
expr_stmt|;
name|context
operator|.
name|addRoutes
argument_list|(
name|builder
argument_list|)
expr_stmt|;
block|}
name|replaceFromEndpoints
argument_list|()
expr_stmt|;
name|boolean
name|skip
init|=
literal|"true"
operator|.
name|equalsIgnoreCase
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"skipStartingCamelContext"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|skip
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Skipping starting CamelContext as system property skipStartingCamelContext is set to be true."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isUseAdviceWith
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Skipping starting CamelContext as isUseAdviceWith is set to true."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|startCamelContext
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|replaceFromEndpoints
argument_list|()
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Using route builder from the created context: "
operator|+
name|context
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"Routing Rules are: "
operator|+
name|context
operator|.
name|getRoutes
argument_list|()
argument_list|)
expr_stmt|;
name|assertValidContext
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
DECL|method|replaceFromEndpoints ()
specifier|private
name|void
name|replaceFromEndpoints
parameter_list|()
throws|throws
name|Exception
block|{
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|fromEndpoints
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|RouteReifier
operator|.
name|adviceWith
argument_list|(
name|context
operator|.
name|getRouteDefinition
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
name|context
argument_list|,
operator|new
name|AdviceWithRouteBuilder
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|configure
parameter_list|()
throws|throws
name|Exception
block|{
name|replaceFromWith
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|isRouteCoverageEnabled ()
specifier|private
name|boolean
name|isRouteCoverageEnabled
parameter_list|()
block|{
return|return
name|System
operator|.
name|getProperty
argument_list|(
name|ROUTE_COVERAGE_ENABLED
argument_list|,
literal|"false"
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"true"
argument_list|)
operator|||
name|isDumpRouteCoverage
argument_list|()
return|;
block|}
annotation|@
name|After
DECL|method|tearDown ()
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|time
init|=
name|watch
operator|.
name|taken
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"********************************************************************************"
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Testing done: "
operator|+
name|getTestMethodName
argument_list|()
operator|+
literal|"("
operator|+
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Took: "
operator|+
name|TimeUtils
operator|.
name|printDuration
argument_list|(
name|time
argument_list|)
operator|+
literal|" ("
operator|+
name|time
operator|+
literal|" millis)"
argument_list|)
expr_stmt|;
comment|// if we should dump route stats, then write that to a file
if|if
condition|(
name|isRouteCoverageEnabled
argument_list|()
condition|)
block|{
name|String
name|className
init|=
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
decl_stmt|;
name|String
name|dir
init|=
literal|"target/camel-route-coverage"
decl_stmt|;
name|String
name|name
init|=
name|className
operator|+
literal|"-"
operator|+
name|getTestMethodName
argument_list|()
operator|+
literal|".xml"
decl_stmt|;
name|ManagedCamelContext
name|mc
init|=
name|context
operator|!=
literal|null
condition|?
name|context
operator|.
name|getExtension
argument_list|(
name|ManagedCamelContext
operator|.
name|class
argument_list|)
else|:
literal|null
decl_stmt|;
name|ManagedCamelContextMBean
name|managedCamelContext
init|=
name|mc
operator|!=
literal|null
condition|?
name|mc
operator|.
name|getManagedCamelContext
argument_list|()
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|managedCamelContext
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Cannot dump route coverage to file as JMX is not enabled. "
operator|+
literal|"Add camel-management-impl JAR as dependency and/or override useJmx() method to enable JMX in the unit test classes."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logCoverageSummary
argument_list|(
name|managedCamelContext
argument_list|)
expr_stmt|;
name|String
name|xml
init|=
name|managedCamelContext
operator|.
name|dumpRoutesCoverageAsXml
argument_list|()
decl_stmt|;
name|String
name|combined
init|=
literal|"<camelRouteCoverage>\n"
operator|+
name|gatherTestDetailsAsXml
argument_list|()
operator|+
name|xml
operator|+
literal|"\n</camelRouteCoverage>"
decl_stmt|;
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|dir
argument_list|)
decl_stmt|;
comment|// ensure dir exists
name|file
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|file
operator|=
operator|new
name|File
argument_list|(
name|dir
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Dumping route coverage to file: {}"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|InputStream
name|is
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|combined
operator|.
name|getBytes
argument_list|()
argument_list|)
decl_stmt|;
name|OutputStream
name|os
init|=
operator|new
name|FileOutputStream
argument_list|(
name|file
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|IOHelper
operator|.
name|copyAndCloseInput
argument_list|(
name|is
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|IOHelper
operator|.
name|close
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"********************************************************************************"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isCreateCamelContextPerClass
argument_list|()
condition|)
block|{
comment|// will tear down test specially in CamelTearDownRule
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"tearDown()"
argument_list|)
expr_stmt|;
name|doStopTemplates
argument_list|(
name|consumer
argument_list|,
name|template
argument_list|,
name|fluentTemplate
argument_list|)
expr_stmt|;
name|doStopCamelContext
argument_list|(
name|context
argument_list|,
name|camelContextService
argument_list|)
expr_stmt|;
name|doPostTearDown
argument_list|()
expr_stmt|;
name|cleanupResources
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|tearDownCreateCamelContextPerClass ()
name|void
name|tearDownCreateCamelContextPerClass
parameter_list|()
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"tearDownCreateCamelContextPerClass()"
argument_list|)
expr_stmt|;
name|TESTS
operator|.
name|remove
argument_list|()
expr_stmt|;
name|doStopTemplates
argument_list|(
name|threadConsumer
operator|.
name|get
argument_list|()
argument_list|,
name|threadTemplate
operator|.
name|get
argument_list|()
argument_list|,
name|threadFluentTemplate
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|doStopCamelContext
argument_list|(
name|threadCamelContext
operator|.
name|get
argument_list|()
argument_list|,
name|threadService
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|doPostTearDown
argument_list|()
expr_stmt|;
name|cleanupResources
argument_list|()
expr_stmt|;
block|}
comment|/**      * Strategy to perform any post action, after {@link CamelContext} is stopped      */
DECL|method|doPostTearDown ()
specifier|protected
name|void
name|doPostTearDown
parameter_list|()
throws|throws
name|Exception
block|{
comment|// noop
block|}
comment|/**      * Strategy to perform resources setup, before {@link CamelContext} is created      */
DECL|method|setupResources ()
specifier|protected
name|void
name|setupResources
parameter_list|()
throws|throws
name|Exception
block|{
comment|// noop
block|}
comment|/**      * Strategy to perform resources cleanup, after {@link CamelContext} is stopped      */
DECL|method|cleanupResources ()
specifier|protected
name|void
name|cleanupResources
parameter_list|()
throws|throws
name|Exception
block|{
comment|// noop
block|}
comment|/**      * Logs route coverage summary:      * - which routes are uncovered      * - what is the coverage of each processor in each route      */
DECL|method|logCoverageSummary (ManagedCamelContextMBean managedCamelContext)
specifier|private
name|void
name|logCoverageSummary
parameter_list|(
name|ManagedCamelContextMBean
name|managedCamelContext
parameter_list|)
throws|throws
name|Exception
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"\nCoverage summary\n"
argument_list|)
decl_stmt|;
name|int
name|routes
init|=
name|managedCamelContext
operator|.
name|getTotalRoutes
argument_list|()
decl_stmt|;
name|long
name|contextExchangesTotal
init|=
name|managedCamelContext
operator|.
name|getExchangesTotal
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|uncoveredRoutes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|StringBuilder
name|routesSummary
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|routesSummary
operator|.
name|append
argument_list|(
literal|"\tProcessor coverage\n"
argument_list|)
expr_stmt|;
name|MBeanServer
name|server
init|=
name|context
operator|.
name|getManagementStrategy
argument_list|()
operator|.
name|getManagementAgent
argument_list|()
operator|.
name|getMBeanServer
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ManagedProcessorMBean
argument_list|>
argument_list|>
name|processorsForRoute
init|=
name|findProcessorsForEachRoute
argument_list|(
name|server
argument_list|)
decl_stmt|;
comment|// log processor coverage for each route
for|for
control|(
name|Route
name|route
range|:
name|context
operator|.
name|getRoutes
argument_list|()
control|)
block|{
name|ManagedRouteMBean
name|managedRoute
init|=
name|context
operator|.
name|getExtension
argument_list|(
name|ManagedCamelContext
operator|.
name|class
argument_list|)
operator|.
name|getManagedRoute
argument_list|(
name|route
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|managedRoute
operator|.
name|getExchangesTotal
argument_list|()
operator|==
literal|0
condition|)
block|{
name|uncoveredRoutes
operator|.
name|add
argument_list|(
name|route
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|long
name|routeCoveragePercentage
init|=
name|Math
operator|.
name|round
argument_list|(
operator|(
name|double
operator|)
name|managedRoute
operator|.
name|getExchangesTotal
argument_list|()
operator|/
name|contextExchangesTotal
operator|*
literal|100
argument_list|)
decl_stmt|;
name|routesSummary
operator|.
name|append
argument_list|(
literal|"\t\tRoute "
argument_list|)
operator|.
name|append
argument_list|(
name|route
operator|.
name|getId
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" total: "
argument_list|)
operator|.
name|append
argument_list|(
name|managedRoute
operator|.
name|getExchangesTotal
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" ("
argument_list|)
operator|.
name|append
argument_list|(
name|routeCoveragePercentage
argument_list|)
operator|.
name|append
argument_list|(
literal|"%)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|ManagedProcessorMBean
argument_list|>
name|processors
init|=
name|processorsForRoute
operator|.
name|get
argument_list|(
name|route
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|processors
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ManagedProcessorMBean
name|managedProcessor
range|:
name|processors
control|)
block|{
name|String
name|processorId
init|=
name|managedProcessor
operator|.
name|getProcessorId
argument_list|()
decl_stmt|;
name|long
name|processorExchangesTotal
init|=
name|managedProcessor
operator|.
name|getExchangesTotal
argument_list|()
decl_stmt|;
name|long
name|processorCoveragePercentage
init|=
name|Math
operator|.
name|round
argument_list|(
operator|(
name|double
operator|)
name|processorExchangesTotal
operator|/
name|contextExchangesTotal
operator|*
literal|100
argument_list|)
decl_stmt|;
name|routesSummary
operator|.
name|append
argument_list|(
literal|"\t\t\tProcessor "
argument_list|)
operator|.
name|append
argument_list|(
name|processorId
argument_list|)
operator|.
name|append
argument_list|(
literal|" total: "
argument_list|)
operator|.
name|append
argument_list|(
name|processorExchangesTotal
argument_list|)
operator|.
name|append
argument_list|(
literal|" ("
argument_list|)
operator|.
name|append
argument_list|(
name|processorCoveragePercentage
argument_list|)
operator|.
name|append
argument_list|(
literal|"%)\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|int
name|used
init|=
name|routes
operator|-
name|uncoveredRoutes
operator|.
name|size
argument_list|()
decl_stmt|;
name|long
name|contextPercentage
init|=
name|Math
operator|.
name|round
argument_list|(
operator|(
name|double
operator|)
name|used
operator|/
name|routes
operator|*
literal|100
argument_list|)
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"\tRoute coverage: "
argument_list|)
operator|.
name|append
argument_list|(
name|used
argument_list|)
operator|.
name|append
argument_list|(
literal|" out of "
argument_list|)
operator|.
name|append
argument_list|(
name|routes
argument_list|)
operator|.
name|append
argument_list|(
literal|" routes used ("
argument_list|)
operator|.
name|append
argument_list|(
name|contextPercentage
argument_list|)
operator|.
name|append
argument_list|(
literal|"%)\n"
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"\t\tCamelContext ("
argument_list|)
operator|.
name|append
argument_list|(
name|managedCamelContext
operator|.
name|getCamelId
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|") total: "
argument_list|)
operator|.
name|append
argument_list|(
name|contextExchangesTotal
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|uncoveredRoutes
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"\t\tUncovered routes: "
argument_list|)
operator|.
name|append
argument_list|(
name|uncoveredRoutes
operator|.
name|stream
argument_list|()
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|joining
argument_list|(
literal|", "
argument_list|)
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|append
argument_list|(
name|routesSummary
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
name|builder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Groups all processors from Camel context by route id      */
DECL|method|findProcessorsForEachRoute (MBeanServer server)
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ManagedProcessorMBean
argument_list|>
argument_list|>
name|findProcessorsForEachRoute
parameter_list|(
name|MBeanServer
name|server
parameter_list|)
throws|throws
name|MalformedObjectNameException
throws|,
name|MBeanException
throws|,
name|AttributeNotFoundException
throws|,
name|InstanceNotFoundException
throws|,
name|ReflectionException
block|{
name|String
name|domain
init|=
name|context
operator|.
name|getManagementStrategy
argument_list|()
operator|.
name|getManagementAgent
argument_list|()
operator|.
name|getMBeanServerDefaultDomain
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ManagedProcessorMBean
argument_list|>
argument_list|>
name|processorsForRoute
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|ObjectName
name|processorsObjectName
init|=
operator|new
name|ObjectName
argument_list|(
name|domain
operator|+
literal|":context="
operator|+
name|context
operator|.
name|getManagementName
argument_list|()
operator|+
literal|",type=processors,name=*"
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|ObjectName
argument_list|>
name|objectNames
init|=
name|server
operator|.
name|queryNames
argument_list|(
name|processorsObjectName
argument_list|,
literal|null
argument_list|)
decl_stmt|;
for|for
control|(
name|ObjectName
name|objectName
range|:
name|objectNames
control|)
block|{
name|String
name|routeId
init|=
name|server
operator|.
name|getAttribute
argument_list|(
name|objectName
argument_list|,
literal|"RouteId"
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|objectName
operator|.
name|getKeyProperty
argument_list|(
literal|"name"
argument_list|)
decl_stmt|;
name|name
operator|=
name|ObjectName
operator|.
name|unquote
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ManagedProcessorMBean
name|managedProcessor
init|=
name|context
operator|.
name|getExtension
argument_list|(
name|ManagedCamelContext
operator|.
name|class
argument_list|)
operator|.
name|getManagedProcessor
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|managedProcessor
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|processorsForRoute
operator|.
name|get
argument_list|(
name|routeId
argument_list|)
operator|==
literal|null
condition|)
block|{
name|List
argument_list|<
name|ManagedProcessorMBean
argument_list|>
name|processorsList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|processorsList
operator|.
name|add
argument_list|(
name|managedProcessor
argument_list|)
expr_stmt|;
name|processorsForRoute
operator|.
name|put
argument_list|(
name|routeId
argument_list|,
name|processorsList
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|processorsForRoute
operator|.
name|get
argument_list|(
name|routeId
argument_list|)
operator|.
name|add
argument_list|(
name|managedProcessor
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// sort processors by position in route definition
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ManagedProcessorMBean
argument_list|>
argument_list|>
name|entry
range|:
name|processorsForRoute
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|Comparator
operator|.
name|comparing
argument_list|(
name|ManagedProcessorMBean
operator|::
name|getIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|processorsForRoute
return|;
block|}
comment|/**      * Gathers test details as xml      */
DECL|method|gatherTestDetailsAsXml ()
specifier|private
name|String
name|gatherTestDetailsAsXml
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"<test>\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"<class>"
argument_list|)
operator|.
name|append
argument_list|(
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"</class>\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"<method>"
argument_list|)
operator|.
name|append
argument_list|(
name|getTestMethodName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"</method>\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"<time>"
argument_list|)
operator|.
name|append
argument_list|(
name|getCamelTestWatcher
argument_list|()
operator|.
name|timeTaken
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"</time>\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"</test>\n"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Returns the timeout to use when shutting down (unit in seconds).      *<p/>      * Will default use 10 seconds.      *      * @return the timeout to use      */
DECL|method|getShutdownTimeout ()
specifier|protected
name|int
name|getShutdownTimeout
parameter_list|()
block|{
return|return
literal|10
return|;
block|}
comment|/**      * Whether or not JMX should be used during testing.      *      * @return<tt>false</tt> by default.      */
DECL|method|useJmx ()
specifier|protected
name|boolean
name|useJmx
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**      * Whether or not type converters should be lazy loaded (notice core converters is always loaded)      *      * @return<tt>false</tt> by default.      */
annotation|@
name|Deprecated
DECL|method|isLazyLoadingTypeConverter ()
specifier|protected
name|boolean
name|isLazyLoadingTypeConverter
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**      * Override this method to include and override properties      * with the Camel {@link PropertiesComponent}.      *      * @return additional properties to add/override.      */
DECL|method|useOverridePropertiesWithPropertiesComponent ()
specifier|protected
name|Properties
name|useOverridePropertiesWithPropertiesComponent
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Rule
DECL|method|getCamelTestWatcher ()
specifier|public
name|CamelTestWatcher
name|getCamelTestWatcher
parameter_list|()
block|{
return|return
name|camelTestWatcher
return|;
block|}
comment|/**      * Whether to ignore missing locations with the {@link PropertiesComponent}.      * For example when unit testing you may want to ignore locations that are      * not available in the environment you use for testing.      *      * @return<tt>true</tt> to ignore,<tt>false</tt> to not ignore, and<tt>null</tt> to leave as configured      * on the {@link PropertiesComponent}      */
DECL|method|ignoreMissingLocationWithPropertiesComponent ()
specifier|protected
name|Boolean
name|ignoreMissingLocationWithPropertiesComponent
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|method|postProcessTest ()
specifier|protected
name|void
name|postProcessTest
parameter_list|()
throws|throws
name|Exception
block|{
name|context
operator|=
name|threadCamelContext
operator|.
name|get
argument_list|()
expr_stmt|;
name|template
operator|=
name|threadTemplate
operator|.
name|get
argument_list|()
expr_stmt|;
name|fluentTemplate
operator|=
name|threadFluentTemplate
operator|.
name|get
argument_list|()
expr_stmt|;
name|consumer
operator|=
name|threadConsumer
operator|.
name|get
argument_list|()
expr_stmt|;
name|camelContextService
operator|=
name|threadService
operator|.
name|get
argument_list|()
expr_stmt|;
name|applyCamelPostProcessor
argument_list|()
expr_stmt|;
block|}
comment|/**      * Applies the {@link CamelBeanPostProcessor} to this instance.      *<p>      * Derived classes using IoC / DI frameworks may wish to turn this into a NoOp such as for CDI      * we would just use CDI to inject this      */
DECL|method|applyCamelPostProcessor ()
specifier|protected
name|void
name|applyCamelPostProcessor
parameter_list|()
throws|throws
name|Exception
block|{
comment|// use the bean post processor if the test class is not dependency injected already by Spring Framework
name|boolean
name|spring
init|=
name|hasClassAnnotation
argument_list|(
literal|"org.springframework.boot.test.context.SpringBootTest"
argument_list|,
literal|"org.springframework.context.annotation.ComponentScan"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|spring
condition|)
block|{
name|context
operator|.
name|getExtension
argument_list|(
name|ExtendedCamelContext
operator|.
name|class
argument_list|)
operator|.
name|getBeanPostProcessor
argument_list|()
operator|.
name|postProcessBeforeInitialization
argument_list|(
name|this
argument_list|,
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|context
operator|.
name|getExtension
argument_list|(
name|ExtendedCamelContext
operator|.
name|class
argument_list|)
operator|.
name|getBeanPostProcessor
argument_list|()
operator|.
name|postProcessAfterInitialization
argument_list|(
name|this
argument_list|,
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Does this test class have any of the following annotations on the class-level.      */
DECL|method|hasClassAnnotation (String... names)
specifier|protected
name|boolean
name|hasClassAnnotation
parameter_list|(
name|String
modifier|...
name|names
parameter_list|)
block|{
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
for|for
control|(
name|Annotation
name|ann
range|:
name|getClass
argument_list|()
operator|.
name|getAnnotations
argument_list|()
control|)
block|{
name|String
name|annName
init|=
name|ann
operator|.
name|annotationType
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|annName
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|stopCamelContext ()
specifier|protected
name|void
name|stopCamelContext
parameter_list|()
throws|throws
name|Exception
block|{
name|doStopCamelContext
argument_list|(
name|context
argument_list|,
name|camelContextService
argument_list|)
expr_stmt|;
block|}
DECL|method|doStopCamelContext (CamelContext context, Service camelContextService)
specifier|private
specifier|static
name|void
name|doStopCamelContext
parameter_list|(
name|CamelContext
name|context
parameter_list|,
name|Service
name|camelContextService
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|camelContextService
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|camelContextService
operator|==
name|threadService
operator|.
name|get
argument_list|()
condition|)
block|{
name|threadService
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
name|camelContextService
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|context
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|context
operator|==
name|threadCamelContext
operator|.
name|get
argument_list|()
condition|)
block|{
name|threadCamelContext
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
name|context
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|doStopTemplates (ConsumerTemplate consumer, ProducerTemplate template, FluentProducerTemplate fluentTemplate)
specifier|private
specifier|static
name|void
name|doStopTemplates
parameter_list|(
name|ConsumerTemplate
name|consumer
parameter_list|,
name|ProducerTemplate
name|template
parameter_list|,
name|FluentProducerTemplate
name|fluentTemplate
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|consumer
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|consumer
operator|==
name|threadConsumer
operator|.
name|get
argument_list|()
condition|)
block|{
name|threadConsumer
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
name|consumer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|template
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|template
operator|==
name|threadTemplate
operator|.
name|get
argument_list|()
condition|)
block|{
name|threadTemplate
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
name|template
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fluentTemplate
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|fluentTemplate
operator|==
name|threadFluentTemplate
operator|.
name|get
argument_list|()
condition|)
block|{
name|threadFluentTemplate
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
name|fluentTemplate
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|startCamelContext ()
specifier|protected
name|void
name|startCamelContext
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|camelContextService
operator|!=
literal|null
condition|)
block|{
name|camelContextService
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|context
operator|instanceof
name|DefaultCamelContext
condition|)
block|{
name|DefaultCamelContext
name|defaultCamelContext
init|=
operator|(
name|DefaultCamelContext
operator|)
name|context
decl_stmt|;
if|if
condition|(
operator|!
name|defaultCamelContext
operator|.
name|isStarted
argument_list|()
condition|)
block|{
name|defaultCamelContext
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|context
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|createCamelContext ()
specifier|protected
name|CamelContext
name|createCamelContext
parameter_list|()
throws|throws
name|Exception
block|{
comment|// for backwards compatibility
name|Registry
name|registry
init|=
name|createRegistry
argument_list|()
decl_stmt|;
if|if
condition|(
name|registry
operator|instanceof
name|FakeJndiRegistry
condition|)
block|{
name|boolean
name|inUse
init|=
operator|(
operator|(
name|FakeJndiRegistry
operator|)
name|registry
operator|)
operator|.
name|isInUse
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|inUse
condition|)
block|{
name|registry
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|registry
operator|!=
literal|null
condition|)
block|{
name|String
name|msg
init|=
literal|"createRegistry() from camel-test is deprecated. Use createCamelRegistry if you want to control which registry to use, however"
operator|+
literal|" if you need to bind beans to the registry then this is possible already with the bind method on registry,"
operator|+
literal|" and there is no need to override this method."
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|registry
operator|=
name|createCamelRegistry
argument_list|()
expr_stmt|;
block|}
name|CamelContext
name|context
decl_stmt|;
if|if
condition|(
name|registry
operator|!=
literal|null
condition|)
block|{
name|context
operator|=
operator|new
name|DefaultCamelContext
argument_list|(
name|registry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|context
operator|=
operator|new
name|DefaultCamelContext
argument_list|()
expr_stmt|;
block|}
return|return
name|context
return|;
block|}
comment|/**      * Allows to bind custom beans to the Camel {@link Registry}.      */
DECL|method|bindToRegistry (Registry registry)
specifier|protected
name|void
name|bindToRegistry
parameter_list|(
name|Registry
name|registry
parameter_list|)
throws|throws
name|Exception
block|{
comment|// noop
block|}
comment|/**      * Override to use a custom {@link Registry}.      *<p>      * However if you need to bind beans to the registry then this is possible already with the bind method on registry,"      * and there is no need to override this method.      */
DECL|method|createCamelRegistry ()
specifier|protected
name|Registry
name|createCamelRegistry
parameter_list|()
throws|throws
name|Exception
block|{
return|return
literal|null
return|;
block|}
comment|/**      * @deprecated use createCamelRegistry if you want to control which registry to use, however      * if you need to bind beans to the registry then this is possible already with the bind method on registry,      * and there is no need to override this method.      */
annotation|@
name|Deprecated
DECL|method|createRegistry ()
specifier|protected
name|JndiRegistry
name|createRegistry
parameter_list|()
throws|throws
name|Exception
block|{
return|return
operator|new
name|FakeJndiRegistry
argument_list|(
name|createJndiContext
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * @deprecated use createCamelRegistry if you want to control which registry to use, however      * if you need to bind beans to the registry then this is possible already with the bind method on registry,      * and there is no need to use JndiRegistry and override this method.      */
annotation|@
name|Deprecated
DECL|method|createJndiContext ()
specifier|protected
name|Context
name|createJndiContext
parameter_list|()
throws|throws
name|Exception
block|{
name|Properties
name|properties
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
comment|// jndi.properties is optional
name|InputStream
name|in
init|=
name|getClass
argument_list|()
operator|.
name|getClassLoader
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
literal|"jndi.properties"
argument_list|)
decl_stmt|;
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Using jndi.properties from classpath root"
argument_list|)
expr_stmt|;
name|properties
operator|.
name|load
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|properties
operator|.
name|put
argument_list|(
literal|"java.naming.factory.initial"
argument_list|,
literal|"org.apache.camel.support.jndi.CamelInitialContextFactory"
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|InitialContext
argument_list|(
operator|new
name|Hashtable
argument_list|<>
argument_list|(
name|properties
argument_list|)
argument_list|)
return|;
block|}
DECL|class|FakeJndiRegistry
specifier|private
class|class
name|FakeJndiRegistry
extends|extends
name|JndiRegistry
block|{
DECL|field|inUse
specifier|private
name|boolean
name|inUse
decl_stmt|;
DECL|method|FakeJndiRegistry (Context context)
specifier|public
name|FakeJndiRegistry
parameter_list|(
name|Context
name|context
parameter_list|)
block|{
name|super
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|bind (String name, Object object)
specifier|public
name|void
name|bind
parameter_list|(
name|String
name|name
parameter_list|,
name|Object
name|object
parameter_list|)
block|{
name|super
operator|.
name|bind
argument_list|(
name|name
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|inUse
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|isInUse ()
specifier|public
name|boolean
name|isInUse
parameter_list|()
block|{
comment|// only if the end user bind beans then its in use
return|return
name|inUse
return|;
block|}
block|}
comment|/**      * Factory method which derived classes can use to create a {@link RouteBuilder}      * to define the routes for testing      */
DECL|method|createRouteBuilder ()
specifier|protected
name|RoutesBuilder
name|createRouteBuilder
parameter_list|()
throws|throws
name|Exception
block|{
return|return
operator|new
name|RouteBuilder
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|configure
parameter_list|()
block|{
comment|// no routes added by default
block|}
block|}
return|;
block|}
comment|/**      * Factory method which derived classes can use to create an array of      * {@link org.apache.camel.builder.RouteBuilder}s to define the routes for testing      *      * @see #createRouteBuilder()      */
DECL|method|createRouteBuilders ()
specifier|protected
name|RoutesBuilder
index|[]
name|createRouteBuilders
parameter_list|()
throws|throws
name|Exception
block|{
return|return
operator|new
name|RoutesBuilder
index|[]
block|{
name|createRouteBuilder
argument_list|()
block|}
return|;
block|}
comment|/**      * Resolves a mandatory endpoint for the given URI or an exception is thrown      *      * @param uri the Camel<a href="">URI</a> to use to create or resolve an endpoint      * @return the endpoint      */
DECL|method|resolveMandatoryEndpoint (String uri)
specifier|protected
name|Endpoint
name|resolveMandatoryEndpoint
parameter_list|(
name|String
name|uri
parameter_list|)
block|{
return|return
name|resolveMandatoryEndpoint
argument_list|(
name|context
argument_list|,
name|uri
argument_list|)
return|;
block|}
comment|/**      * Resolves a mandatory endpoint for the given URI and expected type or an exception is thrown      *      * @param uri the Camel<a href="">URI</a> to use to create or resolve an endpoint      * @return the endpoint      */
DECL|method|resolveMandatoryEndpoint (String uri, Class<T> endpointType)
specifier|protected
parameter_list|<
name|T
extends|extends
name|Endpoint
parameter_list|>
name|T
name|resolveMandatoryEndpoint
parameter_list|(
name|String
name|uri
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|endpointType
parameter_list|)
block|{
return|return
name|resolveMandatoryEndpoint
argument_list|(
name|context
argument_list|,
name|uri
argument_list|,
name|endpointType
argument_list|)
return|;
block|}
comment|/**      * Resolves the mandatory Mock endpoint using a URI of the form<code>mock:someName</code>      *      * @param uri the URI which typically starts with "mock:" and has some name      * @return the mandatory mock endpoint or an exception is thrown if it could not be resolved      */
DECL|method|getMockEndpoint (String uri)
specifier|protected
name|MockEndpoint
name|getMockEndpoint
parameter_list|(
name|String
name|uri
parameter_list|)
block|{
return|return
name|getMockEndpoint
argument_list|(
name|uri
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Resolves the {@link MockEndpoint} using a URI of the form<code>mock:someName</code>, optionally      * creating it if it does not exist. This implementation will lookup existing mock endpoints and match      * on the mock queue name, eg mock:foo and mock:foo?retainFirst=5 would match as the queue name is foo.      *      * @param uri    the URI which typically starts with "mock:" and has some name      * @param create whether or not to allow the endpoint to be created if it doesn't exist      * @return the mock endpoint or an {@link NoSuchEndpointException} is thrown if it could not be resolved      * @throws NoSuchEndpointException is the mock endpoint does not exists      */
DECL|method|getMockEndpoint (String uri, boolean create)
specifier|protected
name|MockEndpoint
name|getMockEndpoint
parameter_list|(
name|String
name|uri
parameter_list|,
name|boolean
name|create
parameter_list|)
throws|throws
name|NoSuchEndpointException
block|{
comment|// look for existing mock endpoints that has the same queue name, and to do that we need to
comment|// normalize uri and strip out query parameters and whatnot
name|String
name|n
decl_stmt|;
try|try
block|{
name|n
operator|=
name|URISupport
operator|.
name|normalizeUri
argument_list|(
name|uri
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|RuntimeCamelException
operator|.
name|wrapRuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// strip query
name|int
name|idx
init|=
name|n
operator|.
name|indexOf
argument_list|(
literal|'?'
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|!=
operator|-
literal|1
condition|)
block|{
name|n
operator|=
name|n
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
specifier|final
name|String
name|target
init|=
name|n
decl_stmt|;
comment|// lookup endpoints in registry and try to find it
name|MockEndpoint
name|found
init|=
operator|(
name|MockEndpoint
operator|)
name|context
operator|.
name|getEndpointRegistry
argument_list|()
operator|.
name|values
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|e
lambda|->
name|e
operator|instanceof
name|MockEndpoint
argument_list|)
operator|.
name|filter
argument_list|(
name|e
lambda|->
block|{
name|String
name|t
operator|=
name|e
operator|.
name|getEndpointUri
argument_list|()
argument_list|;
comment|// strip query
name|int
name|idx2
operator|=
name|t
operator|.
name|indexOf
argument_list|(
literal|'?'
argument_list|)
argument_list|;                     if
operator|(
name|idx2
operator|!=
operator|-
literal|1
operator|)
block|{
name|t
operator|=
name|t
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|idx2
argument_list|)
block|;                     }
return|return
name|t
operator|.
name|startsWith
argument_list|(
name|target
argument_list|)
return|;
block|}
block|)
operator|.
name|findFirst
argument_list|()
operator|.
name|orElse
argument_list|(
literal|null
argument_list|)
expr_stmt|;
end_class

begin_if
if|if
condition|(
name|found
operator|!=
literal|null
condition|)
block|{
return|return
name|found
return|;
block|}
end_if

begin_if
if|if
condition|(
name|create
condition|)
block|{
return|return
name|resolveMandatoryEndpoint
argument_list|(
name|uri
argument_list|,
name|MockEndpoint
operator|.
name|class
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|NoSuchEndpointException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"MockEndpoint %s does not exist."
argument_list|,
name|uri
argument_list|)
argument_list|)
throw|;
block|}
end_if

begin_comment
unit|}
comment|/**      * Sends a message to the given endpoint URI with the body value      *      * @param endpointUri the URI of the endpoint to send to      * @param body        the body for the message      */
end_comment

begin_function
DECL|method|sendBody (String endpointUri, final Object body)
unit|protected
name|void
name|sendBody
parameter_list|(
name|String
name|endpointUri
parameter_list|,
specifier|final
name|Object
name|body
parameter_list|)
block|{
name|template
operator|.
name|send
argument_list|(
name|endpointUri
argument_list|,
operator|new
name|Processor
argument_list|()
block|{
specifier|public
name|void
name|process
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|Message
name|in
init|=
name|exchange
operator|.
name|getIn
argument_list|()
decl_stmt|;
name|in
operator|.
name|setBody
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Sends a message to the given endpoint URI with the body value and specified headers      *      * @param endpointUri the URI of the endpoint to send to      * @param body        the body for the message      * @param headers     any headers to set on the message      */
end_comment

begin_function
DECL|method|sendBody (String endpointUri, final Object body, final Map<String, Object> headers)
specifier|protected
name|void
name|sendBody
parameter_list|(
name|String
name|endpointUri
parameter_list|,
specifier|final
name|Object
name|body
parameter_list|,
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|headers
parameter_list|)
block|{
name|template
operator|.
name|send
argument_list|(
name|endpointUri
argument_list|,
operator|new
name|Processor
argument_list|()
block|{
specifier|public
name|void
name|process
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|Message
name|in
init|=
name|exchange
operator|.
name|getIn
argument_list|()
decl_stmt|;
name|in
operator|.
name|setBody
argument_list|(
name|body
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|headers
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|in
operator|.
name|setHeader
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Sends messages to the given endpoint for each of the specified bodies      *      * @param endpointUri the endpoint URI to send to      * @param bodies      the bodies to send, one per message      */
end_comment

begin_function
DECL|method|sendBodies (String endpointUri, Object... bodies)
specifier|protected
name|void
name|sendBodies
parameter_list|(
name|String
name|endpointUri
parameter_list|,
name|Object
modifier|...
name|bodies
parameter_list|)
block|{
for|for
control|(
name|Object
name|body
range|:
name|bodies
control|)
block|{
name|sendBody
argument_list|(
name|endpointUri
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * Creates an exchange with the given body      */
end_comment

begin_function
DECL|method|createExchangeWithBody (Object body)
specifier|protected
name|Exchange
name|createExchangeWithBody
parameter_list|(
name|Object
name|body
parameter_list|)
block|{
return|return
name|createExchangeWithBody
argument_list|(
name|context
argument_list|,
name|body
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**      * Asserts that the given language name and expression evaluates to the      * given value on a specific exchange      */
end_comment

begin_function
DECL|method|assertExpression (Exchange exchange, String languageName, String expressionText, Object expectedValue)
specifier|protected
name|void
name|assertExpression
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|languageName
parameter_list|,
name|String
name|expressionText
parameter_list|,
name|Object
name|expectedValue
parameter_list|)
block|{
name|Language
name|language
init|=
name|assertResolveLanguage
argument_list|(
name|languageName
argument_list|)
decl_stmt|;
name|Expression
name|expression
init|=
name|language
operator|.
name|createExpression
argument_list|(
name|expressionText
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"No Expression could be created for text: "
operator|+
name|expressionText
operator|+
literal|" language: "
operator|+
name|language
argument_list|,
name|expression
argument_list|)
expr_stmt|;
name|assertExpression
argument_list|(
name|expression
argument_list|,
name|exchange
argument_list|,
name|expectedValue
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Asserts that the given language name and predicate expression evaluates      * to the expected value on the message exchange      */
end_comment

begin_function
DECL|method|assertPredicate (String languageName, String expressionText, Exchange exchange, boolean expected)
specifier|protected
name|void
name|assertPredicate
parameter_list|(
name|String
name|languageName
parameter_list|,
name|String
name|expressionText
parameter_list|,
name|Exchange
name|exchange
parameter_list|,
name|boolean
name|expected
parameter_list|)
block|{
name|Language
name|language
init|=
name|assertResolveLanguage
argument_list|(
name|languageName
argument_list|)
decl_stmt|;
name|Predicate
name|predicate
init|=
name|language
operator|.
name|createPredicate
argument_list|(
name|expressionText
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"No Predicate could be created for text: "
operator|+
name|expressionText
operator|+
literal|" language: "
operator|+
name|language
argument_list|,
name|predicate
argument_list|)
expr_stmt|;
name|assertPredicate
argument_list|(
name|predicate
argument_list|,
name|exchange
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Asserts that the language name can be resolved      */
end_comment

begin_function
DECL|method|assertResolveLanguage (String languageName)
specifier|protected
name|Language
name|assertResolveLanguage
parameter_list|(
name|String
name|languageName
parameter_list|)
block|{
name|Language
name|language
init|=
name|context
operator|.
name|resolveLanguage
argument_list|(
name|languageName
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"No language found for name: "
operator|+
name|languageName
argument_list|,
name|language
argument_list|)
expr_stmt|;
return|return
name|language
return|;
block|}
end_function

begin_comment
comment|/**      * Asserts that all the expectations of the Mock endpoints are valid      */
end_comment

begin_function
DECL|method|assertMockEndpointsSatisfied ()
specifier|protected
name|void
name|assertMockEndpointsSatisfied
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|MockEndpoint
operator|.
name|assertIsSatisfied
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Asserts that all the expectations of the Mock endpoints are valid      */
end_comment

begin_function
DECL|method|assertMockEndpointsSatisfied (long timeout, TimeUnit unit)
specifier|protected
name|void
name|assertMockEndpointsSatisfied
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|MockEndpoint
operator|.
name|assertIsSatisfied
argument_list|(
name|context
argument_list|,
name|timeout
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Reset all Mock endpoints.      */
end_comment

begin_function
DECL|method|resetMocks ()
specifier|protected
name|void
name|resetMocks
parameter_list|()
block|{
name|MockEndpoint
operator|.
name|resetMocks
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|method|assertValidContext (CamelContext context)
specifier|protected
name|void
name|assertValidContext
parameter_list|(
name|CamelContext
name|context
parameter_list|)
block|{
name|assertNotNull
argument_list|(
literal|"No context found!"
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|method|getMandatoryEndpoint (String uri, Class<T> type)
specifier|protected
parameter_list|<
name|T
extends|extends
name|Endpoint
parameter_list|>
name|T
name|getMandatoryEndpoint
parameter_list|(
name|String
name|uri
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
name|T
name|endpoint
init|=
name|context
operator|.
name|getEndpoint
argument_list|(
name|uri
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"No endpoint found for uri: "
operator|+
name|uri
argument_list|,
name|endpoint
argument_list|)
expr_stmt|;
return|return
name|endpoint
return|;
block|}
end_function

begin_function
DECL|method|getMandatoryEndpoint (String uri)
specifier|protected
name|Endpoint
name|getMandatoryEndpoint
parameter_list|(
name|String
name|uri
parameter_list|)
block|{
name|Endpoint
name|endpoint
init|=
name|context
operator|.
name|getEndpoint
argument_list|(
name|uri
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"No endpoint found for uri: "
operator|+
name|uri
argument_list|,
name|endpoint
argument_list|)
expr_stmt|;
return|return
name|endpoint
return|;
block|}
end_function

begin_comment
comment|/**      * Disables the JMX agent. Must be called before the {@link #setUp()} method.      */
end_comment

begin_function
DECL|method|disableJMX ()
specifier|protected
name|void
name|disableJMX
parameter_list|()
block|{
name|System
operator|.
name|setProperty
argument_list|(
name|JmxSystemPropertyKeys
operator|.
name|DISABLED
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Enables the JMX agent. Must be called before the {@link #setUp()} method.      */
end_comment

begin_function
DECL|method|enableJMX ()
specifier|protected
name|void
name|enableJMX
parameter_list|()
block|{
name|System
operator|.
name|setProperty
argument_list|(
name|JmxSystemPropertyKeys
operator|.
name|DISABLED
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Single step debugs and Camel invokes this method before entering the given processor      */
end_comment

begin_function
DECL|method|debugBefore (Exchange exchange, Processor processor, ProcessorDefinition<?> definition, String id, String label)
specifier|protected
name|void
name|debugBefore
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Processor
name|processor
parameter_list|,
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|definition
parameter_list|,
name|String
name|id
parameter_list|,
name|String
name|label
parameter_list|)
block|{     }
end_function

begin_comment
comment|/**      * Single step debugs and Camel invokes this method after processing the given processor      */
end_comment

begin_function
DECL|method|debugAfter (Exchange exchange, Processor processor, ProcessorDefinition<?> definition, String id, String label, long timeTaken)
specifier|protected
name|void
name|debugAfter
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Processor
name|processor
parameter_list|,
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|definition
parameter_list|,
name|String
name|id
parameter_list|,
name|String
name|label
parameter_list|,
name|long
name|timeTaken
parameter_list|)
block|{     }
end_function

begin_comment
comment|/**      * To easily debug by overriding the<tt>debugBefore</tt> and<tt>debugAfter</tt> methods.      */
end_comment

begin_class
DECL|class|DebugBreakpoint
specifier|private
class|class
name|DebugBreakpoint
extends|extends
name|BreakpointSupport
block|{
annotation|@
name|Override
DECL|method|beforeProcess (Exchange exchange, Processor processor, NamedNode definition)
specifier|public
name|void
name|beforeProcess
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Processor
name|processor
parameter_list|,
name|NamedNode
name|definition
parameter_list|)
block|{
name|CamelTestSupport
operator|.
name|this
operator|.
name|debugBefore
argument_list|(
name|exchange
argument_list|,
name|processor
argument_list|,
operator|(
name|ProcessorDefinition
operator|)
name|definition
argument_list|,
name|definition
operator|.
name|getId
argument_list|()
argument_list|,
name|definition
operator|.
name|getLabel
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|afterProcess (Exchange exchange, Processor processor, NamedNode definition, long timeTaken)
specifier|public
name|void
name|afterProcess
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Processor
name|processor
parameter_list|,
name|NamedNode
name|definition
parameter_list|,
name|long
name|timeTaken
parameter_list|)
block|{
name|CamelTestSupport
operator|.
name|this
operator|.
name|debugAfter
argument_list|(
name|exchange
argument_list|,
name|processor
argument_list|,
operator|(
name|ProcessorDefinition
operator|)
name|definition
argument_list|,
name|definition
operator|.
name|getId
argument_list|()
argument_list|,
name|definition
operator|.
name|getLabel
argument_list|()
argument_list|,
name|timeTaken
argument_list|)
expr_stmt|;
block|}
block|}
end_class

unit|}
end_unit

