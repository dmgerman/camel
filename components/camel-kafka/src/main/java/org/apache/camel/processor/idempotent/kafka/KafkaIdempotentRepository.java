begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.processor.idempotent.kafka
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
operator|.
name|idempotent
operator|.
name|kafka
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContextAware
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|api
operator|.
name|management
operator|.
name|ManagedOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|api
operator|.
name|management
operator|.
name|ManagedResource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|IdempotentRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|ServiceSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|IOHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|LRUCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ObjectHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|StringHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kafka
operator|.
name|clients
operator|.
name|consumer
operator|.
name|Consumer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kafka
operator|.
name|clients
operator|.
name|consumer
operator|.
name|ConsumerConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kafka
operator|.
name|clients
operator|.
name|consumer
operator|.
name|ConsumerRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kafka
operator|.
name|clients
operator|.
name|consumer
operator|.
name|ConsumerRecords
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kafka
operator|.
name|clients
operator|.
name|consumer
operator|.
name|KafkaConsumer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kafka
operator|.
name|clients
operator|.
name|producer
operator|.
name|KafkaProducer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kafka
operator|.
name|clients
operator|.
name|producer
operator|.
name|Producer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kafka
operator|.
name|clients
operator|.
name|producer
operator|.
name|ProducerConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kafka
operator|.
name|clients
operator|.
name|producer
operator|.
name|ProducerRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kafka
operator|.
name|common
operator|.
name|serialization
operator|.
name|StringDeserializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kafka
operator|.
name|common
operator|.
name|serialization
operator|.
name|StringSerializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * A Kafka topic-based implementation of {@link org.apache.camel.spi.IdempotentRepository}.  *  * Uses a local cache of previously seen Message IDs. Mutations that come in via the ({@link #add(String)}), or  * {@link #remove(String)} method will update the local cache and broadcast the change in state on a Kafka topic to  * other instances. The cache is back-filled from the topic by a Kafka consumer.  *  * The topic used must be unique per logical repository (i.e. two routes de-duplicate using different repositories,  * and different topics).  *  * This class makes no assumptions about the number of partitions (it is designed to consume from all at the  * same time), or replication factor of the topic.  *  * Each repository instance that uses the topic (e.g. typically on different machines running in parallel) controls its own  * consumer group, so in a cluster of 10 Camel processes using the same topic each will control its own offset.  *  * On startup, the instance subscribes to the topic and rewinds the offset to the beginning, rebuilding the cache to the  * latest state. The cache will not be considered warmed up until one poll of {@link #pollDurationMs} in length  * returns 0 records. Startup will not be completed until either the cache has warmed up, or 30 seconds go by; if the  * latter happens the idempotent repository may be in an inconsistent state until its consumer catches up to the end  * of the topic.  *  * To use, this repository must be placed in the Camel registry, either manually or by registration as a bean in  * Spring/Blueprint, as it is CamelContext aware.  */
end_comment

begin_class
annotation|@
name|ManagedResource
argument_list|(
name|description
operator|=
literal|"Kafka IdempotentRepository"
argument_list|)
DECL|class|KafkaIdempotentRepository
specifier|public
class|class
name|KafkaIdempotentRepository
extends|extends
name|ServiceSupport
implements|implements
name|IdempotentRepository
argument_list|<
name|String
argument_list|>
implements|,
name|CamelContextAware
block|{
DECL|field|DEFAULT_MAXIMUM_CACHE_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_MAXIMUM_CACHE_SIZE
init|=
literal|1000
decl_stmt|;
DECL|field|DEFAULT_POLL_DURATION_MS
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_POLL_DURATION_MS
init|=
literal|100
decl_stmt|;
DECL|field|log
specifier|private
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|duplicateCount
specifier|private
specifier|final
name|AtomicLong
name|duplicateCount
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// configurable
DECL|field|topic
specifier|private
name|String
name|topic
decl_stmt|;
DECL|field|bootstrapServers
specifier|private
name|String
name|bootstrapServers
decl_stmt|;
DECL|field|producerConfig
specifier|private
name|Properties
name|producerConfig
decl_stmt|;
DECL|field|consumerConfig
specifier|private
name|Properties
name|consumerConfig
decl_stmt|;
DECL|field|maxCacheSize
specifier|private
name|int
name|maxCacheSize
init|=
name|DEFAULT_MAXIMUM_CACHE_SIZE
decl_stmt|;
DECL|field|pollDurationMs
specifier|private
name|int
name|pollDurationMs
init|=
name|DEFAULT_POLL_DURATION_MS
decl_stmt|;
comment|// internal properties
DECL|field|cache
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|cache
decl_stmt|;
DECL|field|consumer
specifier|private
name|Consumer
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|consumer
decl_stmt|;
DECL|field|producer
specifier|private
name|Producer
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|producer
decl_stmt|;
DECL|field|topicPoller
specifier|private
name|TopicPoller
name|topicPoller
decl_stmt|;
DECL|field|camelContext
specifier|private
name|CamelContext
name|camelContext
decl_stmt|;
DECL|field|executorService
specifier|private
name|ExecutorService
name|executorService
decl_stmt|;
DECL|field|cacheReadyLatch
specifier|private
name|CountDownLatch
name|cacheReadyLatch
decl_stmt|;
DECL|enum|CacheAction
enum|enum
name|CacheAction
block|{
DECL|enumConstant|add
name|add
block|,
DECL|enumConstant|remove
name|remove
block|,
DECL|enumConstant|clear
name|clear
block|}
comment|/**      * No-op constructor for XML/property-based object initialisation. From Java, prefer one of the other constructors.      */
DECL|method|KafkaIdempotentRepository ()
specifier|public
name|KafkaIdempotentRepository
parameter_list|()
block|{     }
DECL|method|KafkaIdempotentRepository (String topic, String bootstrapServers)
specifier|public
name|KafkaIdempotentRepository
parameter_list|(
name|String
name|topic
parameter_list|,
name|String
name|bootstrapServers
parameter_list|)
block|{
name|this
argument_list|(
name|topic
argument_list|,
name|bootstrapServers
argument_list|,
name|DEFAULT_MAXIMUM_CACHE_SIZE
argument_list|,
name|DEFAULT_POLL_DURATION_MS
argument_list|)
expr_stmt|;
block|}
DECL|method|KafkaIdempotentRepository (String topic, String bootstrapServers, int maxCacheSize, int pollDurationMs)
specifier|public
name|KafkaIdempotentRepository
parameter_list|(
name|String
name|topic
parameter_list|,
name|String
name|bootstrapServers
parameter_list|,
name|int
name|maxCacheSize
parameter_list|,
name|int
name|pollDurationMs
parameter_list|)
block|{
name|this
operator|.
name|topic
operator|=
name|topic
expr_stmt|;
name|this
operator|.
name|bootstrapServers
operator|=
name|bootstrapServers
expr_stmt|;
name|this
operator|.
name|maxCacheSize
operator|=
name|maxCacheSize
expr_stmt|;
name|this
operator|.
name|pollDurationMs
operator|=
name|pollDurationMs
expr_stmt|;
block|}
DECL|method|KafkaIdempotentRepository (String topic, Properties consumerConfig, Properties producerConfig)
specifier|public
name|KafkaIdempotentRepository
parameter_list|(
name|String
name|topic
parameter_list|,
name|Properties
name|consumerConfig
parameter_list|,
name|Properties
name|producerConfig
parameter_list|)
block|{
name|this
argument_list|(
name|topic
argument_list|,
name|consumerConfig
argument_list|,
name|producerConfig
argument_list|,
name|DEFAULT_MAXIMUM_CACHE_SIZE
argument_list|,
name|DEFAULT_POLL_DURATION_MS
argument_list|)
expr_stmt|;
block|}
DECL|method|KafkaIdempotentRepository (String topic, Properties consumerConfig, Properties producerConfig, int maxCacheSize, int pollDurationMs)
specifier|public
name|KafkaIdempotentRepository
parameter_list|(
name|String
name|topic
parameter_list|,
name|Properties
name|consumerConfig
parameter_list|,
name|Properties
name|producerConfig
parameter_list|,
name|int
name|maxCacheSize
parameter_list|,
name|int
name|pollDurationMs
parameter_list|)
block|{
name|this
operator|.
name|topic
operator|=
name|topic
expr_stmt|;
name|this
operator|.
name|consumerConfig
operator|=
name|consumerConfig
expr_stmt|;
name|this
operator|.
name|producerConfig
operator|=
name|producerConfig
expr_stmt|;
name|this
operator|.
name|maxCacheSize
operator|=
name|maxCacheSize
expr_stmt|;
name|this
operator|.
name|pollDurationMs
operator|=
name|pollDurationMs
expr_stmt|;
block|}
DECL|method|getTopic ()
specifier|public
name|String
name|getTopic
parameter_list|()
block|{
return|return
name|topic
return|;
block|}
comment|/**      * Sets the name of the Kafka topic used by this idempotent repository. Each functionally-separate repository      * should use a different topic.      * @param topic The topic name.      */
DECL|method|setTopic (String topic)
specifier|public
name|void
name|setTopic
parameter_list|(
name|String
name|topic
parameter_list|)
block|{
name|this
operator|.
name|topic
operator|=
name|topic
expr_stmt|;
block|}
DECL|method|getBootstrapServers ()
specifier|public
name|String
name|getBootstrapServers
parameter_list|()
block|{
return|return
name|bootstrapServers
return|;
block|}
comment|/**      * Sets the<pre>bootstrap.servers</pre> property on the internal Kafka producer and consumer. Use this as shorthand      * if not setting {@link #consumerConfig} and {@link #producerConfig}. If used, this component will apply sensible      * default configurations for the producer and consumer.      * @param bootstrapServers The<pre>bootstrap.servers</pre> value to use.      */
DECL|method|setBootstrapServers (String bootstrapServers)
specifier|public
name|void
name|setBootstrapServers
parameter_list|(
name|String
name|bootstrapServers
parameter_list|)
block|{
name|this
operator|.
name|bootstrapServers
operator|=
name|bootstrapServers
expr_stmt|;
block|}
DECL|method|getProducerConfig ()
specifier|public
name|Properties
name|getProducerConfig
parameter_list|()
block|{
return|return
name|producerConfig
return|;
block|}
comment|/**      * Sets the properties that will be used by the Kafka producer. Overrides {@link #bootstrapServers}, so must define      * the<pre>bootstrap.servers</pre> property itself.      *      * Prefer using {@link #bootstrapServers} for default configuration unless you specifically need non-standard      * configuration options such as SSL/SASL.      * @param producerConfig The producer configuration properties.      */
DECL|method|setProducerConfig (Properties producerConfig)
specifier|public
name|void
name|setProducerConfig
parameter_list|(
name|Properties
name|producerConfig
parameter_list|)
block|{
name|this
operator|.
name|producerConfig
operator|=
name|producerConfig
expr_stmt|;
block|}
DECL|method|getConsumerConfig ()
specifier|public
name|Properties
name|getConsumerConfig
parameter_list|()
block|{
return|return
name|consumerConfig
return|;
block|}
comment|/**      * Sets the properties that will be used by the Kafka consumer. Overrides {@link #bootstrapServers}, so must define      * the<pre>bootstrap.servers</pre> property itself.      *      * Prefer using {@link #bootstrapServers} for default configuration unless you specifically need non-standard      * configuration options such as SSL/SASL.      * @param consumerConfig The consumer configuration properties.      */
DECL|method|setConsumerConfig (Properties consumerConfig)
specifier|public
name|void
name|setConsumerConfig
parameter_list|(
name|Properties
name|consumerConfig
parameter_list|)
block|{
name|this
operator|.
name|consumerConfig
operator|=
name|consumerConfig
expr_stmt|;
block|}
DECL|method|getMaxCacheSize ()
specifier|public
name|int
name|getMaxCacheSize
parameter_list|()
block|{
return|return
name|maxCacheSize
return|;
block|}
comment|/**      * Sets the maximum size of the local key cache.      * @param maxCacheSize The maximum key cache size.      */
DECL|method|setMaxCacheSize (int maxCacheSize)
specifier|public
name|void
name|setMaxCacheSize
parameter_list|(
name|int
name|maxCacheSize
parameter_list|)
block|{
name|this
operator|.
name|maxCacheSize
operator|=
name|maxCacheSize
expr_stmt|;
block|}
DECL|method|getPollDurationMs ()
specifier|public
name|int
name|getPollDurationMs
parameter_list|()
block|{
return|return
name|pollDurationMs
return|;
block|}
comment|/**      * Sets the poll duration of the Kafka consumer. The local caches are updated immediately; this value will affect      * how far behind other peers in the cluster are, which are updating their caches from the topic, relative to the      * idempotent consumer instance issued the cache action message.      *      * The default value of this is {@link #DEFAULT_POLL_DURATION_MS}. If setting this value explicitly, be aware that      * there is a tradeoff between the remote cache liveness and the volume of network traffic between this repository's      * consumer and the Kafka brokers.      *      * The cache warmup process also depends on there being one poll that fetches nothing - this indicates that the      * stream has been consumed up to the current point. If the poll duration is excessively long for the rate at      * which messages are sent on the topic, there exists a possibility that the cache cannot be warmed up and will      * operate in an inconsistent state relative to its peers until it catches up.      * @param pollDurationMs The poll duration in milliseconds.      */
DECL|method|setPollDurationMs (int pollDurationMs)
specifier|public
name|void
name|setPollDurationMs
parameter_list|(
name|int
name|pollDurationMs
parameter_list|)
block|{
name|this
operator|.
name|pollDurationMs
operator|=
name|pollDurationMs
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setCamelContext (CamelContext camelContext)
specifier|public
name|void
name|setCamelContext
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|)
block|{
name|this
operator|.
name|camelContext
operator|=
name|camelContext
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getCamelContext ()
specifier|public
name|CamelContext
name|getCamelContext
parameter_list|()
block|{
return|return
name|this
operator|.
name|camelContext
return|;
block|}
annotation|@
name|Override
DECL|method|doStart ()
specifier|protected
name|void
name|doStart
parameter_list|()
throws|throws
name|Exception
block|{
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|camelContext
argument_list|,
literal|"camelContext"
argument_list|)
expr_stmt|;
name|StringHelper
operator|.
name|notEmpty
argument_list|(
name|topic
argument_list|,
literal|"topic"
argument_list|)
expr_stmt|;
name|this
operator|.
name|cache
operator|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|LRUCache
argument_list|<>
argument_list|(
name|maxCacheSize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|consumerConfig
operator|==
literal|null
condition|)
block|{
name|consumerConfig
operator|=
operator|new
name|Properties
argument_list|()
expr_stmt|;
name|StringHelper
operator|.
name|notEmpty
argument_list|(
name|bootstrapServers
argument_list|,
literal|"bootstrapServers"
argument_list|)
expr_stmt|;
name|consumerConfig
operator|.
name|put
argument_list|(
name|ConsumerConfig
operator|.
name|BOOTSTRAP_SERVERS_CONFIG
argument_list|,
name|bootstrapServers
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|producerConfig
operator|==
literal|null
condition|)
block|{
name|producerConfig
operator|=
operator|new
name|Properties
argument_list|()
expr_stmt|;
name|StringHelper
operator|.
name|notEmpty
argument_list|(
name|bootstrapServers
argument_list|,
literal|"bootstrapServers"
argument_list|)
expr_stmt|;
name|producerConfig
operator|.
name|put
argument_list|(
name|ProducerConfig
operator|.
name|BOOTSTRAP_SERVERS_CONFIG
argument_list|,
name|bootstrapServers
argument_list|)
expr_stmt|;
block|}
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|consumerConfig
argument_list|,
literal|"consumerConfig"
argument_list|)
expr_stmt|;
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|producerConfig
argument_list|,
literal|"producerConfig"
argument_list|)
expr_stmt|;
comment|// each consumer instance must have control over its own offset, so assign a groupID at random
name|String
name|groupId
init|=
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Creating consumer with {}[{}]"
argument_list|,
name|ConsumerConfig
operator|.
name|GROUP_ID_CONFIG
argument_list|,
name|groupId
argument_list|)
expr_stmt|;
name|consumerConfig
operator|.
name|put
argument_list|(
name|ConsumerConfig
operator|.
name|GROUP_ID_CONFIG
argument_list|,
name|groupId
argument_list|)
expr_stmt|;
name|consumerConfig
operator|.
name|put
argument_list|(
name|ConsumerConfig
operator|.
name|ENABLE_AUTO_COMMIT_CONFIG
argument_list|,
name|Boolean
operator|.
name|TRUE
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|consumerConfig
operator|.
name|put
argument_list|(
name|ConsumerConfig
operator|.
name|KEY_DESERIALIZER_CLASS_CONFIG
argument_list|,
name|StringDeserializer
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|consumerConfig
operator|.
name|put
argument_list|(
name|ConsumerConfig
operator|.
name|VALUE_DESERIALIZER_CLASS_CONFIG
argument_list|,
name|StringDeserializer
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|consumer
operator|=
operator|new
name|KafkaConsumer
argument_list|<>
argument_list|(
name|consumerConfig
argument_list|)
expr_stmt|;
name|producerConfig
operator|.
name|put
argument_list|(
name|ProducerConfig
operator|.
name|KEY_SERIALIZER_CLASS_CONFIG
argument_list|,
name|StringSerializer
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|producerConfig
operator|.
name|put
argument_list|(
name|ProducerConfig
operator|.
name|VALUE_SERIALIZER_CLASS_CONFIG
argument_list|,
name|StringSerializer
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// set up the producer to remove all batching on send, we want all sends to be fully synchronous
name|producerConfig
operator|.
name|putIfAbsent
argument_list|(
name|ProducerConfig
operator|.
name|ACKS_CONFIG
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|producerConfig
operator|.
name|putIfAbsent
argument_list|(
name|ProducerConfig
operator|.
name|BATCH_SIZE_CONFIG
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|producer
operator|=
operator|new
name|KafkaProducer
argument_list|<>
argument_list|(
name|producerConfig
argument_list|)
expr_stmt|;
name|cacheReadyLatch
operator|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|topicPoller
operator|=
operator|new
name|TopicPoller
argument_list|(
name|consumer
argument_list|,
name|cacheReadyLatch
argument_list|,
name|pollDurationMs
argument_list|)
expr_stmt|;
comment|// warm up the cache
name|executorService
operator|=
name|camelContext
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|newSingleThreadExecutor
argument_list|(
name|this
argument_list|,
literal|"KafkaIdempotentRepository"
argument_list|)
expr_stmt|;
name|executorService
operator|.
name|submit
argument_list|(
name|topicPoller
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Warming up cache from topic {}"
argument_list|,
name|topic
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|cacheReadyLatch
operator|.
name|await
argument_list|(
literal|30
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Cache OK"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Timeout waiting for cache warm-up from topic {}. Proceeding anyway. "
operator|+
literal|"Duplicate records may not be detected."
argument_list|,
name|topic
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Interrupted while warming up cache. This exception is ignored."
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|doStop ()
specifier|protected
name|void
name|doStop
parameter_list|()
block|{
comment|// stop the thread
name|topicPoller
operator|.
name|setRunning
argument_list|(
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|topicPoller
operator|.
name|getShutdownLatch
argument_list|()
operator|.
name|await
argument_list|(
literal|30
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Cache from topic {} shutdown successfully"
argument_list|,
name|topic
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Timeout waiting for cache to shutdown from topic {}. Proceeding anyway."
argument_list|,
name|topic
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Interrupted waiting on shutting down cache due {}. This exception is ignored."
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|camelContext
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|shutdown
argument_list|(
name|executorService
argument_list|)
expr_stmt|;
name|IOHelper
operator|.
name|close
argument_list|(
name|consumer
argument_list|,
literal|"consumer"
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|IOHelper
operator|.
name|close
argument_list|(
name|producer
argument_list|,
literal|"producer"
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|add (String key)
specifier|public
name|boolean
name|add
parameter_list|(
name|String
name|key
parameter_list|)
block|{
if|if
condition|(
name|cache
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|duplicateCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// update the local cache and broadcast the addition on the topic, which will be reflected
comment|// at a later point in any peers
name|cache
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|broadcastAction
argument_list|(
name|key
argument_list|,
name|CacheAction
operator|.
name|add
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
DECL|method|broadcastAction (String key, CacheAction action)
specifier|private
name|void
name|broadcastAction
parameter_list|(
name|String
name|key
parameter_list|,
name|CacheAction
name|action
parameter_list|)
block|{
try|try
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Broadcasting action:{} for key:{}"
argument_list|,
name|action
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|producer
operator|.
name|send
argument_list|(
operator|new
name|ProducerRecord
argument_list|<>
argument_list|(
name|topic
argument_list|,
name|key
argument_list|,
name|action
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
operator|.
name|get
argument_list|()
expr_stmt|;
comment|// sync send
block|}
catch|catch
parameter_list|(
name|ExecutionException
decl||
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|ManagedOperation
argument_list|(
name|description
operator|=
literal|"Does the store contain the given key"
argument_list|)
DECL|method|contains (String key)
specifier|public
name|boolean
name|contains
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Checking cache for key:{}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|boolean
name|containsKey
init|=
name|cache
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|containsKey
condition|)
block|{
name|duplicateCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
return|return
name|containsKey
return|;
block|}
annotation|@
name|Override
annotation|@
name|ManagedOperation
argument_list|(
name|description
operator|=
literal|"Remove the key from the store"
argument_list|)
DECL|method|remove (String key)
specifier|public
name|boolean
name|remove
parameter_list|(
name|String
name|key
parameter_list|)
block|{
comment|// update the local cache and broadcast the addition on the topic, which will be reflected
comment|// at a later point in any peers
name|cache
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|broadcastAction
argument_list|(
name|key
argument_list|,
name|CacheAction
operator|.
name|remove
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|confirm (String key)
specifier|public
name|boolean
name|confirm
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
literal|true
return|;
comment|// no-op
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|broadcastAction
argument_list|(
literal|null
argument_list|,
name|CacheAction
operator|.
name|clear
argument_list|)
expr_stmt|;
block|}
annotation|@
name|ManagedOperation
argument_list|(
name|description
operator|=
literal|"Number of times duplicate messages have been detected"
argument_list|)
DECL|method|getDuplicateCount ()
specifier|public
name|long
name|getDuplicateCount
parameter_list|()
block|{
return|return
name|duplicateCount
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|ManagedOperation
argument_list|(
name|description
operator|=
literal|"Number of times duplicate messages have been detected"
argument_list|)
DECL|method|isPollerRunning ()
specifier|public
name|boolean
name|isPollerRunning
parameter_list|()
block|{
return|return
name|topicPoller
operator|.
name|isRunning
argument_list|()
return|;
block|}
DECL|class|TopicPoller
specifier|private
class|class
name|TopicPoller
implements|implements
name|Runnable
block|{
DECL|field|log
specifier|private
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|consumer
specifier|private
specifier|final
name|Consumer
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|consumer
decl_stmt|;
DECL|field|cacheReadyLatch
specifier|private
specifier|final
name|CountDownLatch
name|cacheReadyLatch
decl_stmt|;
DECL|field|pollDurationMs
specifier|private
specifier|final
name|int
name|pollDurationMs
decl_stmt|;
DECL|field|shutdownLatch
specifier|private
specifier|final
name|CountDownLatch
name|shutdownLatch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|field|running
specifier|private
specifier|final
name|AtomicBoolean
name|running
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
decl_stmt|;
DECL|method|TopicPoller (Consumer<String, String> consumer, CountDownLatch cacheReadyLatch, int pollDurationMs)
name|TopicPoller
parameter_list|(
name|Consumer
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|consumer
parameter_list|,
name|CountDownLatch
name|cacheReadyLatch
parameter_list|,
name|int
name|pollDurationMs
parameter_list|)
block|{
name|this
operator|.
name|consumer
operator|=
name|consumer
expr_stmt|;
name|this
operator|.
name|cacheReadyLatch
operator|=
name|cacheReadyLatch
expr_stmt|;
name|this
operator|.
name|pollDurationMs
operator|=
name|pollDurationMs
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Subscribing consumer to {}"
argument_list|,
name|topic
argument_list|)
expr_stmt|;
name|consumer
operator|.
name|subscribe
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
name|topic
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Seeking to beginning"
argument_list|)
expr_stmt|;
name|consumer
operator|.
name|seekToBeginning
argument_list|(
name|consumer
operator|.
name|assignment
argument_list|()
argument_list|)
expr_stmt|;
name|POLL_LOOP
label|:
while|while
condition|(
name|running
operator|.
name|get
argument_list|()
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Polling"
argument_list|)
expr_stmt|;
name|ConsumerRecords
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|consumerRecords
init|=
name|consumer
operator|.
name|poll
argument_list|(
name|pollDurationMs
argument_list|)
decl_stmt|;
if|if
condition|(
name|consumerRecords
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// the first time this happens, we can assume that we have consumed all
comment|// messages up to this point
name|log
operator|.
name|trace
argument_list|(
literal|"0 messages fetched on poll"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cacheReadyLatch
operator|.
name|getCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Cache warmed up"
argument_list|)
expr_stmt|;
name|cacheReadyLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
for|for
control|(
name|ConsumerRecord
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|consumerRecord
range|:
name|consumerRecords
control|)
block|{
name|CacheAction
name|action
decl_stmt|;
try|try
block|{
name|action
operator|=
name|CacheAction
operator|.
name|valueOf
argument_list|(
name|consumerRecord
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iax
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unexpected action value:\"{}\" received on [topic:{}, partition:{}, offset:{}]. Shutting down."
argument_list|,
name|consumerRecord
operator|.
name|key
argument_list|()
argument_list|,
name|consumerRecord
operator|.
name|topic
argument_list|()
argument_list|,
name|consumerRecord
operator|.
name|partition
argument_list|()
argument_list|,
name|consumerRecord
operator|.
name|offset
argument_list|()
argument_list|)
expr_stmt|;
name|setRunning
argument_list|(
literal|false
argument_list|)
expr_stmt|;
continue|continue
name|POLL_LOOP
continue|;
block|}
name|String
name|messageId
init|=
name|consumerRecord
operator|.
name|key
argument_list|()
decl_stmt|;
if|if
condition|(
name|action
operator|==
name|CacheAction
operator|.
name|add
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Adding to cache messageId:{}"
argument_list|,
name|messageId
argument_list|)
expr_stmt|;
name|cache
operator|.
name|put
argument_list|(
name|messageId
argument_list|,
name|messageId
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|==
name|CacheAction
operator|.
name|remove
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Removing from cache messageId:{}"
argument_list|,
name|messageId
argument_list|)
expr_stmt|;
name|cache
operator|.
name|remove
argument_list|(
name|messageId
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|==
name|CacheAction
operator|.
name|clear
condition|)
block|{
name|cache
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// this should never happen
name|log
operator|.
name|warn
argument_list|(
literal|"No idea how to {} a record. Shutting down."
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|setRunning
argument_list|(
literal|false
argument_list|)
expr_stmt|;
continue|continue
name|POLL_LOOP
continue|;
block|}
block|}
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"TopicPoller finished - triggering shutdown latch"
argument_list|)
expr_stmt|;
name|shutdownLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
DECL|method|getShutdownLatch ()
name|CountDownLatch
name|getShutdownLatch
parameter_list|()
block|{
return|return
name|shutdownLatch
return|;
block|}
DECL|method|setRunning (boolean running)
name|void
name|setRunning
parameter_list|(
name|boolean
name|running
parameter_list|)
block|{
name|this
operator|.
name|running
operator|.
name|set
argument_list|(
name|running
argument_list|)
expr_stmt|;
block|}
DECL|method|isRunning ()
name|boolean
name|isRunning
parameter_list|()
block|{
return|return
name|running
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"TopicPoller["
operator|+
name|topic
operator|+
literal|"]"
return|;
block|}
block|}
block|}
end_class

end_unit

