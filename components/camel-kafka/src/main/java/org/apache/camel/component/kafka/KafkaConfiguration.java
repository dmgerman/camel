begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.component.kafka
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|kafka
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|RuntimeCamelException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|kafka
operator|.
name|serde
operator|.
name|DefaultKafkaHeaderDeserializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|kafka
operator|.
name|serde
operator|.
name|DefaultKafkaHeaderSerializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|kafka
operator|.
name|serde
operator|.
name|KafkaHeaderDeserializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|kafka
operator|.
name|serde
operator|.
name|KafkaHeaderSerializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|HeaderFilterStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|HeaderFilterStrategyAware
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|Metadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|StateRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|UriParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|UriParams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|UriPath
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|jsse
operator|.
name|CipherSuitesParameters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|jsse
operator|.
name|KeyManagersParameters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|jsse
operator|.
name|KeyStoreParameters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|jsse
operator|.
name|SSLContextParameters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|jsse
operator|.
name|SecureSocketProtocolsParameters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|jsse
operator|.
name|TrustManagersParameters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kafka
operator|.
name|clients
operator|.
name|CommonClientConfigs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kafka
operator|.
name|clients
operator|.
name|consumer
operator|.
name|ConsumerConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kafka
operator|.
name|clients
operator|.
name|producer
operator|.
name|ProducerConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kafka
operator|.
name|clients
operator|.
name|producer
operator|.
name|RecordMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kafka
operator|.
name|common
operator|.
name|config
operator|.
name|SaslConfigs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kafka
operator|.
name|common
operator|.
name|config
operator|.
name|SslConfigs
import|;
end_import

begin_class
annotation|@
name|UriParams
DECL|class|KafkaConfiguration
specifier|public
class|class
name|KafkaConfiguration
implements|implements
name|Cloneable
implements|,
name|HeaderFilterStrategyAware
block|{
comment|// Common configuration properties
annotation|@
name|UriPath
argument_list|(
name|label
operator|=
literal|"common"
argument_list|)
annotation|@
name|Metadata
argument_list|(
name|required
operator|=
literal|true
argument_list|)
DECL|field|topic
specifier|private
name|String
name|topic
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common"
argument_list|)
DECL|field|brokers
specifier|private
name|String
name|brokers
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common"
argument_list|)
DECL|field|clientId
specifier|private
name|String
name|clientId
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common"
argument_list|,
name|description
operator|=
literal|"To use a custom HeaderFilterStrategy to filter header to and from Camel message."
argument_list|)
DECL|field|headerFilterStrategy
specifier|private
name|HeaderFilterStrategy
name|headerFilterStrategy
init|=
operator|new
name|KafkaHeaderFilterStrategy
argument_list|()
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|)
DECL|field|topicIsPattern
specifier|private
name|boolean
name|topicIsPattern
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|)
DECL|field|groupId
specifier|private
name|String
name|groupId
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"10"
argument_list|)
DECL|field|consumerStreams
specifier|private
name|int
name|consumerStreams
init|=
literal|10
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"1"
argument_list|)
DECL|field|consumersCount
specifier|private
name|int
name|consumersCount
init|=
literal|1
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|description
operator|=
literal|"To use a custom KafkaHeaderDeserializer to deserialize kafka headers values"
argument_list|)
DECL|field|kafkaHeaderDeserializer
specifier|private
name|KafkaHeaderDeserializer
name|kafkaHeaderDeserializer
init|=
operator|new
name|DefaultKafkaHeaderDeserializer
argument_list|()
decl_stmt|;
comment|// interceptor.classes
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common,monitoring"
argument_list|)
DECL|field|interceptorClasses
specifier|private
name|String
name|interceptorClasses
decl_stmt|;
comment|// key.deserializer
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
name|KafkaConstants
operator|.
name|KAFKA_DEFAULT_DESERIALIZER
argument_list|)
DECL|field|keyDeserializer
specifier|private
name|String
name|keyDeserializer
init|=
name|KafkaConstants
operator|.
name|KAFKA_DEFAULT_DESERIALIZER
decl_stmt|;
comment|// value.deserializer
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
name|KafkaConstants
operator|.
name|KAFKA_DEFAULT_DESERIALIZER
argument_list|)
DECL|field|valueDeserializer
specifier|private
name|String
name|valueDeserializer
init|=
name|KafkaConstants
operator|.
name|KAFKA_DEFAULT_DESERIALIZER
decl_stmt|;
comment|// fetch.min.bytes
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"1"
argument_list|)
DECL|field|fetchMinBytes
specifier|private
name|Integer
name|fetchMinBytes
init|=
literal|1
decl_stmt|;
comment|// fetch.min.bytes
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"52428800"
argument_list|)
DECL|field|fetchMaxBytes
specifier|private
name|Integer
name|fetchMaxBytes
init|=
literal|50
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
comment|// heartbeat.interval.ms
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"3000"
argument_list|)
DECL|field|heartbeatIntervalMs
specifier|private
name|Integer
name|heartbeatIntervalMs
init|=
literal|3000
decl_stmt|;
comment|// max.partition.fetch.bytes
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"1048576"
argument_list|)
DECL|field|maxPartitionFetchBytes
specifier|private
name|Integer
name|maxPartitionFetchBytes
init|=
literal|1048576
decl_stmt|;
comment|// session.timeout.ms
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"10000"
argument_list|)
DECL|field|sessionTimeoutMs
specifier|private
name|Integer
name|sessionTimeoutMs
init|=
literal|10000
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"500"
argument_list|)
DECL|field|maxPollRecords
specifier|private
name|Integer
name|maxPollRecords
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"5000"
argument_list|)
DECL|field|pollTimeoutMs
specifier|private
name|Long
name|pollTimeoutMs
init|=
literal|5000L
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|)
DECL|field|maxPollIntervalMs
specifier|private
name|Long
name|maxPollIntervalMs
decl_stmt|;
comment|// auto.offset.reset1
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"latest"
argument_list|,
name|enums
operator|=
literal|"latest,earliest,none"
argument_list|)
DECL|field|autoOffsetReset
specifier|private
name|String
name|autoOffsetReset
init|=
literal|"latest"
decl_stmt|;
comment|// partition.assignment.strategy
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
name|KafkaConstants
operator|.
name|PARTITIONER_RANGE_ASSIGNOR
argument_list|)
DECL|field|partitionAssignor
specifier|private
name|String
name|partitionAssignor
init|=
name|KafkaConstants
operator|.
name|PARTITIONER_RANGE_ASSIGNOR
decl_stmt|;
comment|// request.timeout.ms
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"40000"
argument_list|)
DECL|field|consumerRequestTimeoutMs
specifier|private
name|Integer
name|consumerRequestTimeoutMs
init|=
literal|40000
decl_stmt|;
comment|// auto.commit.interval.ms
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"5000"
argument_list|)
DECL|field|autoCommitIntervalMs
specifier|private
name|Integer
name|autoCommitIntervalMs
init|=
literal|5000
decl_stmt|;
comment|// check.crcs
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"true"
argument_list|)
DECL|field|checkCrcs
specifier|private
name|Boolean
name|checkCrcs
init|=
literal|true
decl_stmt|;
comment|// fetch.max.wait.ms
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"500"
argument_list|)
DECL|field|fetchWaitMaxMs
specifier|private
name|Integer
name|fetchWaitMaxMs
init|=
literal|500
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|enums
operator|=
literal|"beginning,end"
argument_list|)
DECL|field|seekTo
specifier|private
name|String
name|seekTo
decl_stmt|;
comment|// Consumer configuration properties
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"true"
argument_list|)
DECL|field|autoCommitEnable
specifier|private
name|Boolean
name|autoCommitEnable
init|=
literal|true
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|)
DECL|field|allowManualCommit
specifier|private
name|boolean
name|allowManualCommit
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"sync"
argument_list|,
name|enums
operator|=
literal|"sync,async,none"
argument_list|)
DECL|field|autoCommitOnStop
specifier|private
name|String
name|autoCommitOnStop
init|=
literal|"sync"
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|)
DECL|field|breakOnFirstError
specifier|private
name|boolean
name|breakOnFirstError
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|)
DECL|field|offsetRepository
specifier|private
name|StateRepository
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|offsetRepository
decl_stmt|;
comment|// Producer Camel specific configuration properties
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|)
DECL|field|bridgeEndpoint
specifier|private
name|boolean
name|bridgeEndpoint
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"true"
argument_list|)
DECL|field|circularTopicDetection
specifier|private
name|boolean
name|circularTopicDetection
init|=
literal|true
decl_stmt|;
comment|// Producer configuration properties
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
name|KafkaConstants
operator|.
name|KAFKA_DEFAULT_PARTITIONER
argument_list|)
DECL|field|partitioner
specifier|private
name|String
name|partitioner
init|=
name|KafkaConstants
operator|.
name|KAFKA_DEFAULT_PARTITIONER
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"100"
argument_list|)
DECL|field|retryBackoffMs
specifier|private
name|Integer
name|retryBackoffMs
init|=
literal|100
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|)
DECL|field|workerPool
specifier|private
name|ExecutorService
name|workerPool
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"10"
argument_list|)
DECL|field|workerPoolCoreSize
specifier|private
name|Integer
name|workerPoolCoreSize
init|=
literal|10
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"20"
argument_list|)
DECL|field|workerPoolMaxSize
specifier|private
name|Integer
name|workerPoolMaxSize
init|=
literal|20
decl_stmt|;
comment|// Async producer config
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"10000"
argument_list|)
DECL|field|queueBufferingMaxMessages
specifier|private
name|Integer
name|queueBufferingMaxMessages
init|=
literal|10000
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
name|KafkaConstants
operator|.
name|KAFKA_DEFAULT_SERIALIZER
argument_list|)
DECL|field|serializerClass
specifier|private
name|String
name|serializerClass
init|=
name|KafkaConstants
operator|.
name|KAFKA_DEFAULT_SERIALIZER
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
name|KafkaConstants
operator|.
name|KAFKA_DEFAULT_SERIALIZER
argument_list|)
DECL|field|keySerializerClass
specifier|private
name|String
name|keySerializerClass
init|=
name|KafkaConstants
operator|.
name|KAFKA_DEFAULT_SERIALIZER
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|)
DECL|field|key
specifier|private
name|String
name|key
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|)
DECL|field|partitionKey
specifier|private
name|Integer
name|partitionKey
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|enums
operator|=
literal|"-1,0,1,all"
argument_list|,
name|defaultValue
operator|=
literal|"1"
argument_list|)
DECL|field|requestRequiredAcks
specifier|private
name|String
name|requestRequiredAcks
init|=
literal|"1"
decl_stmt|;
comment|// buffer.memory
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"33554432"
argument_list|)
DECL|field|bufferMemorySize
specifier|private
name|Integer
name|bufferMemorySize
init|=
literal|33554432
decl_stmt|;
comment|// compression.type
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"none"
argument_list|,
name|enums
operator|=
literal|"none,gzip,snappy,lz4"
argument_list|)
DECL|field|compressionCodec
specifier|private
name|String
name|compressionCodec
init|=
literal|"none"
decl_stmt|;
comment|// retries
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"0"
argument_list|)
DECL|field|retries
specifier|private
name|Integer
name|retries
init|=
literal|0
decl_stmt|;
comment|// batch.size
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"16384"
argument_list|)
DECL|field|producerBatchSize
specifier|private
name|Integer
name|producerBatchSize
init|=
literal|16384
decl_stmt|;
comment|// connections.max.idle.ms
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"540000"
argument_list|)
DECL|field|connectionMaxIdleMs
specifier|private
name|Integer
name|connectionMaxIdleMs
init|=
literal|540000
decl_stmt|;
comment|// linger.ms
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"0"
argument_list|)
DECL|field|lingerMs
specifier|private
name|Integer
name|lingerMs
init|=
literal|0
decl_stmt|;
comment|// linger.ms
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"60000"
argument_list|)
DECL|field|maxBlockMs
specifier|private
name|Integer
name|maxBlockMs
init|=
literal|60000
decl_stmt|;
comment|// max.request.size
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"1048576"
argument_list|)
DECL|field|maxRequestSize
specifier|private
name|Integer
name|maxRequestSize
init|=
literal|1048576
decl_stmt|;
comment|// receive.buffer.bytes
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"65536"
argument_list|)
DECL|field|receiveBufferBytes
specifier|private
name|Integer
name|receiveBufferBytes
init|=
literal|65536
decl_stmt|;
comment|// request.timeout.ms
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"305000"
argument_list|)
DECL|field|requestTimeoutMs
specifier|private
name|Integer
name|requestTimeoutMs
init|=
literal|305000
decl_stmt|;
comment|// send.buffer.bytes
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"131072"
argument_list|)
DECL|field|sendBufferBytes
specifier|private
name|Integer
name|sendBufferBytes
init|=
literal|131072
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"true"
argument_list|)
DECL|field|recordMetadata
specifier|private
name|boolean
name|recordMetadata
init|=
literal|true
decl_stmt|;
comment|// max.in.flight.requests.per.connection
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"5"
argument_list|)
DECL|field|maxInFlightRequest
specifier|private
name|Integer
name|maxInFlightRequest
init|=
literal|5
decl_stmt|;
comment|// metadata.max.age.ms
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"300000"
argument_list|)
DECL|field|metadataMaxAgeMs
specifier|private
name|Integer
name|metadataMaxAgeMs
init|=
literal|300000
decl_stmt|;
comment|// metric.reporters
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|)
DECL|field|metricReporters
specifier|private
name|String
name|metricReporters
decl_stmt|;
comment|// metrics.num.samples
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"2"
argument_list|)
DECL|field|noOfMetricsSample
specifier|private
name|Integer
name|noOfMetricsSample
init|=
literal|2
decl_stmt|;
comment|// metrics.sample.window.ms
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"30000"
argument_list|)
DECL|field|metricsSampleWindowMs
specifier|private
name|Integer
name|metricsSampleWindowMs
init|=
literal|30000
decl_stmt|;
comment|// reconnect.backoff.ms
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"50"
argument_list|)
DECL|field|reconnectBackoffMs
specifier|private
name|Integer
name|reconnectBackoffMs
init|=
literal|50
decl_stmt|;
comment|// enable.idempotence
comment|// reconnect.backoff.ms
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"false"
argument_list|)
DECL|field|enableIdempotence
specifier|private
name|boolean
name|enableIdempotence
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|description
operator|=
literal|"To use a custom KafkaHeaderSerializer to serialize kafka headers values"
argument_list|)
DECL|field|kafkaHeaderSerializer
specifier|private
name|KafkaHeaderSerializer
name|kafkaHeaderSerializer
init|=
operator|new
name|DefaultKafkaHeaderSerializer
argument_list|()
decl_stmt|;
comment|// reconnect.backoff.max.ms
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common"
argument_list|,
name|defaultValue
operator|=
literal|"1000"
argument_list|)
DECL|field|reconnectBackoffMaxMs
specifier|private
name|Integer
name|reconnectBackoffMaxMs
init|=
literal|1000
decl_stmt|;
comment|// SSL
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common,security"
argument_list|)
DECL|field|sslContextParameters
specifier|private
name|SSLContextParameters
name|sslContextParameters
decl_stmt|;
comment|// SSL
comment|// ssl.key.password
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer,security"
argument_list|,
name|secret
operator|=
literal|true
argument_list|)
DECL|field|sslKeyPassword
specifier|private
name|String
name|sslKeyPassword
decl_stmt|;
comment|// ssl.keystore.location
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer,security"
argument_list|)
DECL|field|sslKeystoreLocation
specifier|private
name|String
name|sslKeystoreLocation
decl_stmt|;
comment|// ssl.keystore.password
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer,security"
argument_list|,
name|secret
operator|=
literal|true
argument_list|)
DECL|field|sslKeystorePassword
specifier|private
name|String
name|sslKeystorePassword
decl_stmt|;
comment|// ssl.truststore.location
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer,security"
argument_list|)
DECL|field|sslTruststoreLocation
specifier|private
name|String
name|sslTruststoreLocation
decl_stmt|;
comment|// ssl.truststore.password
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer,security"
argument_list|,
name|secret
operator|=
literal|true
argument_list|)
DECL|field|sslTruststorePassword
specifier|private
name|String
name|sslTruststorePassword
decl_stmt|;
comment|// SSL
comment|// ssl.enabled.protocols
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common,security"
argument_list|,
name|defaultValue
operator|=
name|SslConfigs
operator|.
name|DEFAULT_SSL_ENABLED_PROTOCOLS
argument_list|)
DECL|field|sslEnabledProtocols
specifier|private
name|String
name|sslEnabledProtocols
init|=
name|SslConfigs
operator|.
name|DEFAULT_SSL_ENABLED_PROTOCOLS
decl_stmt|;
comment|// ssl.keystore.type
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common,security"
argument_list|,
name|defaultValue
operator|=
name|SslConfigs
operator|.
name|DEFAULT_SSL_KEYSTORE_TYPE
argument_list|)
DECL|field|sslKeystoreType
specifier|private
name|String
name|sslKeystoreType
init|=
name|SslConfigs
operator|.
name|DEFAULT_SSL_KEYSTORE_TYPE
decl_stmt|;
comment|// ssl.protocol
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common,security"
argument_list|,
name|defaultValue
operator|=
name|SslConfigs
operator|.
name|DEFAULT_SSL_PROTOCOL
argument_list|)
DECL|field|sslProtocol
specifier|private
name|String
name|sslProtocol
init|=
name|SslConfigs
operator|.
name|DEFAULT_SSL_PROTOCOL
decl_stmt|;
comment|// ssl.provider
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common,security"
argument_list|)
DECL|field|sslProvider
specifier|private
name|String
name|sslProvider
decl_stmt|;
comment|// ssl.truststore.type
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common,security"
argument_list|,
name|defaultValue
operator|=
name|SslConfigs
operator|.
name|DEFAULT_SSL_TRUSTSTORE_TYPE
argument_list|)
DECL|field|sslTruststoreType
specifier|private
name|String
name|sslTruststoreType
init|=
name|SslConfigs
operator|.
name|DEFAULT_SSL_TRUSTSTORE_TYPE
decl_stmt|;
comment|// SSL
comment|// ssl.cipher.suites
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common,security"
argument_list|)
DECL|field|sslCipherSuites
specifier|private
name|String
name|sslCipherSuites
decl_stmt|;
comment|// ssl.endpoint.identification.algorithm
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common,security"
argument_list|)
DECL|field|sslEndpointAlgorithm
specifier|private
name|String
name|sslEndpointAlgorithm
decl_stmt|;
comment|// ssl.keymanager.algorithm
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common,security"
argument_list|,
name|defaultValue
operator|=
literal|"SunX509"
argument_list|)
DECL|field|sslKeymanagerAlgorithm
specifier|private
name|String
name|sslKeymanagerAlgorithm
init|=
literal|"SunX509"
decl_stmt|;
comment|// ssl.trustmanager.algorithm
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common,security"
argument_list|,
name|defaultValue
operator|=
literal|"PKIX"
argument_list|)
DECL|field|sslTrustmanagerAlgorithm
specifier|private
name|String
name|sslTrustmanagerAlgorithm
init|=
literal|"PKIX"
decl_stmt|;
comment|// SASL& sucurity Protocol
comment|// sasl.kerberos.service.name
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common,security"
argument_list|)
DECL|field|saslKerberosServiceName
specifier|private
name|String
name|saslKerberosServiceName
decl_stmt|;
comment|// security.protocol
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common,security"
argument_list|,
name|defaultValue
operator|=
name|CommonClientConfigs
operator|.
name|DEFAULT_SECURITY_PROTOCOL
argument_list|)
DECL|field|securityProtocol
specifier|private
name|String
name|securityProtocol
init|=
name|CommonClientConfigs
operator|.
name|DEFAULT_SECURITY_PROTOCOL
decl_stmt|;
comment|// SASL
comment|// sasl.kerberos.kinit.cmd
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common,security"
argument_list|,
name|defaultValue
operator|=
name|SaslConfigs
operator|.
name|DEFAULT_SASL_MECHANISM
argument_list|)
DECL|field|saslMechanism
specifier|private
name|String
name|saslMechanism
init|=
name|SaslConfigs
operator|.
name|DEFAULT_SASL_MECHANISM
decl_stmt|;
comment|// sasl.kerberos.kinit.cmd
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common,security"
argument_list|,
name|defaultValue
operator|=
name|SaslConfigs
operator|.
name|DEFAULT_KERBEROS_KINIT_CMD
argument_list|)
DECL|field|kerberosInitCmd
specifier|private
name|String
name|kerberosInitCmd
init|=
name|SaslConfigs
operator|.
name|DEFAULT_KERBEROS_KINIT_CMD
decl_stmt|;
comment|// sasl.kerberos.min.time.before.relogin
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common,security"
argument_list|,
name|defaultValue
operator|=
literal|"60000"
argument_list|)
DECL|field|kerberosBeforeReloginMinTime
specifier|private
name|Integer
name|kerberosBeforeReloginMinTime
init|=
literal|60000
decl_stmt|;
comment|// sasl.kerberos.ticket.renew.jitter
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common,security"
argument_list|,
name|defaultValue
operator|=
literal|"0.05"
argument_list|)
DECL|field|kerberosRenewJitter
specifier|private
name|Double
name|kerberosRenewJitter
init|=
name|SaslConfigs
operator|.
name|DEFAULT_KERBEROS_TICKET_RENEW_JITTER
decl_stmt|;
comment|// sasl.kerberos.ticket.renew.window.factor
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common,security"
argument_list|,
name|defaultValue
operator|=
literal|"0.8"
argument_list|)
DECL|field|kerberosRenewWindowFactor
specifier|private
name|Double
name|kerberosRenewWindowFactor
init|=
name|SaslConfigs
operator|.
name|DEFAULT_KERBEROS_TICKET_RENEW_WINDOW_FACTOR
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common,security"
argument_list|,
name|defaultValue
operator|=
literal|"DEFAULT"
argument_list|)
comment|// sasl.kerberos.principal.to.local.rules
DECL|field|kerberosPrincipalToLocalRules
specifier|private
name|String
name|kerberosPrincipalToLocalRules
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"common,security"
argument_list|,
name|secret
operator|=
literal|true
argument_list|)
comment|// sasl.jaas.config
DECL|field|saslJaasConfig
specifier|private
name|String
name|saslJaasConfig
decl_stmt|;
comment|// Confluent only options
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"confluent"
argument_list|)
DECL|field|schemaRegistryURL
specifier|private
name|String
name|schemaRegistryURL
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"confluent,consumer"
argument_list|)
DECL|field|specificAvroReader
specifier|private
name|boolean
name|specificAvroReader
decl_stmt|;
DECL|method|KafkaConfiguration ()
specifier|public
name|KafkaConfiguration
parameter_list|()
block|{     }
comment|/**      * Returns a copy of this configuration      */
DECL|method|copy ()
specifier|public
name|KafkaConfiguration
name|copy
parameter_list|()
block|{
try|try
block|{
name|KafkaConfiguration
name|copy
init|=
operator|(
name|KafkaConfiguration
operator|)
name|clone
argument_list|()
decl_stmt|;
return|return
name|copy
return|;
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeCamelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|createProducerProperties ()
specifier|public
name|Properties
name|createProducerProperties
parameter_list|()
block|{
name|Properties
name|props
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|KEY_SERIALIZER_CLASS_CONFIG
argument_list|,
name|getKeySerializerClass
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|VALUE_SERIALIZER_CLASS_CONFIG
argument_list|,
name|getSerializerClass
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|ACKS_CONFIG
argument_list|,
name|getRequestRequiredAcks
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|BUFFER_MEMORY_CONFIG
argument_list|,
name|getBufferMemorySize
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|COMPRESSION_TYPE_CONFIG
argument_list|,
name|getCompressionCodec
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|RETRIES_CONFIG
argument_list|,
name|getRetries
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|INTERCEPTOR_CLASSES_CONFIG
argument_list|,
name|getInterceptorClasses
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|SEND_BUFFER_CONFIG
argument_list|,
name|getRetries
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|BATCH_SIZE_CONFIG
argument_list|,
name|getProducerBatchSize
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|CLIENT_ID_CONFIG
argument_list|,
name|getClientId
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|CONNECTIONS_MAX_IDLE_MS_CONFIG
argument_list|,
name|getConnectionMaxIdleMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|LINGER_MS_CONFIG
argument_list|,
name|getLingerMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|MAX_BLOCK_MS_CONFIG
argument_list|,
name|getMaxBlockMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|MAX_REQUEST_SIZE_CONFIG
argument_list|,
name|getMaxRequestSize
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|PARTITIONER_CLASS_CONFIG
argument_list|,
name|getPartitioner
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|RECEIVE_BUFFER_CONFIG
argument_list|,
name|getReceiveBufferBytes
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|REQUEST_TIMEOUT_MS_CONFIG
argument_list|,
name|getRequestTimeoutMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|SEND_BUFFER_CONFIG
argument_list|,
name|getSendBufferBytes
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION
argument_list|,
name|getMaxInFlightRequest
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|METADATA_MAX_AGE_CONFIG
argument_list|,
name|getMetadataMaxAgeMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|METRIC_REPORTER_CLASSES_CONFIG
argument_list|,
name|getMetricReporters
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|METRICS_NUM_SAMPLES_CONFIG
argument_list|,
name|getNoOfMetricsSample
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|METRICS_SAMPLE_WINDOW_MS_CONFIG
argument_list|,
name|getMetricsSampleWindowMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|RECONNECT_BACKOFF_MS_CONFIG
argument_list|,
name|getReconnectBackoffMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|RETRY_BACKOFF_MS_CONFIG
argument_list|,
name|getRetryBackoffMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|ENABLE_IDEMPOTENCE_CONFIG
argument_list|,
name|isEnableIdempotence
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|RECONNECT_BACKOFF_MAX_MS_CONFIG
argument_list|,
name|getReconnectBackoffMaxMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"schema.registry.url"
argument_list|,
name|getSchemaRegistryURL
argument_list|()
argument_list|)
expr_stmt|;
comment|// SSL
name|applySslConfiguration
argument_list|(
name|props
argument_list|,
name|getSslContextParameters
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|CommonClientConfigs
operator|.
name|SECURITY_PROTOCOL_CONFIG
argument_list|,
name|getSecurityProtocol
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_KEY_PASSWORD_CONFIG
argument_list|,
name|getSslKeyPassword
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_KEYSTORE_LOCATION_CONFIG
argument_list|,
name|getSslKeystoreLocation
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_KEYSTORE_PASSWORD_CONFIG
argument_list|,
name|getSslKeystorePassword
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_TRUSTSTORE_LOCATION_CONFIG
argument_list|,
name|getSslTruststoreLocation
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_TRUSTSTORE_PASSWORD_CONFIG
argument_list|,
name|getSslTruststorePassword
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_ENABLED_PROTOCOLS_CONFIG
argument_list|,
name|getSslEnabledProtocols
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_KEYSTORE_TYPE_CONFIG
argument_list|,
name|getSslKeystoreType
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_PROTOCOL_CONFIG
argument_list|,
name|getSslProtocol
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_PROVIDER_CONFIG
argument_list|,
name|getSslProvider
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_TRUSTSTORE_TYPE_CONFIG
argument_list|,
name|getSslTruststoreType
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_CIPHER_SUITES_CONFIG
argument_list|,
name|getSslCipherSuites
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG
argument_list|,
name|getSslEndpointAlgorithm
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_KEYMANAGER_ALGORITHM_CONFIG
argument_list|,
name|getSslKeymanagerAlgorithm
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_TRUSTMANAGER_ALGORITHM_CONFIG
argument_list|,
name|getSslTrustmanagerAlgorithm
argument_list|()
argument_list|)
expr_stmt|;
comment|// SASL
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SaslConfigs
operator|.
name|SASL_KERBEROS_SERVICE_NAME
argument_list|,
name|getSaslKerberosServiceName
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SaslConfigs
operator|.
name|SASL_KERBEROS_KINIT_CMD
argument_list|,
name|getKerberosInitCmd
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SaslConfigs
operator|.
name|SASL_KERBEROS_MIN_TIME_BEFORE_RELOGIN
argument_list|,
name|getKerberosBeforeReloginMinTime
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SaslConfigs
operator|.
name|SASL_KERBEROS_TICKET_RENEW_JITTER
argument_list|,
name|getKerberosRenewJitter
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SaslConfigs
operator|.
name|SASL_KERBEROS_TICKET_RENEW_WINDOW_FACTOR
argument_list|,
name|getKerberosRenewWindowFactor
argument_list|()
argument_list|)
expr_stmt|;
name|addListPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SaslConfigs
operator|.
name|SASL_KERBEROS_PRINCIPAL_TO_LOCAL_RULES
argument_list|,
name|getKerberosPrincipalToLocalRules
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SaslConfigs
operator|.
name|SASL_MECHANISM
argument_list|,
name|getSaslMechanism
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SaslConfigs
operator|.
name|SASL_JAAS_CONFIG
argument_list|,
name|getSaslJaasConfig
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|props
return|;
block|}
DECL|method|createConsumerProperties ()
specifier|public
name|Properties
name|createConsumerProperties
parameter_list|()
block|{
name|Properties
name|props
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|KEY_DESERIALIZER_CLASS_CONFIG
argument_list|,
name|getKeyDeserializer
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|VALUE_DESERIALIZER_CLASS_CONFIG
argument_list|,
name|getValueDeserializer
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|FETCH_MIN_BYTES_CONFIG
argument_list|,
name|getFetchMinBytes
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|FETCH_MAX_BYTES_CONFIG
argument_list|,
name|getFetchMaxBytes
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|HEARTBEAT_INTERVAL_MS_CONFIG
argument_list|,
name|getHeartbeatIntervalMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|MAX_PARTITION_FETCH_BYTES_CONFIG
argument_list|,
name|getMaxPartitionFetchBytes
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|SESSION_TIMEOUT_MS_CONFIG
argument_list|,
name|getSessionTimeoutMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|MAX_POLL_INTERVAL_MS_CONFIG
argument_list|,
name|getMaxPollIntervalMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|MAX_POLL_RECORDS_CONFIG
argument_list|,
name|getMaxPollRecords
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|INTERCEPTOR_CLASSES_CONFIG
argument_list|,
name|getInterceptorClasses
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|AUTO_OFFSET_RESET_CONFIG
argument_list|,
name|getAutoOffsetReset
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|CONNECTIONS_MAX_IDLE_MS_CONFIG
argument_list|,
name|getConnectionMaxIdleMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|ENABLE_AUTO_COMMIT_CONFIG
argument_list|,
name|isAutoCommitEnable
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|PARTITION_ASSIGNMENT_STRATEGY_CONFIG
argument_list|,
name|getPartitionAssignor
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|RECEIVE_BUFFER_CONFIG
argument_list|,
name|getReceiveBufferBytes
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|REQUEST_TIMEOUT_MS_CONFIG
argument_list|,
name|getConsumerRequestTimeoutMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|AUTO_COMMIT_INTERVAL_MS_CONFIG
argument_list|,
name|getAutoCommitIntervalMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|CHECK_CRCS_CONFIG
argument_list|,
name|getCheckCrcs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|CLIENT_ID_CONFIG
argument_list|,
name|getClientId
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|FETCH_MAX_WAIT_MS_CONFIG
argument_list|,
name|getFetchWaitMaxMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|METADATA_MAX_AGE_CONFIG
argument_list|,
name|getMetadataMaxAgeMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|METRIC_REPORTER_CLASSES_CONFIG
argument_list|,
name|getMetricReporters
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|METRICS_NUM_SAMPLES_CONFIG
argument_list|,
name|getNoOfMetricsSample
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|METRICS_SAMPLE_WINDOW_MS_CONFIG
argument_list|,
name|getMetricsSampleWindowMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|RECONNECT_BACKOFF_MS_CONFIG
argument_list|,
name|getReconnectBackoffMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|RETRY_BACKOFF_MS_CONFIG
argument_list|,
name|getRetryBackoffMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ConsumerConfig
operator|.
name|RECONNECT_BACKOFF_MAX_MS_CONFIG
argument_list|,
name|getReconnectBackoffMaxMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"schema.registry.url"
argument_list|,
name|getSchemaRegistryURL
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"specific.avro.reader"
argument_list|,
name|isSpecificAvroReader
argument_list|()
argument_list|)
expr_stmt|;
comment|// SSL
name|applySslConfiguration
argument_list|(
name|props
argument_list|,
name|getSslContextParameters
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_KEY_PASSWORD_CONFIG
argument_list|,
name|getSslKeyPassword
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_KEYSTORE_LOCATION_CONFIG
argument_list|,
name|getSslKeystoreLocation
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_KEYSTORE_PASSWORD_CONFIG
argument_list|,
name|getSslKeystorePassword
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_TRUSTSTORE_LOCATION_CONFIG
argument_list|,
name|getSslTruststoreLocation
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_TRUSTSTORE_PASSWORD_CONFIG
argument_list|,
name|getSslTruststorePassword
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_CIPHER_SUITES_CONFIG
argument_list|,
name|getSslCipherSuites
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG
argument_list|,
name|getSslEndpointAlgorithm
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_KEYMANAGER_ALGORITHM_CONFIG
argument_list|,
name|getSslKeymanagerAlgorithm
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_TRUSTMANAGER_ALGORITHM_CONFIG
argument_list|,
name|getSslTrustmanagerAlgorithm
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_ENABLED_PROTOCOLS_CONFIG
argument_list|,
name|getSslEnabledProtocols
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_KEYSTORE_TYPE_CONFIG
argument_list|,
name|getSslKeystoreType
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_PROTOCOL_CONFIG
argument_list|,
name|getSslProtocol
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_PROVIDER_CONFIG
argument_list|,
name|getSslProvider
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_TRUSTSTORE_TYPE_CONFIG
argument_list|,
name|getSslTruststoreType
argument_list|()
argument_list|)
expr_stmt|;
comment|// Security protocol
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|CommonClientConfigs
operator|.
name|SECURITY_PROTOCOL_CONFIG
argument_list|,
name|getSecurityProtocol
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|ProducerConfig
operator|.
name|SEND_BUFFER_CONFIG
argument_list|,
name|getSendBufferBytes
argument_list|()
argument_list|)
expr_stmt|;
comment|// SASL
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SaslConfigs
operator|.
name|SASL_KERBEROS_SERVICE_NAME
argument_list|,
name|getSaslKerberosServiceName
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SaslConfigs
operator|.
name|SASL_KERBEROS_KINIT_CMD
argument_list|,
name|getKerberosInitCmd
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SaslConfigs
operator|.
name|SASL_KERBEROS_MIN_TIME_BEFORE_RELOGIN
argument_list|,
name|getKerberosBeforeReloginMinTime
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SaslConfigs
operator|.
name|SASL_KERBEROS_TICKET_RENEW_JITTER
argument_list|,
name|getKerberosRenewJitter
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SaslConfigs
operator|.
name|SASL_KERBEROS_TICKET_RENEW_WINDOW_FACTOR
argument_list|,
name|getKerberosRenewWindowFactor
argument_list|()
argument_list|)
expr_stmt|;
name|addListPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SaslConfigs
operator|.
name|SASL_KERBEROS_PRINCIPAL_TO_LOCAL_RULES
argument_list|,
name|getKerberosPrincipalToLocalRules
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SaslConfigs
operator|.
name|SASL_MECHANISM
argument_list|,
name|getSaslMechanism
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SaslConfigs
operator|.
name|SASL_JAAS_CONFIG
argument_list|,
name|getSaslJaasConfig
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|props
return|;
block|}
comment|/**      * Uses the standard camel {@link SSLContextParameters} object to fill the      * Kafka SSL properties      *      * @param props Kafka properties      * @param sslContextParameters SSL configuration      */
DECL|method|applySslConfiguration (Properties props, SSLContextParameters sslContextParameters)
specifier|private
name|void
name|applySslConfiguration
parameter_list|(
name|Properties
name|props
parameter_list|,
name|SSLContextParameters
name|sslContextParameters
parameter_list|)
block|{
if|if
condition|(
name|sslContextParameters
operator|!=
literal|null
condition|)
block|{
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_PROTOCOL_CONFIG
argument_list|,
name|sslContextParameters
operator|.
name|getSecureSocketProtocol
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_PROVIDER_CONFIG
argument_list|,
name|sslContextParameters
operator|.
name|getProvider
argument_list|()
argument_list|)
expr_stmt|;
name|CipherSuitesParameters
name|cipherSuites
init|=
name|sslContextParameters
operator|.
name|getCipherSuites
argument_list|()
decl_stmt|;
if|if
condition|(
name|cipherSuites
operator|!=
literal|null
condition|)
block|{
name|addCommaSeparatedList
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_CIPHER_SUITES_CONFIG
argument_list|,
name|cipherSuites
operator|.
name|getCipherSuite
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|SecureSocketProtocolsParameters
name|secureSocketProtocols
init|=
name|sslContextParameters
operator|.
name|getSecureSocketProtocols
argument_list|()
decl_stmt|;
if|if
condition|(
name|secureSocketProtocols
operator|!=
literal|null
condition|)
block|{
name|addCommaSeparatedList
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_ENABLED_PROTOCOLS_CONFIG
argument_list|,
name|secureSocketProtocols
operator|.
name|getSecureSocketProtocol
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|KeyManagersParameters
name|keyManagers
init|=
name|sslContextParameters
operator|.
name|getKeyManagers
argument_list|()
decl_stmt|;
if|if
condition|(
name|keyManagers
operator|!=
literal|null
condition|)
block|{
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_KEYMANAGER_ALGORITHM_CONFIG
argument_list|,
name|keyManagers
operator|.
name|getAlgorithm
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_KEY_PASSWORD_CONFIG
argument_list|,
name|keyManagers
operator|.
name|getKeyPassword
argument_list|()
argument_list|)
expr_stmt|;
name|KeyStoreParameters
name|keyStore
init|=
name|keyManagers
operator|.
name|getKeyStore
argument_list|()
decl_stmt|;
if|if
condition|(
name|keyStore
operator|!=
literal|null
condition|)
block|{
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_KEYSTORE_TYPE_CONFIG
argument_list|,
name|keyStore
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_KEYSTORE_LOCATION_CONFIG
argument_list|,
name|keyStore
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_KEYSTORE_PASSWORD_CONFIG
argument_list|,
name|keyStore
operator|.
name|getPassword
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|TrustManagersParameters
name|trustManagers
init|=
name|sslContextParameters
operator|.
name|getTrustManagers
argument_list|()
decl_stmt|;
if|if
condition|(
name|trustManagers
operator|!=
literal|null
condition|)
block|{
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_TRUSTMANAGER_ALGORITHM_CONFIG
argument_list|,
name|trustManagers
operator|.
name|getAlgorithm
argument_list|()
argument_list|)
expr_stmt|;
name|KeyStoreParameters
name|keyStore
init|=
name|trustManagers
operator|.
name|getKeyStore
argument_list|()
decl_stmt|;
if|if
condition|(
name|keyStore
operator|!=
literal|null
condition|)
block|{
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_TRUSTSTORE_TYPE_CONFIG
argument_list|,
name|keyStore
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_TRUSTSTORE_LOCATION_CONFIG
argument_list|,
name|keyStore
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
name|SslConfigs
operator|.
name|SSL_KEYSTORE_PASSWORD_CONFIG
argument_list|,
name|keyStore
operator|.
name|getPassword
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|addPropertyIfNotNull (Properties props, String key, T value)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|void
name|addPropertyIfNotNull
parameter_list|(
name|Properties
name|props
parameter_list|,
name|String
name|key
parameter_list|,
name|T
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
comment|// Kafka expects all properties as String
name|props
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addListPropertyIfNotNull (Properties props, String key, T value)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|void
name|addListPropertyIfNotNull
parameter_list|(
name|Properties
name|props
parameter_list|,
name|String
name|key
parameter_list|,
name|T
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
comment|// Kafka expects all properties as String
name|String
index|[]
name|values
init|=
name|value
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|values
argument_list|)
decl_stmt|;
name|props
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addCommaSeparatedList (Properties props, String key, List<String> values)
specifier|private
specifier|static
name|void
name|addCommaSeparatedList
parameter_list|(
name|Properties
name|props
parameter_list|,
name|String
name|key
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|values
parameter_list|)
block|{
if|if
condition|(
name|values
operator|!=
literal|null
operator|&&
operator|!
name|values
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|props
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|values
operator|.
name|stream
argument_list|()
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|joining
argument_list|(
literal|","
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|isTopicIsPattern ()
specifier|public
name|boolean
name|isTopicIsPattern
parameter_list|()
block|{
return|return
name|topicIsPattern
return|;
block|}
comment|/**      * Whether the topic is a pattern (regular expression). This can be used to      * subscribe to dynamic number of topics matching the pattern.      */
DECL|method|setTopicIsPattern (boolean topicIsPattern)
specifier|public
name|void
name|setTopicIsPattern
parameter_list|(
name|boolean
name|topicIsPattern
parameter_list|)
block|{
name|this
operator|.
name|topicIsPattern
operator|=
name|topicIsPattern
expr_stmt|;
block|}
DECL|method|getGroupId ()
specifier|public
name|String
name|getGroupId
parameter_list|()
block|{
return|return
name|groupId
return|;
block|}
comment|/**      * A string that uniquely identifies the group of consumer processes to      * which this consumer belongs. By setting the same group id multiple      * processes indicate that they are all part of the same consumer group.      * This option is required for consumers.      */
DECL|method|setGroupId (String groupId)
specifier|public
name|void
name|setGroupId
parameter_list|(
name|String
name|groupId
parameter_list|)
block|{
name|this
operator|.
name|groupId
operator|=
name|groupId
expr_stmt|;
block|}
DECL|method|isBridgeEndpoint ()
specifier|public
name|boolean
name|isBridgeEndpoint
parameter_list|()
block|{
return|return
name|bridgeEndpoint
return|;
block|}
comment|/**      * If the option is true, then KafkaProducer will ignore the      * KafkaConstants.TOPIC header setting of the inbound message.      */
DECL|method|setBridgeEndpoint (boolean bridgeEndpoint)
specifier|public
name|void
name|setBridgeEndpoint
parameter_list|(
name|boolean
name|bridgeEndpoint
parameter_list|)
block|{
name|this
operator|.
name|bridgeEndpoint
operator|=
name|bridgeEndpoint
expr_stmt|;
block|}
DECL|method|isCircularTopicDetection ()
specifier|public
name|boolean
name|isCircularTopicDetection
parameter_list|()
block|{
return|return
name|circularTopicDetection
return|;
block|}
comment|/**      * If the option is true, then KafkaProducer will detect if the message is      * attempted to be sent back to the same topic it may come from, if the      * message was original from a kafka consumer. If the KafkaConstants.TOPIC      * header is the same as the original kafka consumer topic, then the header      * setting is ignored, and the topic of the producer endpoint is used. In      * other words this avoids sending the same message back to where it came      * from. This option is not in use if the option bridgeEndpoint is set to      * true.      */
DECL|method|setCircularTopicDetection (boolean circularTopicDetection)
specifier|public
name|void
name|setCircularTopicDetection
parameter_list|(
name|boolean
name|circularTopicDetection
parameter_list|)
block|{
name|this
operator|.
name|circularTopicDetection
operator|=
name|circularTopicDetection
expr_stmt|;
block|}
DECL|method|getPartitioner ()
specifier|public
name|String
name|getPartitioner
parameter_list|()
block|{
return|return
name|partitioner
return|;
block|}
comment|/**      * The partitioner class for partitioning messages amongst sub-topics. The      * default partitioner is based on the hash of the key.      */
DECL|method|setPartitioner (String partitioner)
specifier|public
name|void
name|setPartitioner
parameter_list|(
name|String
name|partitioner
parameter_list|)
block|{
name|this
operator|.
name|partitioner
operator|=
name|partitioner
expr_stmt|;
block|}
DECL|method|getTopic ()
specifier|public
name|String
name|getTopic
parameter_list|()
block|{
return|return
name|topic
return|;
block|}
comment|/**      * Name of the topic to use. On the consumer you can use comma to separate      * multiple topics. A producer can only send a message to a single topic.      */
DECL|method|setTopic (String topic)
specifier|public
name|void
name|setTopic
parameter_list|(
name|String
name|topic
parameter_list|)
block|{
name|this
operator|.
name|topic
operator|=
name|topic
expr_stmt|;
block|}
DECL|method|getConsumerStreams ()
specifier|public
name|int
name|getConsumerStreams
parameter_list|()
block|{
return|return
name|consumerStreams
return|;
block|}
comment|/**      * Number of concurrent consumers on the consumer      */
DECL|method|setConsumerStreams (int consumerStreams)
specifier|public
name|void
name|setConsumerStreams
parameter_list|(
name|int
name|consumerStreams
parameter_list|)
block|{
name|this
operator|.
name|consumerStreams
operator|=
name|consumerStreams
expr_stmt|;
block|}
DECL|method|getConsumersCount ()
specifier|public
name|int
name|getConsumersCount
parameter_list|()
block|{
return|return
name|consumersCount
return|;
block|}
comment|/**      * The number of consumers that connect to kafka server      */
DECL|method|setConsumersCount (int consumersCount)
specifier|public
name|void
name|setConsumersCount
parameter_list|(
name|int
name|consumersCount
parameter_list|)
block|{
name|this
operator|.
name|consumersCount
operator|=
name|consumersCount
expr_stmt|;
block|}
DECL|method|getClientId ()
specifier|public
name|String
name|getClientId
parameter_list|()
block|{
return|return
name|clientId
return|;
block|}
comment|/**      * The client id is a user-specified string sent in each request to help      * trace calls. It should logically identify the application making the      * request.      */
DECL|method|setClientId (String clientId)
specifier|public
name|void
name|setClientId
parameter_list|(
name|String
name|clientId
parameter_list|)
block|{
name|this
operator|.
name|clientId
operator|=
name|clientId
expr_stmt|;
block|}
DECL|method|isAutoCommitEnable ()
specifier|public
name|Boolean
name|isAutoCommitEnable
parameter_list|()
block|{
return|return
name|offsetRepository
operator|==
literal|null
condition|?
name|autoCommitEnable
else|:
literal|false
return|;
block|}
comment|/**      * If true, periodically commit to ZooKeeper the offset of messages already      * fetched by the consumer. This committed offset will be used when the      * process fails as the position from which the new consumer will begin.      */
DECL|method|setAutoCommitEnable (Boolean autoCommitEnable)
specifier|public
name|void
name|setAutoCommitEnable
parameter_list|(
name|Boolean
name|autoCommitEnable
parameter_list|)
block|{
name|this
operator|.
name|autoCommitEnable
operator|=
name|autoCommitEnable
expr_stmt|;
block|}
DECL|method|isAllowManualCommit ()
specifier|public
name|boolean
name|isAllowManualCommit
parameter_list|()
block|{
return|return
name|allowManualCommit
return|;
block|}
comment|/**      * Whether to allow doing manual commits via {@link KafkaManualCommit}.      *<p/>      * If this option is enabled then an instance of {@link KafkaManualCommit}      * is stored on the {@link Exchange} message header, which allows end users      * to access this API and perform manual offset commits via the Kafka      * consumer.      */
DECL|method|setAllowManualCommit (boolean allowManualCommit)
specifier|public
name|void
name|setAllowManualCommit
parameter_list|(
name|boolean
name|allowManualCommit
parameter_list|)
block|{
name|this
operator|.
name|allowManualCommit
operator|=
name|allowManualCommit
expr_stmt|;
block|}
DECL|method|getOffsetRepository ()
specifier|public
name|StateRepository
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getOffsetRepository
parameter_list|()
block|{
return|return
name|offsetRepository
return|;
block|}
comment|/**      * The offset repository to use in order to locally store the offset of each      * partition of the topic. Defining one will disable the autocommit.      */
DECL|method|setOffsetRepository (StateRepository<String, String> offsetRepository)
specifier|public
name|void
name|setOffsetRepository
parameter_list|(
name|StateRepository
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|offsetRepository
parameter_list|)
block|{
name|this
operator|.
name|offsetRepository
operator|=
name|offsetRepository
expr_stmt|;
block|}
DECL|method|getAutoCommitIntervalMs ()
specifier|public
name|Integer
name|getAutoCommitIntervalMs
parameter_list|()
block|{
return|return
name|autoCommitIntervalMs
return|;
block|}
comment|/**      * The frequency in ms that the consumer offsets are committed to zookeeper.      */
DECL|method|setAutoCommitIntervalMs (Integer autoCommitIntervalMs)
specifier|public
name|void
name|setAutoCommitIntervalMs
parameter_list|(
name|Integer
name|autoCommitIntervalMs
parameter_list|)
block|{
name|this
operator|.
name|autoCommitIntervalMs
operator|=
name|autoCommitIntervalMs
expr_stmt|;
block|}
DECL|method|getFetchMinBytes ()
specifier|public
name|Integer
name|getFetchMinBytes
parameter_list|()
block|{
return|return
name|fetchMinBytes
return|;
block|}
comment|/**      * The minimum amount of data the server should return for a fetch request.      * If insufficient data is available the request will wait for that much      * data to accumulate before answering the request.      */
DECL|method|setFetchMinBytes (Integer fetchMinBytes)
specifier|public
name|void
name|setFetchMinBytes
parameter_list|(
name|Integer
name|fetchMinBytes
parameter_list|)
block|{
name|this
operator|.
name|fetchMinBytes
operator|=
name|fetchMinBytes
expr_stmt|;
block|}
comment|/**      * The maximum amount of data the server should return for a fetch request      * This is not an absolute maximum, if the first message in the first      * non-empty partition of the fetch is larger than this value, the message      * will still be returned to ensure that the consumer can make progress. The      * maximum message size accepted by the broker is defined via      * message.max.bytes (broker config) or max.message.bytes (topic config).      * Note that the consumer performs multiple fetches in parallel.      */
DECL|method|getFetchMaxBytes ()
specifier|public
name|Integer
name|getFetchMaxBytes
parameter_list|()
block|{
return|return
name|fetchMaxBytes
return|;
block|}
DECL|method|setFetchMaxBytes (Integer fetchMaxBytes)
specifier|public
name|void
name|setFetchMaxBytes
parameter_list|(
name|Integer
name|fetchMaxBytes
parameter_list|)
block|{
name|this
operator|.
name|fetchMaxBytes
operator|=
name|fetchMaxBytes
expr_stmt|;
block|}
DECL|method|getFetchWaitMaxMs ()
specifier|public
name|Integer
name|getFetchWaitMaxMs
parameter_list|()
block|{
return|return
name|fetchWaitMaxMs
return|;
block|}
comment|/**      * The maximum amount of time the server will block before answering the      * fetch request if there isn't sufficient data to immediately satisfy      * fetch.min.bytes      */
DECL|method|setFetchWaitMaxMs (Integer fetchWaitMaxMs)
specifier|public
name|void
name|setFetchWaitMaxMs
parameter_list|(
name|Integer
name|fetchWaitMaxMs
parameter_list|)
block|{
name|this
operator|.
name|fetchWaitMaxMs
operator|=
name|fetchWaitMaxMs
expr_stmt|;
block|}
DECL|method|getAutoOffsetReset ()
specifier|public
name|String
name|getAutoOffsetReset
parameter_list|()
block|{
return|return
name|autoOffsetReset
return|;
block|}
comment|/**      * What to do when there is no initial offset in ZooKeeper or if an offset      * is out of range: earliest : automatically reset the offset to the      * earliest offset latest : automatically reset the offset to the latest      * offset fail: throw exception to the consumer      */
DECL|method|setAutoOffsetReset (String autoOffsetReset)
specifier|public
name|void
name|setAutoOffsetReset
parameter_list|(
name|String
name|autoOffsetReset
parameter_list|)
block|{
name|this
operator|.
name|autoOffsetReset
operator|=
name|autoOffsetReset
expr_stmt|;
block|}
DECL|method|getAutoCommitOnStop ()
specifier|public
name|String
name|getAutoCommitOnStop
parameter_list|()
block|{
return|return
name|autoCommitOnStop
return|;
block|}
comment|/**      * Whether to perform an explicit auto commit when the consumer stops to      * ensure the broker has a commit from the last consumed message. This      * requires the option autoCommitEnable is turned on. The possible values      * are: sync, async, or none. And sync is the default value.      */
DECL|method|setAutoCommitOnStop (String autoCommitOnStop)
specifier|public
name|void
name|setAutoCommitOnStop
parameter_list|(
name|String
name|autoCommitOnStop
parameter_list|)
block|{
name|this
operator|.
name|autoCommitOnStop
operator|=
name|autoCommitOnStop
expr_stmt|;
block|}
DECL|method|isBreakOnFirstError ()
specifier|public
name|boolean
name|isBreakOnFirstError
parameter_list|()
block|{
return|return
name|breakOnFirstError
return|;
block|}
comment|/**      * This options controls what happens when a consumer is processing an      * exchange and it fails. If the option is<tt>false</tt> then the consumer      * continues to the next message and processes it. If the option is      *<tt>true</tt> then the consumer breaks out, and will seek back to offset      * of the message that caused a failure, and then re-attempt to process this      * message. However this can lead to endless processing of the same message      * if its bound to fail every time, eg a poison message. Therefore its      * recommended to deal with that for example by using Camel's error handler.      */
DECL|method|setBreakOnFirstError (boolean breakOnFirstError)
specifier|public
name|void
name|setBreakOnFirstError
parameter_list|(
name|boolean
name|breakOnFirstError
parameter_list|)
block|{
name|this
operator|.
name|breakOnFirstError
operator|=
name|breakOnFirstError
expr_stmt|;
block|}
DECL|method|getBrokers ()
specifier|public
name|String
name|getBrokers
parameter_list|()
block|{
return|return
name|brokers
return|;
block|}
comment|/**      * URL of the Kafka brokers to use. The format is host1:port1,host2:port2,      * and the list can be a subset of brokers or a VIP pointing to a subset of      * brokers.      *<p/>      * This option is known as<tt>bootstrap.servers</tt> in the Kafka      * documentation.      */
DECL|method|setBrokers (String brokers)
specifier|public
name|void
name|setBrokers
parameter_list|(
name|String
name|brokers
parameter_list|)
block|{
name|this
operator|.
name|brokers
operator|=
name|brokers
expr_stmt|;
block|}
DECL|method|getSchemaRegistryURL ()
specifier|public
name|String
name|getSchemaRegistryURL
parameter_list|()
block|{
return|return
name|schemaRegistryURL
return|;
block|}
comment|/**      * URL of the Confluent Platform schema registry servers to use.       * The format is host1:port1,host2:port2.       * This is known as schema.registry.url in the Confluent Platform documentation.      * This option is only available in the Confluent Platform (not standard Apache Kafka)      */
DECL|method|setSchemaRegistryURL (String schemaRegistryURL)
specifier|public
name|void
name|setSchemaRegistryURL
parameter_list|(
name|String
name|schemaRegistryURL
parameter_list|)
block|{
name|this
operator|.
name|schemaRegistryURL
operator|=
name|schemaRegistryURL
expr_stmt|;
block|}
DECL|method|isSpecificAvroReader ()
specifier|public
name|boolean
name|isSpecificAvroReader
parameter_list|()
block|{
return|return
name|specificAvroReader
return|;
block|}
comment|/**      * This enables the use of a specific Avro reader for use with the Confluent Platform schema registry and the io.confluent.kafka.serializers.KafkaAvroDeserializer.      * This option is only available in the Confluent Platform (not standard Apache Kafka)      */
DECL|method|setSpecificAvroReader (boolean specificAvroReader)
specifier|public
name|void
name|setSpecificAvroReader
parameter_list|(
name|boolean
name|specificAvroReader
parameter_list|)
block|{
name|this
operator|.
name|specificAvroReader
operator|=
name|specificAvroReader
expr_stmt|;
block|}
DECL|method|getCompressionCodec ()
specifier|public
name|String
name|getCompressionCodec
parameter_list|()
block|{
return|return
name|compressionCodec
return|;
block|}
comment|/**      * This parameter allows you to specify the compression codec for all data      * generated by this producer. Valid values are "none", "gzip" and "snappy".      */
DECL|method|setCompressionCodec (String compressionCodec)
specifier|public
name|void
name|setCompressionCodec
parameter_list|(
name|String
name|compressionCodec
parameter_list|)
block|{
name|this
operator|.
name|compressionCodec
operator|=
name|compressionCodec
expr_stmt|;
block|}
DECL|method|getRetryBackoffMs ()
specifier|public
name|Integer
name|getRetryBackoffMs
parameter_list|()
block|{
return|return
name|retryBackoffMs
return|;
block|}
comment|/**      * Before each retry, the producer refreshes the metadata of relevant topics      * to see if a new leader has been elected. Since leader election takes a      * bit of time, this property specifies the amount of time that the producer      * waits before refreshing the metadata.      */
DECL|method|setRetryBackoffMs (Integer retryBackoffMs)
specifier|public
name|void
name|setRetryBackoffMs
parameter_list|(
name|Integer
name|retryBackoffMs
parameter_list|)
block|{
name|this
operator|.
name|retryBackoffMs
operator|=
name|retryBackoffMs
expr_stmt|;
block|}
DECL|method|getSendBufferBytes ()
specifier|public
name|Integer
name|getSendBufferBytes
parameter_list|()
block|{
return|return
name|sendBufferBytes
return|;
block|}
comment|/**      * Socket write buffer size      */
DECL|method|setSendBufferBytes (Integer sendBufferBytes)
specifier|public
name|void
name|setSendBufferBytes
parameter_list|(
name|Integer
name|sendBufferBytes
parameter_list|)
block|{
name|this
operator|.
name|sendBufferBytes
operator|=
name|sendBufferBytes
expr_stmt|;
block|}
DECL|method|getRequestTimeoutMs ()
specifier|public
name|Integer
name|getRequestTimeoutMs
parameter_list|()
block|{
return|return
name|requestTimeoutMs
return|;
block|}
comment|/**      * The amount of time the broker will wait trying to meet the      * request.required.acks requirement before sending back an error to the      * client.      */
DECL|method|setRequestTimeoutMs (Integer requestTimeoutMs)
specifier|public
name|void
name|setRequestTimeoutMs
parameter_list|(
name|Integer
name|requestTimeoutMs
parameter_list|)
block|{
name|this
operator|.
name|requestTimeoutMs
operator|=
name|requestTimeoutMs
expr_stmt|;
block|}
DECL|method|getQueueBufferingMaxMessages ()
specifier|public
name|Integer
name|getQueueBufferingMaxMessages
parameter_list|()
block|{
return|return
name|queueBufferingMaxMessages
return|;
block|}
comment|/**      * The maximum number of unsent messages that can be queued up the producer      * when using async mode before either the producer must be blocked or data      * must be dropped.      */
DECL|method|setQueueBufferingMaxMessages (Integer queueBufferingMaxMessages)
specifier|public
name|void
name|setQueueBufferingMaxMessages
parameter_list|(
name|Integer
name|queueBufferingMaxMessages
parameter_list|)
block|{
name|this
operator|.
name|queueBufferingMaxMessages
operator|=
name|queueBufferingMaxMessages
expr_stmt|;
block|}
DECL|method|getSerializerClass ()
specifier|public
name|String
name|getSerializerClass
parameter_list|()
block|{
return|return
name|serializerClass
return|;
block|}
comment|/**      * The serializer class for messages.      */
DECL|method|setSerializerClass (String serializerClass)
specifier|public
name|void
name|setSerializerClass
parameter_list|(
name|String
name|serializerClass
parameter_list|)
block|{
name|this
operator|.
name|serializerClass
operator|=
name|serializerClass
expr_stmt|;
block|}
DECL|method|getKeySerializerClass ()
specifier|public
name|String
name|getKeySerializerClass
parameter_list|()
block|{
return|return
name|keySerializerClass
return|;
block|}
comment|/**      * The serializer class for keys (defaults to the same as for messages if      * nothing is given).      */
DECL|method|setKeySerializerClass (String keySerializerClass)
specifier|public
name|void
name|setKeySerializerClass
parameter_list|(
name|String
name|keySerializerClass
parameter_list|)
block|{
name|this
operator|.
name|keySerializerClass
operator|=
name|keySerializerClass
expr_stmt|;
block|}
DECL|method|getKerberosInitCmd ()
specifier|public
name|String
name|getKerberosInitCmd
parameter_list|()
block|{
return|return
name|kerberosInitCmd
return|;
block|}
comment|/**      * Kerberos kinit command path. Default is /usr/bin/kinit      */
DECL|method|setKerberosInitCmd (String kerberosInitCmd)
specifier|public
name|void
name|setKerberosInitCmd
parameter_list|(
name|String
name|kerberosInitCmd
parameter_list|)
block|{
name|this
operator|.
name|kerberosInitCmd
operator|=
name|kerberosInitCmd
expr_stmt|;
block|}
DECL|method|getKerberosBeforeReloginMinTime ()
specifier|public
name|Integer
name|getKerberosBeforeReloginMinTime
parameter_list|()
block|{
return|return
name|kerberosBeforeReloginMinTime
return|;
block|}
comment|/**      * Login thread sleep time between refresh attempts.      */
DECL|method|setKerberosBeforeReloginMinTime (Integer kerberosBeforeReloginMinTime)
specifier|public
name|void
name|setKerberosBeforeReloginMinTime
parameter_list|(
name|Integer
name|kerberosBeforeReloginMinTime
parameter_list|)
block|{
name|this
operator|.
name|kerberosBeforeReloginMinTime
operator|=
name|kerberosBeforeReloginMinTime
expr_stmt|;
block|}
DECL|method|getKerberosRenewJitter ()
specifier|public
name|Double
name|getKerberosRenewJitter
parameter_list|()
block|{
return|return
name|kerberosRenewJitter
return|;
block|}
comment|/**      * Percentage of random jitter added to the renewal time.      */
DECL|method|setKerberosRenewJitter (Double kerberosRenewJitter)
specifier|public
name|void
name|setKerberosRenewJitter
parameter_list|(
name|Double
name|kerberosRenewJitter
parameter_list|)
block|{
name|this
operator|.
name|kerberosRenewJitter
operator|=
name|kerberosRenewJitter
expr_stmt|;
block|}
DECL|method|getKerberosRenewWindowFactor ()
specifier|public
name|Double
name|getKerberosRenewWindowFactor
parameter_list|()
block|{
return|return
name|kerberosRenewWindowFactor
return|;
block|}
comment|/**      * Login thread will sleep until the specified window factor of time from      * last refresh to ticket's expiry has been reached, at which time it will      * try to renew the ticket.      */
DECL|method|setKerberosRenewWindowFactor (Double kerberosRenewWindowFactor)
specifier|public
name|void
name|setKerberosRenewWindowFactor
parameter_list|(
name|Double
name|kerberosRenewWindowFactor
parameter_list|)
block|{
name|this
operator|.
name|kerberosRenewWindowFactor
operator|=
name|kerberosRenewWindowFactor
expr_stmt|;
block|}
DECL|method|getKerberosPrincipalToLocalRules ()
specifier|public
name|String
name|getKerberosPrincipalToLocalRules
parameter_list|()
block|{
return|return
name|kerberosPrincipalToLocalRules
return|;
block|}
comment|/**      * A list of rules for mapping from principal names to short names      * (typically operating system usernames). The rules are evaluated in order      * and the first rule that matches a principal name is used to map it to a      * short name. Any later rules in the list are ignored. By default,      * principal names of the form {username}/{hostname}@{REALM} are mapped to      * {username}. For more details on the format please see the security authorization and acls documentation..      *<p/>      * Multiple values can be separated by comma      */
DECL|method|setKerberosPrincipalToLocalRules (String kerberosPrincipalToLocalRules)
specifier|public
name|void
name|setKerberosPrincipalToLocalRules
parameter_list|(
name|String
name|kerberosPrincipalToLocalRules
parameter_list|)
block|{
name|this
operator|.
name|kerberosPrincipalToLocalRules
operator|=
name|kerberosPrincipalToLocalRules
expr_stmt|;
block|}
DECL|method|getSslCipherSuites ()
specifier|public
name|String
name|getSslCipherSuites
parameter_list|()
block|{
return|return
name|sslCipherSuites
return|;
block|}
comment|/**      * A list of cipher suites. This is a named combination of authentication,      * encryption, MAC and key exchange algorithm used to negotiate the security      * settings for a network connection using TLS or SSL network protocol.By      * default all the available cipher suites are supported.      */
DECL|method|setSslCipherSuites (String sslCipherSuites)
specifier|public
name|void
name|setSslCipherSuites
parameter_list|(
name|String
name|sslCipherSuites
parameter_list|)
block|{
name|this
operator|.
name|sslCipherSuites
operator|=
name|sslCipherSuites
expr_stmt|;
block|}
DECL|method|getSslEndpointAlgorithm ()
specifier|public
name|String
name|getSslEndpointAlgorithm
parameter_list|()
block|{
return|return
name|sslEndpointAlgorithm
return|;
block|}
comment|/**      * The endpoint identification algorithm to validate server hostname using      * server certificate.      */
DECL|method|setSslEndpointAlgorithm (String sslEndpointAlgorithm)
specifier|public
name|void
name|setSslEndpointAlgorithm
parameter_list|(
name|String
name|sslEndpointAlgorithm
parameter_list|)
block|{
name|this
operator|.
name|sslEndpointAlgorithm
operator|=
name|sslEndpointAlgorithm
expr_stmt|;
block|}
DECL|method|getSslKeymanagerAlgorithm ()
specifier|public
name|String
name|getSslKeymanagerAlgorithm
parameter_list|()
block|{
return|return
name|sslKeymanagerAlgorithm
return|;
block|}
comment|/**      * The algorithm used by key manager factory for SSL connections. Default      * value is the key manager factory algorithm configured for the Java      * Virtual Machine.      */
DECL|method|setSslKeymanagerAlgorithm (String sslKeymanagerAlgorithm)
specifier|public
name|void
name|setSslKeymanagerAlgorithm
parameter_list|(
name|String
name|sslKeymanagerAlgorithm
parameter_list|)
block|{
name|this
operator|.
name|sslKeymanagerAlgorithm
operator|=
name|sslKeymanagerAlgorithm
expr_stmt|;
block|}
DECL|method|getSslTrustmanagerAlgorithm ()
specifier|public
name|String
name|getSslTrustmanagerAlgorithm
parameter_list|()
block|{
return|return
name|sslTrustmanagerAlgorithm
return|;
block|}
comment|/**      * The algorithm used by trust manager factory for SSL connections. Default      * value is the trust manager factory algorithm configured for the Java      * Virtual Machine.      */
DECL|method|setSslTrustmanagerAlgorithm (String sslTrustmanagerAlgorithm)
specifier|public
name|void
name|setSslTrustmanagerAlgorithm
parameter_list|(
name|String
name|sslTrustmanagerAlgorithm
parameter_list|)
block|{
name|this
operator|.
name|sslTrustmanagerAlgorithm
operator|=
name|sslTrustmanagerAlgorithm
expr_stmt|;
block|}
DECL|method|getSslEnabledProtocols ()
specifier|public
name|String
name|getSslEnabledProtocols
parameter_list|()
block|{
return|return
name|sslEnabledProtocols
return|;
block|}
comment|/**      * The list of protocols enabled for SSL connections. TLSv1.2, TLSv1.1 and      * TLSv1 are enabled by default.      */
DECL|method|setSslEnabledProtocols (String sslEnabledProtocols)
specifier|public
name|void
name|setSslEnabledProtocols
parameter_list|(
name|String
name|sslEnabledProtocols
parameter_list|)
block|{
name|this
operator|.
name|sslEnabledProtocols
operator|=
name|sslEnabledProtocols
expr_stmt|;
block|}
DECL|method|getSslKeystoreType ()
specifier|public
name|String
name|getSslKeystoreType
parameter_list|()
block|{
return|return
name|sslKeystoreType
return|;
block|}
comment|/**      * The file format of the key store file. This is optional for client.      * Default value is JKS      */
DECL|method|setSslKeystoreType (String sslKeystoreType)
specifier|public
name|void
name|setSslKeystoreType
parameter_list|(
name|String
name|sslKeystoreType
parameter_list|)
block|{
name|this
operator|.
name|sslKeystoreType
operator|=
name|sslKeystoreType
expr_stmt|;
block|}
DECL|method|getSslProtocol ()
specifier|public
name|String
name|getSslProtocol
parameter_list|()
block|{
return|return
name|sslProtocol
return|;
block|}
comment|/**      * The SSL protocol used to generate the SSLContext. Default setting is TLS,      * which is fine for most cases. Allowed values in recent JVMs are TLS,      * TLSv1.1 and TLSv1.2. SSL, SSLv2 and SSLv3 may be supported in older JVMs,      * but their usage is discouraged due to known security vulnerabilities.      */
DECL|method|setSslProtocol (String sslProtocol)
specifier|public
name|void
name|setSslProtocol
parameter_list|(
name|String
name|sslProtocol
parameter_list|)
block|{
name|this
operator|.
name|sslProtocol
operator|=
name|sslProtocol
expr_stmt|;
block|}
DECL|method|getSslProvider ()
specifier|public
name|String
name|getSslProvider
parameter_list|()
block|{
return|return
name|sslProvider
return|;
block|}
comment|/**      * The name of the security provider used for SSL connections. Default value      * is the default security provider of the JVM.      */
DECL|method|setSslProvider (String sslProvider)
specifier|public
name|void
name|setSslProvider
parameter_list|(
name|String
name|sslProvider
parameter_list|)
block|{
name|this
operator|.
name|sslProvider
operator|=
name|sslProvider
expr_stmt|;
block|}
DECL|method|getSslTruststoreType ()
specifier|public
name|String
name|getSslTruststoreType
parameter_list|()
block|{
return|return
name|sslTruststoreType
return|;
block|}
comment|/**      * The file format of the trust store file. Default value is JKS.      */
DECL|method|setSslTruststoreType (String sslTruststoreType)
specifier|public
name|void
name|setSslTruststoreType
parameter_list|(
name|String
name|sslTruststoreType
parameter_list|)
block|{
name|this
operator|.
name|sslTruststoreType
operator|=
name|sslTruststoreType
expr_stmt|;
block|}
DECL|method|getSaslKerberosServiceName ()
specifier|public
name|String
name|getSaslKerberosServiceName
parameter_list|()
block|{
return|return
name|saslKerberosServiceName
return|;
block|}
comment|/**      * The Kerberos principal name that Kafka runs as. This can be defined      * either in Kafka's JAAS config or in Kafka's config.      */
DECL|method|setSaslKerberosServiceName (String saslKerberosServiceName)
specifier|public
name|void
name|setSaslKerberosServiceName
parameter_list|(
name|String
name|saslKerberosServiceName
parameter_list|)
block|{
name|this
operator|.
name|saslKerberosServiceName
operator|=
name|saslKerberosServiceName
expr_stmt|;
block|}
DECL|method|getSaslMechanism ()
specifier|public
name|String
name|getSaslMechanism
parameter_list|()
block|{
return|return
name|saslMechanism
return|;
block|}
comment|/**      * The Simple Authentication and Security Layer (SASL) Mechanism used. For      * the valid values see<a href=      * "http://www.iana.org/assignments/sasl-mechanisms/sasl-mechanisms.xhtml">http://www.iana.org/assignments/sasl-mechanisms/sasl-mechanisms.xhtml</a>      */
DECL|method|setSaslMechanism (String saslMechanism)
specifier|public
name|void
name|setSaslMechanism
parameter_list|(
name|String
name|saslMechanism
parameter_list|)
block|{
name|this
operator|.
name|saslMechanism
operator|=
name|saslMechanism
expr_stmt|;
block|}
DECL|method|getSaslJaasConfig ()
specifier|public
name|String
name|getSaslJaasConfig
parameter_list|()
block|{
return|return
name|saslJaasConfig
return|;
block|}
comment|/**      * Expose the kafka sasl.jaas.config parameter Example:      * org.apache.kafka.common.security.plain.PlainLoginModule required      * username="USERNAME" password="PASSWORD";      */
DECL|method|setSaslJaasConfig (String saslMechanism)
specifier|public
name|void
name|setSaslJaasConfig
parameter_list|(
name|String
name|saslMechanism
parameter_list|)
block|{
name|this
operator|.
name|saslJaasConfig
operator|=
name|saslMechanism
expr_stmt|;
block|}
DECL|method|getSecurityProtocol ()
specifier|public
name|String
name|getSecurityProtocol
parameter_list|()
block|{
return|return
name|securityProtocol
return|;
block|}
comment|/**      * Protocol used to communicate with brokers. SASL_PLAINTEXT, PLAINTEXT and      * SSL are supported      */
DECL|method|setSecurityProtocol (String securityProtocol)
specifier|public
name|void
name|setSecurityProtocol
parameter_list|(
name|String
name|securityProtocol
parameter_list|)
block|{
name|this
operator|.
name|securityProtocol
operator|=
name|securityProtocol
expr_stmt|;
block|}
DECL|method|getSslContextParameters ()
specifier|public
name|SSLContextParameters
name|getSslContextParameters
parameter_list|()
block|{
return|return
name|sslContextParameters
return|;
block|}
comment|/**      * SSL configuration using a Camel {@link SSLContextParameters} object. If      * configured it's applied before the other SSL endpoint parameters.      */
DECL|method|setSslContextParameters (SSLContextParameters sslContextParameters)
specifier|public
name|void
name|setSslContextParameters
parameter_list|(
name|SSLContextParameters
name|sslContextParameters
parameter_list|)
block|{
name|this
operator|.
name|sslContextParameters
operator|=
name|sslContextParameters
expr_stmt|;
block|}
DECL|method|getSslKeyPassword ()
specifier|public
name|String
name|getSslKeyPassword
parameter_list|()
block|{
return|return
name|sslKeyPassword
return|;
block|}
comment|/**      * The password of the private key in the key store file. This is optional      * for client.      */
DECL|method|setSslKeyPassword (String sslKeyPassword)
specifier|public
name|void
name|setSslKeyPassword
parameter_list|(
name|String
name|sslKeyPassword
parameter_list|)
block|{
name|this
operator|.
name|sslKeyPassword
operator|=
name|sslKeyPassword
expr_stmt|;
block|}
DECL|method|getSslKeystoreLocation ()
specifier|public
name|String
name|getSslKeystoreLocation
parameter_list|()
block|{
return|return
name|sslKeystoreLocation
return|;
block|}
comment|/**      * The location of the key store file. This is optional for client and can      * be used for two-way authentication for client.      */
DECL|method|setSslKeystoreLocation (String sslKeystoreLocation)
specifier|public
name|void
name|setSslKeystoreLocation
parameter_list|(
name|String
name|sslKeystoreLocation
parameter_list|)
block|{
name|this
operator|.
name|sslKeystoreLocation
operator|=
name|sslKeystoreLocation
expr_stmt|;
block|}
DECL|method|getSslKeystorePassword ()
specifier|public
name|String
name|getSslKeystorePassword
parameter_list|()
block|{
return|return
name|sslKeystorePassword
return|;
block|}
comment|/**      * The store password for the key store file.This is optional for client and      * only needed if ssl.keystore.location is configured.      */
DECL|method|setSslKeystorePassword (String sslKeystorePassword)
specifier|public
name|void
name|setSslKeystorePassword
parameter_list|(
name|String
name|sslKeystorePassword
parameter_list|)
block|{
name|this
operator|.
name|sslKeystorePassword
operator|=
name|sslKeystorePassword
expr_stmt|;
block|}
DECL|method|getSslTruststoreLocation ()
specifier|public
name|String
name|getSslTruststoreLocation
parameter_list|()
block|{
return|return
name|sslTruststoreLocation
return|;
block|}
comment|/**      * The location of the trust store file.      */
DECL|method|setSslTruststoreLocation (String sslTruststoreLocation)
specifier|public
name|void
name|setSslTruststoreLocation
parameter_list|(
name|String
name|sslTruststoreLocation
parameter_list|)
block|{
name|this
operator|.
name|sslTruststoreLocation
operator|=
name|sslTruststoreLocation
expr_stmt|;
block|}
DECL|method|getSslTruststorePassword ()
specifier|public
name|String
name|getSslTruststorePassword
parameter_list|()
block|{
return|return
name|sslTruststorePassword
return|;
block|}
comment|/**      * The password for the trust store file.      */
DECL|method|setSslTruststorePassword (String sslTruststorePassword)
specifier|public
name|void
name|setSslTruststorePassword
parameter_list|(
name|String
name|sslTruststorePassword
parameter_list|)
block|{
name|this
operator|.
name|sslTruststorePassword
operator|=
name|sslTruststorePassword
expr_stmt|;
block|}
DECL|method|getBufferMemorySize ()
specifier|public
name|Integer
name|getBufferMemorySize
parameter_list|()
block|{
return|return
name|bufferMemorySize
return|;
block|}
comment|/**      * The total bytes of memory the producer can use to buffer records waiting      * to be sent to the server. If records are sent faster than they can be      * delivered to the server the producer will either block or throw an      * exception based on the preference specified by block.on.buffer.full.This      * setting should correspond roughly to the total memory the producer will      * use, but is not a hard bound since not all memory the producer uses is      * used for buffering. Some additional memory will be used for compression      * (if compression is enabled) as well as for maintaining in-flight      * requests.      */
DECL|method|setBufferMemorySize (Integer bufferMemorySize)
specifier|public
name|void
name|setBufferMemorySize
parameter_list|(
name|Integer
name|bufferMemorySize
parameter_list|)
block|{
name|this
operator|.
name|bufferMemorySize
operator|=
name|bufferMemorySize
expr_stmt|;
block|}
DECL|method|getKey ()
specifier|public
name|String
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
comment|/**      * The record key (or null if no key is specified). If this option has been      * configured then it take precedence over header {@link KafkaConstants#KEY}      */
DECL|method|setKey (String key)
specifier|public
name|void
name|setKey
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
block|}
DECL|method|getPartitionKey ()
specifier|public
name|Integer
name|getPartitionKey
parameter_list|()
block|{
return|return
name|partitionKey
return|;
block|}
comment|/**      * The partition to which the record will be sent (or null if no partition      * was specified). If this option has been configured then it take      * precedence over header {@link KafkaConstants#PARTITION_KEY}      */
DECL|method|setPartitionKey (Integer partitionKey)
specifier|public
name|void
name|setPartitionKey
parameter_list|(
name|Integer
name|partitionKey
parameter_list|)
block|{
name|this
operator|.
name|partitionKey
operator|=
name|partitionKey
expr_stmt|;
block|}
DECL|method|getRequestRequiredAcks ()
specifier|public
name|String
name|getRequestRequiredAcks
parameter_list|()
block|{
return|return
name|requestRequiredAcks
return|;
block|}
comment|/**      * The number of acknowledgments the producer requires the leader to have      * received before considering a request complete. This controls the      * durability of records that are sent. The following settings are common:      * acks=0 If set to zero then the producer will not wait for any      * acknowledgment from the server at all. The record will be immediately      * added to the socket buffer and considered sent. No guarantee can be made      * that the server has received the record in this case, and the retries      * configuration will not take effect (as the client won't generally know of      * any failures). The offset given back for each record will always be set      * to -1. acks=1 This will mean the leader will write the record to its      * local log but will respond without awaiting full acknowledgement from all      * followers. In this case should the leader fail immediately after      * acknowledging the record but before the followers have replicated it then      * the record will be lost. acks=all This means the leader will wait for the      * full set of in-sync replicas to acknowledge the record. This guarantees      * that the record will not be lost as long as at least one in-sync replica      * remains alive. This is the strongest available guarantee.      */
DECL|method|setRequestRequiredAcks (String requestRequiredAcks)
specifier|public
name|void
name|setRequestRequiredAcks
parameter_list|(
name|String
name|requestRequiredAcks
parameter_list|)
block|{
name|this
operator|.
name|requestRequiredAcks
operator|=
name|requestRequiredAcks
expr_stmt|;
block|}
DECL|method|getRetries ()
specifier|public
name|Integer
name|getRetries
parameter_list|()
block|{
return|return
name|retries
return|;
block|}
comment|/**      * Setting a value greater than zero will cause the client to resend any      * record whose send fails with a potentially transient error. Note that      * this retry is no different than if the client resent the record upon      * receiving the error. Allowing retries will potentially change the      * ordering of records because if two records are sent to a single      * partition, and the first fails and is retried but the second succeeds,      * then the second record may appear first.      */
DECL|method|setRetries (Integer retries)
specifier|public
name|void
name|setRetries
parameter_list|(
name|Integer
name|retries
parameter_list|)
block|{
name|this
operator|.
name|retries
operator|=
name|retries
expr_stmt|;
block|}
DECL|method|getProducerBatchSize ()
specifier|public
name|Integer
name|getProducerBatchSize
parameter_list|()
block|{
return|return
name|producerBatchSize
return|;
block|}
comment|/**      * The producer will attempt to batch records together into fewer requests      * whenever multiple records are being sent to the same partition. This      * helps performance on both the client and the server. This configuration      * controls the default batch size in bytes. No attempt will be made to      * batch records larger than this size.Requests sent to brokers will contain      * multiple batches, one for each partition with data available to be sent.A      * small batch size will make batching less common and may reduce throughput      * (a batch size of zero will disable batching entirely). A very large batch      * size may use memory a bit more wastefully as we will always allocate a      * buffer of the specified batch size in anticipation of additional records.      */
DECL|method|setProducerBatchSize (Integer producerBatchSize)
specifier|public
name|void
name|setProducerBatchSize
parameter_list|(
name|Integer
name|producerBatchSize
parameter_list|)
block|{
name|this
operator|.
name|producerBatchSize
operator|=
name|producerBatchSize
expr_stmt|;
block|}
DECL|method|getConnectionMaxIdleMs ()
specifier|public
name|Integer
name|getConnectionMaxIdleMs
parameter_list|()
block|{
return|return
name|connectionMaxIdleMs
return|;
block|}
comment|/**      * Close idle connections after the number of milliseconds specified by this      * config.      */
DECL|method|setConnectionMaxIdleMs (Integer connectionMaxIdleMs)
specifier|public
name|void
name|setConnectionMaxIdleMs
parameter_list|(
name|Integer
name|connectionMaxIdleMs
parameter_list|)
block|{
name|this
operator|.
name|connectionMaxIdleMs
operator|=
name|connectionMaxIdleMs
expr_stmt|;
block|}
DECL|method|getLingerMs ()
specifier|public
name|Integer
name|getLingerMs
parameter_list|()
block|{
return|return
name|lingerMs
return|;
block|}
comment|/**      * The producer groups together any records that arrive in between request      * transmissions into a single batched request. Normally this occurs only      * under load when records arrive faster than they can be sent out. However      * in some circumstances the client may want to reduce the number of      * requests even under moderate load. This setting accomplishes this by      * adding a small amount of artificial delaythat is, rather than      * immediately sending out a record the producer will wait for up to the      * given delay to allow other records to be sent so that the sends can be      * batched together. This can be thought of as analogous to Nagle's      * algorithm in TCP. This setting gives the upper bound on the delay for      * batching: once we get batch.size worth of records for a partition it will      * be sent immediately regardless of this setting, however if we have fewer      * than this many bytes accumulated for this partition we will 'linger' for      * the specified time waiting for more records to show up. This setting      * defaults to 0 (i.e. no delay). Setting linger.ms=5, for example, would      * have the effect of reducing the number of requests sent but would add up      * to 5ms of latency to records sent in the absense of load.      */
DECL|method|setLingerMs (Integer lingerMs)
specifier|public
name|void
name|setLingerMs
parameter_list|(
name|Integer
name|lingerMs
parameter_list|)
block|{
name|this
operator|.
name|lingerMs
operator|=
name|lingerMs
expr_stmt|;
block|}
DECL|method|getMaxBlockMs ()
specifier|public
name|Integer
name|getMaxBlockMs
parameter_list|()
block|{
return|return
name|maxBlockMs
return|;
block|}
comment|/**      * The configuration controls how long sending to kafka will block. These      * methods can be blocked for multiple reasons. For e.g: buffer full,      * metadata unavailable.This configuration imposes maximum limit on the      * total time spent in fetching metadata, serialization of key and value,      * partitioning and allocation of buffer memory when doing a send(). In case      * of partitionsFor(), this configuration imposes a maximum time threshold      * on waiting for metadata      */
DECL|method|setMaxBlockMs (Integer maxBlockMs)
specifier|public
name|void
name|setMaxBlockMs
parameter_list|(
name|Integer
name|maxBlockMs
parameter_list|)
block|{
name|this
operator|.
name|maxBlockMs
operator|=
name|maxBlockMs
expr_stmt|;
block|}
DECL|method|getMaxRequestSize ()
specifier|public
name|Integer
name|getMaxRequestSize
parameter_list|()
block|{
return|return
name|maxRequestSize
return|;
block|}
comment|/**      * The maximum size of a request. This is also effectively a cap on the      * maximum record size. Note that the server has its own cap on record size      * which may be different from this. This setting will limit the number of      * record batches the producer will send in a single request to avoid      * sending huge requests.      */
DECL|method|setMaxRequestSize (Integer maxRequestSize)
specifier|public
name|void
name|setMaxRequestSize
parameter_list|(
name|Integer
name|maxRequestSize
parameter_list|)
block|{
name|this
operator|.
name|maxRequestSize
operator|=
name|maxRequestSize
expr_stmt|;
block|}
DECL|method|getReceiveBufferBytes ()
specifier|public
name|Integer
name|getReceiveBufferBytes
parameter_list|()
block|{
return|return
name|receiveBufferBytes
return|;
block|}
comment|/**      * The size of the TCP receive buffer (SO_RCVBUF) to use when reading data.      */
DECL|method|setReceiveBufferBytes (Integer receiveBufferBytes)
specifier|public
name|void
name|setReceiveBufferBytes
parameter_list|(
name|Integer
name|receiveBufferBytes
parameter_list|)
block|{
name|this
operator|.
name|receiveBufferBytes
operator|=
name|receiveBufferBytes
expr_stmt|;
block|}
DECL|method|getMaxInFlightRequest ()
specifier|public
name|Integer
name|getMaxInFlightRequest
parameter_list|()
block|{
return|return
name|maxInFlightRequest
return|;
block|}
comment|/**      * The maximum number of unacknowledged requests the client will send on a      * single connection before blocking. Note that if this setting is set to be      * greater than 1 and there are failed sends, there is a risk of message      * re-ordering due to retries (i.e., if retries are enabled).      */
DECL|method|setMaxInFlightRequest (Integer maxInFlightRequest)
specifier|public
name|void
name|setMaxInFlightRequest
parameter_list|(
name|Integer
name|maxInFlightRequest
parameter_list|)
block|{
name|this
operator|.
name|maxInFlightRequest
operator|=
name|maxInFlightRequest
expr_stmt|;
block|}
DECL|method|getMetadataMaxAgeMs ()
specifier|public
name|Integer
name|getMetadataMaxAgeMs
parameter_list|()
block|{
return|return
name|metadataMaxAgeMs
return|;
block|}
comment|/**      * The period of time in milliseconds after which we force a refresh of      * metadata even if we haven't seen any partition leadership changes to      * proactively discover any new brokers or partitions.      */
DECL|method|setMetadataMaxAgeMs (Integer metadataMaxAgeMs)
specifier|public
name|void
name|setMetadataMaxAgeMs
parameter_list|(
name|Integer
name|metadataMaxAgeMs
parameter_list|)
block|{
name|this
operator|.
name|metadataMaxAgeMs
operator|=
name|metadataMaxAgeMs
expr_stmt|;
block|}
DECL|method|getMetricReporters ()
specifier|public
name|String
name|getMetricReporters
parameter_list|()
block|{
return|return
name|metricReporters
return|;
block|}
comment|/**      * A list of classes to use as metrics reporters. Implementing the      * MetricReporter interface allows plugging in classes that will be notified      * of new metric creation. The JmxReporter is always included to register      * JMX statistics.      */
DECL|method|setMetricReporters (String metricReporters)
specifier|public
name|void
name|setMetricReporters
parameter_list|(
name|String
name|metricReporters
parameter_list|)
block|{
name|this
operator|.
name|metricReporters
operator|=
name|metricReporters
expr_stmt|;
block|}
DECL|method|getNoOfMetricsSample ()
specifier|public
name|Integer
name|getNoOfMetricsSample
parameter_list|()
block|{
return|return
name|noOfMetricsSample
return|;
block|}
comment|/**      * The number of samples maintained to compute metrics.      */
DECL|method|setNoOfMetricsSample (Integer noOfMetricsSample)
specifier|public
name|void
name|setNoOfMetricsSample
parameter_list|(
name|Integer
name|noOfMetricsSample
parameter_list|)
block|{
name|this
operator|.
name|noOfMetricsSample
operator|=
name|noOfMetricsSample
expr_stmt|;
block|}
DECL|method|getMetricsSampleWindowMs ()
specifier|public
name|Integer
name|getMetricsSampleWindowMs
parameter_list|()
block|{
return|return
name|metricsSampleWindowMs
return|;
block|}
comment|/**      * The number of samples maintained to compute metrics.      */
DECL|method|setMetricsSampleWindowMs (Integer metricsSampleWindowMs)
specifier|public
name|void
name|setMetricsSampleWindowMs
parameter_list|(
name|Integer
name|metricsSampleWindowMs
parameter_list|)
block|{
name|this
operator|.
name|metricsSampleWindowMs
operator|=
name|metricsSampleWindowMs
expr_stmt|;
block|}
DECL|method|getReconnectBackoffMs ()
specifier|public
name|Integer
name|getReconnectBackoffMs
parameter_list|()
block|{
return|return
name|reconnectBackoffMs
return|;
block|}
comment|/**      * The amount of time to wait before attempting to reconnect to a given      * host. This avoids repeatedly connecting to a host in a tight loop. This      * backoff applies to all requests sent by the consumer to the broker.      */
DECL|method|setReconnectBackoffMs (Integer reconnectBackoffMs)
specifier|public
name|void
name|setReconnectBackoffMs
parameter_list|(
name|Integer
name|reconnectBackoffMs
parameter_list|)
block|{
name|this
operator|.
name|reconnectBackoffMs
operator|=
name|reconnectBackoffMs
expr_stmt|;
block|}
DECL|method|getHeartbeatIntervalMs ()
specifier|public
name|Integer
name|getHeartbeatIntervalMs
parameter_list|()
block|{
return|return
name|heartbeatIntervalMs
return|;
block|}
comment|/**      * The expected time between heartbeats to the consumer coordinator when      * using Kafka's group management facilities. Heartbeats are used to ensure      * that the consumer's session stays active and to facilitate rebalancing      * when new consumers join or leave the group. The value must be set lower      * than session.timeout.ms, but typically should be set no higher than 1/3      * of that value. It can be adjusted even lower to control the expected time      * for normal rebalances.      */
DECL|method|setHeartbeatIntervalMs (Integer heartbeatIntervalMs)
specifier|public
name|void
name|setHeartbeatIntervalMs
parameter_list|(
name|Integer
name|heartbeatIntervalMs
parameter_list|)
block|{
name|this
operator|.
name|heartbeatIntervalMs
operator|=
name|heartbeatIntervalMs
expr_stmt|;
block|}
DECL|method|getMaxPartitionFetchBytes ()
specifier|public
name|Integer
name|getMaxPartitionFetchBytes
parameter_list|()
block|{
return|return
name|maxPartitionFetchBytes
return|;
block|}
comment|/**      * The maximum amount of data per-partition the server will return. The      * maximum total memory used for a request will be #partitions *      * max.partition.fetch.bytes. This size must be at least as large as the      * maximum message size the server allows or else it is possible for the      * producer to send messages larger than the consumer can fetch. If that      * happens, the consumer can get stuck trying to fetch a large message on a      * certain partition.      */
DECL|method|setMaxPartitionFetchBytes (Integer maxPartitionFetchBytes)
specifier|public
name|void
name|setMaxPartitionFetchBytes
parameter_list|(
name|Integer
name|maxPartitionFetchBytes
parameter_list|)
block|{
name|this
operator|.
name|maxPartitionFetchBytes
operator|=
name|maxPartitionFetchBytes
expr_stmt|;
block|}
DECL|method|getSessionTimeoutMs ()
specifier|public
name|Integer
name|getSessionTimeoutMs
parameter_list|()
block|{
return|return
name|sessionTimeoutMs
return|;
block|}
comment|/**      * The timeout used to detect failures when using Kafka's group management      * facilities.      */
DECL|method|setSessionTimeoutMs (Integer sessionTimeoutMs)
specifier|public
name|void
name|setSessionTimeoutMs
parameter_list|(
name|Integer
name|sessionTimeoutMs
parameter_list|)
block|{
name|this
operator|.
name|sessionTimeoutMs
operator|=
name|sessionTimeoutMs
expr_stmt|;
block|}
DECL|method|getMaxPollRecords ()
specifier|public
name|Integer
name|getMaxPollRecords
parameter_list|()
block|{
return|return
name|maxPollRecords
return|;
block|}
comment|/**      * The maximum number of records returned in a single call to poll()      */
DECL|method|setMaxPollRecords (Integer maxPollRecords)
specifier|public
name|void
name|setMaxPollRecords
parameter_list|(
name|Integer
name|maxPollRecords
parameter_list|)
block|{
name|this
operator|.
name|maxPollRecords
operator|=
name|maxPollRecords
expr_stmt|;
block|}
DECL|method|getPollTimeoutMs ()
specifier|public
name|Long
name|getPollTimeoutMs
parameter_list|()
block|{
return|return
name|pollTimeoutMs
return|;
block|}
comment|/**      * The timeout used when polling the KafkaConsumer.      */
DECL|method|setPollTimeoutMs (Long pollTimeoutMs)
specifier|public
name|void
name|setPollTimeoutMs
parameter_list|(
name|Long
name|pollTimeoutMs
parameter_list|)
block|{
name|this
operator|.
name|pollTimeoutMs
operator|=
name|pollTimeoutMs
expr_stmt|;
block|}
DECL|method|getMaxPollIntervalMs ()
specifier|public
name|Long
name|getMaxPollIntervalMs
parameter_list|()
block|{
return|return
name|maxPollIntervalMs
return|;
block|}
comment|/**      * The maximum delay between invocations of poll() when using consumer group      * management. This places an upper bound on the amount of time that the      * consumer can be idle before fetching more records. If poll() is not      * called before expiration of this timeout, then the consumer is considered      * failed and the group will rebalance in order to reassign the partitions      * to another member.      */
DECL|method|setMaxPollIntervalMs (Long maxPollIntervalMs)
specifier|public
name|void
name|setMaxPollIntervalMs
parameter_list|(
name|Long
name|maxPollIntervalMs
parameter_list|)
block|{
name|this
operator|.
name|maxPollIntervalMs
operator|=
name|maxPollIntervalMs
expr_stmt|;
block|}
DECL|method|getPartitionAssignor ()
specifier|public
name|String
name|getPartitionAssignor
parameter_list|()
block|{
return|return
name|partitionAssignor
return|;
block|}
comment|/**      * The class name of the partition assignment strategy that the client will      * use to distribute partition ownership amongst consumer instances when      * group management is used      */
DECL|method|setPartitionAssignor (String partitionAssignor)
specifier|public
name|void
name|setPartitionAssignor
parameter_list|(
name|String
name|partitionAssignor
parameter_list|)
block|{
name|this
operator|.
name|partitionAssignor
operator|=
name|partitionAssignor
expr_stmt|;
block|}
DECL|method|getConsumerRequestTimeoutMs ()
specifier|public
name|Integer
name|getConsumerRequestTimeoutMs
parameter_list|()
block|{
return|return
name|consumerRequestTimeoutMs
return|;
block|}
comment|/**      * The configuration controls the maximum amount of time the client will      * wait for the response of a request. If the response is not received      * before the timeout elapses the client will resend the request if      * necessary or fail the request if retries are exhausted.      */
DECL|method|setConsumerRequestTimeoutMs (Integer consumerRequestTimeoutMs)
specifier|public
name|void
name|setConsumerRequestTimeoutMs
parameter_list|(
name|Integer
name|consumerRequestTimeoutMs
parameter_list|)
block|{
name|this
operator|.
name|consumerRequestTimeoutMs
operator|=
name|consumerRequestTimeoutMs
expr_stmt|;
block|}
DECL|method|getCheckCrcs ()
specifier|public
name|Boolean
name|getCheckCrcs
parameter_list|()
block|{
return|return
name|checkCrcs
return|;
block|}
comment|/**      * Automatically check the CRC32 of the records consumed. This ensures no      * on-the-wire or on-disk corruption to the messages occurred. This check      * adds some overhead, so it may be disabled in cases seeking extreme      * performance.      */
DECL|method|setCheckCrcs (Boolean checkCrcs)
specifier|public
name|void
name|setCheckCrcs
parameter_list|(
name|Boolean
name|checkCrcs
parameter_list|)
block|{
name|this
operator|.
name|checkCrcs
operator|=
name|checkCrcs
expr_stmt|;
block|}
DECL|method|getKeyDeserializer ()
specifier|public
name|String
name|getKeyDeserializer
parameter_list|()
block|{
return|return
name|keyDeserializer
return|;
block|}
comment|/**      * Deserializer class for key that implements the Deserializer interface.      */
DECL|method|setKeyDeserializer (String keyDeserializer)
specifier|public
name|void
name|setKeyDeserializer
parameter_list|(
name|String
name|keyDeserializer
parameter_list|)
block|{
name|this
operator|.
name|keyDeserializer
operator|=
name|keyDeserializer
expr_stmt|;
block|}
DECL|method|getValueDeserializer ()
specifier|public
name|String
name|getValueDeserializer
parameter_list|()
block|{
return|return
name|valueDeserializer
return|;
block|}
comment|/**      * Deserializer class for value that implements the Deserializer interface.      */
DECL|method|setValueDeserializer (String valueDeserializer)
specifier|public
name|void
name|setValueDeserializer
parameter_list|(
name|String
name|valueDeserializer
parameter_list|)
block|{
name|this
operator|.
name|valueDeserializer
operator|=
name|valueDeserializer
expr_stmt|;
block|}
DECL|method|getSeekTo ()
specifier|public
name|String
name|getSeekTo
parameter_list|()
block|{
return|return
name|seekTo
return|;
block|}
comment|/**      * Set if KafkaConsumer will read from beginning or end on startup:      * beginning : read from beginning end : read from end This is replacing the      * earlier property seekToBeginning      */
DECL|method|setSeekTo (String seekTo)
specifier|public
name|void
name|setSeekTo
parameter_list|(
name|String
name|seekTo
parameter_list|)
block|{
name|this
operator|.
name|seekTo
operator|=
name|seekTo
expr_stmt|;
block|}
DECL|method|getWorkerPool ()
specifier|public
name|ExecutorService
name|getWorkerPool
parameter_list|()
block|{
return|return
name|workerPool
return|;
block|}
comment|/**      * To use a custom worker pool for continue routing {@link Exchange} after      * kafka server has acknowledge the message that was sent to it from      * {@link KafkaProducer} using asynchronous non-blocking processing.      */
DECL|method|setWorkerPool (ExecutorService workerPool)
specifier|public
name|void
name|setWorkerPool
parameter_list|(
name|ExecutorService
name|workerPool
parameter_list|)
block|{
name|this
operator|.
name|workerPool
operator|=
name|workerPool
expr_stmt|;
block|}
DECL|method|getWorkerPoolCoreSize ()
specifier|public
name|Integer
name|getWorkerPoolCoreSize
parameter_list|()
block|{
return|return
name|workerPoolCoreSize
return|;
block|}
comment|/**      * Number of core threads for the worker pool for continue routing      * {@link Exchange} after kafka server has acknowledge the message that was      * sent to it from {@link KafkaProducer} using asynchronous non-blocking      * processing.      */
DECL|method|setWorkerPoolCoreSize (Integer workerPoolCoreSize)
specifier|public
name|void
name|setWorkerPoolCoreSize
parameter_list|(
name|Integer
name|workerPoolCoreSize
parameter_list|)
block|{
name|this
operator|.
name|workerPoolCoreSize
operator|=
name|workerPoolCoreSize
expr_stmt|;
block|}
DECL|method|getWorkerPoolMaxSize ()
specifier|public
name|Integer
name|getWorkerPoolMaxSize
parameter_list|()
block|{
return|return
name|workerPoolMaxSize
return|;
block|}
comment|/**      * Maximum number of threads for the worker pool for continue routing      * {@link Exchange} after kafka server has acknowledge the message that was      * sent to it from {@link KafkaProducer} using asynchronous non-blocking      * processing.      */
DECL|method|setWorkerPoolMaxSize (Integer workerPoolMaxSize)
specifier|public
name|void
name|setWorkerPoolMaxSize
parameter_list|(
name|Integer
name|workerPoolMaxSize
parameter_list|)
block|{
name|this
operator|.
name|workerPoolMaxSize
operator|=
name|workerPoolMaxSize
expr_stmt|;
block|}
DECL|method|isRecordMetadata ()
specifier|public
name|boolean
name|isRecordMetadata
parameter_list|()
block|{
return|return
name|recordMetadata
return|;
block|}
comment|/**      * Whether the producer should store the {@link RecordMetadata} results from      * sending to Kafka. The results are stored in a {@link List} containing the      * {@link RecordMetadata} metadata's. The list is stored on a header with      * the key {@link KafkaConstants#KAFKA_RECORDMETA}      */
DECL|method|setRecordMetadata (boolean recordMetadata)
specifier|public
name|void
name|setRecordMetadata
parameter_list|(
name|boolean
name|recordMetadata
parameter_list|)
block|{
name|this
operator|.
name|recordMetadata
operator|=
name|recordMetadata
expr_stmt|;
block|}
DECL|method|getInterceptorClasses ()
specifier|public
name|String
name|getInterceptorClasses
parameter_list|()
block|{
return|return
name|interceptorClasses
return|;
block|}
comment|/**      * Sets interceptors for producer or consumers. Producer interceptors have      * to be classes implementing      * {@link org.apache.kafka.clients.producer.ProducerInterceptor} Consumer      * interceptors have to be classes implementing      * {@link org.apache.kafka.clients.consumer.ConsumerInterceptor} Note that      * if you use Producer interceptor on a consumer it will throw a class cast      * exception in runtime      */
DECL|method|setInterceptorClasses (String interceptorClasses)
specifier|public
name|void
name|setInterceptorClasses
parameter_list|(
name|String
name|interceptorClasses
parameter_list|)
block|{
name|this
operator|.
name|interceptorClasses
operator|=
name|interceptorClasses
expr_stmt|;
block|}
DECL|method|isEnableIdempotence ()
specifier|public
name|boolean
name|isEnableIdempotence
parameter_list|()
block|{
return|return
name|enableIdempotence
return|;
block|}
comment|/**      * If set to 'true' the producer will ensure that exactly one copy of each      * message is written in the stream. If 'false', producer retries may write      * duplicates of the retried message in the stream. If set to true this      * option will require max.in.flight.requests.per.connection to be set to 1      * and retries cannot be zero and additionally acks must be set to 'all'.      */
DECL|method|setEnableIdempotence (boolean enableIdempotence)
specifier|public
name|void
name|setEnableIdempotence
parameter_list|(
name|boolean
name|enableIdempotence
parameter_list|)
block|{
name|this
operator|.
name|enableIdempotence
operator|=
name|enableIdempotence
expr_stmt|;
block|}
DECL|method|getReconnectBackoffMaxMs ()
specifier|public
name|Integer
name|getReconnectBackoffMaxMs
parameter_list|()
block|{
return|return
name|reconnectBackoffMaxMs
return|;
block|}
comment|/**      * The maximum amount of time in milliseconds to wait when reconnecting to a      * broker that has repeatedly failed to connect. If provided, the backoff      * per host will increase exponentially for each consecutive connection      * failure, up to this maximum. After calculating the backoff increase, 20%      * random jitter is added to avoid connection storms.      */
DECL|method|setReconnectBackoffMaxMs (Integer reconnectBackoffMaxMs)
specifier|public
name|void
name|setReconnectBackoffMaxMs
parameter_list|(
name|Integer
name|reconnectBackoffMaxMs
parameter_list|)
block|{
name|this
operator|.
name|reconnectBackoffMaxMs
operator|=
name|reconnectBackoffMaxMs
expr_stmt|;
block|}
DECL|method|getHeaderFilterStrategy ()
specifier|public
name|HeaderFilterStrategy
name|getHeaderFilterStrategy
parameter_list|()
block|{
return|return
name|headerFilterStrategy
return|;
block|}
comment|/**      * To use a custom HeaderFilterStrategy to filter header to and from Camel      * message.      */
DECL|method|setHeaderFilterStrategy (HeaderFilterStrategy headerFilterStrategy)
specifier|public
name|void
name|setHeaderFilterStrategy
parameter_list|(
name|HeaderFilterStrategy
name|headerFilterStrategy
parameter_list|)
block|{
name|this
operator|.
name|headerFilterStrategy
operator|=
name|headerFilterStrategy
expr_stmt|;
block|}
DECL|method|getKafkaHeaderDeserializer ()
specifier|public
name|KafkaHeaderDeserializer
name|getKafkaHeaderDeserializer
parameter_list|()
block|{
return|return
name|kafkaHeaderDeserializer
return|;
block|}
comment|/**      * Sets custom KafkaHeaderDeserializer for deserialization kafka headers      * values to camel headers values.      *      * @param kafkaHeaderDeserializer custom kafka header deserializer to be      *            used      */
DECL|method|setKafkaHeaderDeserializer (final KafkaHeaderDeserializer kafkaHeaderDeserializer)
specifier|public
name|void
name|setKafkaHeaderDeserializer
parameter_list|(
specifier|final
name|KafkaHeaderDeserializer
name|kafkaHeaderDeserializer
parameter_list|)
block|{
name|this
operator|.
name|kafkaHeaderDeserializer
operator|=
name|kafkaHeaderDeserializer
expr_stmt|;
block|}
DECL|method|getKafkaHeaderSerializer ()
specifier|public
name|KafkaHeaderSerializer
name|getKafkaHeaderSerializer
parameter_list|()
block|{
return|return
name|kafkaHeaderSerializer
return|;
block|}
comment|/**      * Sets custom KafkaHeaderDeserializer for serialization camel headers      * values to kafka headers values.      *      * @param kafkaHeaderSerializer custom kafka header serializer to be used      */
DECL|method|setKafkaHeaderSerializer (final KafkaHeaderSerializer kafkaHeaderSerializer)
specifier|public
name|void
name|setKafkaHeaderSerializer
parameter_list|(
specifier|final
name|KafkaHeaderSerializer
name|kafkaHeaderSerializer
parameter_list|)
block|{
name|this
operator|.
name|kafkaHeaderSerializer
operator|=
name|kafkaHeaderSerializer
expr_stmt|;
block|}
block|}
end_class

end_unit

