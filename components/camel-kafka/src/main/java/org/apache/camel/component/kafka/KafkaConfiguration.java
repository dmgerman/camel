begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.component.kafka
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|kafka
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|kafka
operator|.
name|producer
operator|.
name|DefaultPartitioner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|Metadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|UriParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|UriParams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|UriPath
import|;
end_import

begin_class
annotation|@
name|UriParams
DECL|class|KafkaConfiguration
specifier|public
class|class
name|KafkaConfiguration
block|{
annotation|@
name|UriParam
DECL|field|zookeeperConnect
specifier|private
name|String
name|zookeeperConnect
decl_stmt|;
annotation|@
name|UriParam
DECL|field|zookeeperHost
specifier|private
name|String
name|zookeeperHost
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|defaultValue
operator|=
literal|"2181"
argument_list|)
DECL|field|zookeeperPort
specifier|private
name|int
name|zookeeperPort
init|=
literal|2181
decl_stmt|;
annotation|@
name|UriParam
annotation|@
name|Metadata
argument_list|(
name|required
operator|=
literal|"true"
argument_list|)
DECL|field|topic
specifier|private
name|String
name|topic
decl_stmt|;
annotation|@
name|UriParam
DECL|field|groupId
specifier|private
name|String
name|groupId
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|defaultValue
operator|=
literal|"DefaultPartitioner"
argument_list|)
DECL|field|partitioner
specifier|private
name|String
name|partitioner
init|=
name|DefaultPartitioner
operator|.
name|class
operator|.
name|getCanonicalName
argument_list|()
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"10"
argument_list|)
DECL|field|consumerStreams
specifier|private
name|int
name|consumerStreams
init|=
literal|10
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"1"
argument_list|)
DECL|field|consumersCount
specifier|private
name|int
name|consumersCount
init|=
literal|1
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"100"
argument_list|)
DECL|field|batchSize
specifier|private
name|int
name|batchSize
init|=
literal|100
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"10000"
argument_list|)
DECL|field|barrierAwaitTimeoutMs
specifier|private
name|int
name|barrierAwaitTimeoutMs
init|=
literal|10000
decl_stmt|;
comment|//Common configuration properties
annotation|@
name|UriParam
DECL|field|clientId
specifier|private
name|String
name|clientId
decl_stmt|;
comment|//Consumer configuration properties
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|)
DECL|field|consumerId
specifier|private
name|String
name|consumerId
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"30000"
argument_list|)
DECL|field|socketTimeoutMs
specifier|private
name|Integer
name|socketTimeoutMs
init|=
literal|30
operator|*
literal|1000
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|""
operator|+
literal|64
operator|*
literal|1024
argument_list|)
DECL|field|socketReceiveBufferBytes
specifier|private
name|Integer
name|socketReceiveBufferBytes
init|=
literal|64
operator|*
literal|1024
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|""
operator|+
literal|1024
operator|*
literal|1024
argument_list|)
DECL|field|fetchMessageMaxBytes
specifier|private
name|Integer
name|fetchMessageMaxBytes
init|=
literal|1024
operator|*
literal|1024
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"true"
argument_list|)
DECL|field|autoCommitEnable
specifier|private
name|Boolean
name|autoCommitEnable
init|=
literal|true
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"60000"
argument_list|)
DECL|field|autoCommitIntervalMs
specifier|private
name|Integer
name|autoCommitIntervalMs
init|=
literal|60
operator|*
literal|1000
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"2"
argument_list|)
DECL|field|queuedMaxMessageChunks
specifier|private
name|Integer
name|queuedMaxMessageChunks
init|=
literal|2
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"4"
argument_list|)
DECL|field|rebalanceMaxRetries
specifier|private
name|Integer
name|rebalanceMaxRetries
init|=
literal|4
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"1"
argument_list|)
DECL|field|fetchMinBytes
specifier|private
name|Integer
name|fetchMinBytes
init|=
literal|1
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"100"
argument_list|)
DECL|field|fetchWaitMaxMs
specifier|private
name|Integer
name|fetchWaitMaxMs
init|=
literal|100
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"2000"
argument_list|)
DECL|field|rebalanceBackoffMs
specifier|private
name|Integer
name|rebalanceBackoffMs
init|=
literal|2000
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"200"
argument_list|)
DECL|field|refreshLeaderBackoffMs
specifier|private
name|Integer
name|refreshLeaderBackoffMs
init|=
literal|200
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"largest"
argument_list|,
name|enums
operator|=
literal|"smallest,largest,fail"
argument_list|)
DECL|field|autoOffsetReset
specifier|private
name|String
name|autoOffsetReset
init|=
literal|"largest"
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|)
DECL|field|consumerTimeoutMs
specifier|private
name|Integer
name|consumerTimeoutMs
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"zookeeper"
argument_list|,
name|enums
operator|=
literal|"zookeeper,kafka"
argument_list|)
DECL|field|offsetsStorage
specifier|private
name|String
name|offsetsStorage
init|=
literal|"zookeeper"
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"consumer"
argument_list|,
name|defaultValue
operator|=
literal|"true"
argument_list|)
DECL|field|dualCommitEnabled
specifier|private
name|Boolean
name|dualCommitEnabled
init|=
literal|true
decl_stmt|;
comment|//Zookeepr configuration properties
annotation|@
name|UriParam
DECL|field|zookeeperSessionTimeoutMs
specifier|private
name|Integer
name|zookeeperSessionTimeoutMs
decl_stmt|;
annotation|@
name|UriParam
DECL|field|zookeeperConnectionTimeoutMs
specifier|private
name|Integer
name|zookeeperConnectionTimeoutMs
decl_stmt|;
annotation|@
name|UriParam
DECL|field|zookeeperSyncTimeMs
specifier|private
name|Integer
name|zookeeperSyncTimeMs
decl_stmt|;
comment|//Producer configuration properties
annotation|@
name|UriPath
DECL|field|brokers
specifier|private
name|String
name|brokers
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"sync"
argument_list|,
name|enums
operator|=
literal|"async,sync"
argument_list|)
DECL|field|producerType
specifier|private
name|String
name|producerType
init|=
literal|"sync"
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"none"
argument_list|,
name|enums
operator|=
literal|"none,gzip,snappy"
argument_list|)
DECL|field|compressionCodec
specifier|private
name|String
name|compressionCodec
init|=
literal|"none"
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|)
DECL|field|compressedTopics
specifier|private
name|String
name|compressedTopics
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"3"
argument_list|)
DECL|field|messageSendMaxRetries
specifier|private
name|Integer
name|messageSendMaxRetries
init|=
literal|3
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"100"
argument_list|)
DECL|field|retryBackoffMs
specifier|private
name|Integer
name|retryBackoffMs
init|=
literal|100
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"600000"
argument_list|)
DECL|field|topicMetadataRefreshIntervalMs
specifier|private
name|Integer
name|topicMetadataRefreshIntervalMs
init|=
literal|600
operator|*
literal|1000
decl_stmt|;
comment|//Sync producer config
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|""
operator|+
literal|100
operator|*
literal|1024
argument_list|)
DECL|field|sendBufferBytes
specifier|private
name|Integer
name|sendBufferBytes
init|=
literal|100
operator|*
literal|1024
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"0"
argument_list|)
DECL|field|requestRequiredAcks
specifier|private
name|short
name|requestRequiredAcks
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"10000"
argument_list|)
DECL|field|requestTimeoutMs
specifier|private
name|Integer
name|requestTimeoutMs
init|=
literal|10000
decl_stmt|;
comment|//Async producer config
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"5000"
argument_list|)
DECL|field|queueBufferingMaxMs
specifier|private
name|Integer
name|queueBufferingMaxMs
init|=
literal|5000
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"10000"
argument_list|)
DECL|field|queueBufferingMaxMessages
specifier|private
name|Integer
name|queueBufferingMaxMessages
init|=
literal|10000
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|)
DECL|field|queueEnqueueTimeoutMs
specifier|private
name|Integer
name|queueEnqueueTimeoutMs
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|,
name|defaultValue
operator|=
literal|"200"
argument_list|)
DECL|field|batchNumMessages
specifier|private
name|Integer
name|batchNumMessages
init|=
literal|200
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|)
DECL|field|serializerClass
specifier|private
name|String
name|serializerClass
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
literal|"producer"
argument_list|)
DECL|field|keySerializerClass
specifier|private
name|String
name|keySerializerClass
decl_stmt|;
DECL|method|KafkaConfiguration ()
specifier|public
name|KafkaConfiguration
parameter_list|()
block|{     }
DECL|method|createProducerProperties ()
specifier|public
name|Properties
name|createProducerProperties
parameter_list|()
block|{
name|Properties
name|props
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"request.required.acks"
argument_list|,
name|getRequestRequiredAcks
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"partitioner.class"
argument_list|,
name|getPartitioner
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"serializer.class"
argument_list|,
name|getSerializerClass
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"key.serializer.class"
argument_list|,
name|getKeySerializerClass
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"request.timeout.ms"
argument_list|,
name|getRequestTimeoutMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"producer.type"
argument_list|,
name|getProducerType
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"compression.codec"
argument_list|,
name|getCompressionCodec
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"compressed.topics"
argument_list|,
name|getCompressedTopics
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"message.send.max.retries"
argument_list|,
name|getMessageSendMaxRetries
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"retry.backoff.ms"
argument_list|,
name|getRetryBackoffMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"topic.metadata.refresh.interval.ms"
argument_list|,
name|getTopicMetadataRefreshIntervalMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"queue.buffering.max.ms"
argument_list|,
name|getQueueBufferingMaxMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"queue.buffering.max.messages"
argument_list|,
name|getQueueBufferingMaxMessages
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"queue.enqueue.timeout.ms"
argument_list|,
name|getQueueEnqueueTimeoutMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"batch.num.messages"
argument_list|,
name|getBatchNumMessages
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"send.buffer.bytes"
argument_list|,
name|getSendBufferBytes
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"client.id"
argument_list|,
name|getClientId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|props
return|;
block|}
DECL|method|createConsumerProperties ()
specifier|public
name|Properties
name|createConsumerProperties
parameter_list|()
block|{
name|Properties
name|props
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"consumer.id"
argument_list|,
name|getConsumerId
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"socket.timeout.ms"
argument_list|,
name|getSocketTimeoutMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"socket.receive.buffer.bytes"
argument_list|,
name|getSocketReceiveBufferBytes
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"fetch.message.max.bytes"
argument_list|,
name|getFetchMessageMaxBytes
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"auto.commit.enable"
argument_list|,
name|isAutoCommitEnable
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"auto.commit.interval.ms"
argument_list|,
name|getAutoCommitIntervalMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"queued.max.message.chunks"
argument_list|,
name|getQueueBufferingMaxMessages
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"fetch.min.bytes"
argument_list|,
name|getFetchMinBytes
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"fetch.wait.max.ms"
argument_list|,
name|getFetchWaitMaxMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"queued.max.message.chunks"
argument_list|,
name|getQueuedMaxMessageChunks
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"rebalance.max.retries"
argument_list|,
name|getRebalanceMaxRetries
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"rebalance.backoff.ms"
argument_list|,
name|getRebalanceBackoffMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"refresh.leader.backoff.ms"
argument_list|,
name|getRefreshLeaderBackoffMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"auto.offset.reset"
argument_list|,
name|getAutoOffsetReset
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"consumer.timeout.ms"
argument_list|,
name|getConsumerTimeoutMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"client.id"
argument_list|,
name|getClientId
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"zookeeper.session.timeout.ms"
argument_list|,
name|getZookeeperSessionTimeoutMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"zookeeper.connection.timeout.ms"
argument_list|,
name|getZookeeperConnectionTimeoutMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"zookeeper.sync.time.ms"
argument_list|,
name|getZookeeperSyncTimeMs
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"offsets.storage"
argument_list|,
name|getOffsetsStorage
argument_list|()
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|props
argument_list|,
literal|"dual.commit.enabled"
argument_list|,
name|isDualCommitEnabled
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|props
return|;
block|}
DECL|method|addPropertyIfNotNull (Properties props, String key, T value)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|void
name|addPropertyIfNotNull
parameter_list|(
name|Properties
name|props
parameter_list|,
name|String
name|key
parameter_list|,
name|T
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
comment|// Kafka expects all properties as String
name|props
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getZookeeperConnect ()
specifier|public
name|String
name|getZookeeperConnect
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|zookeeperConnect
operator|!=
literal|null
condition|)
block|{
return|return
name|zookeeperConnect
return|;
block|}
else|else
block|{
return|return
name|getZookeeperHost
argument_list|()
operator|+
literal|":"
operator|+
name|getZookeeperPort
argument_list|()
return|;
block|}
block|}
comment|/**      * Specifies the ZooKeeper connection string in the form hostname:port where host and port are the host and port of a ZooKeeper server.      * To allow connecting through other ZooKeeper nodes when that ZooKeeper machine is down you can also specify multiple hosts in the      * form hostname1:port1,hostname2:port2,hostname3:port3.      * The server may also have a ZooKeeper chroot path as part of it's ZooKeeper connection string which puts its data      * under some path in the global ZooKeeper namespace. If so the consumer should use the same chroot path in its connection string.      * For example to give a chroot path of /chroot/path you would give the connection      * string as hostname1:port1,hostname2:port2,hostname3:port3/chroot/path.      */
DECL|method|setZookeeperConnect (String zookeeperConnect)
specifier|public
name|void
name|setZookeeperConnect
parameter_list|(
name|String
name|zookeeperConnect
parameter_list|)
block|{
name|this
operator|.
name|zookeeperConnect
operator|=
name|zookeeperConnect
expr_stmt|;
comment|// connect overrides host and port
name|this
operator|.
name|zookeeperHost
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|zookeeperPort
operator|=
operator|-
literal|1
expr_stmt|;
block|}
DECL|method|getZookeeperHost ()
specifier|public
name|String
name|getZookeeperHost
parameter_list|()
block|{
return|return
name|zookeeperHost
return|;
block|}
comment|/**      * The zookeeper host to use.      *<p/>      * To connect to multiple zookeeper hosts use the zookeeperConnect option instead.      *<p/>      * This option can only be used if zookeeperConnect is not in use.      */
DECL|method|setZookeeperHost (String zookeeperHost)
specifier|public
name|void
name|setZookeeperHost
parameter_list|(
name|String
name|zookeeperHost
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|zookeeperConnect
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|zookeeperHost
operator|=
name|zookeeperHost
expr_stmt|;
block|}
block|}
DECL|method|getZookeeperPort ()
specifier|public
name|int
name|getZookeeperPort
parameter_list|()
block|{
return|return
name|zookeeperPort
return|;
block|}
comment|/**      * The zookeeper port to use      *<p/>      * To connect to multiple zookeeper hosts use the zookeeperConnect option instead.      *<p/>      * This option can only be used if zookeeperConnect is not in use.      */
DECL|method|setZookeeperPort (int zookeeperPort)
specifier|public
name|void
name|setZookeeperPort
parameter_list|(
name|int
name|zookeeperPort
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|zookeeperConnect
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|zookeeperPort
operator|=
name|zookeeperPort
expr_stmt|;
block|}
block|}
DECL|method|getGroupId ()
specifier|public
name|String
name|getGroupId
parameter_list|()
block|{
return|return
name|groupId
return|;
block|}
comment|/**      * A string that uniquely identifies the group of consumer processes to which this consumer belongs.      * By setting the same group id multiple processes indicate that they are all part of the same consumer group.      */
DECL|method|setGroupId (String groupId)
specifier|public
name|void
name|setGroupId
parameter_list|(
name|String
name|groupId
parameter_list|)
block|{
name|this
operator|.
name|groupId
operator|=
name|groupId
expr_stmt|;
block|}
DECL|method|getPartitioner ()
specifier|public
name|String
name|getPartitioner
parameter_list|()
block|{
return|return
name|partitioner
return|;
block|}
comment|/**      * The partitioner class for partitioning messages amongst sub-topics. The default partitioner is based on the hash of the key.      */
DECL|method|setPartitioner (String partitioner)
specifier|public
name|void
name|setPartitioner
parameter_list|(
name|String
name|partitioner
parameter_list|)
block|{
name|this
operator|.
name|partitioner
operator|=
name|partitioner
expr_stmt|;
block|}
DECL|method|getTopic ()
specifier|public
name|String
name|getTopic
parameter_list|()
block|{
return|return
name|topic
return|;
block|}
comment|/**      * Name of the topic to use      */
DECL|method|setTopic (String topic)
specifier|public
name|void
name|setTopic
parameter_list|(
name|String
name|topic
parameter_list|)
block|{
name|this
operator|.
name|topic
operator|=
name|topic
expr_stmt|;
block|}
DECL|method|getConsumerStreams ()
specifier|public
name|int
name|getConsumerStreams
parameter_list|()
block|{
return|return
name|consumerStreams
return|;
block|}
comment|/**      * Number of concurrent consumers on the consumer      */
DECL|method|setConsumerStreams (int consumerStreams)
specifier|public
name|void
name|setConsumerStreams
parameter_list|(
name|int
name|consumerStreams
parameter_list|)
block|{
name|this
operator|.
name|consumerStreams
operator|=
name|consumerStreams
expr_stmt|;
block|}
DECL|method|getBatchSize ()
specifier|public
name|int
name|getBatchSize
parameter_list|()
block|{
return|return
name|batchSize
return|;
block|}
comment|/**      * The batchSize that the BatchingConsumerTask processes once.      */
DECL|method|setBatchSize (int batchSize)
specifier|public
name|void
name|setBatchSize
parameter_list|(
name|int
name|batchSize
parameter_list|)
block|{
name|this
operator|.
name|batchSize
operator|=
name|batchSize
expr_stmt|;
block|}
DECL|method|getBarrierAwaitTimeoutMs ()
specifier|public
name|int
name|getBarrierAwaitTimeoutMs
parameter_list|()
block|{
return|return
name|barrierAwaitTimeoutMs
return|;
block|}
comment|/**      * If the BatchingConsumerTask processes exchange exceed the batchSize, it will wait for barrierAwaitTimeoutMs.      */
DECL|method|setBarrierAwaitTimeoutMs (int barrierAwaitTimeoutMs)
specifier|public
name|void
name|setBarrierAwaitTimeoutMs
parameter_list|(
name|int
name|barrierAwaitTimeoutMs
parameter_list|)
block|{
name|this
operator|.
name|barrierAwaitTimeoutMs
operator|=
name|barrierAwaitTimeoutMs
expr_stmt|;
block|}
DECL|method|getConsumersCount ()
specifier|public
name|int
name|getConsumersCount
parameter_list|()
block|{
return|return
name|consumersCount
return|;
block|}
comment|/**      * The number of consumers that connect to kafka server      */
DECL|method|setConsumersCount (int consumersCount)
specifier|public
name|void
name|setConsumersCount
parameter_list|(
name|int
name|consumersCount
parameter_list|)
block|{
name|this
operator|.
name|consumersCount
operator|=
name|consumersCount
expr_stmt|;
block|}
DECL|method|getClientId ()
specifier|public
name|String
name|getClientId
parameter_list|()
block|{
return|return
name|clientId
return|;
block|}
comment|/**      * The client id is a user-specified string sent in each request to help trace calls.      * It should logically identify the application making the request.      */
DECL|method|setClientId (String clientId)
specifier|public
name|void
name|setClientId
parameter_list|(
name|String
name|clientId
parameter_list|)
block|{
name|this
operator|.
name|clientId
operator|=
name|clientId
expr_stmt|;
block|}
DECL|method|getConsumerId ()
specifier|public
name|String
name|getConsumerId
parameter_list|()
block|{
return|return
name|consumerId
return|;
block|}
comment|/**      * Generated automatically if not set.      */
DECL|method|setConsumerId (String consumerId)
specifier|public
name|void
name|setConsumerId
parameter_list|(
name|String
name|consumerId
parameter_list|)
block|{
name|this
operator|.
name|consumerId
operator|=
name|consumerId
expr_stmt|;
block|}
DECL|method|getSocketTimeoutMs ()
specifier|public
name|Integer
name|getSocketTimeoutMs
parameter_list|()
block|{
return|return
name|socketTimeoutMs
return|;
block|}
comment|/**      * The socket timeout for network requests. The actual timeout set will be max.fetch.wait + socket.timeout.ms.      */
DECL|method|setSocketTimeoutMs (Integer socketTimeoutMs)
specifier|public
name|void
name|setSocketTimeoutMs
parameter_list|(
name|Integer
name|socketTimeoutMs
parameter_list|)
block|{
name|this
operator|.
name|socketTimeoutMs
operator|=
name|socketTimeoutMs
expr_stmt|;
block|}
DECL|method|getSocketReceiveBufferBytes ()
specifier|public
name|Integer
name|getSocketReceiveBufferBytes
parameter_list|()
block|{
return|return
name|socketReceiveBufferBytes
return|;
block|}
comment|/**      * The socket receive buffer for network requests      */
DECL|method|setSocketReceiveBufferBytes (Integer socketReceiveBufferBytes)
specifier|public
name|void
name|setSocketReceiveBufferBytes
parameter_list|(
name|Integer
name|socketReceiveBufferBytes
parameter_list|)
block|{
name|this
operator|.
name|socketReceiveBufferBytes
operator|=
name|socketReceiveBufferBytes
expr_stmt|;
block|}
DECL|method|getFetchMessageMaxBytes ()
specifier|public
name|Integer
name|getFetchMessageMaxBytes
parameter_list|()
block|{
return|return
name|fetchMessageMaxBytes
return|;
block|}
comment|/**      * The number of byes of messages to attempt to fetch for each topic-partition in each fetch request.      * These bytes will be read into memory for each partition, so this helps control the memory used by the consumer.      * The fetch request size must be at least as large as the maximum message size the server allows or else it      * is possible for the producer to send messages larger than the consumer can fetch.      */
DECL|method|setFetchMessageMaxBytes (Integer fetchMessageMaxBytes)
specifier|public
name|void
name|setFetchMessageMaxBytes
parameter_list|(
name|Integer
name|fetchMessageMaxBytes
parameter_list|)
block|{
name|this
operator|.
name|fetchMessageMaxBytes
operator|=
name|fetchMessageMaxBytes
expr_stmt|;
block|}
DECL|method|isAutoCommitEnable ()
specifier|public
name|Boolean
name|isAutoCommitEnable
parameter_list|()
block|{
return|return
name|autoCommitEnable
return|;
block|}
comment|/**      * If true, periodically commit to ZooKeeper the offset of messages already fetched by the consumer.      * This committed offset will be used when the process fails as the position from which the new consumer will begin.      */
DECL|method|setAutoCommitEnable (Boolean autoCommitEnable)
specifier|public
name|void
name|setAutoCommitEnable
parameter_list|(
name|Boolean
name|autoCommitEnable
parameter_list|)
block|{
name|this
operator|.
name|autoCommitEnable
operator|=
name|autoCommitEnable
expr_stmt|;
block|}
DECL|method|getAutoCommitIntervalMs ()
specifier|public
name|Integer
name|getAutoCommitIntervalMs
parameter_list|()
block|{
return|return
name|autoCommitIntervalMs
return|;
block|}
comment|/**      * The frequency in ms that the consumer offsets are committed to zookeeper.      */
DECL|method|setAutoCommitIntervalMs (Integer autoCommitIntervalMs)
specifier|public
name|void
name|setAutoCommitIntervalMs
parameter_list|(
name|Integer
name|autoCommitIntervalMs
parameter_list|)
block|{
name|this
operator|.
name|autoCommitIntervalMs
operator|=
name|autoCommitIntervalMs
expr_stmt|;
block|}
DECL|method|getQueuedMaxMessageChunks ()
specifier|public
name|Integer
name|getQueuedMaxMessageChunks
parameter_list|()
block|{
return|return
name|queuedMaxMessageChunks
return|;
block|}
comment|/**      * Max number of message chunks buffered for consumption. Each chunk can be up to fetch.message.max.bytes.      */
DECL|method|setQueuedMaxMessageChunks (Integer queuedMaxMessageChunks)
specifier|public
name|void
name|setQueuedMaxMessageChunks
parameter_list|(
name|Integer
name|queuedMaxMessageChunks
parameter_list|)
block|{
name|this
operator|.
name|queuedMaxMessageChunks
operator|=
name|queuedMaxMessageChunks
expr_stmt|;
block|}
DECL|method|getRebalanceMaxRetries ()
specifier|public
name|Integer
name|getRebalanceMaxRetries
parameter_list|()
block|{
return|return
name|rebalanceMaxRetries
return|;
block|}
comment|/**      * When a new consumer joins a consumer group the set of consumers attempt to "rebalance" the load to assign partitions to each consumer.      * If the set of consumers changes while this assignment is taking place the rebalance will fail and retry.      * This setting controls the maximum number of attempts before giving up.      */
DECL|method|setRebalanceMaxRetries (Integer rebalanceMaxRetries)
specifier|public
name|void
name|setRebalanceMaxRetries
parameter_list|(
name|Integer
name|rebalanceMaxRetries
parameter_list|)
block|{
name|this
operator|.
name|rebalanceMaxRetries
operator|=
name|rebalanceMaxRetries
expr_stmt|;
block|}
DECL|method|getFetchMinBytes ()
specifier|public
name|Integer
name|getFetchMinBytes
parameter_list|()
block|{
return|return
name|fetchMinBytes
return|;
block|}
comment|/**      * The minimum amount of data the server should return for a fetch request.      * If insufficient data is available the request will wait for that much data to accumulate before answering the request.      */
DECL|method|setFetchMinBytes (Integer fetchMinBytes)
specifier|public
name|void
name|setFetchMinBytes
parameter_list|(
name|Integer
name|fetchMinBytes
parameter_list|)
block|{
name|this
operator|.
name|fetchMinBytes
operator|=
name|fetchMinBytes
expr_stmt|;
block|}
DECL|method|getFetchWaitMaxMs ()
specifier|public
name|Integer
name|getFetchWaitMaxMs
parameter_list|()
block|{
return|return
name|fetchWaitMaxMs
return|;
block|}
comment|/**      * The maximum amount of time the server will block before answering the fetch request if there isn't sufficient data to immediately satisfy fetch.min.bytes      */
DECL|method|setFetchWaitMaxMs (Integer fetchWaitMaxMs)
specifier|public
name|void
name|setFetchWaitMaxMs
parameter_list|(
name|Integer
name|fetchWaitMaxMs
parameter_list|)
block|{
name|this
operator|.
name|fetchWaitMaxMs
operator|=
name|fetchWaitMaxMs
expr_stmt|;
block|}
DECL|method|getRebalanceBackoffMs ()
specifier|public
name|Integer
name|getRebalanceBackoffMs
parameter_list|()
block|{
return|return
name|rebalanceBackoffMs
return|;
block|}
comment|/**      * Backoff time between retries during rebalance.      */
DECL|method|setRebalanceBackoffMs (Integer rebalanceBackoffMs)
specifier|public
name|void
name|setRebalanceBackoffMs
parameter_list|(
name|Integer
name|rebalanceBackoffMs
parameter_list|)
block|{
name|this
operator|.
name|rebalanceBackoffMs
operator|=
name|rebalanceBackoffMs
expr_stmt|;
block|}
DECL|method|getRefreshLeaderBackoffMs ()
specifier|public
name|Integer
name|getRefreshLeaderBackoffMs
parameter_list|()
block|{
return|return
name|refreshLeaderBackoffMs
return|;
block|}
comment|/**      * Backoff time to wait before trying to determine the leader of a partition that has just lost its leader.      */
DECL|method|setRefreshLeaderBackoffMs (Integer refreshLeaderBackoffMs)
specifier|public
name|void
name|setRefreshLeaderBackoffMs
parameter_list|(
name|Integer
name|refreshLeaderBackoffMs
parameter_list|)
block|{
name|this
operator|.
name|refreshLeaderBackoffMs
operator|=
name|refreshLeaderBackoffMs
expr_stmt|;
block|}
DECL|method|getAutoOffsetReset ()
specifier|public
name|String
name|getAutoOffsetReset
parameter_list|()
block|{
return|return
name|autoOffsetReset
return|;
block|}
comment|/**      * What to do when there is no initial offset in ZooKeeper or if an offset is out of range:      * smallest : automatically reset the offset to the smallest offset      * largest : automatically reset the offset to the largest offset      * fail: throw exception to the consumer      */
DECL|method|setAutoOffsetReset (String autoOffsetReset)
specifier|public
name|void
name|setAutoOffsetReset
parameter_list|(
name|String
name|autoOffsetReset
parameter_list|)
block|{
name|this
operator|.
name|autoOffsetReset
operator|=
name|autoOffsetReset
expr_stmt|;
block|}
DECL|method|getConsumerTimeoutMs ()
specifier|public
name|Integer
name|getConsumerTimeoutMs
parameter_list|()
block|{
return|return
name|consumerTimeoutMs
return|;
block|}
comment|/**      * Throw a timeout exception to the consumer if no message is available for consumption after the specified interval      */
DECL|method|setConsumerTimeoutMs (Integer consumerTimeoutMs)
specifier|public
name|void
name|setConsumerTimeoutMs
parameter_list|(
name|Integer
name|consumerTimeoutMs
parameter_list|)
block|{
name|this
operator|.
name|consumerTimeoutMs
operator|=
name|consumerTimeoutMs
expr_stmt|;
block|}
DECL|method|getZookeeperSessionTimeoutMs ()
specifier|public
name|Integer
name|getZookeeperSessionTimeoutMs
parameter_list|()
block|{
return|return
name|zookeeperSessionTimeoutMs
return|;
block|}
comment|/**      * ZooKeeper session timeout. If the consumer fails to heartbeat to ZooKeeper for this period of time it is considered dead and a rebalance will occur.      */
DECL|method|setZookeeperSessionTimeoutMs (Integer zookeeperSessionTimeoutMs)
specifier|public
name|void
name|setZookeeperSessionTimeoutMs
parameter_list|(
name|Integer
name|zookeeperSessionTimeoutMs
parameter_list|)
block|{
name|this
operator|.
name|zookeeperSessionTimeoutMs
operator|=
name|zookeeperSessionTimeoutMs
expr_stmt|;
block|}
DECL|method|getZookeeperConnectionTimeoutMs ()
specifier|public
name|Integer
name|getZookeeperConnectionTimeoutMs
parameter_list|()
block|{
return|return
name|zookeeperConnectionTimeoutMs
return|;
block|}
comment|/**      * The max time that the client waits while establishing a connection to zookeeper.      */
DECL|method|setZookeeperConnectionTimeoutMs (Integer zookeeperConnectionTimeoutMs)
specifier|public
name|void
name|setZookeeperConnectionTimeoutMs
parameter_list|(
name|Integer
name|zookeeperConnectionTimeoutMs
parameter_list|)
block|{
name|this
operator|.
name|zookeeperConnectionTimeoutMs
operator|=
name|zookeeperConnectionTimeoutMs
expr_stmt|;
block|}
DECL|method|getZookeeperSyncTimeMs ()
specifier|public
name|Integer
name|getZookeeperSyncTimeMs
parameter_list|()
block|{
return|return
name|zookeeperSyncTimeMs
return|;
block|}
comment|/**      * How far a ZK follower can be behind a ZK leader      */
DECL|method|setZookeeperSyncTimeMs (Integer zookeeperSyncTimeMs)
specifier|public
name|void
name|setZookeeperSyncTimeMs
parameter_list|(
name|Integer
name|zookeeperSyncTimeMs
parameter_list|)
block|{
name|this
operator|.
name|zookeeperSyncTimeMs
operator|=
name|zookeeperSyncTimeMs
expr_stmt|;
block|}
DECL|method|getBrokers ()
specifier|public
name|String
name|getBrokers
parameter_list|()
block|{
return|return
name|brokers
return|;
block|}
comment|/**      * This is for bootstrapping and the producer will only use it for getting metadata (topics, partitions and replicas).      * The socket connections for sending the actual data will be established based on the broker information returned in the metadata.      * The format is host1:port1,host2:port2, and the list can be a subset of brokers or a VIP pointing to a subset of brokers.      *<p/>      * This option is known as<tt>metadata.broker.list</tt> in the Kafka documentation.      */
DECL|method|setBrokers (String brokers)
specifier|public
name|void
name|setBrokers
parameter_list|(
name|String
name|brokers
parameter_list|)
block|{
name|this
operator|.
name|brokers
operator|=
name|brokers
expr_stmt|;
block|}
DECL|method|getProducerType ()
specifier|public
name|String
name|getProducerType
parameter_list|()
block|{
return|return
name|producerType
return|;
block|}
comment|/**      * This parameter specifies whether the messages are sent asynchronously in a background thread.      * Valid values are (1) async for asynchronous send and (2) sync for synchronous send.      * By setting the producer to async we allow batching together of requests (which is great for throughput)      * but open the possibility of a failure of the client machine dropping unsent data.      */
DECL|method|setProducerType (String producerType)
specifier|public
name|void
name|setProducerType
parameter_list|(
name|String
name|producerType
parameter_list|)
block|{
name|this
operator|.
name|producerType
operator|=
name|producerType
expr_stmt|;
block|}
DECL|method|getCompressionCodec ()
specifier|public
name|String
name|getCompressionCodec
parameter_list|()
block|{
return|return
name|compressionCodec
return|;
block|}
comment|/**      * This parameter allows you to specify the compression codec for all data generated by this producer. Valid values are "none", "gzip" and "snappy".      */
DECL|method|setCompressionCodec (String compressionCodec)
specifier|public
name|void
name|setCompressionCodec
parameter_list|(
name|String
name|compressionCodec
parameter_list|)
block|{
name|this
operator|.
name|compressionCodec
operator|=
name|compressionCodec
expr_stmt|;
block|}
DECL|method|getCompressedTopics ()
specifier|public
name|String
name|getCompressedTopics
parameter_list|()
block|{
return|return
name|compressedTopics
return|;
block|}
comment|/**      * This parameter allows you to set whether compression should be turned on for particular topics.      * If the compression codec is anything other than NoCompressionCodec, enable compression only for specified topics if any.      * If the list of compressed topics is empty, then enable the specified compression codec for all topics.      * If the compression codec is NoCompressionCodec, compression is disabled for all topics      */
DECL|method|setCompressedTopics (String compressedTopics)
specifier|public
name|void
name|setCompressedTopics
parameter_list|(
name|String
name|compressedTopics
parameter_list|)
block|{
name|this
operator|.
name|compressedTopics
operator|=
name|compressedTopics
expr_stmt|;
block|}
DECL|method|getMessageSendMaxRetries ()
specifier|public
name|Integer
name|getMessageSendMaxRetries
parameter_list|()
block|{
return|return
name|messageSendMaxRetries
return|;
block|}
comment|/**      * This property will cause the producer to automatically retry a failed send request.      * This property specifies the number of retries when such failures occur. Note that setting a non-zero value here      * can lead to duplicates in the case of network errors that cause a message to be sent but the acknowledgement to be lost.      */
DECL|method|setMessageSendMaxRetries (Integer messageSendMaxRetries)
specifier|public
name|void
name|setMessageSendMaxRetries
parameter_list|(
name|Integer
name|messageSendMaxRetries
parameter_list|)
block|{
name|this
operator|.
name|messageSendMaxRetries
operator|=
name|messageSendMaxRetries
expr_stmt|;
block|}
DECL|method|getRetryBackoffMs ()
specifier|public
name|Integer
name|getRetryBackoffMs
parameter_list|()
block|{
return|return
name|retryBackoffMs
return|;
block|}
comment|/**      * Before each retry, the producer refreshes the metadata of relevant topics to see if a new leader has been elected.      * Since leader election takes a bit of time, this property specifies the amount of time that the producer waits before refreshing the metadata.      */
DECL|method|setRetryBackoffMs (Integer retryBackoffMs)
specifier|public
name|void
name|setRetryBackoffMs
parameter_list|(
name|Integer
name|retryBackoffMs
parameter_list|)
block|{
name|this
operator|.
name|retryBackoffMs
operator|=
name|retryBackoffMs
expr_stmt|;
block|}
DECL|method|getTopicMetadataRefreshIntervalMs ()
specifier|public
name|Integer
name|getTopicMetadataRefreshIntervalMs
parameter_list|()
block|{
return|return
name|topicMetadataRefreshIntervalMs
return|;
block|}
comment|/**      * The producer generally refreshes the topic metadata from brokers when there is a failure (partition missing,      * leader not available...). It will also poll regularly (default: every 10min so 600000ms).      * If you set this to a negative value, metadata will only get refreshed on failure.      * If you set this to zero, the metadata will get refreshed after each message sent (not recommended).      * Important note: the refresh happen only AFTER the message is sent, so if the producer never      * sends a message the metadata is never refreshed      */
DECL|method|setTopicMetadataRefreshIntervalMs (Integer topicMetadataRefreshIntervalMs)
specifier|public
name|void
name|setTopicMetadataRefreshIntervalMs
parameter_list|(
name|Integer
name|topicMetadataRefreshIntervalMs
parameter_list|)
block|{
name|this
operator|.
name|topicMetadataRefreshIntervalMs
operator|=
name|topicMetadataRefreshIntervalMs
expr_stmt|;
block|}
DECL|method|getSendBufferBytes ()
specifier|public
name|Integer
name|getSendBufferBytes
parameter_list|()
block|{
return|return
name|sendBufferBytes
return|;
block|}
comment|/**      * Socket write buffer size      */
DECL|method|setSendBufferBytes (Integer sendBufferBytes)
specifier|public
name|void
name|setSendBufferBytes
parameter_list|(
name|Integer
name|sendBufferBytes
parameter_list|)
block|{
name|this
operator|.
name|sendBufferBytes
operator|=
name|sendBufferBytes
expr_stmt|;
block|}
DECL|method|getRequestRequiredAcks ()
specifier|public
name|short
name|getRequestRequiredAcks
parameter_list|()
block|{
return|return
name|requestRequiredAcks
return|;
block|}
comment|/**      * This value controls when a produce request is considered completed. Specifically,      * how many other brokers must have committed the data to their log and acknowledged this to the leader?      * Typical values are (0, 1 or -1):      * 0, which means that the producer never waits for an acknowledgement from the broker (the same behavior as 0.7).      * This option provides the lowest latency but the weakest durability guarantees (some data will be lost when a server fails).      * 1, which means that the producer gets an acknowledgement after the leader replica has received the data.      * This option provides better durability as the client waits until the server acknowledges the request as successful      * (only messages that were written to the now-dead leader but not yet replicated will be lost).      * -1, The producer gets an acknowledgement after all in-sync replicas have received the data.      * This option provides the greatest level of durability.      * However, it does not completely eliminate the risk of message loss because the number of in sync replicas may,      * in rare cases, shrink to 1. If you want to ensure that some minimum number of replicas      * (typically a majority) receive a write, then you must set the topic-level min.insync.replicas setting.      * Please read the Replication section of the design documentation for a more in-depth discussion.      */
DECL|method|setRequestRequiredAcks (short requestRequiredAcks)
specifier|public
name|void
name|setRequestRequiredAcks
parameter_list|(
name|short
name|requestRequiredAcks
parameter_list|)
block|{
name|this
operator|.
name|requestRequiredAcks
operator|=
name|requestRequiredAcks
expr_stmt|;
block|}
DECL|method|getRequestTimeoutMs ()
specifier|public
name|Integer
name|getRequestTimeoutMs
parameter_list|()
block|{
return|return
name|requestTimeoutMs
return|;
block|}
comment|/**      * The amount of time the broker will wait trying to meet the request.required.acks requirement before sending back an error to the client.      */
DECL|method|setRequestTimeoutMs (Integer requestTimeoutMs)
specifier|public
name|void
name|setRequestTimeoutMs
parameter_list|(
name|Integer
name|requestTimeoutMs
parameter_list|)
block|{
name|this
operator|.
name|requestTimeoutMs
operator|=
name|requestTimeoutMs
expr_stmt|;
block|}
DECL|method|getQueueBufferingMaxMs ()
specifier|public
name|Integer
name|getQueueBufferingMaxMs
parameter_list|()
block|{
return|return
name|queueBufferingMaxMs
return|;
block|}
comment|/**      * Maximum time to buffer data when using async mode.      * For example a setting of 100 will try to batch together 100ms of messages to send at once.      * This will improve throughput but adds message delivery latency due to the buffering.      */
DECL|method|setQueueBufferingMaxMs (Integer queueBufferingMaxMs)
specifier|public
name|void
name|setQueueBufferingMaxMs
parameter_list|(
name|Integer
name|queueBufferingMaxMs
parameter_list|)
block|{
name|this
operator|.
name|queueBufferingMaxMs
operator|=
name|queueBufferingMaxMs
expr_stmt|;
block|}
DECL|method|getQueueBufferingMaxMessages ()
specifier|public
name|Integer
name|getQueueBufferingMaxMessages
parameter_list|()
block|{
return|return
name|queueBufferingMaxMessages
return|;
block|}
comment|/**      * The maximum number of unsent messages that can be queued up the producer when using async      * mode before either the producer must be blocked or data must be dropped.      */
DECL|method|setQueueBufferingMaxMessages (Integer queueBufferingMaxMessages)
specifier|public
name|void
name|setQueueBufferingMaxMessages
parameter_list|(
name|Integer
name|queueBufferingMaxMessages
parameter_list|)
block|{
name|this
operator|.
name|queueBufferingMaxMessages
operator|=
name|queueBufferingMaxMessages
expr_stmt|;
block|}
DECL|method|getQueueEnqueueTimeoutMs ()
specifier|public
name|Integer
name|getQueueEnqueueTimeoutMs
parameter_list|()
block|{
return|return
name|queueEnqueueTimeoutMs
return|;
block|}
comment|/**      * The amount of time to block before dropping messages when running in async mode and the buffer has reached      * queue.buffering.max.messages. If set to 0 events will be enqueued immediately or dropped if the queue is full      * (the producer send call will never block). If set to -1 the producer will block indefinitely and never willingly drop a send.      */
DECL|method|setQueueEnqueueTimeoutMs (Integer queueEnqueueTimeoutMs)
specifier|public
name|void
name|setQueueEnqueueTimeoutMs
parameter_list|(
name|Integer
name|queueEnqueueTimeoutMs
parameter_list|)
block|{
name|this
operator|.
name|queueEnqueueTimeoutMs
operator|=
name|queueEnqueueTimeoutMs
expr_stmt|;
block|}
DECL|method|getBatchNumMessages ()
specifier|public
name|Integer
name|getBatchNumMessages
parameter_list|()
block|{
return|return
name|batchNumMessages
return|;
block|}
comment|/**      * The number of messages to send in one batch when using async mode.      * The producer will wait until either this number of messages are ready to send or queue.buffer.max.ms is reached.      */
DECL|method|setBatchNumMessages (Integer batchNumMessages)
specifier|public
name|void
name|setBatchNumMessages
parameter_list|(
name|Integer
name|batchNumMessages
parameter_list|)
block|{
name|this
operator|.
name|batchNumMessages
operator|=
name|batchNumMessages
expr_stmt|;
block|}
DECL|method|getSerializerClass ()
specifier|public
name|String
name|getSerializerClass
parameter_list|()
block|{
return|return
name|serializerClass
return|;
block|}
comment|/**      * The serializer class for messages. The default encoder takes a byte[] and returns the same byte[].      * The default class is kafka.serializer.DefaultEncoder      */
DECL|method|setSerializerClass (String serializerClass)
specifier|public
name|void
name|setSerializerClass
parameter_list|(
name|String
name|serializerClass
parameter_list|)
block|{
name|this
operator|.
name|serializerClass
operator|=
name|serializerClass
expr_stmt|;
block|}
DECL|method|getKeySerializerClass ()
specifier|public
name|String
name|getKeySerializerClass
parameter_list|()
block|{
return|return
name|keySerializerClass
return|;
block|}
comment|/**      * The serializer class for keys (defaults to the same as for messages if nothing is given).      */
DECL|method|setKeySerializerClass (String keySerializerClass)
specifier|public
name|void
name|setKeySerializerClass
parameter_list|(
name|String
name|keySerializerClass
parameter_list|)
block|{
name|this
operator|.
name|keySerializerClass
operator|=
name|keySerializerClass
expr_stmt|;
block|}
DECL|method|getOffsetsStorage ()
specifier|public
name|String
name|getOffsetsStorage
parameter_list|()
block|{
return|return
name|offsetsStorage
return|;
block|}
comment|/**      * Select where offsets should be stored (zookeeper or kafka).      */
DECL|method|setOffsetsStorage (String offsetsStorage)
specifier|public
name|void
name|setOffsetsStorage
parameter_list|(
name|String
name|offsetsStorage
parameter_list|)
block|{
name|this
operator|.
name|offsetsStorage
operator|=
name|offsetsStorage
expr_stmt|;
block|}
DECL|method|isDualCommitEnabled ()
specifier|public
name|Boolean
name|isDualCommitEnabled
parameter_list|()
block|{
return|return
name|dualCommitEnabled
return|;
block|}
comment|/**      * If you are using "kafka" as offsets.storage, you can dual commit offsets to ZooKeeper (in addition to Kafka).      * This is required during migration from zookeeper-based offset storage to kafka-based offset storage.      * With respect to any given consumer group, it is safe to turn this off after all instances within that group have been migrated      * to the new version that commits offsets to the broker (instead of directly to ZooKeeper).      */
DECL|method|setDualCommitEnabled (Boolean dualCommitEnabled)
specifier|public
name|void
name|setDualCommitEnabled
parameter_list|(
name|Boolean
name|dualCommitEnabled
parameter_list|)
block|{
name|this
operator|.
name|dualCommitEnabled
operator|=
name|dualCommitEnabled
expr_stmt|;
block|}
block|}
end_class

end_unit

