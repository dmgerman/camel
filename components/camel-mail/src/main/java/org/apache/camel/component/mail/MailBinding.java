begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.component.mail
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|mail
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|IllegalCharsetNameException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|activation
operator|.
name|DataHandler
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|activation
operator|.
name|DataSource
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|mail
operator|.
name|Address
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|mail
operator|.
name|BodyPart
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|mail
operator|.
name|Header
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|mail
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|mail
operator|.
name|MessagingException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|mail
operator|.
name|Multipart
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|mail
operator|.
name|Part
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|mail
operator|.
name|internet
operator|.
name|InternetAddress
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|mail
operator|.
name|internet
operator|.
name|MimeBodyPart
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|mail
operator|.
name|internet
operator|.
name|MimeMessage
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|mail
operator|.
name|internet
operator|.
name|MimeMultipart
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|mail
operator|.
name|util
operator|.
name|ByteArrayDataSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|RuntimeCamelException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|converter
operator|.
name|ObjectConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|impl
operator|.
name|DefaultHeaderFilterStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|HeaderFilterStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|CollectionHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|IOHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ObjectHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * A Strategy used to convert between a Camel {@link Exchange} and {@link Message} to and  * from a Mail {@link MimeMessage}  *  * @version   */
end_comment

begin_class
DECL|class|MailBinding
specifier|public
class|class
name|MailBinding
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
specifier|transient
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MailBinding
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|headerFilterStrategy
specifier|private
name|HeaderFilterStrategy
name|headerFilterStrategy
decl_stmt|;
DECL|field|contentTypeResolver
specifier|private
name|ContentTypeResolver
name|contentTypeResolver
decl_stmt|;
DECL|method|MailBinding ()
specifier|public
name|MailBinding
parameter_list|()
block|{
name|headerFilterStrategy
operator|=
operator|new
name|DefaultHeaderFilterStrategy
argument_list|()
expr_stmt|;
block|}
DECL|method|MailBinding (HeaderFilterStrategy headerFilterStrategy, ContentTypeResolver contentTypeResolver)
specifier|public
name|MailBinding
parameter_list|(
name|HeaderFilterStrategy
name|headerFilterStrategy
parameter_list|,
name|ContentTypeResolver
name|contentTypeResolver
parameter_list|)
block|{
name|this
operator|.
name|headerFilterStrategy
operator|=
name|headerFilterStrategy
expr_stmt|;
name|this
operator|.
name|contentTypeResolver
operator|=
name|contentTypeResolver
expr_stmt|;
block|}
DECL|method|populateMailMessage (MailEndpoint endpoint, MimeMessage mimeMessage, Exchange exchange)
specifier|public
name|void
name|populateMailMessage
parameter_list|(
name|MailEndpoint
name|endpoint
parameter_list|,
name|MimeMessage
name|mimeMessage
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|MessagingException
throws|,
name|IOException
block|{
comment|// camel message headers takes precedence over endpoint configuration
if|if
condition|(
name|hasRecipientHeaders
argument_list|(
name|exchange
argument_list|)
condition|)
block|{
name|setRecipientFromCamelMessage
argument_list|(
name|mimeMessage
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// fallback to endpoint configuration
name|setRecipientFromEndpointConfiguration
argument_list|(
name|mimeMessage
argument_list|,
name|endpoint
argument_list|)
expr_stmt|;
block|}
comment|// set the replyTo if it was passed in as an option in the uri. Note: if it is in both the URI
comment|// and headers the headers win.
name|String
name|replyTo
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
literal|"Reply-To"
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|replyTo
operator|==
literal|null
condition|)
block|{
name|replyTo
operator|=
name|endpoint
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getReplyTo
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|replyTo
operator|!=
literal|null
condition|)
block|{
name|mimeMessage
operator|.
name|setReplyTo
argument_list|(
operator|new
name|InternetAddress
index|[]
block|{
operator|new
name|InternetAddress
argument_list|(
name|replyTo
argument_list|)
block|}
argument_list|)
expr_stmt|;
block|}
comment|// must have at least one recipients otherwise we do not know where to send the mail
if|if
condition|(
name|mimeMessage
operator|.
name|getAllRecipients
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The mail message does not have any recipients set."
argument_list|)
throw|;
block|}
comment|// set the subject if it was passed in as an option in the uri. Note: if it is in both the URI
comment|// and headers the headers win.
name|String
name|subject
init|=
name|endpoint
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getSubject
argument_list|()
decl_stmt|;
if|if
condition|(
name|subject
operator|!=
literal|null
condition|)
block|{
name|mimeMessage
operator|.
name|setSubject
argument_list|(
name|subject
argument_list|,
name|IOHelper
operator|.
name|getCharsetName
argument_list|(
name|exchange
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// append the rest of the headers (no recipients) that could be subject, reply-to etc.
name|appendHeadersFromCamelMessage
argument_list|(
name|mimeMessage
argument_list|,
name|endpoint
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
if|if
condition|(
name|empty
argument_list|(
name|mimeMessage
operator|.
name|getFrom
argument_list|()
argument_list|)
condition|)
block|{
comment|// lets default the address to the endpoint destination
name|String
name|from
init|=
name|endpoint
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getFrom
argument_list|()
decl_stmt|;
name|mimeMessage
operator|.
name|setFrom
argument_list|(
operator|new
name|InternetAddress
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// if there is an alternative body provided, set up a mime multipart alternative message
if|if
condition|(
name|hasAlternativeBody
argument_list|(
name|endpoint
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|exchange
argument_list|)
condition|)
block|{
name|createMultipartAlternativeMessage
argument_list|(
name|mimeMessage
argument_list|,
name|endpoint
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|hasAttachments
argument_list|()
condition|)
block|{
name|appendAttachmentsFromCamel
argument_list|(
name|mimeMessage
argument_list|,
name|endpoint
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|populateContentOnMimeMessage
argument_list|(
name|mimeMessage
argument_list|,
name|endpoint
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|determineContentType (MailConfiguration configuration, Exchange exchange)
specifier|protected
name|String
name|determineContentType
parameter_list|(
name|MailConfiguration
name|configuration
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
comment|// see if we got any content type set
name|String
name|contentType
init|=
name|configuration
operator|.
name|getContentType
argument_list|()
decl_stmt|;
if|if
condition|(
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
literal|"contentType"
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|contentType
operator|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
literal|"contentType"
argument_list|,
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|Exchange
operator|.
name|CONTENT_TYPE
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|contentType
operator|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|Exchange
operator|.
name|CONTENT_TYPE
argument_list|,
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|// fix content-type to have space after semi colons, otherwise some mail servers will choke
if|if
condition|(
name|contentType
operator|!=
literal|null
operator|&&
name|contentType
operator|.
name|contains
argument_list|(
literal|";"
argument_list|)
condition|)
block|{
name|contentType
operator|=
name|MailUtils
operator|.
name|padContentType
argument_list|(
name|contentType
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|contentType
operator|!=
literal|null
condition|)
block|{
comment|// no charset in content-type, then try to see if we can determine one
name|String
name|charset
init|=
name|determineCharSet
argument_list|(
name|configuration
argument_list|,
name|exchange
argument_list|)
decl_stmt|;
comment|// must replace charset, even with null in case its an unsupported charset
name|contentType
operator|=
name|MailUtils
operator|.
name|replaceCharSet
argument_list|(
name|contentType
argument_list|,
name|charset
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"Determined Content-Type: {}"
argument_list|,
name|contentType
argument_list|)
expr_stmt|;
return|return
name|contentType
return|;
block|}
DECL|method|determineCharSet (MailConfiguration configuration, Exchange exchange)
specifier|protected
name|String
name|determineCharSet
parameter_list|(
name|MailConfiguration
name|configuration
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
comment|// see if we got any content type set
name|String
name|contentType
init|=
name|configuration
operator|.
name|getContentType
argument_list|()
decl_stmt|;
if|if
condition|(
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
literal|"contentType"
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|contentType
operator|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
literal|"contentType"
argument_list|,
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|Exchange
operator|.
name|CONTENT_TYPE
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|contentType
operator|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|Exchange
operator|.
name|CONTENT_TYPE
argument_list|,
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|// look for charset
name|String
name|charset
init|=
name|MailUtils
operator|.
name|getCharSetFromContentType
argument_list|(
name|contentType
argument_list|)
decl_stmt|;
if|if
condition|(
name|charset
operator|!=
literal|null
condition|)
block|{
name|charset
operator|=
name|IOHelper
operator|.
name|normalizeCharset
argument_list|(
name|charset
argument_list|)
expr_stmt|;
if|if
condition|(
name|charset
operator|!=
literal|null
condition|)
block|{
name|boolean
name|supported
decl_stmt|;
try|try
block|{
name|supported
operator|=
name|Charset
operator|.
name|isSupported
argument_list|(
name|charset
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalCharsetNameException
name|e
parameter_list|)
block|{
name|supported
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|supported
condition|)
block|{
return|return
name|charset
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|configuration
operator|.
name|isIgnoreUnsupportedCharset
argument_list|()
condition|)
block|{
return|return
name|charset
return|;
block|}
elseif|else
if|if
condition|(
name|configuration
operator|.
name|isIgnoreUnsupportedCharset
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Charset: "
operator|+
name|charset
operator|+
literal|" is not supported and cannot be used as charset in Content-Type header."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
block|}
comment|// Using the charset header of exchange as a fall back
return|return
name|IOHelper
operator|.
name|getCharsetName
argument_list|(
name|exchange
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|populateContentOnMimeMessage (MimeMessage part, MailConfiguration configuration, Exchange exchange)
specifier|protected
name|String
name|populateContentOnMimeMessage
parameter_list|(
name|MimeMessage
name|part
parameter_list|,
name|MailConfiguration
name|configuration
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|MessagingException
throws|,
name|IOException
block|{
name|String
name|contentType
init|=
name|determineContentType
argument_list|(
name|configuration
argument_list|,
name|exchange
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Using Content-Type {} for MimeMessage: {}"
argument_list|,
name|contentType
argument_list|,
name|part
argument_list|)
expr_stmt|;
name|String
name|body
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|(
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|body
operator|==
literal|null
condition|)
block|{
name|body
operator|=
literal|""
expr_stmt|;
block|}
comment|// always store content in a byte array data store to avoid various content type and charset issues
name|DataSource
name|ds
init|=
operator|new
name|ByteArrayDataSource
argument_list|(
name|body
argument_list|,
name|contentType
argument_list|)
decl_stmt|;
name|part
operator|.
name|setDataHandler
argument_list|(
operator|new
name|DataHandler
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
comment|// set the content type header afterwards
name|part
operator|.
name|setHeader
argument_list|(
literal|"Content-Type"
argument_list|,
name|contentType
argument_list|)
expr_stmt|;
return|return
name|contentType
return|;
block|}
DECL|method|populateContentOnBodyPart (BodyPart part, MailConfiguration configuration, Exchange exchange)
specifier|protected
name|String
name|populateContentOnBodyPart
parameter_list|(
name|BodyPart
name|part
parameter_list|,
name|MailConfiguration
name|configuration
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|MessagingException
throws|,
name|IOException
block|{
name|String
name|contentType
init|=
name|determineContentType
argument_list|(
name|configuration
argument_list|,
name|exchange
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Using Content-Type {} for BodyPart: {}"
argument_list|,
name|contentType
argument_list|,
name|part
argument_list|)
expr_stmt|;
comment|// always store content in a byte array data store to avoid various content type and charset issues
name|DataSource
name|ds
init|=
operator|new
name|ByteArrayDataSource
argument_list|(
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|(
name|String
operator|.
name|class
argument_list|)
argument_list|,
name|contentType
argument_list|)
decl_stmt|;
name|part
operator|.
name|setDataHandler
argument_list|(
operator|new
name|DataHandler
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
comment|// set the content type header afterwards
name|part
operator|.
name|setHeader
argument_list|(
literal|"Content-Type"
argument_list|,
name|contentType
argument_list|)
expr_stmt|;
return|return
name|contentType
return|;
block|}
comment|/**      * Extracts the body from the Mail message      */
DECL|method|extractBodyFromMail (Exchange exchange, MailMessage mailMessage)
specifier|public
name|Object
name|extractBodyFromMail
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|MailMessage
name|mailMessage
parameter_list|)
block|{
name|Message
name|message
init|=
name|mailMessage
operator|.
name|getMessage
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|(
operator|(
name|MailEndpoint
operator|)
name|exchange
operator|.
name|getFromEndpoint
argument_list|()
operator|)
operator|.
name|getConfiguration
argument_list|()
operator|.
name|isMapMailMessage
argument_list|()
condition|)
block|{
return|return
name|message
operator|.
name|getContent
argument_list|()
return|;
block|}
return|return
name|message
return|;
comment|// raw message
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// try to fix message in case it has an unsupported encoding in the Content-Type header
name|UnsupportedEncodingException
name|uee
init|=
name|ObjectHelper
operator|.
name|getException
argument_list|(
name|UnsupportedEncodingException
operator|.
name|class
argument_list|,
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|uee
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unsupported encoding detected: "
operator|+
name|uee
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|String
name|contentType
init|=
name|message
operator|.
name|getContentType
argument_list|()
decl_stmt|;
name|String
name|type
init|=
name|ObjectHelper
operator|.
name|before
argument_list|(
name|contentType
argument_list|,
literal|"charset="
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
comment|// try again with fixed content type
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying to extract mail message again with fixed Content-Type: "
operator|+
name|type
argument_list|)
expr_stmt|;
comment|// Since message is read-only, we need to use a copy
name|MimeMessage
name|messageCopy
init|=
operator|new
name|MimeMessage
argument_list|(
operator|(
name|MimeMessage
operator|)
name|message
argument_list|)
decl_stmt|;
name|messageCopy
operator|.
name|setHeader
argument_list|(
literal|"Content-Type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|Object
name|body
init|=
name|messageCopy
operator|.
name|getContent
argument_list|()
decl_stmt|;
comment|// If we got this far, our fix worked...
comment|// Replace the MailMessage's Message with the copy
name|mailMessage
operator|.
name|setMessage
argument_list|(
name|messageCopy
argument_list|)
expr_stmt|;
return|return
name|body
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e2
parameter_list|)
block|{
comment|// fall through and let original exception be thrown
block|}
block|}
throw|throw
operator|new
name|RuntimeCamelException
argument_list|(
literal|"Failed to extract body due to: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
operator|+
literal|". Exchange: "
operator|+
name|exchange
operator|+
literal|". Message: "
operator|+
name|message
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Parses the attachments of the given mail message and adds them to the map      *      * @param  message  the mail message with attachments      * @param  map      the map to add found attachments (attachmentFilename is the key)      */
DECL|method|extractAttachmentsFromMail (Message message, Map<String, DataHandler> map)
specifier|public
name|void
name|extractAttachmentsFromMail
parameter_list|(
name|Message
name|message
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|DataHandler
argument_list|>
name|map
parameter_list|)
throws|throws
name|javax
operator|.
name|mail
operator|.
name|MessagingException
throws|,
name|IOException
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Extracting attachments +++ start +++"
argument_list|)
expr_stmt|;
name|Object
name|content
init|=
name|message
operator|.
name|getContent
argument_list|()
decl_stmt|;
if|if
condition|(
name|content
operator|instanceof
name|Multipart
condition|)
block|{
name|extractAttachmentsFromMultipart
argument_list|(
operator|(
name|Multipart
operator|)
name|content
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|content
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"No attachments to extract as content is not Multipart: "
operator|+
name|content
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"Extracting attachments +++ done +++"
argument_list|)
expr_stmt|;
block|}
DECL|method|extractAttachmentsFromMultipart (Multipart mp, Map<String, DataHandler> map)
specifier|protected
name|void
name|extractAttachmentsFromMultipart
parameter_list|(
name|Multipart
name|mp
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|DataHandler
argument_list|>
name|map
parameter_list|)
throws|throws
name|javax
operator|.
name|mail
operator|.
name|MessagingException
throws|,
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mp
operator|.
name|getCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Part
name|part
init|=
name|mp
operator|.
name|getBodyPart
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Part #"
operator|+
name|i
operator|+
literal|": "
operator|+
name|part
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|.
name|isMimeType
argument_list|(
literal|"multipart/*"
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Part #"
operator|+
name|i
operator|+
literal|": is mimetype: multipart/*"
argument_list|)
expr_stmt|;
name|extractAttachmentsFromMultipart
argument_list|(
operator|(
name|Multipart
operator|)
name|part
operator|.
name|getContent
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|disposition
init|=
name|part
operator|.
name|getDisposition
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Part #{}: Disposition: {}"
argument_list|,
name|i
argument_list|,
name|part
operator|.
name|getDisposition
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Part #{}: Description: {}"
argument_list|,
name|i
argument_list|,
name|part
operator|.
name|getDescription
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Part #{}: ContentType: {}"
argument_list|,
name|i
argument_list|,
name|part
operator|.
name|getContentType
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Part #{}: FileName: {}"
argument_list|,
name|i
argument_list|,
name|part
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Part #{}: Size: {}"
argument_list|,
name|i
argument_list|,
name|part
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Part #{}: LineCount: {}"
argument_list|,
name|i
argument_list|,
name|part
operator|.
name|getLineCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|disposition
operator|!=
literal|null
operator|&&
operator|(
name|disposition
operator|.
name|equalsIgnoreCase
argument_list|(
name|Part
operator|.
name|ATTACHMENT
argument_list|)
operator|||
name|disposition
operator|.
name|equalsIgnoreCase
argument_list|(
name|Part
operator|.
name|INLINE
argument_list|)
operator|)
condition|)
block|{
comment|// only add named attachments
name|String
name|fileName
init|=
name|part
operator|.
name|getFileName
argument_list|()
decl_stmt|;
if|if
condition|(
name|fileName
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Mail contains file attachment: "
operator|+
name|fileName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|map
operator|.
name|containsKey
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
comment|// Parts marked with a disposition of Part.ATTACHMENT are clearly attachments
name|map
operator|.
name|put
argument_list|(
name|fileName
argument_list|,
name|part
operator|.
name|getDataHandler
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot extract duplicate attachment: "
operator|+
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/**      * Appends the Mail headers from the Camel {@link MailMessage}      */
DECL|method|appendHeadersFromCamelMessage (MimeMessage mimeMessage, MailConfiguration configuration, Exchange exchange)
specifier|protected
name|void
name|appendHeadersFromCamelMessage
parameter_list|(
name|MimeMessage
name|mimeMessage
parameter_list|,
name|MailConfiguration
name|configuration
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|MessagingException
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeaders
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|headerName
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Object
name|headerValue
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|headerValue
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|headerFilterStrategy
operator|!=
literal|null
operator|&&
operator|!
name|headerFilterStrategy
operator|.
name|applyFilterToCamelHeaders
argument_list|(
name|headerName
argument_list|,
name|headerValue
argument_list|,
name|exchange
argument_list|)
condition|)
block|{
if|if
condition|(
name|headerName
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"subject"
argument_list|)
condition|)
block|{
name|mimeMessage
operator|.
name|setSubject
argument_list|(
name|asString
argument_list|(
name|exchange
argument_list|,
name|headerValue
argument_list|)
argument_list|,
name|IOHelper
operator|.
name|getCharsetName
argument_list|(
name|exchange
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|isRecipientHeader
argument_list|(
name|headerName
argument_list|)
condition|)
block|{
comment|// skip any recipients as they are handled specially
continue|continue;
block|}
comment|// alternative body should also be skipped
if|if
condition|(
name|headerName
operator|.
name|equalsIgnoreCase
argument_list|(
name|configuration
operator|.
name|getAlternativeBodyHeader
argument_list|()
argument_list|)
condition|)
block|{
comment|// skip alternative body
continue|continue;
block|}
comment|// Mail messages can repeat the same header...
if|if
condition|(
name|ObjectConverter
operator|.
name|isCollection
argument_list|(
name|headerValue
argument_list|)
condition|)
block|{
name|Iterator
argument_list|<
name|?
argument_list|>
name|iter
init|=
name|ObjectHelper
operator|.
name|createIterator
argument_list|(
name|headerValue
argument_list|)
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Object
name|value
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|mimeMessage
operator|.
name|addHeader
argument_list|(
name|headerName
argument_list|,
name|asString
argument_list|(
name|exchange
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mimeMessage
operator|.
name|setHeader
argument_list|(
name|headerName
argument_list|,
name|asString
argument_list|(
name|exchange
argument_list|,
name|headerValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|method|setRecipientFromCamelMessage (MimeMessage mimeMessage, Exchange exchange)
specifier|private
name|void
name|setRecipientFromCamelMessage
parameter_list|(
name|MimeMessage
name|mimeMessage
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|MessagingException
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeaders
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|headerName
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Object
name|headerValue
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|headerValue
operator|!=
literal|null
operator|&&
name|isRecipientHeader
argument_list|(
name|headerName
argument_list|)
condition|)
block|{
comment|// special handling of recipients
if|if
condition|(
name|ObjectConverter
operator|.
name|isCollection
argument_list|(
name|headerValue
argument_list|)
condition|)
block|{
name|Iterator
argument_list|<
name|?
argument_list|>
name|iter
init|=
name|ObjectHelper
operator|.
name|createIterator
argument_list|(
name|headerValue
argument_list|)
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Object
name|recipient
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|appendRecipientToMimeMessage
argument_list|(
name|mimeMessage
argument_list|,
name|headerName
argument_list|,
name|asString
argument_list|(
name|exchange
argument_list|,
name|recipient
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|appendRecipientToMimeMessage
argument_list|(
name|mimeMessage
argument_list|,
name|headerName
argument_list|,
name|asString
argument_list|(
name|exchange
argument_list|,
name|headerValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Appends the Mail headers from the endpoint configuration.      */
DECL|method|setRecipientFromEndpointConfiguration (MimeMessage mimeMessage, MailEndpoint endpoint)
specifier|protected
name|void
name|setRecipientFromEndpointConfiguration
parameter_list|(
name|MimeMessage
name|mimeMessage
parameter_list|,
name|MailEndpoint
name|endpoint
parameter_list|)
throws|throws
name|MessagingException
block|{
name|Map
argument_list|<
name|Message
operator|.
name|RecipientType
argument_list|,
name|String
argument_list|>
name|recipients
init|=
name|endpoint
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getRecipients
argument_list|()
decl_stmt|;
if|if
condition|(
name|recipients
operator|.
name|containsKey
argument_list|(
name|Message
operator|.
name|RecipientType
operator|.
name|TO
argument_list|)
condition|)
block|{
name|appendRecipientToMimeMessage
argument_list|(
name|mimeMessage
argument_list|,
name|Message
operator|.
name|RecipientType
operator|.
name|TO
operator|.
name|toString
argument_list|()
argument_list|,
name|recipients
operator|.
name|get
argument_list|(
name|Message
operator|.
name|RecipientType
operator|.
name|TO
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recipients
operator|.
name|containsKey
argument_list|(
name|Message
operator|.
name|RecipientType
operator|.
name|CC
argument_list|)
condition|)
block|{
name|appendRecipientToMimeMessage
argument_list|(
name|mimeMessage
argument_list|,
name|Message
operator|.
name|RecipientType
operator|.
name|CC
operator|.
name|toString
argument_list|()
argument_list|,
name|recipients
operator|.
name|get
argument_list|(
name|Message
operator|.
name|RecipientType
operator|.
name|CC
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recipients
operator|.
name|containsKey
argument_list|(
name|Message
operator|.
name|RecipientType
operator|.
name|BCC
argument_list|)
condition|)
block|{
name|appendRecipientToMimeMessage
argument_list|(
name|mimeMessage
argument_list|,
name|Message
operator|.
name|RecipientType
operator|.
name|BCC
operator|.
name|toString
argument_list|()
argument_list|,
name|recipients
operator|.
name|get
argument_list|(
name|Message
operator|.
name|RecipientType
operator|.
name|BCC
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Appends the Mail attachments from the Camel {@link MailMessage}      */
DECL|method|appendAttachmentsFromCamel (MimeMessage mimeMessage, MailConfiguration configuration, Exchange exchange)
specifier|protected
name|void
name|appendAttachmentsFromCamel
parameter_list|(
name|MimeMessage
name|mimeMessage
parameter_list|,
name|MailConfiguration
name|configuration
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|MessagingException
throws|,
name|IOException
block|{
comment|// Put parts in message
name|mimeMessage
operator|.
name|setContent
argument_list|(
name|createMixedMultipartAttachments
argument_list|(
name|configuration
argument_list|,
name|exchange
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|createMixedMultipartAttachments (MailConfiguration configuration, Exchange exchange)
specifier|private
name|MimeMultipart
name|createMixedMultipartAttachments
parameter_list|(
name|MailConfiguration
name|configuration
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|MessagingException
throws|,
name|IOException
block|{
comment|// fill the body with text
name|MimeMultipart
name|multipart
init|=
operator|new
name|MimeMultipart
argument_list|()
decl_stmt|;
name|multipart
operator|.
name|setSubType
argument_list|(
literal|"mixed"
argument_list|)
expr_stmt|;
name|addBodyToMultipart
argument_list|(
name|configuration
argument_list|,
name|multipart
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
name|String
name|partDisposition
init|=
name|configuration
operator|.
name|isUseInlineAttachments
argument_list|()
condition|?
name|Part
operator|.
name|INLINE
else|:
name|Part
operator|.
name|ATTACHMENT
decl_stmt|;
if|if
condition|(
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|hasAttachments
argument_list|()
condition|)
block|{
name|addAttachmentsToMultipart
argument_list|(
name|multipart
argument_list|,
name|partDisposition
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
return|return
name|multipart
return|;
block|}
DECL|method|addAttachmentsToMultipart (MimeMultipart multipart, String partDisposition, Exchange exchange)
specifier|protected
name|void
name|addAttachmentsToMultipart
parameter_list|(
name|MimeMultipart
name|multipart
parameter_list|,
name|String
name|partDisposition
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|MessagingException
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Adding attachments +++ start +++"
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|DataHandler
argument_list|>
name|entry
range|:
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getAttachments
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|attachmentFilename
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|DataHandler
name|handler
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Attachment #{}: Disposition: {}"
argument_list|,
name|i
argument_list|,
name|partDisposition
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Attachment #{}: DataHandler: {}"
argument_list|,
name|i
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Attachment #{}: FileName: {}"
argument_list|,
name|i
argument_list|,
name|attachmentFilename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|handler
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|shouldAddAttachment
argument_list|(
name|exchange
argument_list|,
name|attachmentFilename
argument_list|,
name|handler
argument_list|)
condition|)
block|{
comment|// Create another body part
name|BodyPart
name|messageBodyPart
init|=
operator|new
name|MimeBodyPart
argument_list|()
decl_stmt|;
comment|// Set the data handler to the attachment
name|messageBodyPart
operator|.
name|setDataHandler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|attachmentFilename
operator|.
name|toLowerCase
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"cid:"
argument_list|)
condition|)
block|{
comment|// add a Content-ID header to the attachment
comment|// must use angle brackets according to RFC: http://www.ietf.org/rfc/rfc2392.txt
name|messageBodyPart
operator|.
name|addHeader
argument_list|(
literal|"Content-ID"
argument_list|,
literal|"<"
operator|+
name|attachmentFilename
operator|.
name|substring
argument_list|(
literal|4
argument_list|)
operator|+
literal|">"
argument_list|)
expr_stmt|;
comment|// Set the filename without the cid
name|messageBodyPart
operator|.
name|setFileName
argument_list|(
name|attachmentFilename
operator|.
name|substring
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Set the filename
name|messageBodyPart
operator|.
name|setFileName
argument_list|(
name|attachmentFilename
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"Attachment #"
operator|+
name|i
operator|+
literal|": ContentType: "
operator|+
name|messageBodyPart
operator|.
name|getContentType
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|contentTypeResolver
operator|!=
literal|null
condition|)
block|{
name|String
name|contentType
init|=
name|contentTypeResolver
operator|.
name|resolveContentType
argument_list|(
name|attachmentFilename
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Attachment #"
operator|+
name|i
operator|+
literal|": Using content type resolver: "
operator|+
name|contentTypeResolver
operator|+
literal|" resolved content type as: "
operator|+
name|contentType
argument_list|)
expr_stmt|;
if|if
condition|(
name|contentType
operator|!=
literal|null
condition|)
block|{
name|String
name|value
init|=
name|contentType
operator|+
literal|"; name="
operator|+
name|attachmentFilename
decl_stmt|;
name|messageBodyPart
operator|.
name|setHeader
argument_list|(
literal|"Content-Type"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Attachment #"
operator|+
name|i
operator|+
literal|": ContentType: "
operator|+
name|messageBodyPart
operator|.
name|getContentType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Set Disposition
name|messageBodyPart
operator|.
name|setDisposition
argument_list|(
name|partDisposition
argument_list|)
expr_stmt|;
comment|// Add part to multipart
name|multipart
operator|.
name|addBodyPart
argument_list|(
name|messageBodyPart
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"shouldAddAttachment: false"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot add attachment: "
operator|+
name|attachmentFilename
operator|+
literal|" as DataHandler is null"
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"Adding attachments +++ done +++"
argument_list|)
expr_stmt|;
block|}
DECL|method|createMultipartAlternativeMessage (MimeMessage mimeMessage, MailConfiguration configuration, Exchange exchange)
specifier|protected
name|void
name|createMultipartAlternativeMessage
parameter_list|(
name|MimeMessage
name|mimeMessage
parameter_list|,
name|MailConfiguration
name|configuration
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|MessagingException
throws|,
name|IOException
block|{
name|MimeMultipart
name|multipartAlternative
init|=
operator|new
name|MimeMultipart
argument_list|(
literal|"alternative"
argument_list|)
decl_stmt|;
name|mimeMessage
operator|.
name|setContent
argument_list|(
name|multipartAlternative
argument_list|)
expr_stmt|;
name|MimeBodyPart
name|plainText
init|=
operator|new
name|MimeBodyPart
argument_list|()
decl_stmt|;
name|plainText
operator|.
name|setText
argument_list|(
name|getAlternativeBody
argument_list|(
name|configuration
argument_list|,
name|exchange
argument_list|)
argument_list|,
name|determineCharSet
argument_list|(
name|configuration
argument_list|,
name|exchange
argument_list|)
argument_list|)
expr_stmt|;
comment|// remove the header with the alternative mail now that we got it
comment|// otherwise it might end up twice in the mail reader
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|removeHeader
argument_list|(
name|configuration
operator|.
name|getAlternativeBodyHeader
argument_list|()
argument_list|)
expr_stmt|;
name|multipartAlternative
operator|.
name|addBodyPart
argument_list|(
name|plainText
argument_list|)
expr_stmt|;
comment|// if there are no attachments, add the body to the same mulitpart message
if|if
condition|(
operator|!
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|hasAttachments
argument_list|()
condition|)
block|{
name|addBodyToMultipart
argument_list|(
name|configuration
argument_list|,
name|multipartAlternative
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// if there are attachments, but they aren't set to be inline, add them to
comment|// treat them as normal. It will append a multipart-mixed with the attachments and the body text
if|if
condition|(
operator|!
name|configuration
operator|.
name|isUseInlineAttachments
argument_list|()
condition|)
block|{
name|BodyPart
name|mixedAttachments
init|=
operator|new
name|MimeBodyPart
argument_list|()
decl_stmt|;
name|mixedAttachments
operator|.
name|setContent
argument_list|(
name|createMixedMultipartAttachments
argument_list|(
name|configuration
argument_list|,
name|exchange
argument_list|)
argument_list|)
expr_stmt|;
name|multipartAlternative
operator|.
name|addBodyPart
argument_list|(
name|mixedAttachments
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// if the attachments are set to be inline, attach them as inline attachments
name|MimeMultipart
name|multipartRelated
init|=
operator|new
name|MimeMultipart
argument_list|(
literal|"related"
argument_list|)
decl_stmt|;
name|BodyPart
name|related
init|=
operator|new
name|MimeBodyPart
argument_list|()
decl_stmt|;
name|related
operator|.
name|setContent
argument_list|(
name|multipartRelated
argument_list|)
expr_stmt|;
name|multipartAlternative
operator|.
name|addBodyPart
argument_list|(
name|related
argument_list|)
expr_stmt|;
name|addBodyToMultipart
argument_list|(
name|configuration
argument_list|,
name|multipartRelated
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
name|addAttachmentsToMultipart
argument_list|(
name|multipartRelated
argument_list|,
name|Part
operator|.
name|INLINE
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|addBodyToMultipart (MailConfiguration configuration, MimeMultipart activeMultipart, Exchange exchange)
specifier|protected
name|void
name|addBodyToMultipart
parameter_list|(
name|MailConfiguration
name|configuration
parameter_list|,
name|MimeMultipart
name|activeMultipart
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|MessagingException
throws|,
name|IOException
block|{
name|BodyPart
name|bodyMessage
init|=
operator|new
name|MimeBodyPart
argument_list|()
decl_stmt|;
name|populateContentOnBodyPart
argument_list|(
name|bodyMessage
argument_list|,
name|configuration
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
name|activeMultipart
operator|.
name|addBodyPart
argument_list|(
name|bodyMessage
argument_list|)
expr_stmt|;
block|}
comment|/**      * Strategy to allow filtering of attachments which are added on the Mail message      */
DECL|method|shouldAddAttachment (Exchange exchange, String attachmentFilename, DataHandler handler)
specifier|protected
name|boolean
name|shouldAddAttachment
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|attachmentFilename
parameter_list|,
name|DataHandler
name|handler
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
DECL|method|extractHeadersFromMail (Message mailMessage, Exchange exchange)
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|extractHeadersFromMail
parameter_list|(
name|Message
name|mailMessage
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|MessagingException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|answer
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|Enumeration
argument_list|<
name|?
argument_list|>
name|names
init|=
name|mailMessage
operator|.
name|getAllHeaders
argument_list|()
decl_stmt|;
while|while
condition|(
name|names
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|Header
name|header
init|=
operator|(
name|Header
operator|)
name|names
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|String
name|value
init|=
name|header
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|headerFilterStrategy
operator|!=
literal|null
operator|&&
operator|!
name|headerFilterStrategy
operator|.
name|applyFilterToExternalHeaders
argument_list|(
name|header
operator|.
name|getName
argument_list|()
argument_list|,
name|value
argument_list|,
name|exchange
argument_list|)
condition|)
block|{
name|CollectionHelper
operator|.
name|appendValue
argument_list|(
name|answer
argument_list|,
name|header
operator|.
name|getName
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
DECL|method|appendRecipientToMimeMessage (MimeMessage mimeMessage, String type, String recipient)
specifier|private
specifier|static
name|void
name|appendRecipientToMimeMessage
parameter_list|(
name|MimeMessage
name|mimeMessage
parameter_list|,
name|String
name|type
parameter_list|,
name|String
name|recipient
parameter_list|)
throws|throws
name|MessagingException
block|{
comment|// we support that multi recipient can be given as a string separated by comma or semicolon
comment|// regex ignores comma and semicolon inside of double quotes
name|String
index|[]
name|lines
init|=
name|recipient
operator|.
name|split
argument_list|(
literal|"[,;]++(?=(?:(?:[^\\\"]*+\\\"){2})*+[^\\\"]*+$)"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|line
range|:
name|lines
control|)
block|{
name|line
operator|=
name|line
operator|.
name|trim
argument_list|()
expr_stmt|;
name|mimeMessage
operator|.
name|addRecipients
argument_list|(
name|asRecipientType
argument_list|(
name|type
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Does the given camel message contain any To, CC or BCC header names?      */
DECL|method|hasRecipientHeaders (Exchange exchange)
specifier|private
specifier|static
name|boolean
name|hasRecipientHeaders
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
for|for
control|(
name|String
name|key
range|:
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeaders
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|isRecipientHeader
argument_list|(
name|key
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|hasAlternativeBody (MailConfiguration configuration, Exchange exchange)
specifier|protected
specifier|static
name|boolean
name|hasAlternativeBody
parameter_list|(
name|MailConfiguration
name|configuration
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|getAlternativeBody
argument_list|(
name|configuration
argument_list|,
name|exchange
argument_list|)
operator|!=
literal|null
return|;
block|}
DECL|method|getAlternativeBody (MailConfiguration configuration, Exchange exchange)
specifier|protected
specifier|static
name|String
name|getAlternativeBody
parameter_list|(
name|MailConfiguration
name|configuration
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
name|String
name|alternativeBodyHeader
init|=
name|configuration
operator|.
name|getAlternativeBodyHeader
argument_list|()
decl_stmt|;
return|return
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|alternativeBodyHeader
argument_list|,
name|java
operator|.
name|lang
operator|.
name|String
operator|.
name|class
argument_list|)
return|;
block|}
comment|/**      * Is the given key a mime message recipient header (To, CC or BCC)      */
DECL|method|isRecipientHeader (String key)
specifier|private
specifier|static
name|boolean
name|isRecipientHeader
parameter_list|(
name|String
name|key
parameter_list|)
block|{
if|if
condition|(
name|Message
operator|.
name|RecipientType
operator|.
name|TO
operator|.
name|toString
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|key
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|Message
operator|.
name|RecipientType
operator|.
name|CC
operator|.
name|toString
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|key
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|Message
operator|.
name|RecipientType
operator|.
name|BCC
operator|.
name|toString
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|key
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Returns the RecipientType object.      */
DECL|method|asRecipientType (String type)
specifier|private
specifier|static
name|Message
operator|.
name|RecipientType
name|asRecipientType
parameter_list|(
name|String
name|type
parameter_list|)
block|{
if|if
condition|(
name|Message
operator|.
name|RecipientType
operator|.
name|TO
operator|.
name|toString
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|type
argument_list|)
condition|)
block|{
return|return
name|Message
operator|.
name|RecipientType
operator|.
name|TO
return|;
block|}
elseif|else
if|if
condition|(
name|Message
operator|.
name|RecipientType
operator|.
name|CC
operator|.
name|toString
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|type
argument_list|)
condition|)
block|{
return|return
name|Message
operator|.
name|RecipientType
operator|.
name|CC
return|;
block|}
elseif|else
if|if
condition|(
name|Message
operator|.
name|RecipientType
operator|.
name|BCC
operator|.
name|toString
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|type
argument_list|)
condition|)
block|{
return|return
name|Message
operator|.
name|RecipientType
operator|.
name|BCC
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown recipient type: "
operator|+
name|type
argument_list|)
throw|;
block|}
DECL|method|empty (Address[] addresses)
specifier|private
specifier|static
name|boolean
name|empty
parameter_list|(
name|Address
index|[]
name|addresses
parameter_list|)
block|{
return|return
name|addresses
operator|==
literal|null
operator|||
name|addresses
operator|.
name|length
operator|==
literal|0
return|;
block|}
DECL|method|asString (Exchange exchange, Object value)
specifier|private
specifier|static
name|String
name|asString
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|String
operator|.
name|class
argument_list|,
name|exchange
argument_list|,
name|value
argument_list|)
return|;
block|}
block|}
end_class

end_unit

