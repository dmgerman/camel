begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.guice.inject
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|guice
operator|.
name|inject
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Annotation
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|AbstractModule
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|Binding
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|Guice
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|Injector
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|Key
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|Module
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|Provider
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|Scope
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|Singleton
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|TypeLiteral
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|internal
operator|.
name|BindingImpl
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|internal
operator|.
name|Scoping
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|matcher
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|name
operator|.
name|Names
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|inject
operator|.
name|util
operator|.
name|Modules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|guice
operator|.
name|jndi
operator|.
name|GuiceInitialContextFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|guice
operator|.
name|jndi
operator|.
name|internal
operator|.
name|Classes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|guice
operator|.
name|support
operator|.
name|CloseErrors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|guice
operator|.
name|support
operator|.
name|CloseFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|guice
operator|.
name|support
operator|.
name|Closer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|guice
operator|.
name|support
operator|.
name|Closers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|guice
operator|.
name|support
operator|.
name|CompositeCloser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|guice
operator|.
name|support
operator|.
name|HasScopeAnnotation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|guice
operator|.
name|support
operator|.
name|internal
operator|.
name|CloseErrorsImpl
import|;
end_import

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
DECL|class|Injectors
specifier|public
specifier|final
class|class
name|Injectors
block|{
DECL|field|MODULE_CLASS_NAMES
specifier|public
specifier|static
specifier|final
name|String
name|MODULE_CLASS_NAMES
init|=
literal|"org.guiceyfruit.modules"
decl_stmt|;
DECL|method|Injectors ()
specifier|private
name|Injectors
parameter_list|()
block|{
comment|//Helper class
block|}
comment|/**      * Creates an injector from the given properties, loading any modules define      * by the {@link #MODULE_CLASS_NAMES} property value (space separated) along      * with any other modules passed as an argument.      *       * @param environment      *            the properties used to create the injector      * @param overridingModules      *            any modules which override the modules referenced in the      *            environment such as to provide the actual JNDI context      */
DECL|method|createInjector (final Map environment, Module... overridingModules)
specifier|public
specifier|static
name|Injector
name|createInjector
parameter_list|(
specifier|final
name|Map
name|environment
parameter_list|,
name|Module
modifier|...
name|overridingModules
parameter_list|)
throws|throws
name|ClassNotFoundException
throws|,
name|IllegalAccessException
throws|,
name|InstantiationException
block|{
name|List
argument_list|<
name|Module
argument_list|>
name|modules
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// lets bind the properties
name|modules
operator|.
name|add
argument_list|(
operator|new
name|AbstractModule
argument_list|()
block|{
specifier|protected
name|void
name|configure
parameter_list|()
block|{
name|Names
operator|.
name|bindProperties
argument_list|(
name|binder
argument_list|()
argument_list|,
name|environment
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|Object
name|moduleValue
init|=
name|environment
operator|.
name|get
argument_list|(
name|MODULE_CLASS_NAMES
argument_list|)
decl_stmt|;
if|if
condition|(
name|moduleValue
operator|instanceof
name|String
condition|)
block|{
name|String
name|names
init|=
operator|(
name|String
operator|)
name|moduleValue
decl_stmt|;
name|StringTokenizer
name|iter
init|=
operator|new
name|StringTokenizer
argument_list|(
name|names
argument_list|)
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|moduleName
init|=
name|iter
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|Module
name|module
init|=
name|loadModule
argument_list|(
name|moduleName
argument_list|)
decl_stmt|;
if|if
condition|(
name|module
operator|!=
literal|null
condition|)
block|{
name|modules
operator|.
name|add
argument_list|(
name|module
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Injector
name|injector
init|=
name|Guice
operator|.
name|createInjector
argument_list|(
name|Modules
operator|.
name|override
argument_list|(
name|modules
argument_list|)
operator|.
name|with
argument_list|(
name|overridingModules
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|injector
return|;
block|}
comment|/**      * Returns an instance of the given type with the      * {@link com.google.inject.name.Named} annotation value.      *       * This method allows you to switch this code      *<code>injector.getInstance(Key.get(type, Names.named(name)));</code>      *       * to the more concise      *<code>Injectors.getInstance(injector, type, name);</code>      */
DECL|method|getInstance (Injector injector, java.lang.Class<T> type, String name)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getInstance
parameter_list|(
name|Injector
name|injector
parameter_list|,
name|java
operator|.
name|lang
operator|.
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
name|injector
operator|.
name|getInstance
argument_list|(
name|Key
operator|.
name|get
argument_list|(
name|type
argument_list|,
name|Names
operator|.
name|named
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Returns a collection of all instances of the given base type      *       * @param baseClass      *            the base type of objects required      * @param<T>      *            the base type      * @return a set of objects returned from this injector      */
DECL|method|getInstancesOf (Injector injector, Class<T> baseClass)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Set
argument_list|<
name|T
argument_list|>
name|getInstancesOf
parameter_list|(
name|Injector
name|injector
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|baseClass
parameter_list|)
block|{
name|Set
argument_list|<
name|T
argument_list|>
name|answer
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Entry
argument_list|<
name|Key
argument_list|<
name|?
argument_list|>
argument_list|,
name|Binding
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|entries
init|=
name|injector
operator|.
name|getBindings
argument_list|()
operator|.
name|entrySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Key
argument_list|<
name|?
argument_list|>
argument_list|,
name|Binding
argument_list|<
name|?
argument_list|>
argument_list|>
name|entry
range|:
name|entries
control|)
block|{
name|Key
argument_list|<
name|?
argument_list|>
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|keyType
init|=
name|getKeyType
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyType
operator|!=
literal|null
operator|&&
name|baseClass
operator|.
name|isAssignableFrom
argument_list|(
name|keyType
argument_list|)
condition|)
block|{
name|Binding
argument_list|<
name|?
argument_list|>
name|binding
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Object
name|value
init|=
name|binding
operator|.
name|getProvider
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|T
name|castValue
init|=
name|baseClass
operator|.
name|cast
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|answer
operator|.
name|add
argument_list|(
name|castValue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Returns a collection of all instances matching the given matcher      *       * @param matcher      *            matches the types to return instances      * @return a set of objects returned from this injector      */
DECL|method|getInstancesOf (Injector injector, Matcher<Class> matcher)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Set
argument_list|<
name|T
argument_list|>
name|getInstancesOf
parameter_list|(
name|Injector
name|injector
parameter_list|,
name|Matcher
argument_list|<
name|Class
argument_list|>
name|matcher
parameter_list|)
block|{
name|Set
argument_list|<
name|T
argument_list|>
name|answer
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Entry
argument_list|<
name|Key
argument_list|<
name|?
argument_list|>
argument_list|,
name|Binding
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|entries
init|=
name|injector
operator|.
name|getBindings
argument_list|()
operator|.
name|entrySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Key
argument_list|<
name|?
argument_list|>
argument_list|,
name|Binding
argument_list|<
name|?
argument_list|>
argument_list|>
name|entry
range|:
name|entries
control|)
block|{
name|Key
argument_list|<
name|?
argument_list|>
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|keyType
init|=
name|getKeyType
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyType
operator|!=
literal|null
operator|&&
name|matcher
operator|.
name|matches
argument_list|(
name|keyType
argument_list|)
condition|)
block|{
name|Binding
argument_list|<
name|?
argument_list|>
name|binding
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Object
name|value
init|=
name|binding
operator|.
name|getProvider
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
name|answer
operator|.
name|add
argument_list|(
operator|(
name|T
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Returns a collection of all of the providers matching the given matcher      *       * @param matcher      *            matches the types to return instances      * @return a set of objects returned from this injector      */
DECL|method|getProvidersOf (Injector injector, Matcher<Class> matcher)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Set
argument_list|<
name|Provider
argument_list|<
name|T
argument_list|>
argument_list|>
name|getProvidersOf
parameter_list|(
name|Injector
name|injector
parameter_list|,
name|Matcher
argument_list|<
name|Class
argument_list|>
name|matcher
parameter_list|)
block|{
name|Set
argument_list|<
name|Provider
argument_list|<
name|T
argument_list|>
argument_list|>
name|answer
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Entry
argument_list|<
name|Key
argument_list|<
name|?
argument_list|>
argument_list|,
name|Binding
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|entries
init|=
name|injector
operator|.
name|getBindings
argument_list|()
operator|.
name|entrySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Key
argument_list|<
name|?
argument_list|>
argument_list|,
name|Binding
argument_list|<
name|?
argument_list|>
argument_list|>
name|entry
range|:
name|entries
control|)
block|{
name|Key
argument_list|<
name|?
argument_list|>
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|keyType
init|=
name|getKeyType
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyType
operator|!=
literal|null
operator|&&
name|matcher
operator|.
name|matches
argument_list|(
name|keyType
argument_list|)
condition|)
block|{
name|Binding
argument_list|<
name|?
argument_list|>
name|binding
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|answer
operator|.
name|add
argument_list|(
operator|(
name|Provider
argument_list|<
name|T
argument_list|>
operator|)
name|binding
operator|.
name|getProvider
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Returns a collection of all providers of the given base type      *       * @param baseClass      *            the base type of objects required      * @param<T>      *            the base type      * @return a set of objects returned from this injector      */
DECL|method|getProvidersOf (Injector injector, Class<T> baseClass)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Set
argument_list|<
name|Provider
argument_list|<
name|T
argument_list|>
argument_list|>
name|getProvidersOf
parameter_list|(
name|Injector
name|injector
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|baseClass
parameter_list|)
block|{
name|Set
argument_list|<
name|Provider
argument_list|<
name|T
argument_list|>
argument_list|>
name|answer
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Entry
argument_list|<
name|Key
argument_list|<
name|?
argument_list|>
argument_list|,
name|Binding
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|entries
init|=
name|injector
operator|.
name|getBindings
argument_list|()
operator|.
name|entrySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Key
argument_list|<
name|?
argument_list|>
argument_list|,
name|Binding
argument_list|<
name|?
argument_list|>
argument_list|>
name|entry
range|:
name|entries
control|)
block|{
name|Key
argument_list|<
name|?
argument_list|>
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|keyType
init|=
name|getKeyType
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyType
operator|!=
literal|null
operator|&&
name|baseClass
operator|.
name|isAssignableFrom
argument_list|(
name|keyType
argument_list|)
condition|)
block|{
name|Binding
argument_list|<
name|?
argument_list|>
name|binding
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|answer
operator|.
name|add
argument_list|(
operator|(
name|Provider
argument_list|<
name|T
argument_list|>
operator|)
name|binding
operator|.
name|getProvider
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
comment|/** Returns true if a binding exists for the given matcher */
DECL|method|hasBinding (Injector injector, Matcher<Class> matcher)
specifier|public
specifier|static
name|boolean
name|hasBinding
parameter_list|(
name|Injector
name|injector
parameter_list|,
name|Matcher
argument_list|<
name|Class
argument_list|>
name|matcher
parameter_list|)
block|{
return|return
operator|!
name|getBindingsOf
argument_list|(
name|injector
argument_list|,
name|matcher
argument_list|)
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/** Returns true if a binding exists for the given base class */
DECL|method|hasBinding (Injector injector, Class<?> baseClass)
specifier|public
specifier|static
name|boolean
name|hasBinding
parameter_list|(
name|Injector
name|injector
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|baseClass
parameter_list|)
block|{
return|return
operator|!
name|getBindingsOf
argument_list|(
name|injector
argument_list|,
name|baseClass
argument_list|)
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/** Returns true if a binding exists for the given key */
DECL|method|hasBinding (Injector injector, Key<?> key)
specifier|public
specifier|static
name|boolean
name|hasBinding
parameter_list|(
name|Injector
name|injector
parameter_list|,
name|Key
argument_list|<
name|?
argument_list|>
name|key
parameter_list|)
block|{
name|Binding
argument_list|<
name|?
argument_list|>
name|binding
init|=
name|getBinding
argument_list|(
name|injector
argument_list|,
name|key
argument_list|)
decl_stmt|;
return|return
name|binding
operator|!=
literal|null
return|;
block|}
comment|/**      * Returns the binding for the given key or null if there is no such binding      */
DECL|method|getBinding (Injector injector, Key<?> key)
specifier|public
specifier|static
name|Binding
argument_list|<
name|?
argument_list|>
name|getBinding
parameter_list|(
name|Injector
name|injector
parameter_list|,
name|Key
argument_list|<
name|?
argument_list|>
name|key
parameter_list|)
block|{
name|Map
argument_list|<
name|Key
argument_list|<
name|?
argument_list|>
argument_list|,
name|Binding
argument_list|<
name|?
argument_list|>
argument_list|>
name|bindings
init|=
name|injector
operator|.
name|getBindings
argument_list|()
decl_stmt|;
name|Binding
argument_list|<
name|?
argument_list|>
name|binding
init|=
name|bindings
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|binding
return|;
block|}
comment|/**      * Returns a collection of all of the bindings matching the given matcher      *       * @param matcher      *            matches the types to return instances      * @return a set of objects returned from this injector      */
DECL|method|getBindingsOf (Injector injector, Matcher<Class> matcher)
specifier|public
specifier|static
name|Set
argument_list|<
name|Binding
argument_list|<
name|?
argument_list|>
argument_list|>
name|getBindingsOf
parameter_list|(
name|Injector
name|injector
parameter_list|,
name|Matcher
argument_list|<
name|Class
argument_list|>
name|matcher
parameter_list|)
block|{
name|Set
argument_list|<
name|Binding
argument_list|<
name|?
argument_list|>
argument_list|>
name|answer
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Entry
argument_list|<
name|Key
argument_list|<
name|?
argument_list|>
argument_list|,
name|Binding
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|entries
init|=
name|injector
operator|.
name|getBindings
argument_list|()
operator|.
name|entrySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Key
argument_list|<
name|?
argument_list|>
argument_list|,
name|Binding
argument_list|<
name|?
argument_list|>
argument_list|>
name|entry
range|:
name|entries
control|)
block|{
name|Key
argument_list|<
name|?
argument_list|>
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|keyType
init|=
name|getKeyType
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyType
operator|!=
literal|null
operator|&&
name|matcher
operator|.
name|matches
argument_list|(
name|keyType
argument_list|)
condition|)
block|{
name|answer
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Returns a collection of all bindings of the given base type      *       * @param baseClass      *            the base type of objects required      * @return a set of objects returned from this injector      */
DECL|method|getBindingsOf (Injector injector, Class<?> baseClass)
specifier|public
specifier|static
name|Set
argument_list|<
name|Binding
argument_list|<
name|?
argument_list|>
argument_list|>
name|getBindingsOf
parameter_list|(
name|Injector
name|injector
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|baseClass
parameter_list|)
block|{
name|Set
argument_list|<
name|Binding
argument_list|<
name|?
argument_list|>
argument_list|>
name|answer
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Entry
argument_list|<
name|Key
argument_list|<
name|?
argument_list|>
argument_list|,
name|Binding
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|entries
init|=
name|injector
operator|.
name|getBindings
argument_list|()
operator|.
name|entrySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Key
argument_list|<
name|?
argument_list|>
argument_list|,
name|Binding
argument_list|<
name|?
argument_list|>
argument_list|>
name|entry
range|:
name|entries
control|)
block|{
name|Key
argument_list|<
name|?
argument_list|>
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|keyType
init|=
name|getKeyType
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyType
operator|!=
literal|null
operator|&&
name|baseClass
operator|.
name|isAssignableFrom
argument_list|(
name|keyType
argument_list|)
condition|)
block|{
name|answer
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
comment|/** Returns the key type of the given key */
DECL|method|getKeyType (Key<?> key)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Class
argument_list|<
name|?
argument_list|>
name|getKeyType
parameter_list|(
name|Key
argument_list|<
name|?
argument_list|>
name|key
parameter_list|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|keyType
init|=
literal|null
decl_stmt|;
name|TypeLiteral
argument_list|<
name|?
argument_list|>
name|typeLiteral
init|=
name|key
operator|.
name|getTypeLiteral
argument_list|()
decl_stmt|;
name|Type
name|type
init|=
name|typeLiteral
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|instanceof
name|Class
condition|)
block|{
name|keyType
operator|=
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|type
expr_stmt|;
block|}
return|return
name|keyType
return|;
block|}
DECL|method|loadModule (String moduleName)
specifier|protected
specifier|static
name|Module
name|loadModule
parameter_list|(
name|String
name|moduleName
parameter_list|)
throws|throws
name|ClassNotFoundException
throws|,
name|IllegalAccessException
throws|,
name|InstantiationException
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|type
init|=
name|Classes
operator|.
name|loadClass
argument_list|(
name|moduleName
argument_list|,
name|GuiceInitialContextFactory
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|(
name|Module
operator|)
name|type
operator|.
name|newInstance
argument_list|()
return|;
block|}
comment|/*   */
comment|/**      * Closes the given scope on this injector      *       * @param injector      *            the injector on which to close objects      * @param scopeAnnotation      *            the scope on which to close the objects      * @throws CloseFailedException      *             the exceptions caused if closing an object fails      */
comment|/*      * public static void close(Injector injector, Annotation scopeAnnotation)      * throws CloseFailedException { Key<PreDestroyer> key =      * Key.get(PreDestroyer.class, scopeAnnotation); if (hasBinding(injector,      * key)) { PreDestroyer destroyer = injector.getInstance(key);      * destroyer.close(); } }      */
comment|/**      * Closes any singleton objects in the injector using the currently      * registered {@link Closer} implementations      */
DECL|method|close (Injector injector)
specifier|public
specifier|static
name|void
name|close
parameter_list|(
name|Injector
name|injector
parameter_list|)
throws|throws
name|CloseFailedException
block|{
name|close
argument_list|(
name|injector
argument_list|,
operator|new
name|CloseErrorsImpl
argument_list|(
name|Injectors
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Closes objects within the given scope using the currently registered      * {@link Closer} implementations      */
DECL|method|close (Injector injector, CloseErrors errors)
specifier|public
specifier|static
name|void
name|close
parameter_list|(
name|Injector
name|injector
parameter_list|,
name|CloseErrors
name|errors
parameter_list|)
throws|throws
name|CloseFailedException
block|{
name|close
argument_list|(
name|injector
argument_list|,
name|Singleton
operator|.
name|class
argument_list|,
name|errors
argument_list|)
expr_stmt|;
block|}
comment|/**      * Closes objects within the given scope using the currently registered      * {@link Closer} implementations      */
DECL|method|close (Injector injector, Class<? extends Annotation> scopeAnnotationToClose)
specifier|public
specifier|static
name|void
name|close
parameter_list|(
name|Injector
name|injector
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Annotation
argument_list|>
name|scopeAnnotationToClose
parameter_list|)
throws|throws
name|CloseFailedException
block|{
name|close
argument_list|(
name|injector
argument_list|,
name|scopeAnnotationToClose
argument_list|,
operator|new
name|CloseErrorsImpl
argument_list|(
name|Injectors
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Closes objects within the given scope using the currently registered      * {@link Closer} implementations      */
DECL|method|close (Injector injector, Class<? extends Annotation> scopeAnnotationToClose, CloseErrors errors)
specifier|public
specifier|static
name|void
name|close
parameter_list|(
name|Injector
name|injector
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Annotation
argument_list|>
name|scopeAnnotationToClose
parameter_list|,
name|CloseErrors
name|errors
parameter_list|)
throws|throws
name|CloseFailedException
block|{
name|Set
argument_list|<
name|Closer
argument_list|>
name|closers
init|=
name|getInstancesOf
argument_list|(
name|injector
argument_list|,
name|Closer
operator|.
name|class
argument_list|)
decl_stmt|;
name|Closer
name|closer
init|=
name|CompositeCloser
operator|.
name|newInstance
argument_list|(
name|closers
argument_list|)
decl_stmt|;
if|if
condition|(
name|closer
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|Entry
argument_list|<
name|Key
argument_list|<
name|?
argument_list|>
argument_list|,
name|Binding
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|entries
init|=
name|injector
operator|.
name|getBindings
argument_list|()
operator|.
name|entrySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Key
argument_list|<
name|?
argument_list|>
argument_list|,
name|Binding
argument_list|<
name|?
argument_list|>
argument_list|>
name|entry
range|:
name|entries
control|)
block|{
name|Key
argument_list|<
name|?
argument_list|>
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Binding
argument_list|<
name|?
argument_list|>
name|binding
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|closeBinding
argument_list|(
name|key
argument_list|,
name|binding
argument_list|,
name|scopeAnnotationToClose
argument_list|,
name|closer
argument_list|,
name|errors
argument_list|)
expr_stmt|;
block|}
name|tryCloseJitBindings
argument_list|(
name|closer
argument_list|,
name|injector
argument_list|,
name|scopeAnnotationToClose
argument_list|,
name|errors
argument_list|)
expr_stmt|;
name|errors
operator|.
name|throwIfNecessary
argument_list|()
expr_stmt|;
block|}
DECL|method|tryCloseJitBindings (Closer closer, Injector injector, Class<? extends Annotation> scopeAnnotationToClose, CloseErrors errors)
specifier|private
specifier|static
name|void
name|tryCloseJitBindings
parameter_list|(
name|Closer
name|closer
parameter_list|,
name|Injector
name|injector
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Annotation
argument_list|>
name|scopeAnnotationToClose
parameter_list|,
name|CloseErrors
name|errors
parameter_list|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|Injector
argument_list|>
name|type
init|=
name|injector
operator|.
name|getClass
argument_list|()
decl_stmt|;
name|Field
name|field
decl_stmt|;
try|try
block|{
name|field
operator|=
name|type
operator|.
name|getDeclaredField
argument_list|(
literal|"jitBindings"
argument_list|)
expr_stmt|;
name|field
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Object
name|bindings
init|=
name|field
operator|.
name|get
argument_list|(
name|injector
argument_list|)
decl_stmt|;
if|if
condition|(
name|bindings
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|bindings
operator|instanceof
name|Map
condition|)
block|{
name|Map
argument_list|<
name|Key
argument_list|<
name|?
argument_list|>
argument_list|,
name|BindingImpl
argument_list|<
name|?
argument_list|>
argument_list|>
name|map
init|=
operator|(
name|Map
argument_list|<
name|Key
argument_list|<
name|?
argument_list|>
argument_list|,
name|BindingImpl
argument_list|<
name|?
argument_list|>
argument_list|>
operator|)
name|bindings
decl_stmt|;
name|Set
argument_list|<
name|Entry
argument_list|<
name|Key
argument_list|<
name|?
argument_list|>
argument_list|,
name|BindingImpl
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|entries
init|=
name|map
operator|.
name|entrySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Key
argument_list|<
name|?
argument_list|>
argument_list|,
name|BindingImpl
argument_list|<
name|?
argument_list|>
argument_list|>
name|entry
range|:
name|entries
control|)
block|{
name|closeBinding
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|scopeAnnotationToClose
argument_list|,
name|closer
argument_list|,
name|errors
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|NoSuchFieldException
name|e
parameter_list|)
block|{
comment|// ignore - Guice has refactored so we can't access the jit bindings
comment|// System.out.println("No such field! " + e);
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
comment|// ignore - Guice has refactored so we can't access the jit bindings
comment|// System.out.println("Failed to access field: " + field +
comment|// ". Reason: " + e);
block|}
block|}
DECL|method|closeBinding (Key<?> key, Binding<?> binding, Class<? extends Annotation> scopeAnnotationToClose, Closer closer, CloseErrors errors)
specifier|private
specifier|static
name|void
name|closeBinding
parameter_list|(
name|Key
argument_list|<
name|?
argument_list|>
name|key
parameter_list|,
name|Binding
argument_list|<
name|?
argument_list|>
name|binding
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Annotation
argument_list|>
name|scopeAnnotationToClose
parameter_list|,
name|Closer
name|closer
parameter_list|,
name|CloseErrors
name|errors
parameter_list|)
block|{
name|Provider
argument_list|<
name|?
argument_list|>
name|provider
init|=
name|binding
operator|.
name|getProvider
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|Annotation
argument_list|>
name|scopeAnnotation
init|=
name|getScopeAnnotation
argument_list|(
name|binding
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|scopeAnnotation
operator|!=
literal|null
operator|)
operator|&&
name|scopeAnnotation
operator|.
name|equals
argument_list|(
name|scopeAnnotationToClose
argument_list|)
condition|)
block|{
name|Object
name|value
init|=
name|provider
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|Closers
operator|.
name|close
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|closer
argument_list|,
name|errors
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Returns the scope annotation for the given binding or null if there is no      * scope      */
DECL|method|getScopeAnnotation ( Binding<?> binding)
specifier|public
specifier|static
name|Class
argument_list|<
name|?
extends|extends
name|Annotation
argument_list|>
name|getScopeAnnotation
parameter_list|(
name|Binding
argument_list|<
name|?
argument_list|>
name|binding
parameter_list|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|Annotation
argument_list|>
name|scopeAnnotation
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|binding
operator|instanceof
name|BindingImpl
condition|)
block|{
name|BindingImpl
name|bindingImpl
init|=
operator|(
name|BindingImpl
operator|)
name|binding
decl_stmt|;
name|Scoping
name|scoping
init|=
name|bindingImpl
operator|.
name|getScoping
argument_list|()
decl_stmt|;
if|if
condition|(
name|scoping
operator|!=
literal|null
condition|)
block|{
name|scopeAnnotation
operator|=
name|scoping
operator|.
name|getScopeAnnotation
argument_list|()
expr_stmt|;
comment|// TODO not sure why we need this hack???
if|if
condition|(
name|scopeAnnotation
operator|==
literal|null
condition|)
block|{
name|Scope
name|scope
init|=
name|scoping
operator|.
name|getScopeInstance
argument_list|()
decl_stmt|;
if|if
condition|(
name|scope
operator|instanceof
name|HasScopeAnnotation
condition|)
block|{
name|HasScopeAnnotation
name|hasScopeAnnotation
init|=
operator|(
name|HasScopeAnnotation
operator|)
name|scope
decl_stmt|;
name|scopeAnnotation
operator|=
name|hasScopeAnnotation
operator|.
name|getScopeAnnotation
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|scopeAnnotation
operator|==
literal|null
operator|&&
operator|(
name|scoping
operator|==
name|Scoping
operator|.
name|EAGER_SINGLETON
operator|||
name|scoping
operator|==
name|Scoping
operator|.
name|SINGLETON_ANNOTATION
operator|||
name|scoping
operator|==
name|Scoping
operator|.
name|SINGLETON_INSTANCE
operator|)
condition|)
block|{
name|scopeAnnotation
operator|=
name|Singleton
operator|.
name|class
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|scopeAnnotation
return|;
block|}
block|}
end_class

end_unit

