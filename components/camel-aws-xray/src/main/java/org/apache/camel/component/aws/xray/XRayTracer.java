begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.component.aws.xray
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|aws
operator|.
name|xray
package|;
end_package

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ServiceLoader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|xray
operator|.
name|AWSXRay
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|xray
operator|.
name|entities
operator|.
name|Entity
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|xray
operator|.
name|entities
operator|.
name|Segment
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|xray
operator|.
name|entities
operator|.
name|Subsegment
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|xray
operator|.
name|entities
operator|.
name|TraceID
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|xray
operator|.
name|exceptions
operator|.
name|AlreadyEmittedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContextAware
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Endpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|NamedNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Route
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|RuntimeCamelException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|StaticService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|CamelEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|CamelEvent
operator|.
name|ExchangeSendingEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|CamelEvent
operator|.
name|ExchangeSentEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|InterceptStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|RoutePolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|RoutePolicyFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|EventNotifierSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|RoutePolicySupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|service
operator|.
name|ServiceHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|service
operator|.
name|ServiceSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ObjectHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * To use AWS XRay with Camel setup this {@link XRayTracer} in your Camel application.  *<p/>  * This class uses a {@link org.apache.camel.spi.RoutePolicy} as well as a {@link  * org.apache.camel.spi.EventNotifier} internally to manage the creation and termination of AWS XRay  * {@link Segment Segments} and {@link Subsegment Subsegments} once an exchange was created,  * forwarded or closed in order to allow monitoring the lifetime metrics of the exchange.  *<p/>  * A {@link InterceptStrategy} is used in order to track invocations and durations of EIP patterns  * used in processed routes. If no strategy is passed while configuration via {@link  * #setTracingStrategy(InterceptStrategy)}, a {@link NoopTracingStrategy} will be used by default  * which will not monitor any invocations at all.  *<p/>  * By default every invoked route will be tracked by AWS XRay. If certain routes shell not be  * tracked {@link #addExcludePattern(String)} and {@link #setExcludePatterns(Set)} can be used to  * provide the<em>routeId</em> of the routes to exclude from monitoring.  */
end_comment

begin_class
DECL|class|XRayTracer
specifier|public
class|class
name|XRayTracer
extends|extends
name|ServiceSupport
implements|implements
name|RoutePolicyFactory
implements|,
name|StaticService
implements|,
name|CamelContextAware
block|{
comment|/** Header value kept in the message of the exchange **/
DECL|field|XRAY_TRACE_ID
specifier|public
specifier|static
specifier|final
name|String
name|XRAY_TRACE_ID
init|=
literal|"Camel-AWS-XRay-Trace-ID"
decl_stmt|;
comment|// Note that the Entity itself is not serializable, so don't share this object among different VMs!
DECL|field|XRAY_TRACE_ENTITY
specifier|public
specifier|static
specifier|final
name|String
name|XRAY_TRACE_ENTITY
init|=
literal|"Camel-AWS-XRay-Trace-Entity"
decl_stmt|;
DECL|field|decorators
specifier|private
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|SegmentDecorator
argument_list|>
name|decorators
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Exchange property for passing a segment between threads **/
DECL|field|CURRENT_SEGMENT
specifier|private
specifier|static
specifier|final
name|String
name|CURRENT_SEGMENT
init|=
literal|"CAMEL_PROPERTY_AWS_XRAY_CURRENT_SEGMENT"
decl_stmt|;
DECL|field|eventNotifier
specifier|private
specifier|final
name|XRayEventNotifier
name|eventNotifier
init|=
operator|new
name|XRayEventNotifier
argument_list|()
decl_stmt|;
DECL|field|camelContext
specifier|private
name|CamelContext
name|camelContext
decl_stmt|;
DECL|field|excludePatterns
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|excludePatterns
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|tracingStrategy
specifier|private
name|InterceptStrategy
name|tracingStrategy
decl_stmt|;
static|static
block|{
name|ServiceLoader
operator|.
name|load
argument_list|(
name|SegmentDecorator
operator|.
name|class
argument_list|)
operator|.
name|forEach
argument_list|(
name|d
lambda|->
block|{
name|SegmentDecorator
name|existing
init|=
name|decorators
operator|.
name|get
argument_list|(
name|d
operator|.
name|getComponent
argument_list|()
argument_list|)
decl_stmt|;
comment|// Add segment decorator only if no existing decorator for the component exists yet or if we have have a
comment|// derived one. This allows custom decorators to be added if they extend the standard decorators
if|if
condition|(
name|existing
operator|==
literal|null
operator|||
name|existing
operator|.
name|getClass
argument_list|()
operator|.
name|isInstance
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|XRayTracer
operator|.
name|class
argument_list|)
decl_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"Adding segment decorator {}"
argument_list|,
name|d
operator|.
name|getComponent
argument_list|()
argument_list|)
expr_stmt|;
name|decorators
operator|.
name|put
argument_list|(
name|d
operator|.
name|getComponent
argument_list|()
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setCamelContext (CamelContext camelContext)
specifier|public
name|void
name|setCamelContext
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|)
block|{
name|this
operator|.
name|camelContext
operator|=
name|camelContext
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getCamelContext ()
specifier|public
name|CamelContext
name|getCamelContext
parameter_list|()
block|{
return|return
name|this
operator|.
name|camelContext
return|;
block|}
annotation|@
name|Override
DECL|method|createRoutePolicy (CamelContext camelContext, String routeId, NamedNode route)
specifier|public
name|RoutePolicy
name|createRoutePolicy
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|,
name|String
name|routeId
parameter_list|,
name|NamedNode
name|route
parameter_list|)
block|{
name|init
argument_list|(
name|camelContext
argument_list|)
expr_stmt|;
return|return
operator|new
name|XRayRoutePolicy
argument_list|(
name|routeId
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|doStart ()
specifier|protected
name|void
name|doStart
parameter_list|()
throws|throws
name|Exception
block|{
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|camelContext
argument_list|,
literal|"CamelContext"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|camelContext
operator|.
name|getManagementStrategy
argument_list|()
operator|.
name|addEventNotifier
argument_list|(
name|eventNotifier
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|camelContext
operator|.
name|getRoutePolicyFactories
argument_list|()
operator|.
name|contains
argument_list|(
name|this
argument_list|)
condition|)
block|{
name|camelContext
operator|.
name|addRoutePolicyFactory
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|==
name|tracingStrategy
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"No tracing strategy available. Defaulting to no-op strategy"
argument_list|)
expr_stmt|;
name|tracingStrategy
operator|=
operator|new
name|NoopTracingStrategy
argument_list|()
expr_stmt|;
block|}
name|camelContext
operator|.
name|addInterceptStrategy
argument_list|(
name|tracingStrategy
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Starting XRay tracer"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStop ()
specifier|protected
name|void
name|doStop
parameter_list|()
throws|throws
name|Exception
block|{
comment|// stop event notifier
name|camelContext
operator|.
name|getManagementStrategy
argument_list|()
operator|.
name|removeEventNotifier
argument_list|(
name|eventNotifier
argument_list|)
expr_stmt|;
name|ServiceHelper
operator|.
name|stopAndShutdownService
argument_list|(
name|eventNotifier
argument_list|)
expr_stmt|;
name|camelContext
operator|.
name|getRoutePolicyFactories
argument_list|()
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"XRay tracer stopped"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Initializes this AWS XRay tracer implementation as service within the Camel environment.      *      * @param camelContext The context to register this tracer as service with      */
DECL|method|init (CamelContext camelContext)
specifier|public
name|void
name|init
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|)
block|{
if|if
condition|(
operator|!
name|camelContext
operator|.
name|hasService
argument_list|(
name|this
argument_list|)
condition|)
block|{
try|try
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Initializing XRay tracer"
argument_list|)
expr_stmt|;
comment|// start this service eager so we init before Camel is starting up
name|camelContext
operator|.
name|addService
argument_list|(
name|this
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|RuntimeCamelException
operator|.
name|wrapRuntimeCamelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Returns the currently used tracing strategy which is responsible for tracking invoked EIP or      * beans.      *      * @return The currently used tracing strategy      */
DECL|method|getTracingStrategy ()
specifier|public
name|InterceptStrategy
name|getTracingStrategy
parameter_list|()
block|{
return|return
name|tracingStrategy
return|;
block|}
comment|/**      * Specifies the instance responsible for tracking invoked EIP and beans with AWS XRay.      *      * @param tracingStrategy The instance which tracks invoked EIP and beans      */
DECL|method|setTracingStrategy (InterceptStrategy tracingStrategy)
specifier|public
name|void
name|setTracingStrategy
parameter_list|(
name|InterceptStrategy
name|tracingStrategy
parameter_list|)
block|{
name|this
operator|.
name|tracingStrategy
operator|=
name|tracingStrategy
expr_stmt|;
block|}
comment|/**      * Returns the set of currently excluded routes. Any route ID specified in the returned set will      * not be monitored by this AWS XRay tracer implementation.      *      * @return The IDs of the currently excluded routes for which no tracking will be performed      */
DECL|method|getExcludePatterns ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getExcludePatterns
parameter_list|()
block|{
return|return
name|this
operator|.
name|excludePatterns
return|;
block|}
comment|/**      * Excludes all of the routes matching any of the contained routeIds within the given argument      * from tracking by this tracer implementation. Excluded routes will not appear within the AWS      * XRay monitoring.      *      * @param excludePatterns A set of routeIds which should not be tracked by this tracer      */
DECL|method|setExcludePatterns (Set<String> excludePatterns)
specifier|public
name|void
name|setExcludePatterns
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|excludePatterns
parameter_list|)
block|{
name|this
operator|.
name|excludePatterns
operator|=
name|excludePatterns
expr_stmt|;
block|}
comment|/**      * Adds an exclude pattern that will disable tracing for Camel messages that matches the pattern.      *      * @param pattern The pattern such as route id, endpoint url      */
DECL|method|addExcludePattern (String pattern)
specifier|public
name|void
name|addExcludePattern
parameter_list|(
name|String
name|pattern
parameter_list|)
block|{
name|excludePatterns
operator|.
name|add
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
DECL|method|isExcluded (String routeId)
specifier|private
name|boolean
name|isExcluded
parameter_list|(
name|String
name|routeId
parameter_list|)
block|{
comment|// check for a defined routeId
if|if
condition|(
operator|!
name|excludePatterns
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|String
name|pattern
range|:
name|excludePatterns
control|)
block|{
if|if
condition|(
name|pattern
operator|.
name|equals
argument_list|(
name|routeId
argument_list|)
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Ignoring route with ID {}"
argument_list|,
name|routeId
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|getSegmentDecorator (Endpoint endpoint)
specifier|protected
name|SegmentDecorator
name|getSegmentDecorator
parameter_list|(
name|Endpoint
name|endpoint
parameter_list|)
block|{
name|SegmentDecorator
name|sd
init|=
name|decorators
operator|.
name|get
argument_list|(
name|URI
operator|.
name|create
argument_list|(
name|endpoint
operator|.
name|getEndpointUri
argument_list|()
argument_list|)
operator|.
name|getScheme
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|sd
condition|)
block|{
return|return
name|SegmentDecorator
operator|.
name|DEFAULT
return|;
block|}
return|return
name|sd
return|;
block|}
DECL|method|getTraceEntityFromExchange (Exchange exchange)
specifier|protected
name|Entity
name|getTraceEntityFromExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|Entity
name|entity
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|XRAY_TRACE_ENTITY
argument_list|,
name|Entity
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|entity
operator|==
literal|null
condition|)
block|{
name|entity
operator|=
operator|(
name|Entity
operator|)
name|exchange
operator|.
name|getProperty
argument_list|(
name|CURRENT_SEGMENT
argument_list|)
expr_stmt|;
block|}
return|return
name|entity
return|;
block|}
comment|/**      * Custom camel event handler that will create a new {@link Subsegment XRay subsegment} in case      * the current exchange is forwarded via<code>.to(someEndpoint)</code> to some endpoint and      * accordingly closes the subsegment if the execution returns.      *<p/>      * Note that AWS XRay is designed to manage {@link Segment segments} and {@link Subsegment      * subsegments} within a {@link ThreadLocal} context. Forwarding the exchange to a<em>SEDA</em>      * endpoint will thus copy over the exchange to a new thread, though any available segment      * information collected by AWS XRay will not be available within that new thread!      *<p/>      * As  {@link ExchangeSendingEvent} and {@link ExchangeSentEvent} both are executed within the      * invoking thread (in contrast to {@link org.apache.camel.spi.CamelEvent.ExchangeCreatedEvent      * ExchangeCreatedEvent} and {@link org.apache.camel.spi.CamelEvent.ExchangeCompletedEvent      * ExchangeCompletedEvent} which both run in the context of the spawned thread), adding further      * subsegments by this {@link org.apache.camel.spi.EventNotifier EventNotifier} implementation      * should be safe.      */
DECL|class|XRayEventNotifier
specifier|private
specifier|final
class|class
name|XRayEventNotifier
extends|extends
name|EventNotifierSupport
block|{
annotation|@
name|Override
DECL|method|notify (CamelEvent event)
specifier|public
name|void
name|notify
parameter_list|(
name|CamelEvent
name|event
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|event
operator|instanceof
name|ExchangeSendingEvent
condition|)
block|{
name|ExchangeSendingEvent
name|ese
init|=
operator|(
name|ExchangeSendingEvent
operator|)
name|event
decl_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"-> {} - target: {} (routeId: {})"
argument_list|,
name|event
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|ese
operator|.
name|getEndpoint
argument_list|()
argument_list|,
name|ese
operator|.
name|getExchange
argument_list|()
operator|.
name|getFromRouteId
argument_list|()
argument_list|)
expr_stmt|;
name|SegmentDecorator
name|sd
init|=
name|getSegmentDecorator
argument_list|(
name|ese
operator|.
name|getEndpoint
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sd
operator|.
name|newSegment
argument_list|()
condition|)
block|{
return|return;
block|}
name|Entity
name|entity
init|=
name|getTraceEntityFromExchange
argument_list|(
name|ese
operator|.
name|getExchange
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|entity
operator|!=
literal|null
condition|)
block|{
name|AWSXRay
operator|.
name|setTraceEntity
argument_list|(
name|entity
argument_list|)
expr_stmt|;
comment|// AWS XRay does only allow a certain set of characters to appear within a name
comment|// Allowed characters: a-z, A-Z, 0-9, _, ., :, /, %,&, #, =, +, \, -, @
name|String
name|name
init|=
name|sd
operator|.
name|getOperationName
argument_list|(
name|ese
operator|.
name|getExchange
argument_list|()
argument_list|,
name|ese
operator|.
name|getEndpoint
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|sd
operator|.
name|getComponent
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|name
operator|=
name|sd
operator|.
name|getComponent
argument_list|()
operator|+
literal|":"
operator|+
name|name
expr_stmt|;
block|}
name|name
operator|=
name|sanitizeName
argument_list|(
name|name
argument_list|)
expr_stmt|;
try|try
block|{
name|Subsegment
name|subsegment
init|=
name|AWSXRay
operator|.
name|beginSubsegment
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|sd
operator|.
name|pre
argument_list|(
name|subsegment
argument_list|,
name|ese
operator|.
name|getExchange
argument_list|()
argument_list|,
name|ese
operator|.
name|getEndpoint
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"Creating new subsegment with ID {} and name {} (parent {}, references: {})"
argument_list|,
name|subsegment
operator|.
name|getId
argument_list|()
argument_list|,
name|subsegment
operator|.
name|getName
argument_list|()
argument_list|,
name|subsegment
operator|.
name|getParentSegment
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|subsegment
operator|.
name|getParentSegment
argument_list|()
operator|.
name|getReferenceCount
argument_list|()
argument_list|)
expr_stmt|;
name|ese
operator|.
name|getExchange
argument_list|()
operator|.
name|setProperty
argument_list|(
name|CURRENT_SEGMENT
argument_list|,
name|subsegment
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AlreadyEmittedException
name|aeEx
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Ignoring starting of subsegment "
operator|+
name|name
operator|+
literal|" as its parent segment"
operator|+
literal|" was already emitted to AWS."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Ignoring creation of XRay subsegment as no segment exists in the current thread"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|event
operator|instanceof
name|ExchangeSentEvent
condition|)
block|{
name|ExchangeSentEvent
name|ese
init|=
operator|(
name|ExchangeSentEvent
operator|)
name|event
decl_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"-> {} - target: {} (routeId: {})"
argument_list|,
name|event
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|ese
operator|.
name|getEndpoint
argument_list|()
argument_list|,
name|ese
operator|.
name|getExchange
argument_list|()
operator|.
name|getFromRouteId
argument_list|()
argument_list|)
expr_stmt|;
name|Entity
name|entity
init|=
name|getTraceEntityFromExchange
argument_list|(
name|ese
operator|.
name|getExchange
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|entity
operator|instanceof
name|Subsegment
condition|)
block|{
name|AWSXRay
operator|.
name|setTraceEntity
argument_list|(
name|entity
argument_list|)
expr_stmt|;
name|SegmentDecorator
name|sd
init|=
name|getSegmentDecorator
argument_list|(
name|ese
operator|.
name|getEndpoint
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|Subsegment
name|subsegment
init|=
operator|(
name|Subsegment
operator|)
name|entity
decl_stmt|;
name|sd
operator|.
name|post
argument_list|(
name|subsegment
argument_list|,
name|ese
operator|.
name|getExchange
argument_list|()
argument_list|,
name|ese
operator|.
name|getEndpoint
argument_list|()
argument_list|)
expr_stmt|;
name|subsegment
operator|.
name|close
argument_list|()
expr_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"Closing down subsegment with ID {} and name {}"
argument_list|,
name|subsegment
operator|.
name|getId
argument_list|()
argument_list|,
name|subsegment
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"Setting trace entity for exchange {} to {}"
argument_list|,
name|ese
operator|.
name|getExchange
argument_list|()
argument_list|,
name|subsegment
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
name|ese
operator|.
name|getExchange
argument_list|()
operator|.
name|setProperty
argument_list|(
name|CURRENT_SEGMENT
argument_list|,
name|subsegment
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AlreadyEmittedException
name|aeEx
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Ignoring close of subsegment "
operator|+
name|entity
operator|.
name|getName
argument_list|()
operator|+
literal|" as its parent segment was already emitted to AWS"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Received event {} from source {}"
argument_list|,
name|event
argument_list|,
name|event
operator|.
name|getSource
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|isEnabled (CamelEvent event)
specifier|public
name|boolean
name|isEnabled
parameter_list|(
name|CamelEvent
name|event
parameter_list|)
block|{
comment|// listen for either when an exchange invoked an other endpoint
return|return
name|event
operator|instanceof
name|ExchangeSendingEvent
operator|||
name|event
operator|instanceof
name|ExchangeSentEvent
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"XRayEventNotifier"
return|;
block|}
block|}
comment|/**      * A custom {@link org.apache.camel.spi.RoutePolicy RoutePolicy} implementation that will create      * a new AWS XRay {@link Segment} once a new exchange is being created and the current thread      * does not know of an active segment yet. In case the exchange was forwarded within the same      * thread (i.e. by forwarding to a direct endpoint via<code>.to("direct:...)</code>) and a      * previous exchange already created a {@link Segment} this policy will add a new {@link      * Subsegment} for the created exchange to the trace.      *<p/>      * This policy will also manage the termination of created {@link Segment Segments} and {@link      * Subsegment Subsegments}.      *<p/>      * As AWS XRay is designed to manage {@link Segment Segments} in a {@link ThreadLocal} context      * this policy will create a new segment for each forward to a new thread i.e. by sending the      * exchange to a<em>SEDA</em> endpoint.      */
DECL|class|XRayRoutePolicy
specifier|private
specifier|final
class|class
name|XRayRoutePolicy
extends|extends
name|RoutePolicySupport
block|{
DECL|field|routeId
specifier|private
name|String
name|routeId
decl_stmt|;
DECL|method|XRayRoutePolicy (String routeId)
name|XRayRoutePolicy
parameter_list|(
name|String
name|routeId
parameter_list|)
block|{
name|this
operator|.
name|routeId
operator|=
name|routeId
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onExchangeBegin (Route route, Exchange exchange)
specifier|public
name|void
name|onExchangeBegin
parameter_list|(
name|Route
name|route
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
comment|// kicks in after a seda-thread was created. The new thread has the control
if|if
condition|(
name|isExcluded
argument_list|(
name|route
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
name|log
operator|.
name|trace
argument_list|(
literal|"=> RoutePolicy-Begin: Route: {} - RouteId: {}"
argument_list|,
name|routeId
argument_list|,
name|route
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|Entity
name|entity
init|=
name|getTraceEntityFromExchange
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
name|boolean
name|createSegment
init|=
name|entity
operator|==
literal|null
operator|||
operator|!
name|Objects
operator|.
name|equals
argument_list|(
name|entity
operator|.
name|getName
argument_list|()
argument_list|,
name|routeId
argument_list|)
decl_stmt|;
name|TraceID
name|traceID
decl_stmt|;
if|if
condition|(
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeaders
argument_list|()
operator|.
name|containsKey
argument_list|(
name|XRAY_TRACE_ID
argument_list|)
condition|)
block|{
name|traceID
operator|=
name|TraceID
operator|.
name|fromString
argument_list|(
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|XRAY_TRACE_ID
argument_list|,
name|String
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|traceID
operator|=
operator|new
name|TraceID
argument_list|()
expr_stmt|;
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|setHeader
argument_list|(
name|XRAY_TRACE_ID
argument_list|,
name|traceID
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|AWSXRay
operator|.
name|setTraceEntity
argument_list|(
name|entity
argument_list|)
expr_stmt|;
name|SegmentDecorator
name|sd
init|=
name|getSegmentDecorator
argument_list|(
name|route
operator|.
name|getEndpoint
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|createSegment
condition|)
block|{
name|Segment
name|segment
init|=
name|AWSXRay
operator|.
name|beginSegment
argument_list|(
name|sanitizeName
argument_list|(
name|route
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|segment
operator|.
name|setParent
argument_list|(
name|entity
argument_list|)
expr_stmt|;
name|segment
operator|.
name|setTraceId
argument_list|(
name|traceID
argument_list|)
expr_stmt|;
name|sd
operator|.
name|pre
argument_list|(
name|segment
argument_list|,
name|exchange
argument_list|,
name|route
operator|.
name|getEndpoint
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"Created new XRay segment {} with name {}"
argument_list|,
name|segment
operator|.
name|getId
argument_list|()
argument_list|,
name|segment
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|exchange
operator|.
name|setProperty
argument_list|(
name|CURRENT_SEGMENT
argument_list|,
name|segment
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|segmentName
init|=
name|entity
operator|.
name|getId
argument_list|()
decl_stmt|;
try|try
block|{
name|Subsegment
name|subsegment
init|=
name|AWSXRay
operator|.
name|beginSubsegment
argument_list|(
name|route
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|sd
operator|.
name|pre
argument_list|(
name|subsegment
argument_list|,
name|exchange
argument_list|,
name|route
operator|.
name|getEndpoint
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"Creating new subsegment with ID {} and name {} (parent {}, references: {})"
argument_list|,
name|subsegment
operator|.
name|getId
argument_list|()
argument_list|,
name|subsegment
operator|.
name|getName
argument_list|()
argument_list|,
name|subsegment
operator|.
name|getParentSegment
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|subsegment
operator|.
name|getParentSegment
argument_list|()
operator|.
name|getReferenceCount
argument_list|()
argument_list|)
expr_stmt|;
name|exchange
operator|.
name|setProperty
argument_list|(
name|CURRENT_SEGMENT
argument_list|,
name|subsegment
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AlreadyEmittedException
name|aeEx
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Ignoring opening of subsegment "
operator|+
name|route
operator|.
name|getId
argument_list|()
operator|+
literal|" as its parent segment "
operator|+
name|segmentName
operator|+
literal|" was already emitted before."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|onExchangeDone (Route route, Exchange exchange)
specifier|public
name|void
name|onExchangeDone
parameter_list|(
name|Route
name|route
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
comment|// kicks in before the seda-thread is terminated. Control is still in the seda-thread
if|if
condition|(
name|isExcluded
argument_list|(
name|route
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
name|log
operator|.
name|trace
argument_list|(
literal|"=> RoutePolicy-Done: Route: {} - RouteId: {}"
argument_list|,
name|routeId
argument_list|,
name|route
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|Entity
name|entity
init|=
name|getTraceEntityFromExchange
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
name|AWSXRay
operator|.
name|setTraceEntity
argument_list|(
name|entity
argument_list|)
expr_stmt|;
try|try
block|{
name|SegmentDecorator
name|sd
init|=
name|getSegmentDecorator
argument_list|(
name|route
operator|.
name|getEndpoint
argument_list|()
argument_list|)
decl_stmt|;
name|sd
operator|.
name|post
argument_list|(
name|entity
argument_list|,
name|exchange
argument_list|,
name|route
operator|.
name|getEndpoint
argument_list|()
argument_list|)
expr_stmt|;
name|entity
operator|.
name|close
argument_list|()
expr_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"Closing down (sub)segment {} with name {} (parent {}, references: {})"
argument_list|,
name|entity
operator|.
name|getId
argument_list|()
argument_list|,
name|entity
operator|.
name|getName
argument_list|()
argument_list|,
name|entity
operator|.
name|getParentSegment
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|entity
operator|.
name|getParentSegment
argument_list|()
operator|.
name|getReferenceCount
argument_list|()
argument_list|)
expr_stmt|;
name|exchange
operator|.
name|setProperty
argument_list|(
name|CURRENT_SEGMENT
argument_list|,
name|entity
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AlreadyEmittedException
name|aeEx
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Ignoring closing of (sub)segment {} as the segment was already emitted."
argument_list|,
name|route
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Error closing entity"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|AWSXRay
operator|.
name|setTraceEntity
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"XRayRoutePolicy"
return|;
block|}
block|}
comment|/**      * Removes invalid characters from AWS XRay (sub-)segment names and replaces the invalid characters with an      * underscore character.      *      * @param name The name to assign to an AWS XRay (sub-)segment      * @return The sanitized name of the (sub-)segment      */
DECL|method|sanitizeName (String name)
specifier|public
specifier|static
name|String
name|sanitizeName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
comment|// Allowed characters: a-z, A-Z, 0-9, _, ., :, /, %,&, #, =, +, \, -, @
comment|// \w = a-zA-Z0-9_
return|return
name|name
operator|.
name|replaceAll
argument_list|(
literal|"[^\\w.:/%&#=+\\-@]"
argument_list|,
literal|"_"
argument_list|)
return|;
block|}
block|}
end_class

end_unit

