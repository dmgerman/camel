begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.component.aws.xray
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|aws
operator|.
name|xray
package|;
end_package

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|xray
operator|.
name|AWSXRay
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|xray
operator|.
name|entities
operator|.
name|Segment
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|xray
operator|.
name|entities
operator|.
name|Subsegment
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|xray
operator|.
name|entities
operator|.
name|TraceID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EventObject
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContextAware
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Route
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|StaticService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|management
operator|.
name|event
operator|.
name|ExchangeSendingEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|management
operator|.
name|event
operator|.
name|ExchangeSentEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|model
operator|.
name|RouteDefinition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|InterceptStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|RoutePolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|RoutePolicyFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|EventNotifierSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|RoutePolicySupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|ServiceSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ObjectHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ServiceHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * To use AWS XRay with Camel setup this {@link XRayTracer} in your Camel application.  *<p/>  * This class uses a {@link org.apache.camel.spi.RoutePolicy} as well as a {@link  * org.apache.camel.spi.EventNotifier} internally to manage the creation and termination of AWS XRay  * {@link Segment Segments} and {@link Subsegment Subsegments} once an exchange was created,  * forwarded or closed in order to allow monitoring the lifetime metrics of the exchange.  *<p/>  * A {@link InterceptStrategy} is used in order to track invocations and durations of EIP patterns  * used in processed routes. If no strategy is passed while configuration via {@link  * #setTracingStrategy(InterceptStrategy)}, a {@link NoopTracingStrategy} will be used by default  * which will not monitor any invocations at all.  *<p/>  * By default every invoked route will be tracked by AWS XRay. If certain routes shell not be  * tracked {@link #addExcludePattern(String)} and {@link #setExcludePatterns(Set)} can be used to  * provide the<em>routeId</em> of the routes to exclude from monitoring.  */
end_comment

begin_class
DECL|class|XRayTracer
specifier|public
class|class
name|XRayTracer
extends|extends
name|ServiceSupport
implements|implements
name|RoutePolicyFactory
implements|,
name|StaticService
implements|,
name|CamelContextAware
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MethodHandles
operator|.
name|lookup
argument_list|()
operator|.
name|lookupClass
argument_list|()
argument_list|)
decl_stmt|;
comment|/** Header value kept in the message of the exchange **/
DECL|field|XRAY_TRACE_ID
specifier|public
specifier|static
specifier|final
name|String
name|XRAY_TRACE_ID
init|=
literal|"Camel-AWS-XRay-Trace-ID"
decl_stmt|;
comment|/** Exchange property for passing a segment between threads **/
DECL|field|CURRENT_SEGMENT
specifier|private
specifier|static
specifier|final
name|String
name|CURRENT_SEGMENT
init|=
literal|"CAMEL_PROPERTY_AWS_XRAY_CURRENT_SEGMENT"
decl_stmt|;
DECL|field|eventNotifier
specifier|private
specifier|final
name|XRayEventNotifier
name|eventNotifier
init|=
operator|new
name|XRayEventNotifier
argument_list|()
decl_stmt|;
DECL|field|camelContext
specifier|private
name|CamelContext
name|camelContext
decl_stmt|;
DECL|field|excludePatterns
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|excludePatterns
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|tracingStrategy
specifier|private
name|InterceptStrategy
name|tracingStrategy
decl_stmt|;
annotation|@
name|Override
DECL|method|setCamelContext (CamelContext camelContext)
specifier|public
name|void
name|setCamelContext
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|)
block|{
name|this
operator|.
name|camelContext
operator|=
name|camelContext
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getCamelContext ()
specifier|public
name|CamelContext
name|getCamelContext
parameter_list|()
block|{
return|return
name|this
operator|.
name|camelContext
return|;
block|}
annotation|@
name|Override
DECL|method|createRoutePolicy (CamelContext camelContext, String routeId, RouteDefinition route)
specifier|public
name|RoutePolicy
name|createRoutePolicy
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|,
name|String
name|routeId
parameter_list|,
name|RouteDefinition
name|route
parameter_list|)
block|{
name|init
argument_list|(
name|camelContext
argument_list|)
expr_stmt|;
return|return
operator|new
name|XRayRoutePolicy
argument_list|(
name|routeId
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|doStart ()
specifier|protected
name|void
name|doStart
parameter_list|()
throws|throws
name|Exception
block|{
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|camelContext
argument_list|,
literal|"CamelContext"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|camelContext
operator|.
name|getManagementStrategy
argument_list|()
operator|.
name|addEventNotifier
argument_list|(
name|eventNotifier
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|camelContext
operator|.
name|getRoutePolicyFactories
argument_list|()
operator|.
name|contains
argument_list|(
name|this
argument_list|)
condition|)
block|{
name|camelContext
operator|.
name|addRoutePolicyFactory
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|==
name|tracingStrategy
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No tracing strategy available. Defaulting to no-op strategy"
argument_list|)
expr_stmt|;
name|tracingStrategy
operator|=
operator|new
name|NoopTracingStrategy
argument_list|()
expr_stmt|;
block|}
name|camelContext
operator|.
name|addInterceptStrategy
argument_list|(
name|tracingStrategy
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Starting XRay tracer"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStop ()
specifier|protected
name|void
name|doStop
parameter_list|()
throws|throws
name|Exception
block|{
comment|// stop event notifier
name|camelContext
operator|.
name|getManagementStrategy
argument_list|()
operator|.
name|removeEventNotifier
argument_list|(
name|eventNotifier
argument_list|)
expr_stmt|;
name|ServiceHelper
operator|.
name|stopAndShutdownService
argument_list|(
name|eventNotifier
argument_list|)
expr_stmt|;
name|camelContext
operator|.
name|getRoutePolicyFactories
argument_list|()
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"XRay tracer stopped"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Initializes this AWS XRay tracer implementation as service within the Camel environment.      *      * @param camelContext The context to register this tracer as service with      */
DECL|method|init (CamelContext camelContext)
specifier|public
name|void
name|init
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|)
block|{
if|if
condition|(
operator|!
name|camelContext
operator|.
name|hasService
argument_list|(
name|this
argument_list|)
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initializing XRay tracer"
argument_list|)
expr_stmt|;
comment|// start this service eager so we init before Camel is starting up
name|camelContext
operator|.
name|addService
argument_list|(
name|this
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|ObjectHelper
operator|.
name|wrapRuntimeCamelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Returns the currently used tracing strategy which is responsible for tracking invoked EIP or      * beans.      *      * @return The currently used tracing strategy      */
DECL|method|getTracingStrategy ()
specifier|public
name|InterceptStrategy
name|getTracingStrategy
parameter_list|()
block|{
return|return
name|tracingStrategy
return|;
block|}
comment|/**      * Specifies the instance responsible for tracking invoked EIP and beans with AWS XRay.      *      * @param traceingStrategy The instance which tracks invoked EIP and beans      */
DECL|method|setTracingStrategy (InterceptStrategy traceingStrategy)
specifier|public
name|void
name|setTracingStrategy
parameter_list|(
name|InterceptStrategy
name|traceingStrategy
parameter_list|)
block|{
name|this
operator|.
name|tracingStrategy
operator|=
name|traceingStrategy
expr_stmt|;
block|}
comment|/**      * Returns the set of currently excluded routes. Any route ID specified in the returned set will      * not be monitored by this AWS XRay tracer implementation.      *      * @return The IDs of the currently excluded routes for which no tracking will be performed      */
DECL|method|getExcludePatterns ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getExcludePatterns
parameter_list|()
block|{
return|return
name|this
operator|.
name|excludePatterns
return|;
block|}
comment|/**      * Excludes all of the routes matching any of the contained routeIds within the given argument      * from tracking by this tracer implementation. Excluded routes will not appear within the AWS      * XRay monitoring.      *      * @param excludePatterns A set of routeIds which should not be tracked by this tracer      */
DECL|method|setExcludePatterns (Set<String> excludePatterns)
specifier|public
name|void
name|setExcludePatterns
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|excludePatterns
parameter_list|)
block|{
name|this
operator|.
name|excludePatterns
operator|=
name|excludePatterns
expr_stmt|;
block|}
comment|/**      * Adds an exclude pattern that will disable tracing for Camel messages that matches the pattern.      *      * @param pattern The pattern such as route id, endpoint url      */
DECL|method|addExcludePattern (String pattern)
specifier|public
name|void
name|addExcludePattern
parameter_list|(
name|String
name|pattern
parameter_list|)
block|{
name|excludePatterns
operator|.
name|add
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
DECL|method|isExcluded (String routeId)
specifier|private
name|boolean
name|isExcluded
parameter_list|(
name|String
name|routeId
parameter_list|)
block|{
comment|// check for a defined routeId
if|if
condition|(
operator|!
name|excludePatterns
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|String
name|pattern
range|:
name|excludePatterns
control|)
block|{
if|if
condition|(
name|pattern
operator|.
name|equals
argument_list|(
name|routeId
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring route with ID {}"
argument_list|,
name|routeId
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Custom camel event handler that will create a new {@link Subsegment XRay subsegment} in case      * the current exchange is forwarded via<code>.to(someEndpoint)</code> to some endpoint and      * accordingly closes the subsegment if the execution returns.      *<p/>      * Note that AWS XRay is designed to manage {@link Segment segments} and {@link Subsegment      * subsegments} within a {@link ThreadLocal} context. Forwarding the exchange to a<em>SEDA</em>      * endpoint will thus copy over the exchange to a new thread, though any available segment      * information collected by AWS XRay will not be available within that new thread!      *<p/>      * As  {@link ExchangeSendingEvent} and {@link ExchangeSentEvent} both are executed within the      * invoking thread (in contrast to {@link org.apache.camel.management.event.ExchangeCreatedEvent      * ExchangeCreatedEvent} and {@link org.apache.camel.management.event.ExchangeCompletedEvent      * ExchangeCompletedEvent} which both run in the context of the spawned thread), adding further      * subsegments by this {@link org.apache.camel.spi.EventNotifier EventNotifier} implementation      * should be safe.      */
DECL|class|XRayEventNotifier
specifier|private
specifier|final
class|class
name|XRayEventNotifier
extends|extends
name|EventNotifierSupport
block|{
annotation|@
name|Override
DECL|method|notify (EventObject event)
specifier|public
name|void
name|notify
parameter_list|(
name|EventObject
name|event
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|event
operator|instanceof
name|ExchangeSendingEvent
condition|)
block|{
name|ExchangeSendingEvent
name|ese
init|=
operator|(
name|ExchangeSendingEvent
operator|)
name|event
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"-> {} - target: {} (routeId: {})"
argument_list|,
name|event
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|ese
operator|.
name|getEndpoint
argument_list|()
argument_list|,
name|ese
operator|.
name|getExchange
argument_list|()
operator|.
name|getFromRouteId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|contains
argument_list|(
literal|"Multicast"
argument_list|)
condition|)
block|{
comment|// copy the segment from the exchange to the thread (local) context
name|Segment
name|segment
init|=
operator|(
name|Segment
operator|)
name|ese
operator|.
name|getExchange
argument_list|()
operator|.
name|getProperty
argument_list|(
name|CURRENT_SEGMENT
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Copying over segment {}/{} from exchange received from {} to exchange processing {}"
argument_list|,
name|segment
operator|.
name|getId
argument_list|()
argument_list|,
name|segment
operator|.
name|getName
argument_list|()
argument_list|,
name|ese
operator|.
name|getExchange
argument_list|()
operator|.
name|getFromEndpoint
argument_list|()
argument_list|,
name|ese
operator|.
name|getEndpoint
argument_list|()
argument_list|)
expr_stmt|;
name|AWSXRay
operator|.
name|setTraceEntity
argument_list|(
name|segment
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AWSXRay
operator|.
name|getCurrentSegmentOptional
argument_list|()
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|String
name|endpointName
init|=
name|ese
operator|.
name|getEndpoint
argument_list|()
operator|.
name|getEndpointKey
argument_list|()
decl_stmt|;
comment|// AWS XRay does only allow a certain set of characters to appear within a name
comment|// Allowed characters: a-z, A-Z, 0-9, _, ., :, /, %,&, #, =, +, \, -, @
name|endpointName
operator|=
name|endpointName
operator|.
name|replaceAll
argument_list|(
literal|"://"
argument_list|,
literal|"_"
argument_list|)
expr_stmt|;
name|endpointName
operator|=
name|endpointName
operator|.
name|replaceAll
argument_list|(
literal|"\\?"
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
name|Subsegment
name|subsegment
init|=
name|AWSXRay
operator|.
name|beginSubsegment
argument_list|(
literal|"SendingTo_"
operator|+
name|endpointName
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Creating new subsegment with ID {} and name {}"
argument_list|,
name|subsegment
operator|.
name|getId
argument_list|()
argument_list|,
name|subsegment
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Ignoring creation of XRay subsegment as no segment exists in the current thread"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|event
operator|instanceof
name|ExchangeSentEvent
condition|)
block|{
name|ExchangeSentEvent
name|ese
init|=
operator|(
name|ExchangeSentEvent
operator|)
name|event
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"-> {} - target: {} (routeId: {})"
argument_list|,
name|event
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|ese
operator|.
name|getEndpoint
argument_list|()
argument_list|,
name|ese
operator|.
name|getExchange
argument_list|()
operator|.
name|getFromRouteId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|AWSXRay
operator|.
name|getCurrentSubsegmentOptional
argument_list|()
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|Subsegment
name|subsegment
init|=
name|AWSXRay
operator|.
name|getCurrentSubsegment
argument_list|()
decl_stmt|;
name|subsegment
operator|.
name|close
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Closing down subsegment with ID {} and name {}"
argument_list|,
name|subsegment
operator|.
name|getId
argument_list|()
argument_list|,
name|subsegment
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Received event {} from source {}"
argument_list|,
name|event
argument_list|,
name|event
operator|.
name|getSource
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|isEnabled (EventObject event)
specifier|public
name|boolean
name|isEnabled
parameter_list|(
name|EventObject
name|event
parameter_list|)
block|{
comment|// listen for either when an exchange invoked an other endpoint
return|return
name|event
operator|instanceof
name|ExchangeSendingEvent
operator|||
name|event
operator|instanceof
name|ExchangeSentEvent
return|;
block|}
block|}
comment|/**      * A custom {@link org.apache.camel.spi.RoutePolicy RoutePolicy} implementation that will create      * a new AWS XRay {@link Segment} once a new exchange is being created and the current thread      * does not know of an active segment yet. In case the exchange was forwarded within the same      * thread (i.e. by forwarding to a direct endpoint via<code>.to("direct:...)</code>) and a      * previous exchange already created a {@link Segment} this policy will add a new {@link      * Subsegment} for the created exchange to the trace.      *<p/>      * This policy will also manage the termination of created {@link Segment Segments} and {@link      * Subsegment Subsegments}.      *<p/>      * As AWS XRay is designed to manage {@link Segment Segments} in a {@link ThreadLocal} context      * this policy will create a new segment for each forward to a new thread i.e. by sending the      * exchange to a<em>SEDA</em> endpoint.      */
DECL|class|XRayRoutePolicy
specifier|private
specifier|final
class|class
name|XRayRoutePolicy
extends|extends
name|RoutePolicySupport
block|{
DECL|field|routeId
specifier|private
name|String
name|routeId
decl_stmt|;
DECL|method|XRayRoutePolicy (String routeId)
name|XRayRoutePolicy
parameter_list|(
name|String
name|routeId
parameter_list|)
block|{
name|this
operator|.
name|routeId
operator|=
name|routeId
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onExchangeBegin (Route route, Exchange exchange)
specifier|public
name|void
name|onExchangeBegin
parameter_list|(
name|Route
name|route
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
comment|// kicks in after a seda-thread was created. The new thread has the control
if|if
condition|(
name|isExcluded
argument_list|(
name|route
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"=> RoutePolicy-Begin: Route: {} - RouteId: {}"
argument_list|,
name|routeId
argument_list|,
name|route
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|TraceID
name|traceID
decl_stmt|;
if|if
condition|(
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeaders
argument_list|()
operator|.
name|containsKey
argument_list|(
name|XRAY_TRACE_ID
argument_list|)
condition|)
block|{
name|traceID
operator|=
name|TraceID
operator|.
name|fromString
argument_list|(
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|XRAY_TRACE_ID
argument_list|,
name|String
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|traceID
operator|=
operator|new
name|TraceID
argument_list|()
expr_stmt|;
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|setHeader
argument_list|(
name|XRAY_TRACE_ID
argument_list|,
name|traceID
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|AWSXRay
operator|.
name|getCurrentSegmentOptional
argument_list|()
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|Segment
name|segment
init|=
name|AWSXRay
operator|.
name|beginSegment
argument_list|(
name|route
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|segment
operator|.
name|setTraceId
argument_list|(
name|traceID
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Created new XRay segment {} with name {}"
argument_list|,
name|segment
operator|.
name|getId
argument_list|()
argument_list|,
name|segment
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|exchange
operator|.
name|setProperty
argument_list|(
name|CURRENT_SEGMENT
argument_list|,
name|segment
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Subsegment
name|subsegment
init|=
name|AWSXRay
operator|.
name|beginSubsegment
argument_list|(
name|route
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Created new XRay subsegment {} with name {}"
argument_list|,
name|subsegment
operator|.
name|getId
argument_list|()
argument_list|,
name|subsegment
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|onExchangeDone (Route route, Exchange exchange)
specifier|public
name|void
name|onExchangeDone
parameter_list|(
name|Route
name|route
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
comment|// kicks in before the seda-thread is terminated. Control is still in the seda-thread
if|if
condition|(
name|isExcluded
argument_list|(
name|route
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"=> RoutePolicy-Done: Route: {} - RouteId: {}"
argument_list|,
name|routeId
argument_list|,
name|route
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|AWSXRay
operator|.
name|getCurrentSubsegmentOptional
argument_list|()
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|Subsegment
name|subsegment
init|=
name|AWSXRay
operator|.
name|getCurrentSubsegment
argument_list|()
decl_stmt|;
name|subsegment
operator|.
name|close
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Closing down Subsegment {} with name {}"
argument_list|,
name|subsegment
operator|.
name|getId
argument_list|()
argument_list|,
name|subsegment
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AWSXRay
operator|.
name|getCurrentSegmentOptional
argument_list|()
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|Segment
name|segment
init|=
name|AWSXRay
operator|.
name|getCurrentSegment
argument_list|()
decl_stmt|;
name|segment
operator|.
name|close
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Closing down Segment {} with name {}"
argument_list|,
name|segment
operator|.
name|getId
argument_list|()
argument_list|,
name|segment
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

