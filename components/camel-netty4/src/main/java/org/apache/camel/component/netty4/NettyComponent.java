begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.component.netty4
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|netty4
package|;
end_package

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactory
import|;
end_import

begin_import
import|import
name|io
operator|.
name|netty
operator|.
name|channel
operator|.
name|ChannelHandler
import|;
end_import

begin_import
import|import
name|io
operator|.
name|netty
operator|.
name|channel
operator|.
name|EventLoopGroup
import|;
end_import

begin_import
import|import
name|io
operator|.
name|netty
operator|.
name|channel
operator|.
name|group
operator|.
name|ChannelGroup
import|;
end_import

begin_import
import|import
name|io
operator|.
name|netty
operator|.
name|handler
operator|.
name|ssl
operator|.
name|SslHandler
import|;
end_import

begin_import
import|import
name|io
operator|.
name|netty
operator|.
name|util
operator|.
name|concurrent
operator|.
name|DefaultEventExecutorGroup
import|;
end_import

begin_import
import|import
name|io
operator|.
name|netty
operator|.
name|util
operator|.
name|concurrent
operator|.
name|EventExecutorGroup
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Endpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|LoggingLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|impl
operator|.
name|UriEndpointComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|IntrospectionSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CamelThreadFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|jsse
operator|.
name|SSLContextParameters
import|;
end_import

begin_class
DECL|class|NettyComponent
specifier|public
class|class
name|NettyComponent
extends|extends
name|UriEndpointComponent
block|{
DECL|field|configuration
specifier|private
name|NettyConfiguration
name|configuration
decl_stmt|;
DECL|field|maximumPoolSize
specifier|private
name|int
name|maximumPoolSize
init|=
literal|16
decl_stmt|;
DECL|field|executorService
specifier|private
specifier|volatile
name|EventExecutorGroup
name|executorService
decl_stmt|;
DECL|method|NettyComponent ()
specifier|public
name|NettyComponent
parameter_list|()
block|{
name|super
argument_list|(
name|NettyEndpoint
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
DECL|method|NettyComponent (Class<? extends Endpoint> endpointClass)
specifier|public
name|NettyComponent
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Endpoint
argument_list|>
name|endpointClass
parameter_list|)
block|{
name|super
argument_list|(
name|endpointClass
argument_list|)
expr_stmt|;
block|}
DECL|method|NettyComponent (CamelContext context)
specifier|public
name|NettyComponent
parameter_list|(
name|CamelContext
name|context
parameter_list|)
block|{
name|super
argument_list|(
name|context
argument_list|,
name|NettyEndpoint
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
DECL|method|getMaximumPoolSize ()
specifier|public
name|int
name|getMaximumPoolSize
parameter_list|()
block|{
return|return
name|maximumPoolSize
return|;
block|}
comment|/**      * The thread pool size for the EventExecutorGroup if its in use.      *<p/>      * The default value is 16.      */
DECL|method|setMaximumPoolSize (int maximumPoolSize)
specifier|public
name|void
name|setMaximumPoolSize
parameter_list|(
name|int
name|maximumPoolSize
parameter_list|)
block|{
name|this
operator|.
name|maximumPoolSize
operator|=
name|maximumPoolSize
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createEndpoint (String uri, String remaining, Map<String, Object> parameters)
specifier|protected
name|Endpoint
name|createEndpoint
parameter_list|(
name|String
name|uri
parameter_list|,
name|String
name|remaining
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|parameters
parameter_list|)
throws|throws
name|Exception
block|{
name|NettyConfiguration
name|config
decl_stmt|;
if|if
condition|(
name|configuration
operator|!=
literal|null
condition|)
block|{
name|config
operator|=
name|configuration
operator|.
name|copy
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|config
operator|=
operator|new
name|NettyConfiguration
argument_list|()
expr_stmt|;
block|}
name|config
operator|=
name|parseConfiguration
argument_list|(
name|config
argument_list|,
name|remaining
argument_list|,
name|parameters
argument_list|)
expr_stmt|;
comment|// merge any custom bootstrap configuration on the config
name|NettyServerBootstrapConfiguration
name|bootstrapConfiguration
init|=
name|resolveAndRemoveReferenceParameter
argument_list|(
name|parameters
argument_list|,
literal|"bootstrapConfiguration"
argument_list|,
name|NettyServerBootstrapConfiguration
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|bootstrapConfiguration
operator|!=
literal|null
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|options
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|IntrospectionSupport
operator|.
name|getProperties
argument_list|(
name|bootstrapConfiguration
argument_list|,
name|options
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|IntrospectionSupport
operator|.
name|setProperties
argument_list|(
name|getCamelContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
argument_list|,
name|config
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
block|}
comment|// validate config
name|config
operator|.
name|validateConfiguration
argument_list|()
expr_stmt|;
name|NettyEndpoint
name|nettyEndpoint
init|=
operator|new
name|NettyEndpoint
argument_list|(
name|remaining
argument_list|,
name|this
argument_list|,
name|config
argument_list|)
decl_stmt|;
name|setProperties
argument_list|(
name|nettyEndpoint
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|parameters
argument_list|)
expr_stmt|;
return|return
name|nettyEndpoint
return|;
block|}
comment|/**      * Parses the configuration      *      * @return the parsed and valid configuration to use      */
DECL|method|parseConfiguration (NettyConfiguration configuration, String remaining, Map<String, Object> parameters)
specifier|protected
name|NettyConfiguration
name|parseConfiguration
parameter_list|(
name|NettyConfiguration
name|configuration
parameter_list|,
name|String
name|remaining
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|parameters
parameter_list|)
throws|throws
name|Exception
block|{
name|configuration
operator|.
name|parseURI
argument_list|(
operator|new
name|URI
argument_list|(
name|remaining
argument_list|)
argument_list|,
name|parameters
argument_list|,
name|this
argument_list|,
literal|"tcp"
argument_list|,
literal|"udp"
argument_list|)
expr_stmt|;
return|return
name|configuration
return|;
block|}
DECL|method|getConfiguration ()
specifier|public
name|NettyConfiguration
name|getConfiguration
parameter_list|()
block|{
return|return
name|configuration
return|;
block|}
comment|/**      * To use the NettyConfiguration as configuration when creating endpoints. Properties of the shared configuration can also be set individually.      */
DECL|method|setConfiguration (NettyConfiguration configuration)
specifier|public
name|void
name|setConfiguration
parameter_list|(
name|NettyConfiguration
name|configuration
parameter_list|)
block|{
name|this
operator|.
name|configuration
operator|=
name|configuration
expr_stmt|;
block|}
comment|/**      * To use the given EventExecutorGroup      */
DECL|method|setExecutorService (EventExecutorGroup executorService)
specifier|public
name|void
name|setExecutorService
parameter_list|(
name|EventExecutorGroup
name|executorService
parameter_list|)
block|{
name|this
operator|.
name|executorService
operator|=
name|executorService
expr_stmt|;
block|}
DECL|method|getExecutorService ()
specifier|public
name|EventExecutorGroup
name|getExecutorService
parameter_list|()
block|{
return|return
name|executorService
return|;
block|}
annotation|@
name|Override
DECL|method|doStart ()
specifier|protected
name|void
name|doStart
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|configuration
operator|==
literal|null
condition|)
block|{
name|configuration
operator|=
operator|new
name|NettyConfiguration
argument_list|()
expr_stmt|;
block|}
comment|//Only setup the executorService if it is needed
if|if
condition|(
name|configuration
operator|.
name|isUsingExecutorService
argument_list|()
operator|&&
name|executorService
operator|==
literal|null
condition|)
block|{
name|executorService
operator|=
name|createExecutorService
argument_list|()
expr_stmt|;
block|}
name|super
operator|.
name|doStart
argument_list|()
expr_stmt|;
block|}
DECL|method|createExecutorService ()
specifier|protected
name|EventExecutorGroup
name|createExecutorService
parameter_list|()
block|{
comment|// Provide the executor service for the application
comment|// and use a Camel thread factory so we have consistent thread namings
comment|// we should use a shared thread pool as recommended by Netty
name|String
name|pattern
init|=
name|getCamelContext
argument_list|()
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|getThreadNamePattern
argument_list|()
decl_stmt|;
name|ThreadFactory
name|factory
init|=
operator|new
name|CamelThreadFactory
argument_list|(
name|pattern
argument_list|,
literal|"NettyEventExecutorGroup"
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
operator|new
name|DefaultEventExecutorGroup
argument_list|(
name|getMaximumPoolSize
argument_list|()
argument_list|,
name|factory
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|doStop ()
specifier|protected
name|void
name|doStop
parameter_list|()
throws|throws
name|Exception
block|{
comment|//Only shutdown the executorService if it is created by netty component
if|if
condition|(
name|configuration
operator|.
name|isUsingExecutorService
argument_list|()
operator|&&
name|executorService
operator|!=
literal|null
condition|)
block|{
name|getCamelContext
argument_list|()
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|shutdownGraceful
argument_list|(
name|executorService
argument_list|)
expr_stmt|;
name|executorService
operator|=
literal|null
expr_stmt|;
block|}
name|super
operator|.
name|doStop
argument_list|()
expr_stmt|;
block|}
DECL|method|getConfigurationOrCreate ()
specifier|private
name|NettyConfiguration
name|getConfigurationOrCreate
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|getConfiguration
argument_list|()
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|setConfiguration
argument_list|(
operator|new
name|NettyConfiguration
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|getConfiguration
argument_list|()
return|;
block|}
DECL|method|getAddress ()
specifier|public
name|String
name|getAddress
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getAddress
argument_list|()
return|;
block|}
DECL|method|isTcp ()
specifier|public
name|boolean
name|isTcp
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isTcp
argument_list|()
return|;
block|}
DECL|method|getProtocol ()
specifier|public
name|String
name|getProtocol
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getProtocol
argument_list|()
return|;
block|}
comment|/**      * The protocol to use which can be tcp or udp.      * @param protocol      */
DECL|method|setProtocol (String protocol)
specifier|public
name|void
name|setProtocol
parameter_list|(
name|String
name|protocol
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setProtocol
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
block|}
DECL|method|getHost ()
specifier|public
name|String
name|getHost
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getHost
argument_list|()
return|;
block|}
comment|/**      * The hostname.      *<p/>      * For the consumer the hostname is localhost or 0.0.0.0      * For the producer the hostname is the remote host to connect to      * @param host      */
DECL|method|setHost (String host)
specifier|public
name|void
name|setHost
parameter_list|(
name|String
name|host
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setHost
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
DECL|method|getPort ()
specifier|public
name|int
name|getPort
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getPort
argument_list|()
return|;
block|}
comment|/**      * The host port number      * @param port      */
DECL|method|setPort (int port)
specifier|public
name|void
name|setPort
parameter_list|(
name|int
name|port
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setPort
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
DECL|method|isBroadcast ()
specifier|public
name|boolean
name|isBroadcast
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isBroadcast
argument_list|()
return|;
block|}
comment|/**      * Setting to choose Multicast over UDP      * @param broadcast      */
DECL|method|setBroadcast (boolean broadcast)
specifier|public
name|void
name|setBroadcast
parameter_list|(
name|boolean
name|broadcast
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setBroadcast
argument_list|(
name|broadcast
argument_list|)
expr_stmt|;
block|}
DECL|method|getSendBufferSize ()
specifier|public
name|int
name|getSendBufferSize
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getSendBufferSize
argument_list|()
return|;
block|}
comment|/**      * The TCP/UDP buffer sizes to be used during outbound communication. Size is bytes.      * @param sendBufferSize      */
DECL|method|setSendBufferSize (int sendBufferSize)
specifier|public
name|void
name|setSendBufferSize
parameter_list|(
name|int
name|sendBufferSize
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setSendBufferSize
argument_list|(
name|sendBufferSize
argument_list|)
expr_stmt|;
block|}
DECL|method|getReceiveBufferSize ()
specifier|public
name|int
name|getReceiveBufferSize
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getReceiveBufferSize
argument_list|()
return|;
block|}
comment|/**      * The TCP/UDP buffer sizes to be used during inbound communication. Size is bytes.      * @param receiveBufferSize      */
DECL|method|setReceiveBufferSize (int receiveBufferSize)
specifier|public
name|void
name|setReceiveBufferSize
parameter_list|(
name|int
name|receiveBufferSize
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setReceiveBufferSize
argument_list|(
name|receiveBufferSize
argument_list|)
expr_stmt|;
block|}
DECL|method|getReceiveBufferSizePredictor ()
specifier|public
name|int
name|getReceiveBufferSizePredictor
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getReceiveBufferSizePredictor
argument_list|()
return|;
block|}
comment|/**      * Configures the buffer size predictor. See details at Jetty documentation and this mail thread.      * @param receiveBufferSizePredictor      */
DECL|method|setReceiveBufferSizePredictor (int receiveBufferSizePredictor)
specifier|public
name|void
name|setReceiveBufferSizePredictor
parameter_list|(
name|int
name|receiveBufferSizePredictor
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setReceiveBufferSizePredictor
argument_list|(
name|receiveBufferSizePredictor
argument_list|)
expr_stmt|;
block|}
DECL|method|getWorkerCount ()
specifier|public
name|int
name|getWorkerCount
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getWorkerCount
argument_list|()
return|;
block|}
comment|/**      * When netty works on nio mode, it uses default workerCount parameter from Netty, which is cpu_core_threads*2.      * User can use this operation to override the default workerCount from Netty      * @param workerCount      */
DECL|method|setWorkerCount (int workerCount)
specifier|public
name|void
name|setWorkerCount
parameter_list|(
name|int
name|workerCount
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setWorkerCount
argument_list|(
name|workerCount
argument_list|)
expr_stmt|;
block|}
DECL|method|getBossCount ()
specifier|public
name|int
name|getBossCount
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getBossCount
argument_list|()
return|;
block|}
comment|/**      * When netty works on nio mode, it uses default bossCount parameter from Netty, which is 1.      * User can use this operation to override the default bossCount from Netty      * @param bossCount      */
DECL|method|setBossCount (int bossCount)
specifier|public
name|void
name|setBossCount
parameter_list|(
name|int
name|bossCount
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setBossCount
argument_list|(
name|bossCount
argument_list|)
expr_stmt|;
block|}
DECL|method|isKeepAlive ()
specifier|public
name|boolean
name|isKeepAlive
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isKeepAlive
argument_list|()
return|;
block|}
comment|/**      * Setting to ensure socket is not closed due to inactivity      * @param keepAlive      */
DECL|method|setKeepAlive (boolean keepAlive)
specifier|public
name|void
name|setKeepAlive
parameter_list|(
name|boolean
name|keepAlive
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setKeepAlive
argument_list|(
name|keepAlive
argument_list|)
expr_stmt|;
block|}
DECL|method|isTcpNoDelay ()
specifier|public
name|boolean
name|isTcpNoDelay
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isTcpNoDelay
argument_list|()
return|;
block|}
comment|/**      * Setting to improve TCP protocol performance      * @param tcpNoDelay      */
DECL|method|setTcpNoDelay (boolean tcpNoDelay)
specifier|public
name|void
name|setTcpNoDelay
parameter_list|(
name|boolean
name|tcpNoDelay
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setTcpNoDelay
argument_list|(
name|tcpNoDelay
argument_list|)
expr_stmt|;
block|}
DECL|method|isReuseAddress ()
specifier|public
name|boolean
name|isReuseAddress
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isReuseAddress
argument_list|()
return|;
block|}
comment|/**      * Setting to facilitate socket multiplexing      * @param reuseAddress      */
DECL|method|setReuseAddress (boolean reuseAddress)
specifier|public
name|void
name|setReuseAddress
parameter_list|(
name|boolean
name|reuseAddress
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setReuseAddress
argument_list|(
name|reuseAddress
argument_list|)
expr_stmt|;
block|}
DECL|method|getConnectTimeout ()
specifier|public
name|int
name|getConnectTimeout
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getConnectTimeout
argument_list|()
return|;
block|}
comment|/**      * Time to wait for a socket connection to be available. Value is in millis.      * @param connectTimeout      */
DECL|method|setConnectTimeout (int connectTimeout)
specifier|public
name|void
name|setConnectTimeout
parameter_list|(
name|int
name|connectTimeout
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setConnectTimeout
argument_list|(
name|connectTimeout
argument_list|)
expr_stmt|;
block|}
DECL|method|getBacklog ()
specifier|public
name|int
name|getBacklog
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getBacklog
argument_list|()
return|;
block|}
comment|/**      * Allows to configure a backlog for netty consumer (server).      * Note the backlog is just a best effort depending on the OS.      * Setting this option to a value such as 200, 500 or 1000, tells the TCP stack how long the "accept" queue can be      * If this option is not configured, then the backlog depends on OS setting.      * @param backlog      */
DECL|method|setBacklog (int backlog)
specifier|public
name|void
name|setBacklog
parameter_list|(
name|int
name|backlog
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setBacklog
argument_list|(
name|backlog
argument_list|)
expr_stmt|;
block|}
DECL|method|isSsl ()
specifier|public
name|boolean
name|isSsl
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isSsl
argument_list|()
return|;
block|}
comment|/**      * Setting to specify whether SSL encryption is applied to this endpoint      * @param ssl      */
DECL|method|setSsl (boolean ssl)
specifier|public
name|void
name|setSsl
parameter_list|(
name|boolean
name|ssl
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setSsl
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
block|}
DECL|method|isSslClientCertHeaders ()
specifier|public
name|boolean
name|isSslClientCertHeaders
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isSslClientCertHeaders
argument_list|()
return|;
block|}
comment|/**      * When enabled and in SSL mode, then the Netty consumer will enrich the Camel Message with headers having      * information about the client certificate such as subject name, issuer name, serial number, and the valid date range.      * @param sslClientCertHeaders      */
DECL|method|setSslClientCertHeaders (boolean sslClientCertHeaders)
specifier|public
name|void
name|setSslClientCertHeaders
parameter_list|(
name|boolean
name|sslClientCertHeaders
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setSslClientCertHeaders
argument_list|(
name|sslClientCertHeaders
argument_list|)
expr_stmt|;
block|}
DECL|method|getSslHandler ()
specifier|public
name|SslHandler
name|getSslHandler
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getSslHandler
argument_list|()
return|;
block|}
comment|/**      * Reference to a class that could be used to return an SSL Handler      * @param sslHandler      */
DECL|method|setSslHandler (SslHandler sslHandler)
specifier|public
name|void
name|setSslHandler
parameter_list|(
name|SslHandler
name|sslHandler
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setSslHandler
argument_list|(
name|sslHandler
argument_list|)
expr_stmt|;
block|}
DECL|method|getSslContextParameters ()
specifier|public
name|SSLContextParameters
name|getSslContextParameters
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getSslContextParameters
argument_list|()
return|;
block|}
comment|/**      * To configure security using SSLContextParameters      * @param sslContextParameters      */
DECL|method|setSslContextParameters (SSLContextParameters sslContextParameters)
specifier|public
name|void
name|setSslContextParameters
parameter_list|(
name|SSLContextParameters
name|sslContextParameters
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setSslContextParameters
argument_list|(
name|sslContextParameters
argument_list|)
expr_stmt|;
block|}
DECL|method|isNeedClientAuth ()
specifier|public
name|boolean
name|isNeedClientAuth
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isNeedClientAuth
argument_list|()
return|;
block|}
comment|/**      * Configures whether the server needs client authentication when using SSL.      * @param needClientAuth      */
DECL|method|setNeedClientAuth (boolean needClientAuth)
specifier|public
name|void
name|setNeedClientAuth
parameter_list|(
name|boolean
name|needClientAuth
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setNeedClientAuth
argument_list|(
name|needClientAuth
argument_list|)
expr_stmt|;
block|}
DECL|method|getKeyStoreResource ()
specifier|public
name|String
name|getKeyStoreResource
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getKeyStoreResource
argument_list|()
return|;
block|}
comment|/**      * Client side certificate keystore to be used for encryption. Is loaded by default from classpath,      * but you can prefix with "classpath:", "file:", or "http:" to load the resource from different systems.      * @param keyStoreResource      */
DECL|method|setKeyStoreResource (String keyStoreResource)
specifier|public
name|void
name|setKeyStoreResource
parameter_list|(
name|String
name|keyStoreResource
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setKeyStoreResource
argument_list|(
name|keyStoreResource
argument_list|)
expr_stmt|;
block|}
DECL|method|getTrustStoreResource ()
specifier|public
name|String
name|getTrustStoreResource
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getTrustStoreResource
argument_list|()
return|;
block|}
comment|/**      * Server side certificate keystore to be used for encryption.      * Is loaded by default from classpath, but you can prefix with "classpath:", "file:", or "http:" to load the resource from different systems.      * @param trustStoreResource      */
DECL|method|setTrustStoreResource (String trustStoreResource)
specifier|public
name|void
name|setTrustStoreResource
parameter_list|(
name|String
name|trustStoreResource
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setTrustStoreResource
argument_list|(
name|trustStoreResource
argument_list|)
expr_stmt|;
block|}
DECL|method|getKeyStoreFormat ()
specifier|public
name|String
name|getKeyStoreFormat
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getKeyStoreFormat
argument_list|()
return|;
block|}
comment|/**      * Keystore format to be used for payload encryption. Defaults to "JKS" if not set      * @param keyStoreFormat      */
DECL|method|setKeyStoreFormat (String keyStoreFormat)
specifier|public
name|void
name|setKeyStoreFormat
parameter_list|(
name|String
name|keyStoreFormat
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setKeyStoreFormat
argument_list|(
name|keyStoreFormat
argument_list|)
expr_stmt|;
block|}
DECL|method|getSecurityProvider ()
specifier|public
name|String
name|getSecurityProvider
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getSecurityProvider
argument_list|()
return|;
block|}
comment|/**      * Security provider to be used for payload encryption. Defaults to "SunX509" if not set.      * @param securityProvider      */
DECL|method|setSecurityProvider (String securityProvider)
specifier|public
name|void
name|setSecurityProvider
parameter_list|(
name|String
name|securityProvider
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setSecurityProvider
argument_list|(
name|securityProvider
argument_list|)
expr_stmt|;
block|}
DECL|method|getPassphrase ()
specifier|public
name|String
name|getPassphrase
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getPassphrase
argument_list|()
return|;
block|}
comment|/**      * Password setting to use in order to encrypt/decrypt payloads sent using SSH      * @param passphrase      */
DECL|method|setPassphrase (String passphrase)
specifier|public
name|void
name|setPassphrase
parameter_list|(
name|String
name|passphrase
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setPassphrase
argument_list|(
name|passphrase
argument_list|)
expr_stmt|;
block|}
DECL|method|getServerInitializerFactory ()
specifier|public
name|ServerInitializerFactory
name|getServerInitializerFactory
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getServerInitializerFactory
argument_list|()
return|;
block|}
DECL|method|getCharsetName ()
specifier|public
name|String
name|getCharsetName
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getCharsetName
argument_list|()
return|;
block|}
comment|/**      * To use a custom ServerInitializerFactory      * @param serverInitializerFactory      */
DECL|method|setServerInitializerFactory (ServerInitializerFactory serverInitializerFactory)
specifier|public
name|void
name|setServerInitializerFactory
parameter_list|(
name|ServerInitializerFactory
name|serverInitializerFactory
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setServerInitializerFactory
argument_list|(
name|serverInitializerFactory
argument_list|)
expr_stmt|;
block|}
DECL|method|getNettyServerBootstrapFactory ()
specifier|public
name|NettyServerBootstrapFactory
name|getNettyServerBootstrapFactory
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getNettyServerBootstrapFactory
argument_list|()
return|;
block|}
DECL|method|getRequestTimeout ()
specifier|public
name|long
name|getRequestTimeout
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getRequestTimeout
argument_list|()
return|;
block|}
comment|/**      * To use a custom NettyServerBootstrapFactory      * @param nettyServerBootstrapFactory      */
DECL|method|setNettyServerBootstrapFactory (NettyServerBootstrapFactory nettyServerBootstrapFactory)
specifier|public
name|void
name|setNettyServerBootstrapFactory
parameter_list|(
name|NettyServerBootstrapFactory
name|nettyServerBootstrapFactory
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setNettyServerBootstrapFactory
argument_list|(
name|nettyServerBootstrapFactory
argument_list|)
expr_stmt|;
block|}
DECL|method|getOptions ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getOptions
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getOptions
argument_list|()
return|;
block|}
comment|/**      * Allows to use a timeout for the Netty producer when calling a remote server.      * By default no timeout is in use. The value is in milli seconds, so eg 30000 is 30 seconds.      * The requestTimeout is using Netty's ReadTimeoutHandler to trigger the timeout.      * @param requestTimeout      */
DECL|method|setRequestTimeout (long requestTimeout)
specifier|public
name|void
name|setRequestTimeout
parameter_list|(
name|long
name|requestTimeout
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setRequestTimeout
argument_list|(
name|requestTimeout
argument_list|)
expr_stmt|;
block|}
DECL|method|isSync ()
specifier|public
name|boolean
name|isSync
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isSync
argument_list|()
return|;
block|}
comment|/**      * Setting to set endpoint as one-way or request-response      * @param sync      */
DECL|method|setSync (boolean sync)
specifier|public
name|void
name|setSync
parameter_list|(
name|boolean
name|sync
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setSync
argument_list|(
name|sync
argument_list|)
expr_stmt|;
block|}
comment|/**      * Allows to configure additional netty options using "option." as prefix.      * For example "option.child.keepAlive=false" to set the netty option "child.keepAlive=false". See the Netty documentation for possible options that can be used.      * @param options      */
DECL|method|setOptions (Map<String, Object> options)
specifier|public
name|void
name|setOptions
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|options
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setOptions
argument_list|(
name|options
argument_list|)
expr_stmt|;
block|}
DECL|method|isTextline ()
specifier|public
name|boolean
name|isTextline
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isTextline
argument_list|()
return|;
block|}
DECL|method|isNativeTransport ()
specifier|public
name|boolean
name|isNativeTransport
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isNativeTransport
argument_list|()
return|;
block|}
comment|/**      * Only used for TCP. If no codec is specified, you can use this flag to indicate a text line based codec;      * if not specified or the value is false, then Object Serialization is assumed over TCP.      * @param textline      */
DECL|method|setTextline (boolean textline)
specifier|public
name|void
name|setTextline
parameter_list|(
name|boolean
name|textline
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setTextline
argument_list|(
name|textline
argument_list|)
expr_stmt|;
block|}
DECL|method|getDecoderMaxLineLength ()
specifier|public
name|int
name|getDecoderMaxLineLength
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getDecoderMaxLineLength
argument_list|()
return|;
block|}
comment|/**      * Whether to use native transport instead of NIO. Native transport takes advantage of the host operating system and is only supported on some platforms.      * You need to add the netty JAR for the host operating system you are using. See more details at: http://netty.io/wiki/native-transports.html      * @param nativeTransport      */
DECL|method|setNativeTransport (boolean nativeTransport)
specifier|public
name|void
name|setNativeTransport
parameter_list|(
name|boolean
name|nativeTransport
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setNativeTransport
argument_list|(
name|nativeTransport
argument_list|)
expr_stmt|;
block|}
comment|/**      * The max line length to use for the textline codec.      * @param decoderMaxLineLength      */
DECL|method|setDecoderMaxLineLength (int decoderMaxLineLength)
specifier|public
name|void
name|setDecoderMaxLineLength
parameter_list|(
name|int
name|decoderMaxLineLength
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setDecoderMaxLineLength
argument_list|(
name|decoderMaxLineLength
argument_list|)
expr_stmt|;
block|}
DECL|method|getBossGroup ()
specifier|public
name|EventLoopGroup
name|getBossGroup
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getBossGroup
argument_list|()
return|;
block|}
DECL|method|getDelimiter ()
specifier|public
name|TextLineDelimiter
name|getDelimiter
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getDelimiter
argument_list|()
return|;
block|}
comment|/**      * Set the BossGroup which could be used for handling the new connection of the server side across the NettyEndpoint      * @param bossGroup      */
DECL|method|setBossGroup (EventLoopGroup bossGroup)
specifier|public
name|void
name|setBossGroup
parameter_list|(
name|EventLoopGroup
name|bossGroup
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setBossGroup
argument_list|(
name|bossGroup
argument_list|)
expr_stmt|;
block|}
comment|/**      * The delimiter to use for the textline codec. Possible values are LINE and NULL.      * @param delimiter      */
DECL|method|setDelimiter (TextLineDelimiter delimiter)
specifier|public
name|void
name|setDelimiter
parameter_list|(
name|TextLineDelimiter
name|delimiter
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setDelimiter
argument_list|(
name|delimiter
argument_list|)
expr_stmt|;
block|}
DECL|method|getWorkerGroup ()
specifier|public
name|EventLoopGroup
name|getWorkerGroup
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getWorkerGroup
argument_list|()
return|;
block|}
DECL|method|isAutoAppendDelimiter ()
specifier|public
name|boolean
name|isAutoAppendDelimiter
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isAutoAppendDelimiter
argument_list|()
return|;
block|}
comment|/**      * Whether or not to auto append missing end delimiter when sending using the textline codec.      * @param autoAppendDelimiter      */
DECL|method|setAutoAppendDelimiter (boolean autoAppendDelimiter)
specifier|public
name|void
name|setAutoAppendDelimiter
parameter_list|(
name|boolean
name|autoAppendDelimiter
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setAutoAppendDelimiter
argument_list|(
name|autoAppendDelimiter
argument_list|)
expr_stmt|;
block|}
comment|/**      * To use a explicit EventLoopGroup as the boss thread pool.      * For example to share a thread pool with multiple consumers. By default each consumer has their own boss pool with 1 core thread.      * @param workerGroup      */
DECL|method|setWorkerGroup (EventLoopGroup workerGroup)
specifier|public
name|void
name|setWorkerGroup
parameter_list|(
name|EventLoopGroup
name|workerGroup
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setWorkerGroup
argument_list|(
name|workerGroup
argument_list|)
expr_stmt|;
block|}
DECL|method|getEncoding ()
specifier|public
name|String
name|getEncoding
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getEncoding
argument_list|()
return|;
block|}
DECL|method|getChannelGroup ()
specifier|public
name|ChannelGroup
name|getChannelGroup
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getChannelGroup
argument_list|()
return|;
block|}
comment|/**      * To use a explicit ChannelGroup.      * @param channelGroup      */
DECL|method|setChannelGroup (ChannelGroup channelGroup)
specifier|public
name|void
name|setChannelGroup
parameter_list|(
name|ChannelGroup
name|channelGroup
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setChannelGroup
argument_list|(
name|channelGroup
argument_list|)
expr_stmt|;
block|}
comment|/**      * The encoding (a charset name) to use for the textline codec. If not provided, Camel will use the JVM default Charset.      * @param encoding      */
DECL|method|setEncoding (String encoding)
specifier|public
name|void
name|setEncoding
parameter_list|(
name|String
name|encoding
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setEncoding
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
block|}
DECL|method|getNetworkInterface ()
specifier|public
name|String
name|getNetworkInterface
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getNetworkInterface
argument_list|()
return|;
block|}
DECL|method|getDecoders ()
specifier|public
name|List
argument_list|<
name|ChannelHandler
argument_list|>
name|getDecoders
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getDecoders
argument_list|()
return|;
block|}
comment|/**      * When using UDP then this option can be used to specify a network interface by its name, such as eth0 to join a multicast group.      * @param networkInterface      */
DECL|method|setNetworkInterface (String networkInterface)
specifier|public
name|void
name|setNetworkInterface
parameter_list|(
name|String
name|networkInterface
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setNetworkInterface
argument_list|(
name|networkInterface
argument_list|)
expr_stmt|;
block|}
comment|/**      * A list of decoders to be used.      * You can use a String which have values separated by comma, and have the values be looked up in the Registry.      * Just remember to prefix the value with # so Camel knows it should lookup.      * @param decoders      */
DECL|method|setDecoders (List<ChannelHandler> decoders)
specifier|public
name|void
name|setDecoders
parameter_list|(
name|List
argument_list|<
name|ChannelHandler
argument_list|>
name|decoders
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setDecoders
argument_list|(
name|decoders
argument_list|)
expr_stmt|;
block|}
DECL|method|getEnabledProtocols ()
specifier|public
name|String
name|getEnabledProtocols
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getEnabledProtocols
argument_list|()
return|;
block|}
DECL|method|getEncoders ()
specifier|public
name|List
argument_list|<
name|ChannelHandler
argument_list|>
name|getEncoders
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getEncoders
argument_list|()
return|;
block|}
comment|/**      * Which protocols to enable when using SSL      * @param enabledProtocols      */
DECL|method|setEnabledProtocols (String enabledProtocols)
specifier|public
name|void
name|setEnabledProtocols
parameter_list|(
name|String
name|enabledProtocols
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setEnabledProtocols
argument_list|(
name|enabledProtocols
argument_list|)
expr_stmt|;
block|}
comment|/**      * Used only in clientMode in consumer, the consumer will attempt to reconnect on disconnection if this is enabled      */
DECL|method|isReconnect ()
specifier|public
name|boolean
name|isReconnect
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isReconnect
argument_list|()
return|;
block|}
comment|/**      * A list of encoders to be used. You can use a String which have values separated by comma, and have the values be looked up in the Registry.      * Just remember to prefix the value with # so Camel knows it should lookup.      * @param encoders      */
DECL|method|setEncoders (List<ChannelHandler> encoders)
specifier|public
name|void
name|setEncoders
parameter_list|(
name|List
argument_list|<
name|ChannelHandler
argument_list|>
name|encoders
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setEncoders
argument_list|(
name|encoders
argument_list|)
expr_stmt|;
block|}
DECL|method|setReconnect (boolean reconnect)
specifier|public
name|void
name|setReconnect
parameter_list|(
name|boolean
name|reconnect
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setReconnect
argument_list|(
name|reconnect
argument_list|)
expr_stmt|;
block|}
DECL|method|getEncoder ()
specifier|public
name|ChannelHandler
name|getEncoder
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getEncoder
argument_list|()
return|;
block|}
comment|/**      * Used if reconnect and clientMode is enabled. The interval in milli seconds to attempt reconnection      */
DECL|method|getReconnectInterval ()
specifier|public
name|int
name|getReconnectInterval
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getReconnectInterval
argument_list|()
return|;
block|}
comment|/**      * A custom ChannelHandler class that can be used to perform special marshalling of outbound payloads.      * @param encoder      */
DECL|method|setEncoder (ChannelHandler encoder)
specifier|public
name|void
name|setEncoder
parameter_list|(
name|ChannelHandler
name|encoder
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setEncoder
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
block|}
DECL|method|setReconnectInterval (int reconnectInterval)
specifier|public
name|void
name|setReconnectInterval
parameter_list|(
name|int
name|reconnectInterval
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setReconnectInterval
argument_list|(
name|reconnectInterval
argument_list|)
expr_stmt|;
block|}
DECL|method|getDecoder ()
specifier|public
name|ChannelHandler
name|getDecoder
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getDecoder
argument_list|()
return|;
block|}
comment|/**      * A custom ChannelHandler class that can be used to perform special marshalling of inbound payloads.      * @param decoder      */
DECL|method|setDecoder (ChannelHandler decoder)
specifier|public
name|void
name|setDecoder
parameter_list|(
name|ChannelHandler
name|decoder
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setDecoder
argument_list|(
name|decoder
argument_list|)
expr_stmt|;
block|}
DECL|method|isDisconnect ()
specifier|public
name|boolean
name|isDisconnect
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isDisconnect
argument_list|()
return|;
block|}
comment|/**      * Whether or not to disconnect(close) from Netty Channel right after use. Can be used for both consumer and producer.      * @param disconnect      */
DECL|method|setDisconnect (boolean disconnect)
specifier|public
name|void
name|setDisconnect
parameter_list|(
name|boolean
name|disconnect
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setDisconnect
argument_list|(
name|disconnect
argument_list|)
expr_stmt|;
block|}
DECL|method|isLazyChannelCreation ()
specifier|public
name|boolean
name|isLazyChannelCreation
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isLazyChannelCreation
argument_list|()
return|;
block|}
comment|/**      * Channels can be lazily created to avoid exceptions, if the remote server is not up and running when the Camel producer is started.      * @param lazyChannelCreation      */
DECL|method|setLazyChannelCreation (boolean lazyChannelCreation)
specifier|public
name|void
name|setLazyChannelCreation
parameter_list|(
name|boolean
name|lazyChannelCreation
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setLazyChannelCreation
argument_list|(
name|lazyChannelCreation
argument_list|)
expr_stmt|;
block|}
DECL|method|isTransferExchange ()
specifier|public
name|boolean
name|isTransferExchange
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isTransferExchange
argument_list|()
return|;
block|}
comment|/**      * Only used for TCP. You can transfer the exchange over the wire instead of just the body.      * The following fields are transferred: In body, Out body, fault body, In headers, Out headers, fault headers,      * exchange properties, exchange exception.      * This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.      * @param transferExchange      */
DECL|method|setTransferExchange (boolean transferExchange)
specifier|public
name|void
name|setTransferExchange
parameter_list|(
name|boolean
name|transferExchange
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setTransferExchange
argument_list|(
name|transferExchange
argument_list|)
expr_stmt|;
block|}
DECL|method|isDisconnectOnNoReply ()
specifier|public
name|boolean
name|isDisconnectOnNoReply
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isDisconnectOnNoReply
argument_list|()
return|;
block|}
comment|/**      * If sync is enabled then this option dictates NettyConsumer if it should disconnect where there is no reply to send back.      * @param disconnectOnNoReply      */
DECL|method|setDisconnectOnNoReply (boolean disconnectOnNoReply)
specifier|public
name|void
name|setDisconnectOnNoReply
parameter_list|(
name|boolean
name|disconnectOnNoReply
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setDisconnectOnNoReply
argument_list|(
name|disconnectOnNoReply
argument_list|)
expr_stmt|;
block|}
DECL|method|getNoReplyLogLevel ()
specifier|public
name|LoggingLevel
name|getNoReplyLogLevel
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getNoReplyLogLevel
argument_list|()
return|;
block|}
comment|/**      * If sync is enabled this option dictates NettyConsumer which logging level to use when logging a there is no reply to send back.      * @param noReplyLogLevel      */
DECL|method|setNoReplyLogLevel (LoggingLevel noReplyLogLevel)
specifier|public
name|void
name|setNoReplyLogLevel
parameter_list|(
name|LoggingLevel
name|noReplyLogLevel
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setNoReplyLogLevel
argument_list|(
name|noReplyLogLevel
argument_list|)
expr_stmt|;
block|}
DECL|method|getServerExceptionCaughtLogLevel ()
specifier|public
name|LoggingLevel
name|getServerExceptionCaughtLogLevel
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getServerExceptionCaughtLogLevel
argument_list|()
return|;
block|}
comment|/**      * If the server (NettyConsumer) catches an exception then its logged using this logging level.      * @param serverExceptionCaughtLogLevel      */
DECL|method|setServerExceptionCaughtLogLevel (LoggingLevel serverExceptionCaughtLogLevel)
specifier|public
name|void
name|setServerExceptionCaughtLogLevel
parameter_list|(
name|LoggingLevel
name|serverExceptionCaughtLogLevel
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setServerExceptionCaughtLogLevel
argument_list|(
name|serverExceptionCaughtLogLevel
argument_list|)
expr_stmt|;
block|}
DECL|method|getServerClosedChannelExceptionCaughtLogLevel ()
specifier|public
name|LoggingLevel
name|getServerClosedChannelExceptionCaughtLogLevel
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getServerClosedChannelExceptionCaughtLogLevel
argument_list|()
return|;
block|}
comment|/**      * If the server (NettyConsumer) catches an java.nio.channels.ClosedChannelException then its logged using this logging level.      * This is used to avoid logging the closed channel exceptions, as clients can disconnect abruptly and then cause a flood of closed exceptions in the Netty server.      * @param serverClosedChannelExceptionCaughtLogLevel      */
DECL|method|setServerClosedChannelExceptionCaughtLogLevel (LoggingLevel serverClosedChannelExceptionCaughtLogLevel)
specifier|public
name|void
name|setServerClosedChannelExceptionCaughtLogLevel
parameter_list|(
name|LoggingLevel
name|serverClosedChannelExceptionCaughtLogLevel
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setServerClosedChannelExceptionCaughtLogLevel
argument_list|(
name|serverClosedChannelExceptionCaughtLogLevel
argument_list|)
expr_stmt|;
block|}
DECL|method|isAllowDefaultCodec ()
specifier|public
name|boolean
name|isAllowDefaultCodec
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isAllowDefaultCodec
argument_list|()
return|;
block|}
comment|/**      * The netty component installs a default codec if both, encoder/deocder is null and textline is false.      * Setting allowDefaultCodec to false prevents the netty component from installing a default codec as the first element in the filter chain.      * @param allowDefaultCodec      */
DECL|method|setAllowDefaultCodec (boolean allowDefaultCodec)
specifier|public
name|void
name|setAllowDefaultCodec
parameter_list|(
name|boolean
name|allowDefaultCodec
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setAllowDefaultCodec
argument_list|(
name|allowDefaultCodec
argument_list|)
expr_stmt|;
block|}
DECL|method|getClientInitializerFactory ()
specifier|public
name|ClientInitializerFactory
name|getClientInitializerFactory
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getClientInitializerFactory
argument_list|()
return|;
block|}
comment|/**      * To use a custom ClientInitializerFactory      * @param clientInitializerFactory      */
DECL|method|setClientInitializerFactory (ClientInitializerFactory clientInitializerFactory)
specifier|public
name|void
name|setClientInitializerFactory
parameter_list|(
name|ClientInitializerFactory
name|clientInitializerFactory
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setClientInitializerFactory
argument_list|(
name|clientInitializerFactory
argument_list|)
expr_stmt|;
block|}
DECL|method|isUsingExecutorService ()
specifier|public
name|boolean
name|isUsingExecutorService
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isUsingExecutorService
argument_list|()
return|;
block|}
comment|/**      * Whether to use ordered thread pool, to ensure events are processed orderly on the same channel.      * @param usingExecutorService      */
DECL|method|setUsingExecutorService (boolean usingExecutorService)
specifier|public
name|void
name|setUsingExecutorService
parameter_list|(
name|boolean
name|usingExecutorService
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setUsingExecutorService
argument_list|(
name|usingExecutorService
argument_list|)
expr_stmt|;
block|}
DECL|method|getProducerPoolMaxActive ()
specifier|public
name|int
name|getProducerPoolMaxActive
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getProducerPoolMaxActive
argument_list|()
return|;
block|}
comment|/**      * Sets the cap on the number of objects that can be allocated by the pool      * (checked out to clients, or idle awaiting checkout) at a given time. Use a negative value for no limit.      * @param producerPoolMaxActive      */
DECL|method|setProducerPoolMaxActive (int producerPoolMaxActive)
specifier|public
name|void
name|setProducerPoolMaxActive
parameter_list|(
name|int
name|producerPoolMaxActive
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setProducerPoolMaxActive
argument_list|(
name|producerPoolMaxActive
argument_list|)
expr_stmt|;
block|}
DECL|method|getProducerPoolMinIdle ()
specifier|public
name|int
name|getProducerPoolMinIdle
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getProducerPoolMinIdle
argument_list|()
return|;
block|}
comment|/**      * Sets the minimum number of instances allowed in the producer pool before the evictor thread (if active) spawns new objects.      * @param producerPoolMinIdle      */
DECL|method|setProducerPoolMinIdle (int producerPoolMinIdle)
specifier|public
name|void
name|setProducerPoolMinIdle
parameter_list|(
name|int
name|producerPoolMinIdle
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setProducerPoolMinIdle
argument_list|(
name|producerPoolMinIdle
argument_list|)
expr_stmt|;
block|}
DECL|method|getProducerPoolMaxIdle ()
specifier|public
name|int
name|getProducerPoolMaxIdle
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getProducerPoolMaxIdle
argument_list|()
return|;
block|}
comment|/**      * Sets the cap on the number of "idle" instances in the pool.      * @param producerPoolMaxIdle      */
DECL|method|setProducerPoolMaxIdle (int producerPoolMaxIdle)
specifier|public
name|void
name|setProducerPoolMaxIdle
parameter_list|(
name|int
name|producerPoolMaxIdle
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setProducerPoolMaxIdle
argument_list|(
name|producerPoolMaxIdle
argument_list|)
expr_stmt|;
block|}
DECL|method|getProducerPoolMinEvictableIdle ()
specifier|public
name|long
name|getProducerPoolMinEvictableIdle
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|getProducerPoolMinEvictableIdle
argument_list|()
return|;
block|}
comment|/**      * Sets the minimum amount of time (value in millis) an object may sit idle in the pool before it is eligible for eviction by the idle object evictor.      * @param producerPoolMinEvictableIdle      */
DECL|method|setProducerPoolMinEvictableIdle (long producerPoolMinEvictableIdle)
specifier|public
name|void
name|setProducerPoolMinEvictableIdle
parameter_list|(
name|long
name|producerPoolMinEvictableIdle
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setProducerPoolMinEvictableIdle
argument_list|(
name|producerPoolMinEvictableIdle
argument_list|)
expr_stmt|;
block|}
DECL|method|isProducerPoolEnabled ()
specifier|public
name|boolean
name|isProducerPoolEnabled
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isProducerPoolEnabled
argument_list|()
return|;
block|}
comment|/**      * Whether producer pool is enabled or not.      * Important: Do not turn this off, as the pooling is needed for handling concurrency and reliable request/reply.      * @param producerPoolEnabled      */
DECL|method|setProducerPoolEnabled (boolean producerPoolEnabled)
specifier|public
name|void
name|setProducerPoolEnabled
parameter_list|(
name|boolean
name|producerPoolEnabled
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setProducerPoolEnabled
argument_list|(
name|producerPoolEnabled
argument_list|)
expr_stmt|;
block|}
DECL|method|isUdpConnectionlessSending ()
specifier|public
name|boolean
name|isUdpConnectionlessSending
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isUdpConnectionlessSending
argument_list|()
return|;
block|}
comment|/**      * This option supports connection less udp sending which is a real fire and forget.      * A connected udp send receive the PortUnreachableException if no one is listen on the receiving port.      * @param udpConnectionlessSending      */
DECL|method|setUdpConnectionlessSending (boolean udpConnectionlessSending)
specifier|public
name|void
name|setUdpConnectionlessSending
parameter_list|(
name|boolean
name|udpConnectionlessSending
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setUdpConnectionlessSending
argument_list|(
name|udpConnectionlessSending
argument_list|)
expr_stmt|;
block|}
DECL|method|isClientMode ()
specifier|public
name|boolean
name|isClientMode
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isClientMode
argument_list|()
return|;
block|}
comment|/**      * If the clientMode is true, netty consumer will connect the address as a TCP client.      * @param clientMode      */
DECL|method|setClientMode (boolean clientMode)
specifier|public
name|void
name|setClientMode
parameter_list|(
name|boolean
name|clientMode
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setClientMode
argument_list|(
name|clientMode
argument_list|)
expr_stmt|;
block|}
DECL|method|isUseByteBuf ()
specifier|public
name|boolean
name|isUseByteBuf
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isUseByteBuf
argument_list|()
return|;
block|}
comment|/**      * If the useByteBuf is true, netty producer will turn the message body into {@link ByteBuf} before sending it out.      * @param useByteBuf      */
DECL|method|setUseByteBuf (boolean useByteBuf)
specifier|public
name|void
name|setUseByteBuf
parameter_list|(
name|boolean
name|useByteBuf
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setUseByteBuf
argument_list|(
name|useByteBuf
argument_list|)
expr_stmt|;
block|}
DECL|method|isUdpByteArrayCodec ()
specifier|public
name|boolean
name|isUdpByteArrayCodec
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isUdpByteArrayCodec
argument_list|()
return|;
block|}
comment|/**      * For UDP only. If enabled the using byte array codec instead of Java serialization protocol.      * @param udpByteArrayCodec      */
DECL|method|setUdpByteArrayCodec (boolean udpByteArrayCodec)
specifier|public
name|void
name|setUdpByteArrayCodec
parameter_list|(
name|boolean
name|udpByteArrayCodec
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setUdpByteArrayCodec
argument_list|(
name|udpByteArrayCodec
argument_list|)
expr_stmt|;
block|}
DECL|method|isReuseChannel ()
specifier|public
name|boolean
name|isReuseChannel
parameter_list|()
block|{
return|return
name|getConfigurationOrCreate
argument_list|()
operator|.
name|isReuseChannel
argument_list|()
return|;
block|}
comment|/**      * This option allows producers to reuse the same Netty {@link Channel} for the lifecycle of processing the {@link Exchange}.      * This is useable if you need to call a server multiple times in a Camel route and want to use the same network connection.      * When using this the channel is not returned to the connection pool until the {@link Exchange} is done; or disconnected      * if the disconnect option is set to true.      *<p/>      * The reused {@link Channel} is stored on the {@link Exchange} as an exchange property with the key {@link NettyConstants#NETTY_CHANNEL}      * which allows you to obtain the channel during routing and use it as well.      * @param reuseChannel      */
DECL|method|setReuseChannel (boolean reuseChannel)
specifier|public
name|void
name|setReuseChannel
parameter_list|(
name|boolean
name|reuseChannel
parameter_list|)
block|{
name|getConfigurationOrCreate
argument_list|()
operator|.
name|setReuseChannel
argument_list|(
name|reuseChannel
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

