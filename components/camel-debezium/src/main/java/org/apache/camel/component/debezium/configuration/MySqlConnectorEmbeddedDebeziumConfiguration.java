begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.component.debezium.configuration
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|debezium
operator|.
name|configuration
package|;
end_package

begin_import
import|import
name|io
operator|.
name|debezium
operator|.
name|config
operator|.
name|CommonConnectorConfig
import|;
end_import

begin_import
import|import
name|io
operator|.
name|debezium
operator|.
name|config
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|io
operator|.
name|debezium
operator|.
name|connector
operator|.
name|mysql
operator|.
name|MySqlConnector
import|;
end_import

begin_import
import|import
name|io
operator|.
name|debezium
operator|.
name|connector
operator|.
name|mysql
operator|.
name|MySqlConnectorConfig
import|;
end_import

begin_import
import|import
name|io
operator|.
name|debezium
operator|.
name|relational
operator|.
name|history
operator|.
name|FileDatabaseHistory
import|;
end_import

begin_import
import|import
name|io
operator|.
name|debezium
operator|.
name|relational
operator|.
name|history
operator|.
name|KafkaDatabaseHistory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|debezium
operator|.
name|DebeziumConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|Metadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|UriParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|UriParams
import|;
end_import

begin_class
annotation|@
name|UriParams
DECL|class|MySqlConnectorEmbeddedDebeziumConfiguration
specifier|public
class|class
name|MySqlConnectorEmbeddedDebeziumConfiguration
extends|extends
name|EmbeddedDebeziumConfiguration
block|{
DECL|field|LABEL_NAME
specifier|private
specifier|static
specifier|final
name|String
name|LABEL_NAME
init|=
literal|"consumer,mysql"
decl_stmt|;
comment|// database.hostname
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|)
annotation|@
name|Metadata
argument_list|(
name|required
operator|=
literal|true
argument_list|)
DECL|field|databaseHostName
specifier|private
name|String
name|databaseHostName
decl_stmt|;
comment|// database.port
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|,
name|defaultValue
operator|=
literal|"3306"
argument_list|)
DECL|field|databasePort
specifier|private
name|int
name|databasePort
init|=
literal|3306
decl_stmt|;
comment|// database.user
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|)
annotation|@
name|Metadata
argument_list|(
name|required
operator|=
literal|true
argument_list|)
DECL|field|databaseUser
specifier|private
name|String
name|databaseUser
decl_stmt|;
comment|// database.password
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|)
annotation|@
name|Metadata
argument_list|(
name|required
operator|=
literal|true
argument_list|,
name|secret
operator|=
literal|true
argument_list|)
DECL|field|databasePassword
specifier|private
name|String
name|databasePassword
decl_stmt|;
comment|// database.server.name
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|)
annotation|@
name|Metadata
argument_list|(
name|required
operator|=
literal|true
argument_list|)
DECL|field|databaseServerName
specifier|private
name|String
name|databaseServerName
decl_stmt|;
comment|// database.server.id
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|)
annotation|@
name|Metadata
argument_list|(
name|required
operator|=
literal|true
argument_list|)
DECL|field|databaseServerId
specifier|private
name|int
name|databaseServerId
decl_stmt|;
comment|// database.history
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|,
name|defaultValue
operator|=
literal|"io.debezium.relational.history.FileDatabaseHistory"
argument_list|)
DECL|field|databaseHistory
specifier|private
name|String
name|databaseHistory
init|=
name|DebeziumConstants
operator|.
name|DEFAULT_DATABASE_HISTORY
decl_stmt|;
comment|// database.history.filename
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|)
DECL|field|databaseHistoryFileName
specifier|private
name|String
name|databaseHistoryFileName
decl_stmt|;
comment|// database.history.kafka.topic
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|)
DECL|field|databaseHistoryKafkaTopic
specifier|private
name|String
name|databaseHistoryKafkaTopic
decl_stmt|;
comment|// database.historyâ.kafka.bootstrap.servers
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|)
DECL|field|databaseHistoryKafkaBootstrapServers
specifier|private
name|String
name|databaseHistoryKafkaBootstrapServers
decl_stmt|;
comment|// database.whitelist
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|)
DECL|field|databaseWhitelist
specifier|private
name|String
name|databaseWhitelist
decl_stmt|;
comment|// database.blacklist
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|)
DECL|field|databaseBlacklist
specifier|private
name|String
name|databaseBlacklist
decl_stmt|;
comment|// table.whitelist
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|)
DECL|field|tableWhitelist
specifier|private
name|String
name|tableWhitelist
decl_stmt|;
comment|// table.blacklist
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|)
DECL|field|tableBlacklist
specifier|private
name|String
name|tableBlacklist
decl_stmt|;
comment|// column.blacklist
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|)
DECL|field|columnBlacklist
specifier|private
name|String
name|columnBlacklist
decl_stmt|;
comment|// time.precision.mode
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|,
name|defaultValue
operator|=
literal|"adaptive_time_microseconds"
argument_list|)
DECL|field|timePrecisionMode
specifier|private
name|String
name|timePrecisionMode
init|=
literal|"adaptive_time_microseconds"
decl_stmt|;
comment|// decimal.handling.mode
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|,
name|defaultValue
operator|=
literal|"precise"
argument_list|)
DECL|field|decimalHandlingMode
specifier|private
name|String
name|decimalHandlingMode
init|=
literal|"precise"
decl_stmt|;
comment|// bigint.unsigned.handling.mode
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|,
name|defaultValue
operator|=
literal|"long"
argument_list|)
DECL|field|bigintUnsignedHandlingMode
specifier|private
name|String
name|bigintUnsignedHandlingMode
init|=
literal|"long"
decl_stmt|;
comment|// include.schema.changes
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|,
name|defaultValue
operator|=
literal|"true"
argument_list|)
DECL|field|includeSchemaChanges
specifier|private
name|boolean
name|includeSchemaChanges
init|=
literal|true
decl_stmt|;
comment|// include.query
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|,
name|defaultValue
operator|=
literal|"false"
argument_list|)
DECL|field|includeQuery
specifier|private
name|boolean
name|includeQuery
decl_stmt|;
comment|// event.deserializationâ.failure.handling.mode
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|,
name|defaultValue
operator|=
literal|"fail"
argument_list|)
DECL|field|eventDeserializationFailureHandlingMode
specifier|private
name|String
name|eventDeserializationFailureHandlingMode
init|=
literal|"fail"
decl_stmt|;
comment|// inconsistent.schema.handling.mode
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|,
name|defaultValue
operator|=
literal|"fail"
argument_list|)
DECL|field|inconsistentSchemaHandlingMode
specifier|private
name|String
name|inconsistentSchemaHandlingMode
init|=
literal|"fail"
decl_stmt|;
comment|// max.queue.size
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|,
name|defaultValue
operator|=
literal|"8192"
argument_list|)
DECL|field|maxQueueSize
specifier|private
name|int
name|maxQueueSize
init|=
literal|8192
decl_stmt|;
comment|// max.batch.size
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|,
name|defaultValue
operator|=
literal|"2048"
argument_list|)
DECL|field|maxBatchSize
specifier|private
name|int
name|maxBatchSize
init|=
literal|2048
decl_stmt|;
comment|// poll.interval.ms
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|,
name|defaultValue
operator|=
literal|"1000"
argument_list|)
DECL|field|pollIntervalMs
specifier|private
name|long
name|pollIntervalMs
init|=
literal|1000
decl_stmt|;
comment|// connect.timeout.ms
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|,
name|defaultValue
operator|=
literal|"30000"
argument_list|)
DECL|field|connectTimeoutMs
specifier|private
name|long
name|connectTimeoutMs
init|=
literal|30000
decl_stmt|;
comment|// gtid.source.includes
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|)
DECL|field|gtidSourceIncludes
specifier|private
name|String
name|gtidSourceIncludes
decl_stmt|;
comment|// gtid.source.excludes
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|)
DECL|field|gtidSourceExcludes
specifier|private
name|String
name|gtidSourceExcludes
decl_stmt|;
comment|// gtid.new.channel.position
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|,
name|defaultValue
operator|=
literal|"latest"
argument_list|)
DECL|field|gtidNewChannelPosition
specifier|private
name|String
name|gtidNewChannelPosition
init|=
literal|"latest"
decl_stmt|;
comment|// tombstones.on.delete
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|,
name|defaultValue
operator|=
literal|"false"
argument_list|)
DECL|field|tombstonesOnDelete
specifier|private
name|boolean
name|tombstonesOnDelete
decl_stmt|;
comment|// ddl.parser.mode
annotation|@
name|UriParam
argument_list|(
name|label
operator|=
name|LABEL_NAME
argument_list|,
name|defaultValue
operator|=
literal|"antlr"
argument_list|)
DECL|field|ddlParserMode
specifier|private
name|String
name|ddlParserMode
init|=
literal|"antlr"
decl_stmt|;
annotation|@
name|Override
DECL|method|createConnectorConfiguration ()
specifier|protected
name|Configuration
name|createConnectorConfiguration
parameter_list|()
block|{
return|return
name|createDebeziumMySqlConnectorConfiguration
argument_list|()
return|;
block|}
DECL|method|createDebeziumMySqlConnectorConfiguration ()
specifier|private
name|Configuration
name|createDebeziumMySqlConnectorConfiguration
parameter_list|()
block|{
specifier|final
name|Configuration
operator|.
name|Builder
name|configBuilder
init|=
name|Configuration
operator|.
name|create
argument_list|()
decl_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|HOSTNAME
argument_list|,
name|databaseHostName
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|PORT
argument_list|,
name|databasePort
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|USER
argument_list|,
name|databaseUser
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|PASSWORD
argument_list|,
name|databasePassword
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|SERVER_ID
argument_list|,
name|databaseServerId
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|SERVER_NAME
argument_list|,
name|databaseServerName
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|DATABASE_WHITELIST
argument_list|,
name|databaseWhitelist
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|DATABASE_HISTORY
argument_list|,
name|databaseHistory
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|FileDatabaseHistory
operator|.
name|FILE_PATH
argument_list|,
name|databaseHistoryFileName
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|KafkaDatabaseHistory
operator|.
name|TOPIC
argument_list|,
name|databaseHistoryKafkaTopic
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|KafkaDatabaseHistory
operator|.
name|BOOTSTRAP_SERVERS
argument_list|,
name|databaseHistoryKafkaBootstrapServers
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|DATABASE_WHITELIST
argument_list|,
name|databaseWhitelist
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|DATABASE_BLACKLIST
argument_list|,
name|databaseBlacklist
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|TABLE_WHITELIST
argument_list|,
name|tableWhitelist
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|TABLE_BLACKLIST
argument_list|,
name|tableBlacklist
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|COLUMN_BLACKLIST
argument_list|,
name|columnBlacklist
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|TIME_PRECISION_MODE
argument_list|,
name|timePrecisionMode
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|DECIMAL_HANDLING_MODE
argument_list|,
name|decimalHandlingMode
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|BIGINT_UNSIGNED_HANDLING_MODE
argument_list|,
name|bigintUnsignedHandlingMode
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|INCLUDE_SCHEMA_CHANGES
argument_list|,
name|includeSchemaChanges
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|INCLUDE_SQL_QUERY
argument_list|,
name|includeQuery
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|EVENT_DESERIALIZATION_FAILURE_HANDLING_MODE
argument_list|,
name|eventDeserializationFailureHandlingMode
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|INCONSISTENT_SCHEMA_HANDLING_MODE
argument_list|,
name|inconsistentSchemaHandlingMode
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|CommonConnectorConfig
operator|.
name|MAX_QUEUE_SIZE
argument_list|,
name|maxQueueSize
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|MAX_BATCH_SIZE
argument_list|,
name|maxBatchSize
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|POLL_INTERVAL_MS
argument_list|,
name|pollIntervalMs
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|CONNECTION_TIMEOUT_MS
argument_list|,
name|connectTimeoutMs
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|GTID_SOURCE_INCLUDES
argument_list|,
name|gtidSourceIncludes
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|GTID_SOURCE_EXCLUDES
argument_list|,
name|gtidSourceExcludes
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|GTID_NEW_CHANNEL_POSITION
argument_list|,
name|gtidNewChannelPosition
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|TOMBSTONES_ON_DELETE
argument_list|,
name|tombstonesOnDelete
argument_list|)
expr_stmt|;
name|addPropertyIfNotNull
argument_list|(
name|configBuilder
argument_list|,
name|MySqlConnectorConfig
operator|.
name|DDL_PARSER_MODE
argument_list|,
name|ddlParserMode
argument_list|)
expr_stmt|;
return|return
name|configBuilder
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|validateConnectorConfiguration ()
specifier|protected
name|ConfigurationValidation
name|validateConnectorConfiguration
parameter_list|()
block|{
return|return
name|validateMySqlConnectorConfiguration
argument_list|()
return|;
block|}
DECL|method|validateMySqlConnectorConfiguration ()
specifier|private
name|ConfigurationValidation
name|validateMySqlConnectorConfiguration
parameter_list|()
block|{
if|if
condition|(
name|isFieldValueNotSet
argument_list|(
name|databasePassword
argument_list|)
condition|)
block|{
return|return
name|ConfigurationValidation
operator|.
name|notValid
argument_list|(
literal|"Required field 'databasePassword' must be set."
argument_list|)
return|;
block|}
if|if
condition|(
name|isFieldValueNotSet
argument_list|(
name|databaseServerId
argument_list|)
condition|)
block|{
return|return
name|ConfigurationValidation
operator|.
name|notValid
argument_list|(
literal|"Required field 'databaseServerId' must be set."
argument_list|)
return|;
block|}
if|if
condition|(
name|isFieldValueNotSet
argument_list|(
name|databaseServerName
argument_list|)
condition|)
block|{
return|return
name|ConfigurationValidation
operator|.
name|notValid
argument_list|(
literal|"Required field 'databaseServerName' must be set."
argument_list|)
return|;
block|}
comment|// check for databaseHistory
if|if
condition|(
name|databaseHistory
operator|.
name|equals
argument_list|(
name|DebeziumConstants
operator|.
name|DEFAULT_DATABASE_HISTORY
argument_list|)
operator|&&
name|isFieldValueNotSet
argument_list|(
name|databaseHistoryFileName
argument_list|)
condition|)
block|{
return|return
name|ConfigurationValidation
operator|.
name|notValid
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Required field 'databaseHistoryFileName' must be set since 'databaseHistory' is set to '%s'"
argument_list|,
name|DebeziumConstants
operator|.
name|DEFAULT_DATABASE_HISTORY
argument_list|)
argument_list|)
return|;
block|}
return|return
name|ConfigurationValidation
operator|.
name|valid
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|configureConnectorClass ()
specifier|protected
name|Class
argument_list|<
name|?
argument_list|>
name|configureConnectorClass
parameter_list|()
block|{
return|return
name|MySqlConnector
operator|.
name|class
return|;
block|}
comment|/**      * IP address or hostname of the target database server.      */
DECL|method|getDatabaseHostName ()
specifier|public
name|String
name|getDatabaseHostName
parameter_list|()
block|{
return|return
name|databaseHostName
return|;
block|}
DECL|method|setDatabaseHostName (String databaseHostName)
specifier|public
name|void
name|setDatabaseHostName
parameter_list|(
name|String
name|databaseHostName
parameter_list|)
block|{
name|this
operator|.
name|databaseHostName
operator|=
name|databaseHostName
expr_stmt|;
block|}
comment|/**      * Integer port number of the database server.      */
DECL|method|getDatabasePort ()
specifier|public
name|int
name|getDatabasePort
parameter_list|()
block|{
return|return
name|databasePort
return|;
block|}
DECL|method|setDatabasePort (int databasePort)
specifier|public
name|void
name|setDatabasePort
parameter_list|(
name|int
name|databasePort
parameter_list|)
block|{
name|this
operator|.
name|databasePort
operator|=
name|databasePort
expr_stmt|;
block|}
comment|/**      * Name of the MySQL database to use when connecting to the database server.      */
DECL|method|getDatabaseUser ()
specifier|public
name|String
name|getDatabaseUser
parameter_list|()
block|{
return|return
name|databaseUser
return|;
block|}
DECL|method|setDatabaseUser (String databaseUser)
specifier|public
name|void
name|setDatabaseUser
parameter_list|(
name|String
name|databaseUser
parameter_list|)
block|{
name|this
operator|.
name|databaseUser
operator|=
name|databaseUser
expr_stmt|;
block|}
comment|/**      * Password to use when connecting to the database server.      */
DECL|method|getDatabasePassword ()
specifier|public
name|String
name|getDatabasePassword
parameter_list|()
block|{
return|return
name|databasePassword
return|;
block|}
DECL|method|setDatabasePassword (String databasePassword)
specifier|public
name|void
name|setDatabasePassword
parameter_list|(
name|String
name|databasePassword
parameter_list|)
block|{
name|this
operator|.
name|databasePassword
operator|=
name|databasePassword
expr_stmt|;
block|}
comment|/**      * Logical name that identifies and provides a namespace for the particular      * database server/cluster being monitored.      */
DECL|method|getDatabaseServerName ()
specifier|public
name|String
name|getDatabaseServerName
parameter_list|()
block|{
return|return
name|databaseServerName
return|;
block|}
DECL|method|setDatabaseServerName (String databaseServerName)
specifier|public
name|void
name|setDatabaseServerName
parameter_list|(
name|String
name|databaseServerName
parameter_list|)
block|{
name|this
operator|.
name|databaseServerName
operator|=
name|databaseServerName
expr_stmt|;
block|}
comment|/**      * A numeric ID of this database client, which must be unique across all      * currently-running database processes in the database cluster. This connector      * joins the database cluster as another server (with this unique ID) so it can      * read the binlog.      */
DECL|method|getDatabaseServerId ()
specifier|public
name|int
name|getDatabaseServerId
parameter_list|()
block|{
return|return
name|databaseServerId
return|;
block|}
DECL|method|setDatabaseServerId (int databaseServerId)
specifier|public
name|void
name|setDatabaseServerId
parameter_list|(
name|int
name|databaseServerId
parameter_list|)
block|{
name|this
operator|.
name|databaseServerId
operator|=
name|databaseServerId
expr_stmt|;
block|}
comment|/**      * The full name of the Kafka topic where the connector will store the database      * schema history.      */
DECL|method|getDatabaseHistoryKafkaTopic ()
specifier|public
name|String
name|getDatabaseHistoryKafkaTopic
parameter_list|()
block|{
return|return
name|databaseHistoryKafkaTopic
return|;
block|}
DECL|method|setDatabaseHistoryKafkaTopic (String databaseHistoryKafkaTopic)
specifier|public
name|void
name|setDatabaseHistoryKafkaTopic
parameter_list|(
name|String
name|databaseHistoryKafkaTopic
parameter_list|)
block|{
name|this
operator|.
name|databaseHistoryKafkaTopic
operator|=
name|databaseHistoryKafkaTopic
expr_stmt|;
block|}
comment|/**      * An optional comma-separated list of regular expressions that match database      * names to be monitored; any database name not included in the whitelist will      * be excluded from monitoring. By default all databases will be monitored. May      * not be used with database.blacklist.      */
DECL|method|getDatabaseWhitelist ()
specifier|public
name|String
name|getDatabaseWhitelist
parameter_list|()
block|{
return|return
name|databaseWhitelist
return|;
block|}
DECL|method|setDatabaseWhitelist (String databaseWhitelist)
specifier|public
name|void
name|setDatabaseWhitelist
parameter_list|(
name|String
name|databaseWhitelist
parameter_list|)
block|{
name|this
operator|.
name|databaseWhitelist
operator|=
name|databaseWhitelist
expr_stmt|;
block|}
comment|/**      * The name of the DatabaseHistory class that should be used to store and      * recover database schema changes.      */
DECL|method|getDatabaseHistory ()
specifier|public
name|String
name|getDatabaseHistory
parameter_list|()
block|{
return|return
name|databaseHistory
return|;
block|}
DECL|method|setDatabaseHistory (String databaseHistory)
specifier|public
name|void
name|setDatabaseHistory
parameter_list|(
name|String
name|databaseHistory
parameter_list|)
block|{
name|this
operator|.
name|databaseHistory
operator|=
name|databaseHistory
expr_stmt|;
block|}
comment|/**      * The path to the file that will be used to record the database history      */
DECL|method|getDatabaseHistoryFileName ()
specifier|public
name|String
name|getDatabaseHistoryFileName
parameter_list|()
block|{
return|return
name|databaseHistoryFileName
return|;
block|}
DECL|method|setDatabaseHistoryFileName (String databaseHistoryFileName)
specifier|public
name|void
name|setDatabaseHistoryFileName
parameter_list|(
name|String
name|databaseHistoryFileName
parameter_list|)
block|{
name|this
operator|.
name|databaseHistoryFileName
operator|=
name|databaseHistoryFileName
expr_stmt|;
block|}
comment|/**      * The full name of the Kafka topic where the connector will store the database      * schema history.      */
DECL|method|getDatabaseHistoryKafkaBootstrapServers ()
specifier|public
name|String
name|getDatabaseHistoryKafkaBootstrapServers
parameter_list|()
block|{
return|return
name|databaseHistoryKafkaBootstrapServers
return|;
block|}
DECL|method|setDatabaseHistoryKafkaBootstrapServers (String databaseHistoryKafkaBootstrapServers)
specifier|public
name|void
name|setDatabaseHistoryKafkaBootstrapServers
parameter_list|(
name|String
name|databaseHistoryKafkaBootstrapServers
parameter_list|)
block|{
name|this
operator|.
name|databaseHistoryKafkaBootstrapServers
operator|=
name|databaseHistoryKafkaBootstrapServers
expr_stmt|;
block|}
comment|/**      * An optional comma-separated list of regular expressions that match database      * names to be excluded from monitoring; any database name not included in the      * blacklist will be monitored. May not be used with database.whitelist.      */
DECL|method|getDatabaseBlacklist ()
specifier|public
name|String
name|getDatabaseBlacklist
parameter_list|()
block|{
return|return
name|databaseBlacklist
return|;
block|}
DECL|method|setDatabaseBlacklist (String databaseBlacklist)
specifier|public
name|void
name|setDatabaseBlacklist
parameter_list|(
name|String
name|databaseBlacklist
parameter_list|)
block|{
name|this
operator|.
name|databaseBlacklist
operator|=
name|databaseBlacklist
expr_stmt|;
block|}
comment|/**      * An optional comma-separated list of regular expressions that match      * fully-qualified table identifiers for tables to be monitored; any table not      * included in the whitelist will be excluded from monitoring. Each identifier      * is of the form databaseName.tableName. By default the connector will monitor      * every non-system table in each monitored database. May not be used with      * table.blacklist.      */
DECL|method|getTableWhitelist ()
specifier|public
name|String
name|getTableWhitelist
parameter_list|()
block|{
return|return
name|tableWhitelist
return|;
block|}
DECL|method|setTableWhitelist (String tableWhitelist)
specifier|public
name|void
name|setTableWhitelist
parameter_list|(
name|String
name|tableWhitelist
parameter_list|)
block|{
name|this
operator|.
name|tableWhitelist
operator|=
name|tableWhitelist
expr_stmt|;
block|}
comment|/**      * An optional comma-separated list of regular expressions that match      * fully-qualified table identifiers for tables to be excluded from monitoring;      * any table not included in the blacklist will be monitored. Each identifier is      * of the form databaseName.tableName. May not be used with table.whitelist.      */
DECL|method|getTableBlacklist ()
specifier|public
name|String
name|getTableBlacklist
parameter_list|()
block|{
return|return
name|tableBlacklist
return|;
block|}
DECL|method|setTableBlacklist (String tableBlacklist)
specifier|public
name|void
name|setTableBlacklist
parameter_list|(
name|String
name|tableBlacklist
parameter_list|)
block|{
name|this
operator|.
name|tableBlacklist
operator|=
name|tableBlacklist
expr_stmt|;
block|}
comment|/**      * An optional comma-separated list of regular expressions that match the      * fully-qualified names of columns that should be excluded from change event      * message values. Fully-qualified names for columns are of the form      * databaseName.tableName.columnName, or      * databaseName.schemaName.tableName.columnName.      */
DECL|method|getColumnBlacklist ()
specifier|public
name|String
name|getColumnBlacklist
parameter_list|()
block|{
return|return
name|columnBlacklist
return|;
block|}
DECL|method|setColumnBlacklist (String columnBlacklist)
specifier|public
name|void
name|setColumnBlacklist
parameter_list|(
name|String
name|columnBlacklist
parameter_list|)
block|{
name|this
operator|.
name|columnBlacklist
operator|=
name|columnBlacklist
expr_stmt|;
block|}
comment|/**      * Time, date, and timestamps can be represented with different kinds of      * precision, including: adaptive_time_microseconds (the default) captures the      * date, datetime and timestamp values exactly as in the database using either      * millisecond, microsecond, or nanosecond precision values based on the      * database columnâs type, with the exception of TIME type fields, which are      * always captured as microseconds; adaptive (deprecated) captures the time and      * timestamp values exactly as in the database using either millisecond,      * microsecond, or nanosecond precision values based on the database columnâs      * type; or connect always represents time and timestamp values using Kafka      * Connectâs built-in representations for Time, Date, and Timestamp, which uses      * millisecond precision regardless of the database columns' precision. See      * Temporal values.      */
DECL|method|getTimePrecisionMode ()
specifier|public
name|String
name|getTimePrecisionMode
parameter_list|()
block|{
return|return
name|timePrecisionMode
return|;
block|}
DECL|method|setTimePrecisionMode (String timePrecisionMode)
specifier|public
name|void
name|setTimePrecisionMode
parameter_list|(
name|String
name|timePrecisionMode
parameter_list|)
block|{
name|this
operator|.
name|timePrecisionMode
operator|=
name|timePrecisionMode
expr_stmt|;
block|}
comment|/**      * Specifies how the connector should handle values for DECIMAL and NUMERIC      * columns: precise (the default) represents them precisely using      * java.math.BigDecimal values represented in change events in a binary form; or      * double represents them using double values, which may result in a loss of      * precision but will be far easier to use. string option encodes values as      * formatted string which is easy to consume but a semantic information about      * the real type is lost. See Decimal values.      */
DECL|method|getDecimalHandlingMode ()
specifier|public
name|String
name|getDecimalHandlingMode
parameter_list|()
block|{
return|return
name|decimalHandlingMode
return|;
block|}
DECL|method|setDecimalHandlingMode (String decimalHandlingMode)
specifier|public
name|void
name|setDecimalHandlingMode
parameter_list|(
name|String
name|decimalHandlingMode
parameter_list|)
block|{
name|this
operator|.
name|decimalHandlingMode
operator|=
name|decimalHandlingMode
expr_stmt|;
block|}
comment|/**      * Specifies how BIGINT UNSIGNED columns should be represented in change events,      * including: precise uses java.math.BigDecimal to represent values, which are      * encoded in the change events using a binary representation and Kafka      * Connectâs org.apache.kafka.connect.data.Decimal type; long (the default)      * represents values using Javaâs long, which may not offer the precision but      * will be far easier to use in consumers. long is usually the preferable      * setting. Only when working with values larger than 2^63, the precise setting      * should be used as those values canât be conveyed using long. See Data types.      */
DECL|method|getBigintUnsignedHandlingMode ()
specifier|public
name|String
name|getBigintUnsignedHandlingMode
parameter_list|()
block|{
return|return
name|bigintUnsignedHandlingMode
return|;
block|}
DECL|method|setBigintUnsignedHandlingMode (String bigintUnsignedHandlingMode)
specifier|public
name|void
name|setBigintUnsignedHandlingMode
parameter_list|(
name|String
name|bigintUnsignedHandlingMode
parameter_list|)
block|{
name|this
operator|.
name|bigintUnsignedHandlingMode
operator|=
name|bigintUnsignedHandlingMode
expr_stmt|;
block|}
comment|/**      * Boolean value that specifies whether the connector should publish changes in      * the database schema to a Kafka topic with the same name as the database      * server ID. Each schema change will be recorded using a key that contains the      * database name and whose value includes the DDL statement(s). This is      * independent of how the connector internally records database history. The      * default is true.      */
DECL|method|isIncludeSchemaChanges ()
specifier|public
name|boolean
name|isIncludeSchemaChanges
parameter_list|()
block|{
return|return
name|includeSchemaChanges
return|;
block|}
DECL|method|setIncludeSchemaChanges (boolean includeSchemaChanges)
specifier|public
name|void
name|setIncludeSchemaChanges
parameter_list|(
name|boolean
name|includeSchemaChanges
parameter_list|)
block|{
name|this
operator|.
name|includeSchemaChanges
operator|=
name|includeSchemaChanges
expr_stmt|;
block|}
comment|/**      * Boolean value that specifies whether the connector should include the      * original SQL query that generated the change event. Note: This option      * requires MySQL be configured with the binlog_rows_query_log_events option set      * to ON. Query will not be present for events generated from the snapshot      * process. Warning: Enabling this option may expose tables or fields explicitly      * blacklisted or masked by including the original SQL statement in the change      * event. For this reason this option is defaulted to 'false'.      */
DECL|method|isIncludeQuery ()
specifier|public
name|boolean
name|isIncludeQuery
parameter_list|()
block|{
return|return
name|includeQuery
return|;
block|}
DECL|method|setIncludeQuery (boolean includeQuery)
specifier|public
name|void
name|setIncludeQuery
parameter_list|(
name|boolean
name|includeQuery
parameter_list|)
block|{
name|this
operator|.
name|includeQuery
operator|=
name|includeQuery
expr_stmt|;
block|}
comment|/**      * Specifies how the connector should react to exceptions during deserialization      * of binlog events. fail will propagate the exception (indicating the      * problematic event and its binlog offset), causing the connector to stop. warn      * will cause the problematic event to be skipped and the problematic event and      * its binlog offset to be logged (make sure that the logger is set to the WARN      * or ERROR level). ignore will cause problematic event will be skipped.      */
DECL|method|getEventDeserializationFailureHandlingMode ()
specifier|public
name|String
name|getEventDeserializationFailureHandlingMode
parameter_list|()
block|{
return|return
name|eventDeserializationFailureHandlingMode
return|;
block|}
DECL|method|setEventDeserializationFailureHandlingMode (String eventDeserializationFailureHandlingMode)
specifier|public
name|void
name|setEventDeserializationFailureHandlingMode
parameter_list|(
name|String
name|eventDeserializationFailureHandlingMode
parameter_list|)
block|{
name|this
operator|.
name|eventDeserializationFailureHandlingMode
operator|=
name|eventDeserializationFailureHandlingMode
expr_stmt|;
block|}
comment|/**      * Specifies how the connector should react to binlog events that relate to      * tables that are not present in internal schema representation (i.e. internal      * representation is not consistent with database) fail will throw an exception      * (indicating the problematic event and its binlog offset), causing the      * connector to stop. warn will cause the problematic event to be skipped and      * the problematic event and its binlog offset to be logged (make sure that the      * logger is set to the WARN or ERROR level). ignore will cause the problematic      * event to be skipped.      */
DECL|method|getInconsistentSchemaHandlingMode ()
specifier|public
name|String
name|getInconsistentSchemaHandlingMode
parameter_list|()
block|{
return|return
name|inconsistentSchemaHandlingMode
return|;
block|}
DECL|method|setInconsistentSchemaHandlingMode (String inconsistentSchemaHandlingMode)
specifier|public
name|void
name|setInconsistentSchemaHandlingMode
parameter_list|(
name|String
name|inconsistentSchemaHandlingMode
parameter_list|)
block|{
name|this
operator|.
name|inconsistentSchemaHandlingMode
operator|=
name|inconsistentSchemaHandlingMode
expr_stmt|;
block|}
comment|/**      * Positive integer value that specifies the maximum size of the blocking queue      * into which change events read from the database log are placed before they      * are written to Kafka. This queue can provide backpressure to the binlog      * reader when, for example, writes to Kafka are slower or if Kafka is not      * available. Events that appear in the queue are not included in the offsets      * periodically recorded by this connector. Defaults to 8192, and should always      * be larger than the maximum batch size specified in the max.batch.size      * property.      */
DECL|method|getMaxQueueSize ()
specifier|public
name|int
name|getMaxQueueSize
parameter_list|()
block|{
return|return
name|maxQueueSize
return|;
block|}
DECL|method|setMaxQueueSize (int maxQueueSize)
specifier|public
name|void
name|setMaxQueueSize
parameter_list|(
name|int
name|maxQueueSize
parameter_list|)
block|{
name|this
operator|.
name|maxQueueSize
operator|=
name|maxQueueSize
expr_stmt|;
block|}
comment|/**      * Positive integer value that specifies the maximum size of each batch of      * events that should be processed during each iteration of this connector.      * Defaults to 2048.      */
DECL|method|getMaxBatchSize ()
specifier|public
name|int
name|getMaxBatchSize
parameter_list|()
block|{
return|return
name|maxBatchSize
return|;
block|}
DECL|method|setMaxBatchSize (int maxBatchSize)
specifier|public
name|void
name|setMaxBatchSize
parameter_list|(
name|int
name|maxBatchSize
parameter_list|)
block|{
name|this
operator|.
name|maxBatchSize
operator|=
name|maxBatchSize
expr_stmt|;
block|}
comment|/**      * Positive integer value that specifies the number of milliseconds the      * connector should wait during each iteration for new change events to appear.      * Defaults to 1000 milliseconds, or 1 second.      */
DECL|method|getPollIntervalMs ()
specifier|public
name|long
name|getPollIntervalMs
parameter_list|()
block|{
return|return
name|pollIntervalMs
return|;
block|}
DECL|method|setPollIntervalMs (long pollIntervalMs)
specifier|public
name|void
name|setPollIntervalMs
parameter_list|(
name|long
name|pollIntervalMs
parameter_list|)
block|{
name|this
operator|.
name|pollIntervalMs
operator|=
name|pollIntervalMs
expr_stmt|;
block|}
comment|/**      * A positive integer value that specifies the maximum time in milliseconds this      * connector should wait after trying to connect to the MySQL database server      * before timing out. Defaults to 30 seconds.      */
DECL|method|getConnectTimeoutMs ()
specifier|public
name|long
name|getConnectTimeoutMs
parameter_list|()
block|{
return|return
name|connectTimeoutMs
return|;
block|}
DECL|method|setConnectTimeoutMs (long connectTimeoutMs)
specifier|public
name|void
name|setConnectTimeoutMs
parameter_list|(
name|long
name|connectTimeoutMs
parameter_list|)
block|{
name|this
operator|.
name|connectTimeoutMs
operator|=
name|connectTimeoutMs
expr_stmt|;
block|}
comment|/**      * A comma-separated list of regular expressions that match source UUIDs in the      * GTID set used to find the binlog position in the MySQL server. Only the GTID      * ranges that have sources matching one of these include patterns will be used.      * May not be used with gtid.source.excludes.      */
DECL|method|getGtidSourceIncludes ()
specifier|public
name|String
name|getGtidSourceIncludes
parameter_list|()
block|{
return|return
name|gtidSourceIncludes
return|;
block|}
DECL|method|setGtidSourceIncludes (String gtidSourceIncludes)
specifier|public
name|void
name|setGtidSourceIncludes
parameter_list|(
name|String
name|gtidSourceIncludes
parameter_list|)
block|{
name|this
operator|.
name|gtidSourceIncludes
operator|=
name|gtidSourceIncludes
expr_stmt|;
block|}
comment|/**      * A comma-separated list of regular expressions that match source UUIDs in the      * GTID set used to find the binlog position in the MySQL server. Only the GTID      * ranges that have sources matching none of these exclude patterns will be      * used. May not be used with gtid.source.includes.      */
DECL|method|getGtidSourceExcludes ()
specifier|public
name|String
name|getGtidSourceExcludes
parameter_list|()
block|{
return|return
name|gtidSourceExcludes
return|;
block|}
DECL|method|setGtidSourceExcludes (String gtidSourceExcludes)
specifier|public
name|void
name|setGtidSourceExcludes
parameter_list|(
name|String
name|gtidSourceExcludes
parameter_list|)
block|{
name|this
operator|.
name|gtidSourceExcludes
operator|=
name|gtidSourceExcludes
expr_stmt|;
block|}
comment|/**      * When set to latest, when the connector sees a new GTID channel, it will start      * consuming from the last executed transaction in that GTID channel. If set to      * earliest, the connector starts reading that channel from the first available      * (not purged) GTID position. earliest is useful when you have a active-passive      * MySQL setup where Debezium is connected to master, in this case during      * failover the slave with new UUID (and GTID channel) starts receiving writes      * before Debezium is connected. These writes would be lost when using latest.      */
DECL|method|getGtidNewChannelPosition ()
specifier|public
name|String
name|getGtidNewChannelPosition
parameter_list|()
block|{
return|return
name|gtidNewChannelPosition
return|;
block|}
DECL|method|setGtidNewChannelPosition (String gtidNewChannelPosition)
specifier|public
name|void
name|setGtidNewChannelPosition
parameter_list|(
name|String
name|gtidNewChannelPosition
parameter_list|)
block|{
name|this
operator|.
name|gtidNewChannelPosition
operator|=
name|gtidNewChannelPosition
expr_stmt|;
block|}
comment|/**      * Controls whether a tombstone event should be generated after a delete event.      * When true the delete operations are represented by a delete event and a      * subsequent tombstone event. When false only a delete event is sent. Emitting      * the tombstone event (the default behavior) allows Kafka to completely delete      * all events pertaining to the given key once the source record got deleted.      */
DECL|method|isTombstonesOnDelete ()
specifier|public
name|boolean
name|isTombstonesOnDelete
parameter_list|()
block|{
return|return
name|tombstonesOnDelete
return|;
block|}
DECL|method|setTombstonesOnDelete (boolean tombstonesOnDelete)
specifier|public
name|void
name|setTombstonesOnDelete
parameter_list|(
name|boolean
name|tombstonesOnDelete
parameter_list|)
block|{
name|this
operator|.
name|tombstonesOnDelete
operator|=
name|tombstonesOnDelete
expr_stmt|;
block|}
comment|/**      * Controls which parser should be used for parsing DDL statements when building      * up the meta-model of the captured database structure. Can be one of legacy      * (for the legacy hand-written parser implementation) or antlr (for new Antlr      * based implementation introduced in Debezium 0.8.0). While the legacy parser      * remains the default for Debezium 0.8.x, please try out the new implementation      * and report back any issues you encounter. The new parser is the default as of      * 0.9. The legacy parser as well as this configuration property has been      * removed as of 0.10.      */
DECL|method|getDdlParserMode ()
specifier|public
name|String
name|getDdlParserMode
parameter_list|()
block|{
return|return
name|ddlParserMode
return|;
block|}
DECL|method|setDdlParserMode (String ddlParserMode)
specifier|public
name|void
name|setDdlParserMode
parameter_list|(
name|String
name|ddlParserMode
parameter_list|)
block|{
name|this
operator|.
name|ddlParserMode
operator|=
name|ddlParserMode
expr_stmt|;
block|}
block|}
end_class

end_unit

