begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.spring.xml
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spring
operator|.
name|xml
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Expression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|Fluent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|FluentArg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|RouteBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|ValueBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|springframework
operator|.
name|beans
operator|.
name|SimpleTypeConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|springframework
operator|.
name|beans
operator|.
name|factory
operator|.
name|config
operator|.
name|RuntimeBeanReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|springframework
operator|.
name|beans
operator|.
name|factory
operator|.
name|support
operator|.
name|AbstractBeanDefinition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|springframework
operator|.
name|beans
operator|.
name|factory
operator|.
name|support
operator|.
name|BeanDefinitionBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|springframework
operator|.
name|beans
operator|.
name|factory
operator|.
name|xml
operator|.
name|AbstractBeanDefinitionParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|springframework
operator|.
name|beans
operator|.
name|factory
operator|.
name|xml
operator|.
name|ParserContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|springframework
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|springframework
operator|.
name|util
operator|.
name|xml
operator|.
name|DomUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Attr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Element
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NamedNodeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Annotation
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_class
DECL|class|CamelBeanDefinitionParser
specifier|public
class|class
name|CamelBeanDefinitionParser
extends|extends
name|AbstractBeanDefinitionParser
block|{
DECL|field|namespaceHandler
specifier|private
specifier|final
name|CamelNamespaceHandler
name|namespaceHandler
decl_stmt|;
DECL|field|counter
specifier|private
name|int
name|counter
decl_stmt|;
DECL|method|CamelBeanDefinitionParser (CamelNamespaceHandler namespaceHandler)
specifier|public
name|CamelBeanDefinitionParser
parameter_list|(
name|CamelNamespaceHandler
name|namespaceHandler
parameter_list|)
block|{
name|this
operator|.
name|namespaceHandler
operator|=
name|namespaceHandler
expr_stmt|;
block|}
DECL|method|parseInternal (Element element, ParserContext parserContext)
specifier|protected
name|AbstractBeanDefinition
name|parseInternal
parameter_list|(
name|Element
name|element
parameter_list|,
name|ParserContext
name|parserContext
parameter_list|)
block|{
name|BeanDefinitionBuilder
name|factory
init|=
name|BeanDefinitionBuilder
operator|.
name|rootBeanDefinition
argument_list|(
name|RouteBuilderFactoryBean
operator|.
name|class
argument_list|)
decl_stmt|;
name|List
name|childElements
init|=
name|DomUtils
operator|.
name|getChildElementsByTagName
argument_list|(
name|element
argument_list|,
literal|"route"
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|BuilderStatement
argument_list|>
name|routes
init|=
operator|new
name|ArrayList
argument_list|<
name|BuilderStatement
argument_list|>
argument_list|(
name|childElements
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|childElements
operator|!=
literal|null
operator|&&
name|childElements
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childElements
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Element
name|routeElement
init|=
operator|(
name|Element
operator|)
name|childElements
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|BuilderAction
argument_list|>
name|actions
init|=
operator|new
name|ArrayList
argument_list|<
name|BuilderAction
argument_list|>
argument_list|()
decl_stmt|;
name|Class
name|type
init|=
name|parseBuilderElement
argument_list|(
name|parserContext
argument_list|,
name|routeElement
argument_list|,
name|RouteBuilder
operator|.
name|class
argument_list|,
name|actions
argument_list|)
decl_stmt|;
name|BuilderStatement
name|statement
init|=
operator|new
name|BuilderStatement
argument_list|()
decl_stmt|;
name|statement
operator|.
name|setReturnType
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|statement
operator|.
name|setActions
argument_list|(
name|actions
argument_list|)
expr_stmt|;
name|routes
operator|.
name|add
argument_list|(
name|statement
argument_list|)
expr_stmt|;
block|}
block|}
name|factory
operator|.
name|addPropertyValue
argument_list|(
literal|"routes"
argument_list|,
name|routes
argument_list|)
expr_stmt|;
return|return
name|factory
operator|.
name|getBeanDefinition
argument_list|()
return|;
block|}
comment|/**      * Use reflection to figure out what is the valid next element.      */
DECL|method|parseBuilderElement (ParserContext parserContext, Element element, Class<RouteBuilder> builder, ArrayList<BuilderAction> actions)
specifier|private
name|Class
name|parseBuilderElement
parameter_list|(
name|ParserContext
name|parserContext
parameter_list|,
name|Element
name|element
parameter_list|,
name|Class
argument_list|<
name|RouteBuilder
argument_list|>
name|builder
parameter_list|,
name|ArrayList
argument_list|<
name|BuilderAction
argument_list|>
name|actions
parameter_list|)
block|{
name|Class
name|currentBuilder
init|=
name|builder
decl_stmt|;
name|NodeList
name|childElements
init|=
name|element
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
name|Element
name|previousElement
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childElements
operator|.
name|getLength
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
name|node
init|=
name|childElements
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|currentBuilder
operator|=
name|parseAction
argument_list|(
name|parserContext
argument_list|,
name|currentBuilder
argument_list|,
name|actions
argument_list|,
operator|(
name|Element
operator|)
name|node
argument_list|,
name|previousElement
argument_list|)
expr_stmt|;
name|previousElement
operator|=
operator|(
name|Element
operator|)
name|node
expr_stmt|;
name|BuilderAction
name|action
init|=
name|actions
operator|.
name|get
argument_list|(
name|actions
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|action
operator|.
name|getMethodInfo
argument_list|()
operator|.
name|methodAnnotation
operator|.
name|nestedActions
argument_list|()
condition|)
block|{
name|currentBuilder
operator|=
name|parseBuilderElement
argument_list|(
name|parserContext
argument_list|,
operator|(
name|Element
operator|)
name|node
argument_list|,
name|currentBuilder
argument_list|,
name|actions
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Make sure the there are no child elements.
if|if
condition|(
name|hasChildElements
argument_list|(
name|node
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The element "
operator|+
name|node
operator|.
name|getLocalName
argument_list|()
operator|+
literal|" should not have any child elements."
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|// Add the builder actions that are annotated with @Fluent(callOnElementEnd=true)
if|if
condition|(
name|currentBuilder
operator|!=
literal|null
condition|)
block|{
name|Method
index|[]
name|methods
init|=
name|currentBuilder
operator|.
name|getMethods
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|methods
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Method
name|method
init|=
name|methods
index|[
name|i
index|]
decl_stmt|;
name|Fluent
name|annotation
init|=
name|method
operator|.
name|getAnnotation
argument_list|(
name|Fluent
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|annotation
operator|!=
literal|null
operator|&&
name|annotation
operator|.
name|callOnElementEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|method
operator|.
name|getParameterTypes
argument_list|()
operator|.
name|length
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Only methods with no parameters can annotated with @Fluent(callOnElementEnd=true): "
operator|+
name|method
argument_list|)
throw|;
block|}
name|MethodInfo
name|methodInfo
init|=
operator|new
name|MethodInfo
argument_list|(
name|method
argument_list|,
name|annotation
argument_list|,
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Class
argument_list|>
argument_list|()
argument_list|,
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|FluentArg
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
name|actions
operator|.
name|add
argument_list|(
operator|new
name|BuilderAction
argument_list|(
name|methodInfo
argument_list|,
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|currentBuilder
operator|=
name|method
operator|.
name|getReturnType
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
name|currentBuilder
return|;
block|}
DECL|method|hasChildElements (Node node)
specifier|private
name|boolean
name|hasChildElements
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
name|NodeList
name|nl
init|=
name|node
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|nl
operator|.
name|getLength
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|nl
operator|.
name|item
argument_list|(
name|j
argument_list|)
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|parseAction (ParserContext parserContext, Class currentBuilder, ArrayList<BuilderAction> actions, Element element, Element previousElement)
specifier|private
name|Class
name|parseAction
parameter_list|(
name|ParserContext
name|parserContext
parameter_list|,
name|Class
name|currentBuilder
parameter_list|,
name|ArrayList
argument_list|<
name|BuilderAction
argument_list|>
name|actions
parameter_list|,
name|Element
name|element
parameter_list|,
name|Element
name|previousElement
parameter_list|)
block|{
name|String
name|actionName
init|=
name|element
operator|.
name|getLocalName
argument_list|()
decl_stmt|;
comment|// Get a list of method names that match the action.
name|ArrayList
argument_list|<
name|MethodInfo
argument_list|>
name|methods
init|=
name|findFluentMethodsWithName
argument_list|(
name|currentBuilder
argument_list|,
name|element
operator|.
name|getLocalName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|methods
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalActionException
argument_list|(
name|actionName
argument_list|,
name|previousElement
operator|==
literal|null
condition|?
literal|null
else|:
name|previousElement
operator|.
name|getLocalName
argument_list|()
argument_list|)
throw|;
block|}
comment|// Pick the best method out of the list. Sort by argument length. Pick
comment|// first longest match.
name|Collections
operator|.
name|sort
argument_list|(
name|methods
argument_list|,
operator|new
name|Comparator
argument_list|<
name|MethodInfo
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|MethodInfo
name|m1
parameter_list|,
name|MethodInfo
name|m2
parameter_list|)
block|{
return|return
name|m1
operator|.
name|method
operator|.
name|getParameterTypes
argument_list|()
operator|.
name|length
operator|-
name|m2
operator|.
name|method
operator|.
name|getParameterTypes
argument_list|()
operator|.
name|length
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Build the possible list of arguments from the attributes and child
comment|// elements
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|attributeArguments
init|=
name|getArugmentsFromAttributes
argument_list|(
name|element
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|Element
argument_list|>
argument_list|>
name|elementArguments
init|=
name|getArgumentsFromElements
argument_list|(
name|element
argument_list|)
decl_stmt|;
comment|// Find the first method that we can supply arguments for.
name|MethodInfo
name|match
init|=
literal|null
decl_stmt|;
name|match
operator|=
name|findMethodMatch
argument_list|(
name|methods
argument_list|,
name|attributeArguments
operator|.
name|keySet
argument_list|()
argument_list|,
name|elementArguments
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalActionException
argument_list|(
name|actionName
argument_list|,
name|previousElement
operator|==
literal|null
condition|?
literal|null
else|:
name|previousElement
operator|.
name|getLocalName
argument_list|()
argument_list|)
throw|;
block|}
comment|// lets convert any references
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|attributeEntries
init|=
name|attributeArguments
operator|.
name|entrySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|attributeEntries
control|)
block|{
name|String
name|name
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|FluentArg
name|arg
init|=
name|match
operator|.
name|parameterAnnotations
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|!=
literal|null
operator|&&
operator|(
name|arg
operator|.
name|reference
argument_list|()
operator|||
name|name
operator|.
name|equals
argument_list|(
literal|"ref"
argument_list|)
operator|)
condition|)
block|{
name|Object
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
name|entry
operator|.
name|setValue
argument_list|(
operator|new
name|RuntimeBeanReference
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Move element arguments into the attributeArguments map if needed.
name|Set
argument_list|<
name|String
argument_list|>
name|parameterNames
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|match
operator|.
name|parameters
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|parameterNames
operator|.
name|removeAll
argument_list|(
name|attributeArguments
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|key
range|:
name|parameterNames
control|)
block|{
name|ArrayList
argument_list|<
name|Element
argument_list|>
name|elements
init|=
name|elementArguments
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|elements
operator|==
literal|null
condition|)
block|{
name|elements
operator|=
name|getFirstChildElements
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
name|Class
name|clazz
init|=
name|match
operator|.
name|parameters
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|Object
name|value
init|=
name|convertTo
argument_list|(
name|parserContext
argument_list|,
name|elements
argument_list|,
name|clazz
argument_list|)
decl_stmt|;
name|attributeArguments
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|Element
name|el
range|:
name|elements
control|)
block|{
comment|// remove the argument nodes so that they don't get interpreted as
comment|// actions.
name|el
operator|.
name|getParentNode
argument_list|()
operator|.
name|removeChild
argument_list|(
name|el
argument_list|)
expr_stmt|;
block|}
block|}
name|actions
operator|.
name|add
argument_list|(
operator|new
name|BuilderAction
argument_list|(
name|match
argument_list|,
name|attributeArguments
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|match
operator|.
name|method
operator|.
name|getReturnType
argument_list|()
return|;
block|}
DECL|method|getFirstChildElements (Element element)
specifier|private
name|ArrayList
argument_list|<
name|Element
argument_list|>
name|getFirstChildElements
parameter_list|(
name|Element
name|element
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|Element
argument_list|>
name|answer
init|=
operator|new
name|ArrayList
argument_list|<
name|Element
argument_list|>
argument_list|()
decl_stmt|;
name|NodeList
name|list
init|=
name|element
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|size
init|=
name|list
operator|.
name|getLength
argument_list|()
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|node
init|=
name|list
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|Element
condition|)
block|{
name|answer
operator|.
name|add
argument_list|(
operator|(
name|Element
operator|)
name|node
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|answer
return|;
block|}
DECL|method|convertTo (ParserContext parserContext, ArrayList<Element> elements, Class clazz)
specifier|private
name|Object
name|convertTo
parameter_list|(
name|ParserContext
name|parserContext
parameter_list|,
name|ArrayList
argument_list|<
name|Element
argument_list|>
name|elements
parameter_list|,
name|Class
name|clazz
parameter_list|)
block|{
if|if
condition|(
name|clazz
operator|.
name|isArray
argument_list|()
operator|||
name|elements
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|List
name|list
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|elements
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ArrayList
argument_list|<
name|Element
argument_list|>
name|e
init|=
operator|new
name|ArrayList
argument_list|<
name|Element
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|e
operator|.
name|add
argument_list|(
name|elements
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|Object
name|value
init|=
name|convertTo
argument_list|(
name|parserContext
argument_list|,
name|e
argument_list|,
name|clazz
operator|.
name|getComponentType
argument_list|()
argument_list|)
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
comment|/*             Object array = Array.newInstance(clazz.getComponentType(), elements.size()); 			for( int i=0; i< elements.size(); i ++ ) { 				ArrayList<Element> e = new ArrayList<Element>(1); 				e.add(elements.get(i)); 				Object value = convertTo(parserContext, e, clazz.getComponentType());                  Array.set(array, i, value); 			} 			return array; 			*/
block|}
else|else
block|{
name|Element
name|element
init|=
name|elements
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|ref
init|=
name|element
operator|.
name|getAttribute
argument_list|(
literal|"ref"
argument_list|)
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|hasText
argument_list|(
name|ref
argument_list|)
condition|)
block|{
return|return
operator|new
name|RuntimeBeanReference
argument_list|(
name|ref
argument_list|)
return|;
block|}
comment|// Use a builder to create the value..
if|if
condition|(
name|hasChildElements
argument_list|(
name|element
argument_list|)
condition|)
block|{
name|ArrayList
argument_list|<
name|BuilderAction
argument_list|>
name|actions
init|=
operator|new
name|ArrayList
argument_list|<
name|BuilderAction
argument_list|>
argument_list|()
decl_stmt|;
name|Class
name|type
init|=
name|parseBuilderElement
argument_list|(
name|parserContext
argument_list|,
name|element
argument_list|,
name|RouteBuilder
operator|.
name|class
argument_list|,
name|actions
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|ValueBuilder
operator|.
name|class
operator|&&
name|clazz
operator|==
name|Expression
operator|.
name|class
condition|)
block|{
name|Method
name|method
decl_stmt|;
try|try
block|{
name|method
operator|=
name|ValueBuilder
operator|.
name|class
operator|.
name|getMethod
argument_list|(
literal|"getExpression"
argument_list|,
operator|new
name|Class
index|[]
block|{}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ValueBuilder
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|" does not have the getExpression() method."
argument_list|)
throw|;
block|}
name|MethodInfo
name|methodInfo
init|=
operator|new
name|MethodInfo
argument_list|(
name|method
argument_list|,
literal|null
argument_list|,
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Class
argument_list|>
argument_list|()
argument_list|,
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|FluentArg
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
name|actions
operator|.
name|add
argument_list|(
operator|new
name|BuilderAction
argument_list|(
name|methodInfo
argument_list|,
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|Expression
operator|.
name|class
expr_stmt|;
block|}
name|BuilderStatement
name|statement
init|=
operator|new
name|BuilderStatement
argument_list|()
decl_stmt|;
name|statement
operator|.
name|setReturnType
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|statement
operator|.
name|setActions
argument_list|(
name|actions
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clazz
operator|.
name|isAssignableFrom
argument_list|(
name|statement
operator|.
name|getReturnType
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Builder does not produce object of expected type: "
operator|+
name|clazz
operator|.
name|getName
argument_list|()
operator|+
literal|", it produced: "
operator|+
name|statement
operator|.
name|getReturnType
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|statement
return|;
block|}
else|else
block|{
comment|// if we are on an element which has a custom parser, lets use that.
name|String
name|name
init|=
name|element
operator|.
name|getLocalName
argument_list|()
decl_stmt|;
if|if
condition|(
name|namespaceHandler
operator|.
name|getParserElementNames
argument_list|()
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|String
name|id
init|=
name|createBeanId
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|element
operator|.
name|setAttribute
argument_list|(
literal|"id"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|namespaceHandler
operator|.
name|parse
argument_list|(
name|element
argument_list|,
name|parserContext
argument_list|)
expr_stmt|;
return|return
operator|new
name|RuntimeBeanReference
argument_list|(
name|id
argument_list|)
return|;
block|}
comment|// Just use the text in the element as the value.
name|SimpleTypeConverter
name|converter
init|=
operator|new
name|SimpleTypeConverter
argument_list|()
decl_stmt|;
return|return
name|converter
operator|.
name|convertIfNecessary
argument_list|(
name|element
operator|.
name|getTextContent
argument_list|()
argument_list|,
name|clazz
argument_list|)
return|;
block|}
block|}
block|}
DECL|method|createBeanId (String name)
specifier|protected
specifier|synchronized
name|String
name|createBeanId
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
literal|"_internal:camel:bean:"
operator|+
name|name
operator|+
operator|(
operator|++
name|counter
operator|)
return|;
block|}
DECL|method|findMethodMatch (ArrayList<MethodInfo> methods, Set<String> attributeNames, Set<String> elementNames)
specifier|private
name|MethodInfo
name|findMethodMatch
parameter_list|(
name|ArrayList
argument_list|<
name|MethodInfo
argument_list|>
name|methods
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|attributeNames
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|elementNames
parameter_list|)
block|{
for|for
control|(
name|MethodInfo
name|method
range|:
name|methods
control|)
block|{
comment|// make sure all the given attribute parameters can be assigned via
comment|// attributes
name|boolean
name|miss
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|key
range|:
name|attributeNames
control|)
block|{
name|FluentArg
name|arg
init|=
name|method
operator|.
name|parameterAnnotations
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|null
operator|||
operator|!
name|arg
operator|.
name|attribute
argument_list|()
condition|)
block|{
name|miss
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|miss
condition|)
block|{
continue|continue;
comment|// Keep looking...
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|parameterNames
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|method
operator|.
name|parameters
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|parameterNames
operator|.
name|removeAll
argument_list|(
name|attributeNames
argument_list|)
expr_stmt|;
comment|// Bingo we found a match.
if|if
condition|(
name|parameterNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|method
return|;
block|}
comment|// We may still be able to match using elements as parameters.
comment|/*             for (String key : elementNames) { 				if (parameterNames.isEmpty()) { 					break; 				} 				// We only want to use the first child elements as arguments, 				// once we don't match, we can stop looking. 				FluentArg arg = method.parameterAnnotations.get(key); 				if (arg == null || !arg.element()) { 					break; 				} 				if (!parameterNames.remove(key)) { 					break; 				} 			}  			// All parameters found! We have a match! 			if (parameterNames.isEmpty()) { 				return method; 			} 			*/
return|return
name|method
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|getArgumentsFromElements (Element element)
specifier|private
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|Element
argument_list|>
argument_list|>
name|getArgumentsFromElements
parameter_list|(
name|Element
name|element
parameter_list|)
block|{
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|Element
argument_list|>
argument_list|>
name|elements
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|Element
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|NodeList
name|childNodes
init|=
name|element
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
name|String
name|lastTag
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childNodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|node
init|=
name|childNodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|Element
name|el
init|=
operator|(
name|Element
operator|)
name|node
decl_stmt|;
name|String
name|tag
init|=
name|el
operator|.
name|getLocalName
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|Element
argument_list|>
name|els
init|=
name|elements
operator|.
name|get
argument_list|(
name|tag
argument_list|)
decl_stmt|;
if|if
condition|(
name|els
operator|==
literal|null
condition|)
block|{
name|els
operator|=
operator|new
name|ArrayList
argument_list|<
name|Element
argument_list|>
argument_list|()
expr_stmt|;
name|elements
operator|.
name|put
argument_list|(
name|el
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|els
argument_list|)
expr_stmt|;
name|els
operator|.
name|add
argument_list|(
name|el
argument_list|)
expr_stmt|;
name|lastTag
operator|=
name|tag
expr_stmt|;
block|}
else|else
block|{
comment|// add to array if the elements are consecutive
if|if
condition|(
name|tag
operator|.
name|equals
argument_list|(
name|lastTag
argument_list|)
condition|)
block|{
name|els
operator|.
name|add
argument_list|(
name|el
argument_list|)
expr_stmt|;
name|lastTag
operator|=
name|tag
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|elements
return|;
block|}
DECL|method|getArugmentsFromAttributes (Element element)
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getArugmentsFromAttributes
parameter_list|(
name|Element
name|element
parameter_list|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|attributes
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|NamedNodeMap
name|childNodes
init|=
name|element
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childNodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|node
init|=
name|childNodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ATTRIBUTE_NODE
condition|)
block|{
name|Attr
name|attr
init|=
operator|(
name|Attr
operator|)
name|node
decl_stmt|;
name|String
name|str
init|=
name|attr
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Object
name|value
init|=
name|str
decl_stmt|;
comment|// If the value starts with # then it's a bean reference
if|if
condition|(
name|str
operator|.
name|startsWith
argument_list|(
literal|"#"
argument_list|)
condition|)
block|{
name|str
operator|=
name|str
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// Support using ## to escape the bean reference feature.
if|if
condition|(
operator|!
name|str
operator|.
name|startsWith
argument_list|(
literal|"#"
argument_list|)
condition|)
block|{
name|value
operator|=
operator|new
name|RuntimeBeanReference
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
name|attributes
operator|.
name|put
argument_list|(
name|attr
operator|.
name|getName
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|attributes
return|;
block|}
comment|/**      * Finds all the methods on the clazz that match the name and which have the      * {@see Fluent} annotation and whoes parameters have the {@see FluentArg}      * annotation.      *      * @param clazz      * @param name      * @return      */
DECL|method|findFluentMethodsWithName (Class clazz, String name)
specifier|private
name|ArrayList
argument_list|<
name|MethodInfo
argument_list|>
name|findFluentMethodsWithName
parameter_list|(
name|Class
name|clazz
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|MethodInfo
argument_list|>
name|rc
init|=
operator|new
name|ArrayList
argument_list|<
name|MethodInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Method
index|[]
name|methods
init|=
name|clazz
operator|.
name|getMethods
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|methods
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Method
name|method
init|=
name|methods
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|method
operator|.
name|isAnnotationPresent
argument_list|(
name|Fluent
operator|.
name|class
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// Use the fluent supplied name for the action, or the method name if not set.
name|Fluent
name|fluentAnnotation
init|=
name|method
operator|.
name|getAnnotation
argument_list|(
name|Fluent
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|hasText
argument_list|(
name|fluentAnnotation
operator|.
name|value
argument_list|()
argument_list|)
condition|?
name|name
operator|.
name|equals
argument_list|(
name|fluentAnnotation
operator|.
name|value
argument_list|()
argument_list|)
else|:
name|name
operator|.
name|equals
argument_list|(
name|method
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Class
argument_list|>
name|map
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Class
argument_list|>
argument_list|()
decl_stmt|;
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|FluentArg
argument_list|>
name|amap
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|FluentArg
argument_list|>
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|parameters
init|=
name|method
operator|.
name|getParameterTypes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|parameters
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|parameter
init|=
name|parameters
index|[
name|j
index|]
decl_stmt|;
name|FluentArg
name|annotation
init|=
name|getParameterAnnotation
argument_list|(
name|FluentArg
operator|.
name|class
argument_list|,
name|method
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|annotation
operator|!=
literal|null
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|annotation
operator|.
name|value
argument_list|()
argument_list|,
name|parameter
argument_list|)
expr_stmt|;
name|amap
operator|.
name|put
argument_list|(
name|annotation
operator|.
name|value
argument_list|()
argument_list|,
name|annotation
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
comment|// If all the parameters were annotated...
if|if
condition|(
name|parameters
operator|.
name|length
operator|==
name|map
operator|.
name|size
argument_list|()
condition|)
block|{
name|rc
operator|.
name|add
argument_list|(
operator|new
name|MethodInfo
argument_list|(
name|method
argument_list|,
name|fluentAnnotation
argument_list|,
name|map
argument_list|,
name|amap
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|rc
return|;
block|}
DECL|method|getParameterAnnotation (Class<T> annotationClass, Method method, int index)
specifier|private
parameter_list|<
name|T
parameter_list|>
name|T
name|getParameterAnnotation
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|annotationClass
parameter_list|,
name|Method
name|method
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|Annotation
index|[]
name|annotations
init|=
name|method
operator|.
name|getParameterAnnotations
argument_list|()
index|[
name|index
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|annotations
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|annotationClass
operator|.
name|isAssignableFrom
argument_list|(
name|annotations
index|[
name|i
index|]
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
return|return
operator|(
name|T
operator|)
name|annotations
index|[
name|i
index|]
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
end_class

end_unit

