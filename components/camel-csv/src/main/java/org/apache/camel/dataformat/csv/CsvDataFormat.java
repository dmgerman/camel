begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.dataformat.csv
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|dataformat
operator|.
name|csv
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|DataFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|DataFormatName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|annotations
operator|.
name|Dataformat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|service
operator|.
name|ServiceSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|csv
operator|.
name|CSVFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|csv
operator|.
name|QuoteMode
import|;
end_import

begin_comment
comment|/**  * CSV Data format.  *<p/>  * By default, columns are autogenerated in the resulting CSV. Subsequent  * messages use the previously created columns with new fields being added at  * the end of the line. Thus, field order is the same from message to message.  * Autogeneration can be disabled. In this case, only the fields defined in  * csvConfig are written on the output.  */
end_comment

begin_class
annotation|@
name|Dataformat
argument_list|(
literal|"csv"
argument_list|)
DECL|class|CsvDataFormat
specifier|public
class|class
name|CsvDataFormat
extends|extends
name|ServiceSupport
implements|implements
name|DataFormat
implements|,
name|DataFormatName
block|{
comment|// CSV format options
DECL|field|format
specifier|private
name|CSVFormat
name|format
init|=
name|CSVFormat
operator|.
name|DEFAULT
decl_stmt|;
DECL|field|commentMarkerDisabled
specifier|private
name|boolean
name|commentMarkerDisabled
decl_stmt|;
DECL|field|commentMarker
specifier|private
name|Character
name|commentMarker
decl_stmt|;
DECL|field|delimiter
specifier|private
name|Character
name|delimiter
decl_stmt|;
DECL|field|escapeDisabled
specifier|private
name|boolean
name|escapeDisabled
decl_stmt|;
DECL|field|escape
specifier|private
name|Character
name|escape
decl_stmt|;
DECL|field|headerDisabled
specifier|private
name|boolean
name|headerDisabled
decl_stmt|;
DECL|field|header
specifier|private
name|String
index|[]
name|header
decl_stmt|;
DECL|field|allowMissingColumnNames
specifier|private
name|Boolean
name|allowMissingColumnNames
decl_stmt|;
DECL|field|ignoreEmptyLines
specifier|private
name|Boolean
name|ignoreEmptyLines
decl_stmt|;
DECL|field|ignoreSurroundingSpaces
specifier|private
name|Boolean
name|ignoreSurroundingSpaces
decl_stmt|;
DECL|field|nullStringDisabled
specifier|private
name|boolean
name|nullStringDisabled
decl_stmt|;
DECL|field|nullString
specifier|private
name|String
name|nullString
decl_stmt|;
DECL|field|quoteDisabled
specifier|private
name|boolean
name|quoteDisabled
decl_stmt|;
DECL|field|quote
specifier|private
name|Character
name|quote
decl_stmt|;
DECL|field|quoteMode
specifier|private
name|QuoteMode
name|quoteMode
decl_stmt|;
DECL|field|recordSeparatorDisabled
specifier|private
name|boolean
name|recordSeparatorDisabled
decl_stmt|;
DECL|field|recordSeparator
specifier|private
name|String
name|recordSeparator
decl_stmt|;
DECL|field|skipHeaderRecord
specifier|private
name|Boolean
name|skipHeaderRecord
decl_stmt|;
DECL|field|trim
specifier|private
name|Boolean
name|trim
decl_stmt|;
DECL|field|ignoreHeaderCase
specifier|private
name|Boolean
name|ignoreHeaderCase
decl_stmt|;
DECL|field|trailingDelimiter
specifier|private
name|Boolean
name|trailingDelimiter
decl_stmt|;
comment|// Unmarshal options
DECL|field|lazyLoad
specifier|private
name|boolean
name|lazyLoad
decl_stmt|;
DECL|field|useMaps
specifier|private
name|boolean
name|useMaps
decl_stmt|;
DECL|field|useOrderedMaps
specifier|private
name|boolean
name|useOrderedMaps
decl_stmt|;
DECL|field|recordConverter
specifier|private
name|CsvRecordConverter
argument_list|<
name|?
argument_list|>
name|recordConverter
decl_stmt|;
DECL|field|marshallerFactory
specifier|private
name|CsvMarshallerFactory
name|marshallerFactory
init|=
name|CsvMarshallerFactory
operator|.
name|DEFAULT
decl_stmt|;
DECL|field|marshaller
specifier|private
specifier|volatile
name|CsvMarshaller
name|marshaller
decl_stmt|;
DECL|field|unmarshaller
specifier|private
specifier|volatile
name|CsvUnmarshaller
name|unmarshaller
decl_stmt|;
DECL|method|CsvDataFormat ()
specifier|public
name|CsvDataFormat
parameter_list|()
block|{     }
DECL|method|CsvDataFormat (CSVFormat format)
specifier|public
name|CsvDataFormat
parameter_list|(
name|CSVFormat
name|format
parameter_list|)
block|{
name|setFormat
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getDataFormatName ()
specifier|public
name|String
name|getDataFormatName
parameter_list|()
block|{
return|return
literal|"csv"
return|;
block|}
annotation|@
name|Override
DECL|method|marshal (Exchange exchange, Object object, OutputStream outputStream)
specifier|public
name|void
name|marshal
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|object
parameter_list|,
name|OutputStream
name|outputStream
parameter_list|)
throws|throws
name|Exception
block|{
name|marshaller
operator|.
name|marshal
argument_list|(
name|exchange
argument_list|,
name|object
argument_list|,
name|outputStream
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|unmarshal (Exchange exchange, InputStream inputStream)
specifier|public
name|Object
name|unmarshal
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|InputStream
name|inputStream
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|unmarshaller
operator|.
name|unmarshal
argument_list|(
name|exchange
argument_list|,
name|inputStream
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|doStart ()
specifier|protected
name|void
name|doStart
parameter_list|()
throws|throws
name|Exception
block|{
name|marshaller
operator|=
name|marshallerFactory
operator|.
name|create
argument_list|(
name|getActiveFormat
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|unmarshaller
operator|=
name|CsvUnmarshaller
operator|.
name|create
argument_list|(
name|getActiveFormat
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStop ()
specifier|protected
name|void
name|doStop
parameter_list|()
throws|throws
name|Exception
block|{
comment|// noop
block|}
DECL|method|getActiveFormat ()
name|CSVFormat
name|getActiveFormat
parameter_list|()
block|{
name|CSVFormat
name|answer
init|=
name|format
decl_stmt|;
if|if
condition|(
name|commentMarkerDisabled
condition|)
block|{
name|answer
operator|=
name|answer
operator|.
name|withCommentMarker
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// null disables the comment marker
block|}
elseif|else
if|if
condition|(
name|commentMarker
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|answer
operator|.
name|withCommentMarker
argument_list|(
name|commentMarker
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|delimiter
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|answer
operator|.
name|withDelimiter
argument_list|(
name|delimiter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|escapeDisabled
condition|)
block|{
name|answer
operator|=
name|answer
operator|.
name|withEscape
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// null disables the escape
block|}
elseif|else
if|if
condition|(
name|escape
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|answer
operator|.
name|withEscape
argument_list|(
name|escape
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|headerDisabled
condition|)
block|{
name|answer
operator|=
name|answer
operator|.
name|withHeader
argument_list|(
operator|(
name|String
index|[]
operator|)
literal|null
argument_list|)
expr_stmt|;
comment|// null disables the header
block|}
elseif|else
if|if
condition|(
name|header
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|answer
operator|.
name|withHeader
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|allowMissingColumnNames
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|answer
operator|.
name|withAllowMissingColumnNames
argument_list|(
name|allowMissingColumnNames
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ignoreEmptyLines
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|answer
operator|.
name|withIgnoreEmptyLines
argument_list|(
name|ignoreEmptyLines
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ignoreSurroundingSpaces
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|answer
operator|.
name|withIgnoreSurroundingSpaces
argument_list|(
name|ignoreSurroundingSpaces
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nullStringDisabled
condition|)
block|{
name|answer
operator|=
name|answer
operator|.
name|withNullString
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// null disables the null string replacement
block|}
elseif|else
if|if
condition|(
name|nullString
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|answer
operator|.
name|withNullString
argument_list|(
name|nullString
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|quoteDisabled
condition|)
block|{
name|answer
operator|=
name|answer
operator|.
name|withQuote
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// null disables quotes
block|}
elseif|else
if|if
condition|(
name|quote
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|answer
operator|.
name|withQuote
argument_list|(
name|quote
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|quoteMode
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|answer
operator|.
name|withQuoteMode
argument_list|(
name|quoteMode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recordSeparatorDisabled
condition|)
block|{
name|answer
operator|=
name|answer
operator|.
name|withRecordSeparator
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// null disables the record separator
block|}
elseif|else
if|if
condition|(
name|recordSeparator
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|answer
operator|.
name|withRecordSeparator
argument_list|(
name|recordSeparator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|skipHeaderRecord
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|answer
operator|.
name|withSkipHeaderRecord
argument_list|(
name|skipHeaderRecord
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trim
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|answer
operator|.
name|withTrim
argument_list|(
name|trim
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ignoreHeaderCase
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|answer
operator|.
name|withIgnoreHeaderCase
argument_list|(
name|ignoreHeaderCase
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trailingDelimiter
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|answer
operator|.
name|withTrailingDelimiter
argument_list|(
name|trailingDelimiter
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
comment|//region Getters/Setters
comment|/**      * Gets the CSV format before applying any changes.      * It cannot be {@code null}, the default one is {@link org.apache.commons.csv.CSVFormat#DEFAULT}.      *      * @return CSV format      */
DECL|method|getFormat ()
specifier|public
name|CSVFormat
name|getFormat
parameter_list|()
block|{
return|return
name|format
return|;
block|}
comment|/**      * Sets the CSV format before applying any changes.      * If {@code null}, then {@link org.apache.commons.csv.CSVFormat#DEFAULT} is used instead.      *      * @param format CSV format      * @return Current {@code CsvDataFormat}, fluent API      * @see org.apache.commons.csv.CSVFormat      * @see org.apache.commons.csv.CSVFormat#DEFAULT      */
DECL|method|setFormat (CSVFormat format)
specifier|public
name|CsvDataFormat
name|setFormat
parameter_list|(
name|CSVFormat
name|format
parameter_list|)
block|{
name|this
operator|.
name|format
operator|=
operator|(
name|format
operator|==
literal|null
operator|)
condition|?
name|CSVFormat
operator|.
name|DEFAULT
else|:
name|format
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets the {@link CsvMarshaller} factory.      * If {@code null}, then {@link CsvMarshallerFactory#DEFAULT} is used instead.      *      * @param marshallerFactory      * @return Current {@code CsvDataFormat}, fluent API      */
DECL|method|setMarshallerFactory (CsvMarshallerFactory marshallerFactory)
specifier|public
name|CsvDataFormat
name|setMarshallerFactory
parameter_list|(
name|CsvMarshallerFactory
name|marshallerFactory
parameter_list|)
block|{
name|this
operator|.
name|marshallerFactory
operator|=
operator|(
name|marshallerFactory
operator|==
literal|null
operator|)
condition|?
name|CsvMarshallerFactory
operator|.
name|DEFAULT
else|:
name|marshallerFactory
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Returns the used {@link CsvMarshallerFactory}.      *      * @return never {@code null}.      */
DECL|method|getMarshallerFactory ()
specifier|public
name|CsvMarshallerFactory
name|getMarshallerFactory
parameter_list|()
block|{
return|return
name|marshallerFactory
return|;
block|}
comment|/**      * Sets the CSV format by name before applying any changes.      *      * @param name CSV format name      * @return Current {@code CsvDataFormat}, fluent API      * @see #setFormat(org.apache.commons.csv.CSVFormat)      * @see org.apache.commons.csv.CSVFormat      */
DECL|method|setFormatName (String name)
specifier|public
name|CsvDataFormat
name|setFormatName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
name|setFormat
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"DEFAULT"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|setFormat
argument_list|(
name|CSVFormat
operator|.
name|DEFAULT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"RFC4180"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|setFormat
argument_list|(
name|CSVFormat
operator|.
name|RFC4180
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"EXCEL"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|setFormat
argument_list|(
name|CSVFormat
operator|.
name|EXCEL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"TDF"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|setFormat
argument_list|(
name|CSVFormat
operator|.
name|TDF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"MYSQL"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|setFormat
argument_list|(
name|CSVFormat
operator|.
name|MYSQL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unsupported format"
argument_list|)
throw|;
block|}
return|return
name|this
return|;
block|}
comment|/**      * Indicates whether or not the comment markers are disabled.      *      * @return {@code true} if the comment markers are disabled, {@code false} otherwise      */
DECL|method|isCommentMarkerDisabled ()
specifier|public
name|boolean
name|isCommentMarkerDisabled
parameter_list|()
block|{
return|return
name|commentMarkerDisabled
return|;
block|}
comment|/**      * Sets whether or not the comment markers are disabled.      *      * @param commentMarkerDisabled {@code true} if the comment markers are disabled, {@code false} otherwise      * @return Current {@code CsvDataFormat}, fluent API      * @see org.apache.commons.csv.CSVFormat#withCommentMarker(java.lang.Character)      */
DECL|method|setCommentMarkerDisabled (boolean commentMarkerDisabled)
specifier|public
name|CsvDataFormat
name|setCommentMarkerDisabled
parameter_list|(
name|boolean
name|commentMarkerDisabled
parameter_list|)
block|{
name|this
operator|.
name|commentMarkerDisabled
operator|=
name|commentMarkerDisabled
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Gets the comment marker.      * If {@code null} then the default one of the format used.      *      * @return Comment marker      */
DECL|method|getCommentMarker ()
specifier|public
name|Character
name|getCommentMarker
parameter_list|()
block|{
return|return
name|commentMarker
return|;
block|}
comment|/**      * Sets the comment marker to use.      * If {@code null} then the default one of the format used.      *      * @param commentMarker Comment marker      * @return Current {@code CsvDataFormat}, fluent API      * @see org.apache.commons.csv.CSVFormat#withCommentMarker(Character)      */
DECL|method|setCommentMarker (Character commentMarker)
specifier|public
name|CsvDataFormat
name|setCommentMarker
parameter_list|(
name|Character
name|commentMarker
parameter_list|)
block|{
name|this
operator|.
name|commentMarker
operator|=
name|commentMarker
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Gets the delimiter.      * If {@code null} then the default one of the format used.      *      * @return Delimiter      */
DECL|method|getDelimiter ()
specifier|public
name|Character
name|getDelimiter
parameter_list|()
block|{
return|return
name|delimiter
return|;
block|}
comment|/**      * Sets the delimiter.      * If {@code null} then the default one of the format used.      *      * @param delimiter Delimiter      * @return Current {@code CsvDataFormat}, fluent API      * @see org.apache.commons.csv.CSVFormat#withDelimiter(char)      */
DECL|method|setDelimiter (Character delimiter)
specifier|public
name|CsvDataFormat
name|setDelimiter
parameter_list|(
name|Character
name|delimiter
parameter_list|)
block|{
name|this
operator|.
name|delimiter
operator|=
name|delimiter
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Indicates whether or not the escaping is disabled.      *      * @return {@code true} if the escaping is disabled, {@code false} otherwise      */
DECL|method|isEscapeDisabled ()
specifier|public
name|boolean
name|isEscapeDisabled
parameter_list|()
block|{
return|return
name|escapeDisabled
return|;
block|}
comment|/**      * Sets whether or not the escaping is disabled.      *      * @param escapeDisabled {@code true} if the escaping is disabled, {@code false} otherwise      * @return Current {@code CsvDataFormat}, fluent API      * @see org.apache.commons.csv.CSVFormat#withEscape(Character)      */
DECL|method|setEscapeDisabled (boolean escapeDisabled)
specifier|public
name|CsvDataFormat
name|setEscapeDisabled
parameter_list|(
name|boolean
name|escapeDisabled
parameter_list|)
block|{
name|this
operator|.
name|escapeDisabled
operator|=
name|escapeDisabled
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Gets the escape character.      * If {@code null} then the default one of the format used.      *      * @return Escape character      */
DECL|method|getEscape ()
specifier|public
name|Character
name|getEscape
parameter_list|()
block|{
return|return
name|escape
return|;
block|}
comment|/**      * Sets the escape character.      * If {@code null} then the default one of the format used.      *      * @param escape Escape character      * @return Current {@code CsvDataFormat}, fluent API      * @see org.apache.commons.csv.CSVFormat#withEscape(Character)      */
DECL|method|setEscape (Character escape)
specifier|public
name|CsvDataFormat
name|setEscape
parameter_list|(
name|Character
name|escape
parameter_list|)
block|{
name|this
operator|.
name|escape
operator|=
name|escape
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Indicates whether or not the headers are disabled.      *      * @return {@code true} if the headers are disabled, {@code false} otherwise      */
DECL|method|isHeaderDisabled ()
specifier|public
name|boolean
name|isHeaderDisabled
parameter_list|()
block|{
return|return
name|headerDisabled
return|;
block|}
comment|/**      * Sets whether or not the headers are disabled.      *      * @param headerDisabled {@code true} if the headers are disabled, {@code false} otherwise      * @return Current {@code CsvDataFormat}, fluent API      * @see org.apache.commons.csv.CSVFormat#withHeader(String...)      */
DECL|method|setHeaderDisabled (boolean headerDisabled)
specifier|public
name|CsvDataFormat
name|setHeaderDisabled
parameter_list|(
name|boolean
name|headerDisabled
parameter_list|)
block|{
name|this
operator|.
name|headerDisabled
operator|=
name|headerDisabled
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Gets the header.      * If {@code null} then the default one of the format used. If empty then it will be automatically handled.      *      * @return Header      */
DECL|method|getHeader ()
specifier|public
name|String
index|[]
name|getHeader
parameter_list|()
block|{
return|return
name|header
return|;
block|}
comment|/**      * Gets the header.      * If {@code null} then the default one of the format used. If empty then it will be automatically handled.      *      * @param header Header      * @return Current {@code CsvDataFormat}, fluent API      * @see org.apache.commons.csv.CSVFormat#withHeader(String...)      */
DECL|method|setHeader (String[] header)
specifier|public
name|CsvDataFormat
name|setHeader
parameter_list|(
name|String
index|[]
name|header
parameter_list|)
block|{
name|this
operator|.
name|header
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|header
argument_list|,
name|header
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Indicates whether or not missing column names are allowed.      * If {@code null} then the default value of the format used.      *      * @return Whether or not missing column names are allowed      */
DECL|method|getAllowMissingColumnNames ()
specifier|public
name|Boolean
name|getAllowMissingColumnNames
parameter_list|()
block|{
return|return
name|allowMissingColumnNames
return|;
block|}
comment|/**      * Sets whether or not missing column names are allowed.      * If {@code null} then the default value of the format used.      *      * @param allowMissingColumnNames Whether or not missing column names are allowed      * @return Current {@code CsvDataFormat}, fluent API      * @see org.apache.commons.csv.CSVFormat#withAllowMissingColumnNames(boolean)      */
DECL|method|setAllowMissingColumnNames (Boolean allowMissingColumnNames)
specifier|public
name|CsvDataFormat
name|setAllowMissingColumnNames
parameter_list|(
name|Boolean
name|allowMissingColumnNames
parameter_list|)
block|{
name|this
operator|.
name|allowMissingColumnNames
operator|=
name|allowMissingColumnNames
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Indicates whether or not empty lines must be ignored.      * If {@code null} then the default value of the format used.      *      * @return Whether or not empty lines must be ignored      */
DECL|method|getIgnoreEmptyLines ()
specifier|public
name|Boolean
name|getIgnoreEmptyLines
parameter_list|()
block|{
return|return
name|ignoreEmptyLines
return|;
block|}
comment|/**      * Sets whether or not empty lines must be ignored.      * If {@code null} then the default value of the format used.      *      * @param ignoreEmptyLines Whether or not empty lines must be ignored      * @return Current {@code CsvDataFormat}, fluent API      * @see org.apache.commons.csv.CSVFormat#withIgnoreEmptyLines(boolean)      */
DECL|method|setIgnoreEmptyLines (Boolean ignoreEmptyLines)
specifier|public
name|CsvDataFormat
name|setIgnoreEmptyLines
parameter_list|(
name|Boolean
name|ignoreEmptyLines
parameter_list|)
block|{
name|this
operator|.
name|ignoreEmptyLines
operator|=
name|ignoreEmptyLines
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Indicates whether or not surrounding spaces must be ignored.      * If {@code null} then the default value of the format used.      *      * @return Whether or not surrounding spaces must be ignored      */
DECL|method|getIgnoreSurroundingSpaces ()
specifier|public
name|Boolean
name|getIgnoreSurroundingSpaces
parameter_list|()
block|{
return|return
name|ignoreSurroundingSpaces
return|;
block|}
comment|/**      * Sets whether or not surrounding spaces must be ignored.      * If {@code null} then the default value of the format used.      *      * @param ignoreSurroundingSpaces Whether or not surrounding spaces must be ignored      * @return Current {@code CsvDataFormat}, fluent API      * @see org.apache.commons.csv.CSVFormat#withIgnoreSurroundingSpaces(boolean)      */
DECL|method|setIgnoreSurroundingSpaces (Boolean ignoreSurroundingSpaces)
specifier|public
name|CsvDataFormat
name|setIgnoreSurroundingSpaces
parameter_list|(
name|Boolean
name|ignoreSurroundingSpaces
parameter_list|)
block|{
name|this
operator|.
name|ignoreSurroundingSpaces
operator|=
name|ignoreSurroundingSpaces
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Indicates whether or not the null string replacement is disabled.      *      * @return {@code true} if the null string replacement is disabled, {@code false} otherwise      */
DECL|method|isNullStringDisabled ()
specifier|public
name|boolean
name|isNullStringDisabled
parameter_list|()
block|{
return|return
name|nullStringDisabled
return|;
block|}
comment|/**      * Sets whether or not the null string replacement is disabled.      *      * @param nullStringDisabled {@code true} if the null string replacement is disabled, {@code false} otherwise      * @return Current {@code CsvDataFormat}, fluent API      * @see org.apache.commons.csv.CSVFormat#withNullString(String)      */
DECL|method|setNullStringDisabled (boolean nullStringDisabled)
specifier|public
name|CsvDataFormat
name|setNullStringDisabled
parameter_list|(
name|boolean
name|nullStringDisabled
parameter_list|)
block|{
name|this
operator|.
name|nullStringDisabled
operator|=
name|nullStringDisabled
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Gets the null string replacement.      * If {@code null} then the default one of the format used.      *      * @return Null string replacement      */
DECL|method|getNullString ()
specifier|public
name|String
name|getNullString
parameter_list|()
block|{
return|return
name|nullString
return|;
block|}
comment|/**      * Sets the null string replacement.      * If {@code null} then the default one of the format used.      *      * @param nullString Null string replacement      * @return Current {@code CsvDataFormat}, fluent API      * @see org.apache.commons.csv.CSVFormat#withNullString(String)      */
DECL|method|setNullString (String nullString)
specifier|public
name|CsvDataFormat
name|setNullString
parameter_list|(
name|String
name|nullString
parameter_list|)
block|{
name|this
operator|.
name|nullString
operator|=
name|nullString
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Indicates whether or not quotes are disabled.      *      * @return {@code true} if quotes are disabled, {@code false} otherwise      */
DECL|method|isQuoteDisabled ()
specifier|public
name|boolean
name|isQuoteDisabled
parameter_list|()
block|{
return|return
name|quoteDisabled
return|;
block|}
comment|/**      * Sets whether or not quotes are disabled      *      * @param quoteDisabled {@code true} if quotes are disabled, {@code false} otherwise      * @return Current {@code CsvDataFormat}, fluent API      * @see org.apache.commons.csv.CSVFormat#withQuote(Character)      */
DECL|method|setQuoteDisabled (boolean quoteDisabled)
specifier|public
name|CsvDataFormat
name|setQuoteDisabled
parameter_list|(
name|boolean
name|quoteDisabled
parameter_list|)
block|{
name|this
operator|.
name|quoteDisabled
operator|=
name|quoteDisabled
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Gets the quote character.      * If {@code null} then the default one of the format used.      *      * @return Quote character      */
DECL|method|getQuote ()
specifier|public
name|Character
name|getQuote
parameter_list|()
block|{
return|return
name|quote
return|;
block|}
comment|/**      * Sets the quote character.      * If {@code null} then the default one of the format used.      *      * @param quote Quote character      * @return Current {@code CsvDataFormat}, fluent API      * @see org.apache.commons.csv.CSVFormat#withQuote(Character)      */
DECL|method|setQuote (Character quote)
specifier|public
name|CsvDataFormat
name|setQuote
parameter_list|(
name|Character
name|quote
parameter_list|)
block|{
name|this
operator|.
name|quote
operator|=
name|quote
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Gets the quote mode.      * If {@code null} then the default one of the format used.      *      * @return Quote mode      */
DECL|method|getQuoteMode ()
specifier|public
name|QuoteMode
name|getQuoteMode
parameter_list|()
block|{
return|return
name|quoteMode
return|;
block|}
comment|/**      * Sets the quote mode.      * If {@code null} then the default one of the format used.      *      * @param quoteMode Quote mode      * @return Current {@code CsvDataFormat}, fluent API      * @see org.apache.commons.csv.CSVFormat#withQuoteMode(org.apache.commons.csv.QuoteMode)      */
DECL|method|setQuoteMode (QuoteMode quoteMode)
specifier|public
name|CsvDataFormat
name|setQuoteMode
parameter_list|(
name|QuoteMode
name|quoteMode
parameter_list|)
block|{
name|this
operator|.
name|quoteMode
operator|=
name|quoteMode
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Indicates whether or not the record separator is disabled.      *      * @return {@code true} if the record separator disabled, {@code false} otherwise      */
DECL|method|isRecordSeparatorDisabled ()
specifier|public
name|boolean
name|isRecordSeparatorDisabled
parameter_list|()
block|{
return|return
name|recordSeparatorDisabled
return|;
block|}
comment|/**      * Sets whether or not the record separator is disabled.      *      * @param recordSeparatorDisabled {@code true} if the record separator disabled, {@code false} otherwise      * @return Current {@code CsvDataFormat}, fluent API      * @see org.apache.commons.csv.CSVFormat#withRecordSeparator(String)      */
DECL|method|setRecordSeparatorDisabled (boolean recordSeparatorDisabled)
specifier|public
name|CsvDataFormat
name|setRecordSeparatorDisabled
parameter_list|(
name|boolean
name|recordSeparatorDisabled
parameter_list|)
block|{
name|this
operator|.
name|recordSeparatorDisabled
operator|=
name|recordSeparatorDisabled
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Gets the record separator.      * If {@code null} then the default one of the format used.      *      * @return Record separator      */
DECL|method|getRecordSeparator ()
specifier|public
name|String
name|getRecordSeparator
parameter_list|()
block|{
return|return
name|recordSeparator
return|;
block|}
comment|/**      * Sets the record separator.      * If {@code null} then the default one of the format used.      *      * @param recordSeparator Record separator      * @return Current {@code CsvDataFormat}, fluent API      * @see org.apache.commons.csv.CSVFormat#withRecordSeparator(String)      */
DECL|method|setRecordSeparator (String recordSeparator)
specifier|public
name|CsvDataFormat
name|setRecordSeparator
parameter_list|(
name|String
name|recordSeparator
parameter_list|)
block|{
name|this
operator|.
name|recordSeparator
operator|=
name|recordSeparator
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Indicates whether or not header record must be skipped.      * If {@code null} then the default value of the format used.      *      * @return Whether or not header record must be skipped      */
DECL|method|getSkipHeaderRecord ()
specifier|public
name|Boolean
name|getSkipHeaderRecord
parameter_list|()
block|{
return|return
name|skipHeaderRecord
return|;
block|}
comment|/**      * Sets whether or not header record must be skipped.      * If {@code null} then the default value of the format used.      *      * @param skipHeaderRecord Whether or not header record must be skipped      * @return Current {@code CsvDataFormat}, fluent API      * @see org.apache.commons.csv.CSVFormat#withSkipHeaderRecord(boolean)      */
DECL|method|setSkipHeaderRecord (Boolean skipHeaderRecord)
specifier|public
name|CsvDataFormat
name|setSkipHeaderRecord
parameter_list|(
name|Boolean
name|skipHeaderRecord
parameter_list|)
block|{
name|this
operator|.
name|skipHeaderRecord
operator|=
name|skipHeaderRecord
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Indicates whether or not the unmarshalling should lazily load the records.      *      * @return {@code true} for lazy loading, {@code false} otherwise      */
DECL|method|isLazyLoad ()
specifier|public
name|boolean
name|isLazyLoad
parameter_list|()
block|{
return|return
name|lazyLoad
return|;
block|}
comment|/**      * Indicates whether or not the unmarshalling should lazily load the records.      *      * @param lazyLoad {@code true} for lazy loading, {@code false} otherwise      * @return Current {@code CsvDataFormat}, fluent API      */
DECL|method|setLazyLoad (boolean lazyLoad)
specifier|public
name|CsvDataFormat
name|setLazyLoad
parameter_list|(
name|boolean
name|lazyLoad
parameter_list|)
block|{
name|this
operator|.
name|lazyLoad
operator|=
name|lazyLoad
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Indicates whether or not the unmarshalling should produce maps instead of lists.      *      * @return {@code true} for maps, {@code false} for lists      */
DECL|method|isUseMaps ()
specifier|public
name|boolean
name|isUseMaps
parameter_list|()
block|{
return|return
name|useMaps
return|;
block|}
comment|/**      * Sets whether or not the unmarshalling should produce maps instead of lists.      *      * @param useMaps {@code true} for maps, {@code false} for lists      * @return Current {@code CsvDataFormat}, fluent API      */
DECL|method|setUseMaps (boolean useMaps)
specifier|public
name|CsvDataFormat
name|setUseMaps
parameter_list|(
name|boolean
name|useMaps
parameter_list|)
block|{
name|this
operator|.
name|useMaps
operator|=
name|useMaps
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Indicates whether or not the unmarshalling should produce ordered maps instead of lists.      *      * @return {@code true} for maps, {@code false} for lists      */
DECL|method|isUseOrderedMaps ()
specifier|public
name|boolean
name|isUseOrderedMaps
parameter_list|()
block|{
return|return
name|useOrderedMaps
return|;
block|}
comment|/**      * Sets whether or not the unmarshalling should produce ordered maps instead of lists.      *      * @param useOrderedMaps {@code true} for maps, {@code false} for lists      * @return Current {@code CsvDataFormat}, fluent API      */
DECL|method|setUseOrderedMaps (boolean useOrderedMaps)
specifier|public
name|CsvDataFormat
name|setUseOrderedMaps
parameter_list|(
name|boolean
name|useOrderedMaps
parameter_list|)
block|{
name|this
operator|.
name|useOrderedMaps
operator|=
name|useOrderedMaps
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Gets the record converter to use. If {@code null} then it will use {@link CsvDataFormat#isUseMaps()} for finding      * the proper converter.      *      * @return Record converter to use      */
DECL|method|getRecordConverter ()
specifier|public
name|CsvRecordConverter
argument_list|<
name|?
argument_list|>
name|getRecordConverter
parameter_list|()
block|{
return|return
name|recordConverter
return|;
block|}
comment|/**      * Sets the record converter to use. If {@code null} then it will use {@link CsvDataFormat#isUseMaps()} for finding      * the proper converter.      *      * @param recordConverter Record converter to use      * @return Current {@code CsvDataFormat}, fluent API      */
DECL|method|setRecordConverter (CsvRecordConverter<?> recordConverter)
specifier|public
name|CsvDataFormat
name|setRecordConverter
parameter_list|(
name|CsvRecordConverter
argument_list|<
name|?
argument_list|>
name|recordConverter
parameter_list|)
block|{
name|this
operator|.
name|recordConverter
operator|=
name|recordConverter
expr_stmt|;
return|return
name|this
return|;
block|}
comment|//endregion
comment|/**      * Sets whether or not to trim leading and trailing blanks.      *<p>      * If {@code null} then the default value of the format used.      *</p>      *       * @param trim whether or not to trim leading and trailing blanks.      *<code>null</code> value allowed.      * @return Current {@code CsvDataFormat}, fluent API.      */
DECL|method|setTrim (Boolean trim)
specifier|public
name|CsvDataFormat
name|setTrim
parameter_list|(
name|Boolean
name|trim
parameter_list|)
block|{
name|this
operator|.
name|trim
operator|=
name|trim
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Indicates whether or not to trim leading and trailing blanks.      *       * @return {@link Boolean#TRUE} if leading and trailing blanks should be      *         trimmed. {@link Boolean#FALSE} otherwise. Could return      *<code>null</code> if value has NOT been set.      */
DECL|method|getTrim ()
specifier|public
name|Boolean
name|getTrim
parameter_list|()
block|{
return|return
name|trim
return|;
block|}
comment|/**      * Sets whether or not to ignore case when accessing header names.      *<p>      * If {@code null} then the default value of the format used.      *</p>      *       * @param ignoreHeaderCase whether or not to ignore case when accessing header names.      *<code>null</code> value allowed.      * @return Current {@code CsvDataFormat}, fluent API.      */
DECL|method|setIgnoreHeaderCase (Boolean ignoreHeaderCase)
specifier|public
name|CsvDataFormat
name|setIgnoreHeaderCase
parameter_list|(
name|Boolean
name|ignoreHeaderCase
parameter_list|)
block|{
name|this
operator|.
name|ignoreHeaderCase
operator|=
name|ignoreHeaderCase
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Indicates whether or not to ignore case when accessing header names.      *       * @return {@link Boolean#TRUE} if case should be ignored when accessing      *         header name. {@link Boolean#FALSE} otherwise. Could return      *<code>null</code> if value has NOT been set.      */
DECL|method|getIgnoreHeaderCase ()
specifier|public
name|Boolean
name|getIgnoreHeaderCase
parameter_list|()
block|{
return|return
name|ignoreHeaderCase
return|;
block|}
comment|/**      * Sets whether or not to add a trailing delimiter.      *<p>      * If {@code null} then the default value of the format used.      *</p>      *       * @param trailingDelimiter whether or not to add a trailing delimiter.      * @return Current {@code CsvDataFormat}, fluent API.      */
DECL|method|setTrailingDelimiter (Boolean trailingDelimiter)
specifier|public
name|CsvDataFormat
name|setTrailingDelimiter
parameter_list|(
name|Boolean
name|trailingDelimiter
parameter_list|)
block|{
name|this
operator|.
name|trailingDelimiter
operator|=
name|trailingDelimiter
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Indicates whether or not to add a trailing delimiter.      *       * @return {@link Boolean#TRUE} if a trailing delimiter should be added.      *         {@link Boolean#FALSE} otherwise. Could return<code>null</code>      *         if value has NOT been set.      */
DECL|method|getTrailingDelimiter ()
specifier|public
name|Boolean
name|getTrailingDelimiter
parameter_list|()
block|{
return|return
name|trailingDelimiter
return|;
block|}
block|}
end_class

end_unit

