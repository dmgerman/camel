begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|org.apache.camel.spring
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spring
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Annotation
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|Fluent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|FluentArg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|RouteBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|springframework
operator|.
name|beans
operator|.
name|factory
operator|.
name|config
operator|.
name|RuntimeBeanReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|springframework
operator|.
name|beans
operator|.
name|factory
operator|.
name|support
operator|.
name|AbstractBeanDefinition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|springframework
operator|.
name|beans
operator|.
name|factory
operator|.
name|support
operator|.
name|BeanDefinitionBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|springframework
operator|.
name|beans
operator|.
name|factory
operator|.
name|xml
operator|.
name|AbstractBeanDefinitionParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|springframework
operator|.
name|beans
operator|.
name|factory
operator|.
name|xml
operator|.
name|ParserContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|springframework
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|springframework
operator|.
name|util
operator|.
name|xml
operator|.
name|DomUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Attr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Element
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NamedNodeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import

begin_class
DECL|class|CamelBeanDefinitionParser
specifier|public
class|class
name|CamelBeanDefinitionParser
extends|extends
name|AbstractBeanDefinitionParser
block|{
DECL|method|parseInternal (Element element, ParserContext parserContext)
specifier|protected
name|AbstractBeanDefinition
name|parseInternal
parameter_list|(
name|Element
name|element
parameter_list|,
name|ParserContext
name|parserContext
parameter_list|)
block|{
name|BeanDefinitionBuilder
name|factory
init|=
name|BeanDefinitionBuilder
operator|.
name|rootBeanDefinition
argument_list|(
name|RouteBuilderFactory
operator|.
name|class
argument_list|)
decl_stmt|;
name|List
name|childElements
init|=
name|DomUtils
operator|.
name|getChildElementsByTagName
argument_list|(
name|element
argument_list|,
literal|"route"
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|BuilderStatement
argument_list|>
name|routes
init|=
operator|new
name|ArrayList
argument_list|<
name|BuilderStatement
argument_list|>
argument_list|(
name|childElements
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|childElements
operator|!=
literal|null
operator|&&
name|childElements
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childElements
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Element
name|routeElement
init|=
operator|(
name|Element
operator|)
name|childElements
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|BuilderAction
argument_list|>
name|actions
init|=
operator|new
name|ArrayList
argument_list|<
name|BuilderAction
argument_list|>
argument_list|()
decl_stmt|;
name|Class
name|type
init|=
name|parseBuilderElement
argument_list|(
name|routeElement
argument_list|,
name|RouteBuilder
operator|.
name|class
argument_list|,
name|actions
argument_list|)
decl_stmt|;
name|BuilderStatement
name|statement
init|=
operator|new
name|BuilderStatement
argument_list|()
decl_stmt|;
name|statement
operator|.
name|setReturnType
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|statement
operator|.
name|setActions
argument_list|(
name|actions
argument_list|)
expr_stmt|;
name|routes
operator|.
name|add
argument_list|(
name|statement
argument_list|)
expr_stmt|;
block|}
block|}
name|factory
operator|.
name|addPropertyValue
argument_list|(
literal|"routes"
argument_list|,
name|routes
argument_list|)
expr_stmt|;
return|return
name|factory
operator|.
name|getBeanDefinition
argument_list|()
return|;
block|}
comment|/** 	 * Use reflection to figure out what is the valid next element. 	 * @param builder TODO 	 * @param routeElement 	 *  	 * @return 	 */
DECL|method|parseBuilderElement (Element element, Class<RouteBuilder> builder, ArrayList<BuilderAction> actions)
specifier|private
name|Class
name|parseBuilderElement
parameter_list|(
name|Element
name|element
parameter_list|,
name|Class
argument_list|<
name|RouteBuilder
argument_list|>
name|builder
parameter_list|,
name|ArrayList
argument_list|<
name|BuilderAction
argument_list|>
name|actions
parameter_list|)
block|{
name|Class
name|currentBuilder
init|=
name|builder
decl_stmt|;
name|NodeList
name|childElements
init|=
name|element
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
name|Element
name|previousElement
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childElements
operator|.
name|getLength
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Node
name|node
init|=
name|childElements
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|currentBuilder
operator|=
name|parseAction
argument_list|(
name|currentBuilder
argument_list|,
name|actions
argument_list|,
operator|(
name|Element
operator|)
name|node
argument_list|,
name|previousElement
argument_list|)
expr_stmt|;
name|previousElement
operator|=
operator|(
name|Element
operator|)
name|node
expr_stmt|;
name|BuilderAction
name|action
init|=
name|actions
operator|.
name|get
argument_list|(
name|actions
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|action
operator|.
name|getMethodInfo
argument_list|()
operator|.
name|methodAnnotation
operator|.
name|nestedActions
argument_list|()
condition|)
block|{
name|currentBuilder
operator|=
name|parseBuilderElement
argument_list|(
operator|(
name|Element
operator|)
name|node
argument_list|,
name|currentBuilder
argument_list|,
name|actions
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Make sure the there are no child elements.
name|NodeList
name|nl
init|=
name|node
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|nl
operator|.
name|getLength
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|nl
operator|.
name|item
argument_list|(
name|j
argument_list|)
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The element "
operator|+
name|node
operator|.
name|getLocalName
argument_list|()
operator|+
literal|" should not have any child elements."
argument_list|)
throw|;
block|}
block|}
block|}
block|}
block|}
comment|// Add the builder actions that are annotated with @Fluent(callOnElementEnd=true)
if|if
condition|(
name|currentBuilder
operator|!=
literal|null
condition|)
block|{
name|Method
index|[]
name|methods
init|=
name|currentBuilder
operator|.
name|getMethods
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|methods
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Method
name|method
init|=
name|methods
index|[
name|i
index|]
decl_stmt|;
name|Fluent
name|annotation
init|=
name|method
operator|.
name|getAnnotation
argument_list|(
name|Fluent
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|annotation
operator|!=
literal|null
operator|&&
name|annotation
operator|.
name|callOnElementEnd
argument_list|()
condition|)
block|{
if|if
condition|(
name|method
operator|.
name|getParameterTypes
argument_list|()
operator|.
name|length
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Only methods with no parameters can annotated with @Fluent(callOnElementEnd=true): "
operator|+
name|method
argument_list|)
throw|;
block|}
name|MethodInfo
name|methodInfo
init|=
operator|new
name|MethodInfo
argument_list|(
name|method
argument_list|,
name|annotation
argument_list|,
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Class
argument_list|>
argument_list|()
argument_list|,
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|FluentArg
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
name|actions
operator|.
name|add
argument_list|(
operator|new
name|BuilderAction
argument_list|(
name|methodInfo
argument_list|,
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|currentBuilder
operator|=
name|method
operator|.
name|getReturnType
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
name|currentBuilder
return|;
block|}
DECL|method|parseAction (Class currentBuilder, ArrayList<BuilderAction> actions, Element element, Element previousElement)
specifier|private
name|Class
name|parseAction
parameter_list|(
name|Class
name|currentBuilder
parameter_list|,
name|ArrayList
argument_list|<
name|BuilderAction
argument_list|>
name|actions
parameter_list|,
name|Element
name|element
parameter_list|,
name|Element
name|previousElement
parameter_list|)
block|{
name|String
name|actionName
init|=
name|element
operator|.
name|getLocalName
argument_list|()
decl_stmt|;
comment|// Get a list of method names that match the action.
name|ArrayList
argument_list|<
name|MethodInfo
argument_list|>
name|methods
init|=
name|findFluentMethodsWithName
argument_list|(
name|currentBuilder
argument_list|,
name|element
operator|.
name|getLocalName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|methods
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalActionException
argument_list|(
name|actionName
argument_list|,
name|previousElement
operator|==
literal|null
condition|?
literal|null
else|:
name|previousElement
operator|.
name|getLocalName
argument_list|()
argument_list|)
throw|;
block|}
comment|// Pick the best method out of the list. Sort by argument length. Pick
comment|// first longest match.
name|Collections
operator|.
name|sort
argument_list|(
name|methods
argument_list|,
operator|new
name|Comparator
argument_list|<
name|MethodInfo
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|MethodInfo
name|m1
parameter_list|,
name|MethodInfo
name|m2
parameter_list|)
block|{
return|return
name|m1
operator|.
name|method
operator|.
name|getParameterTypes
argument_list|()
operator|.
name|length
operator|-
name|m2
operator|.
name|method
operator|.
name|getParameterTypes
argument_list|()
operator|.
name|length
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Build the possible list of arguments from the attributes and child
comment|// elements
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|attributeArguments
init|=
name|getArugmentsFromAttributes
argument_list|(
name|element
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|Element
argument_list|>
argument_list|>
name|elementArguments
init|=
name|getArgumentsFromElements
argument_list|(
name|element
argument_list|)
decl_stmt|;
comment|// Find the first method that we can supply arguments for.
name|MethodInfo
name|match
init|=
literal|null
decl_stmt|;
name|match
operator|=
name|findMethodMatch
argument_list|(
name|methods
argument_list|,
name|attributeArguments
operator|.
name|keySet
argument_list|()
argument_list|,
name|elementArguments
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalActionException
argument_list|(
name|actionName
argument_list|,
name|previousElement
operator|==
literal|null
condition|?
literal|null
else|:
name|previousElement
operator|.
name|getLocalName
argument_list|()
argument_list|)
throw|;
comment|// Move element arguments into the attributeArguments map if needed.
name|Set
argument_list|<
name|String
argument_list|>
name|parameterNames
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|match
operator|.
name|parameters
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|parameterNames
operator|.
name|removeAll
argument_list|(
name|attributeArguments
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|key
range|:
name|parameterNames
control|)
block|{
name|ArrayList
argument_list|<
name|Element
argument_list|>
name|elements
init|=
name|elementArguments
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|Class
name|clazz
init|=
name|match
operator|.
name|parameters
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|Object
name|value
init|=
name|convertTo
argument_list|(
name|elements
argument_list|,
name|clazz
argument_list|)
decl_stmt|;
name|attributeArguments
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|Element
name|el
range|:
name|elements
control|)
block|{
comment|// remove the argument nodes so that they don't get interpreted as
comment|// actions.
name|el
operator|.
name|getParentNode
argument_list|()
operator|.
name|removeChild
argument_list|(
name|el
argument_list|)
expr_stmt|;
block|}
block|}
name|actions
operator|.
name|add
argument_list|(
operator|new
name|BuilderAction
argument_list|(
name|match
argument_list|,
name|attributeArguments
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|match
operator|.
name|method
operator|.
name|getReturnType
argument_list|()
return|;
block|}
DECL|method|convertTo (ArrayList<Element> elements, Class clazz)
specifier|private
name|Object
name|convertTo
parameter_list|(
name|ArrayList
argument_list|<
name|Element
argument_list|>
name|elements
parameter_list|,
name|Class
name|clazz
parameter_list|)
block|{
if|if
condition|(
name|clazz
operator|.
name|isArray
argument_list|()
operator|||
name|elements
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// TODO: we could support arrays one day soon.
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"We don't support injecting array values."
argument_list|)
throw|;
block|}
else|else
block|{
name|Element
name|element
init|=
name|elements
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|ref
init|=
name|element
operator|.
name|getAttribute
argument_list|(
literal|"ref"
argument_list|)
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|hasText
argument_list|(
name|ref
argument_list|)
condition|)
block|{
return|return
operator|new
name|RuntimeBeanReference
argument_list|(
name|ref
argument_list|)
return|;
block|}
name|ArrayList
argument_list|<
name|BuilderAction
argument_list|>
name|actions
init|=
operator|new
name|ArrayList
argument_list|<
name|BuilderAction
argument_list|>
argument_list|()
decl_stmt|;
name|Class
name|type
init|=
name|parseBuilderElement
argument_list|(
name|element
argument_list|,
name|RouteBuilder
operator|.
name|class
argument_list|,
name|actions
argument_list|)
decl_stmt|;
name|BuilderStatement
name|statement
init|=
operator|new
name|BuilderStatement
argument_list|()
decl_stmt|;
name|statement
operator|.
name|setReturnType
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|statement
operator|.
name|setActions
argument_list|(
name|actions
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clazz
operator|.
name|isAssignableFrom
argument_list|(
name|statement
operator|.
name|getReturnType
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Builder does not produce object of expected type: "
operator|+
name|clazz
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|statement
return|;
block|}
block|}
DECL|method|findMethodMatch (ArrayList<MethodInfo> methods, Set<String> attributeNames, Set<String> elementNames)
specifier|private
name|MethodInfo
name|findMethodMatch
parameter_list|(
name|ArrayList
argument_list|<
name|MethodInfo
argument_list|>
name|methods
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|attributeNames
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|elementNames
parameter_list|)
block|{
for|for
control|(
name|MethodInfo
name|method
range|:
name|methods
control|)
block|{
comment|// make sure all the given attribute parameters can be assigned via
comment|// attributes
name|boolean
name|miss
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|key
range|:
name|attributeNames
control|)
block|{
name|FluentArg
name|arg
init|=
name|method
operator|.
name|parameterAnnotations
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|null
operator|||
operator|!
name|arg
operator|.
name|attribute
argument_list|()
condition|)
block|{
name|miss
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|miss
condition|)
continue|continue;
comment|// Keep looking...
name|Set
argument_list|<
name|String
argument_list|>
name|parameterNames
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|method
operator|.
name|parameters
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|parameterNames
operator|.
name|removeAll
argument_list|(
name|attributeNames
argument_list|)
expr_stmt|;
comment|// Bingo we found a match.
if|if
condition|(
name|parameterNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|method
return|;
block|}
comment|// We may still be able to match using elements as parameters.
for|for
control|(
name|String
name|key
range|:
name|elementNames
control|)
block|{
if|if
condition|(
name|parameterNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
break|break;
block|}
comment|// We only want to use the first child elements as arguments,
comment|// once we don't match, we can stop looking.
name|FluentArg
name|arg
init|=
name|method
operator|.
name|parameterAnnotations
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|null
operator|||
operator|!
name|arg
operator|.
name|element
argument_list|()
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|!
name|parameterNames
operator|.
name|remove
argument_list|(
name|key
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
comment|// All parameters found! We have a match!
if|if
condition|(
name|parameterNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|method
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|getArgumentsFromElements (Element element)
specifier|private
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|Element
argument_list|>
argument_list|>
name|getArgumentsFromElements
parameter_list|(
name|Element
name|element
parameter_list|)
block|{
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|Element
argument_list|>
argument_list|>
name|elements
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|Element
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|NodeList
name|childNodes
init|=
name|element
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
name|String
name|lastTag
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childNodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|node
init|=
name|childNodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ELEMENT_NODE
condition|)
block|{
name|Element
name|el
init|=
operator|(
name|Element
operator|)
name|node
decl_stmt|;
name|String
name|tag
init|=
name|el
operator|.
name|getLocalName
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|Element
argument_list|>
name|els
init|=
name|elements
operator|.
name|get
argument_list|(
name|tag
argument_list|)
decl_stmt|;
if|if
condition|(
name|els
operator|==
literal|null
condition|)
block|{
name|els
operator|=
operator|new
name|ArrayList
argument_list|<
name|Element
argument_list|>
argument_list|()
expr_stmt|;
name|elements
operator|.
name|put
argument_list|(
name|el
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|els
argument_list|)
expr_stmt|;
name|els
operator|.
name|add
argument_list|(
name|el
argument_list|)
expr_stmt|;
name|lastTag
operator|=
name|tag
expr_stmt|;
block|}
else|else
block|{
comment|// add to array if the elements are consecutive
if|if
condition|(
name|tag
operator|.
name|equals
argument_list|(
name|lastTag
argument_list|)
condition|)
block|{
name|els
operator|.
name|add
argument_list|(
name|el
argument_list|)
expr_stmt|;
name|lastTag
operator|=
name|tag
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|elements
return|;
block|}
DECL|method|getArugmentsFromAttributes (Element element)
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getArugmentsFromAttributes
parameter_list|(
name|Element
name|element
parameter_list|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|attributes
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|NamedNodeMap
name|childNodes
init|=
name|element
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childNodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|node
init|=
name|childNodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getNodeType
argument_list|()
operator|==
name|Node
operator|.
name|ATTRIBUTE_NODE
condition|)
block|{
name|Attr
name|attr
init|=
operator|(
name|Attr
operator|)
name|node
decl_stmt|;
name|String
name|str
init|=
name|attr
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Object
name|value
init|=
name|str
decl_stmt|;
comment|// If the value starts with # then it's a bean reference
if|if
condition|(
name|str
operator|.
name|startsWith
argument_list|(
literal|"#"
argument_list|)
condition|)
block|{
name|str
operator|=
name|str
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// Support using ## to escape the bean reference feature.
if|if
condition|(
operator|!
name|str
operator|.
name|startsWith
argument_list|(
literal|"#"
argument_list|)
condition|)
block|{
name|value
operator|=
operator|new
name|RuntimeBeanReference
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
name|attributes
operator|.
name|put
argument_list|(
name|attr
operator|.
name|getName
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|attributes
return|;
block|}
comment|/** 	 * Finds all the methods on the clazz that match the name and which have the 	 * {@see Fluent} annotation and whoes parameters have the {@see FluentArg} 	 * annotation. 	 *  	 * @param clazz 	 * @param name 	 * @return 	 */
DECL|method|findFluentMethodsWithName (Class clazz, String name)
specifier|private
name|ArrayList
argument_list|<
name|MethodInfo
argument_list|>
name|findFluentMethodsWithName
parameter_list|(
name|Class
name|clazz
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|MethodInfo
argument_list|>
name|rc
init|=
operator|new
name|ArrayList
argument_list|<
name|MethodInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Method
index|[]
name|methods
init|=
name|clazz
operator|.
name|getMethods
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|methods
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Method
name|method
init|=
name|methods
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|method
operator|.
name|isAnnotationPresent
argument_list|(
name|Fluent
operator|.
name|class
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// Use the fluent supplied name for the action, or the method name if not set.
name|Fluent
name|fluentAnnotation
init|=
name|method
operator|.
name|getAnnotation
argument_list|(
name|Fluent
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|hasText
argument_list|(
name|fluentAnnotation
operator|.
name|value
argument_list|()
argument_list|)
condition|?
name|name
operator|.
name|equals
argument_list|(
name|fluentAnnotation
operator|.
name|value
argument_list|()
argument_list|)
else|:
name|name
operator|.
name|equals
argument_list|(
name|method
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Class
argument_list|>
name|map
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Class
argument_list|>
argument_list|()
decl_stmt|;
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|FluentArg
argument_list|>
name|amap
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|FluentArg
argument_list|>
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|parameters
init|=
name|method
operator|.
name|getParameterTypes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|parameters
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|parameter
init|=
name|parameters
index|[
name|j
index|]
decl_stmt|;
name|FluentArg
name|annotation
init|=
name|getParameterAnnotation
argument_list|(
name|FluentArg
operator|.
name|class
argument_list|,
name|method
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|annotation
operator|!=
literal|null
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|annotation
operator|.
name|value
argument_list|()
argument_list|,
name|parameter
argument_list|)
expr_stmt|;
name|amap
operator|.
name|put
argument_list|(
name|annotation
operator|.
name|value
argument_list|()
argument_list|,
name|annotation
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
comment|// If all the parameters were annotated...
if|if
condition|(
name|parameters
operator|.
name|length
operator|==
name|map
operator|.
name|size
argument_list|()
condition|)
block|{
name|rc
operator|.
name|add
argument_list|(
operator|new
name|MethodInfo
argument_list|(
name|method
argument_list|,
name|fluentAnnotation
argument_list|,
name|map
argument_list|,
name|amap
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|rc
return|;
block|}
DECL|method|getParameterAnnotation (Class<T> annotationClass, Method method, int index)
specifier|private
parameter_list|<
name|T
parameter_list|>
name|T
name|getParameterAnnotation
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|annotationClass
parameter_list|,
name|Method
name|method
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|Annotation
index|[]
name|annotations
init|=
name|method
operator|.
name|getParameterAnnotations
argument_list|()
index|[
name|index
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|annotations
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|annotationClass
operator|.
name|isAssignableFrom
argument_list|(
name|annotations
index|[
name|i
index|]
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
return|return
operator|(
name|T
operator|)
name|annotations
index|[
name|i
index|]
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
end_class

end_unit

