begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.component.amqp.springboot
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|amqp
operator|.
name|springboot
package|;
end_package

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Generated
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|LoggingLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|amqp
operator|.
name|AMQPComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|jms
operator|.
name|DefaultTaskExecutorType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|jms
operator|.
name|ReplyToType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spring
operator|.
name|boot
operator|.
name|ComponentConfigurationPropertiesCommon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|springframework
operator|.
name|boot
operator|.
name|context
operator|.
name|properties
operator|.
name|ConfigurationProperties
import|;
end_import

begin_comment
comment|/**  * Messaging with AMQP protocol using Apache QPid Client.  *   * Generated by camel-package-maven-plugin - do not edit this file!  */
end_comment

begin_class
annotation|@
name|Generated
argument_list|(
literal|"org.apache.camel.maven.packaging.SpringBootAutoConfigurationMojo"
argument_list|)
annotation|@
name|ConfigurationProperties
argument_list|(
name|prefix
operator|=
literal|"camel.component.amqp"
argument_list|)
DECL|class|AMQPComponentConfiguration
specifier|public
class|class
name|AMQPComponentConfiguration
extends|extends
name|ComponentConfigurationPropertiesCommon
block|{
comment|/**      * Whether to enable auto configuration of the amqp component. This is      * enabled by default.      */
DECL|field|enabled
specifier|private
name|Boolean
name|enabled
decl_stmt|;
comment|/**      * To use a shared JMS configuration. The option is a      * org.apache.camel.component.jms.JmsConfiguration type.      */
DECL|field|configuration
specifier|private
name|String
name|configuration
decl_stmt|;
comment|/**      * Specifies whether the consumer accept messages while it is stopping. You      * may consider enabling this option, if you start and stop JMS routes at      * runtime, while there are still messages enqueued on the queue. If this      * option is false, and you stop the JMS route, then messages may be      * rejected, and the JMS broker would have to attempt redeliveries, which      * yet again may be rejected, and eventually the message may be moved at a      * dead letter queue on the JMS broker. To avoid this its recommended to      * enable this option.      */
DECL|field|acceptMessagesWhileStopping
specifier|private
name|Boolean
name|acceptMessagesWhileStopping
init|=
literal|false
decl_stmt|;
comment|/**      * Whether the DefaultMessageListenerContainer used in the reply managers      * for request-reply messaging allow the      * DefaultMessageListenerContainer.runningAllowed flag to quick stop in case      * JmsConfigurationisAcceptMessagesWhileStopping is enabled, and      * org.apache.camel.CamelContext is currently being stopped. This quick stop      * ability is enabled by default in the regular JMS consumers but to enable      * for reply managers you must enable this flag.      */
DECL|field|allowReplyManagerQuickStop
specifier|private
name|Boolean
name|allowReplyManagerQuickStop
init|=
literal|false
decl_stmt|;
comment|/**      * The JMS acknowledgement mode defined as an Integer. Allows you to set      * vendor-specific extensions to the acknowledgment mode.For the regular      * modes, it is preferable to use the acknowledgementModeName instead.      */
DECL|field|acknowledgementMode
specifier|private
name|Integer
name|acknowledgementMode
decl_stmt|;
comment|/**      * Enables eager loading of JMS properties as soon as a message is loaded      * which generally is inefficient as the JMS properties may not be required      * but sometimes can catch early any issues with the underlying JMS provider      * and the use of JMS properties      */
DECL|field|eagerLoadingOfProperties
specifier|private
name|Boolean
name|eagerLoadingOfProperties
init|=
literal|false
decl_stmt|;
comment|/**      * The JMS acknowledgement name, which is one of: SESSION_TRANSACTED,      * CLIENT_ACKNOWLEDGE, AUTO_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE      */
DECL|field|acknowledgementModeName
specifier|private
name|String
name|acknowledgementModeName
init|=
literal|"AUTO_ACKNOWLEDGE"
decl_stmt|;
comment|/**      * Specifies whether the consumer container should auto-startup.      */
DECL|field|autoStartup
specifier|private
name|Boolean
name|autoStartup
init|=
literal|true
decl_stmt|;
comment|/**      * Sets the cache level by ID for the underlying JMS resources. See      * cacheLevelName option for more details.      */
DECL|field|cacheLevel
specifier|private
name|Integer
name|cacheLevel
decl_stmt|;
comment|/**      * Sets the cache level by name for the underlying JMS resources. Possible      * values are: CACHE_AUTO, CACHE_CONNECTION, CACHE_CONSUMER, CACHE_NONE, and      * CACHE_SESSION. The default setting is CACHE_AUTO. See the Spring      * documentation and Transactions Cache Levels for more information.      */
DECL|field|cacheLevelName
specifier|private
name|String
name|cacheLevelName
init|=
literal|"CACHE_AUTO"
decl_stmt|;
comment|/**      * Sets the cache level by name for the reply consumer when doing      * request/reply over JMS. This option only applies when using fixed reply      * queues (not temporary). Camel will by default use: CACHE_CONSUMER for      * exclusive or shared w/ replyToSelectorName. And CACHE_SESSION for shared      * without replyToSelectorName. Some JMS brokers such as IBM WebSphere may      * require to set the replyToCacheLevelName=CACHE_NONE to work. Note: If      * using temporary queues then CACHE_NONE is not allowed, and you must use a      * higher value such as CACHE_CONSUMER or CACHE_SESSION.      */
DECL|field|replyToCacheLevelName
specifier|private
name|String
name|replyToCacheLevelName
decl_stmt|;
comment|/**      * Sets the JMS client ID to use. Note that this value, if specified, must      * be unique and can only be used by a single JMS connection instance. It is      * typically only required for durable topic subscriptions. If using Apache      * ActiveMQ you may prefer to use Virtual Topics instead.      */
DECL|field|clientId
specifier|private
name|String
name|clientId
decl_stmt|;
comment|/**      * Specifies the default number of concurrent consumers when consuming from      * JMS (not for request/reply over JMS). See also the maxMessagesPerTask      * option to control dynamic scaling up/down of threads. When doing      * request/reply over JMS then the option replyToConcurrentConsumers is used      * to control number of concurrent consumers on the reply message listener.      */
DECL|field|concurrentConsumers
specifier|private
name|Integer
name|concurrentConsumers
init|=
literal|1
decl_stmt|;
comment|/**      * Specifies the default number of concurrent consumers when doing      * request/reply over JMS. See also the maxMessagesPerTask option to control      * dynamic scaling up/down of threads.      */
DECL|field|replyToConcurrentConsumers
specifier|private
name|Integer
name|replyToConcurrentConsumers
init|=
literal|1
decl_stmt|;
comment|/**      * The connection factory to be use. A connection factory must be configured      * either on the component or endpoint. The option is a      * javax.jms.ConnectionFactory type.      */
DECL|field|connectionFactory
specifier|private
name|String
name|connectionFactory
decl_stmt|;
comment|/**      * Username to use with the ConnectionFactory. You can also configure      * username/password directly on the ConnectionFactory.      */
DECL|field|username
specifier|private
name|String
name|username
decl_stmt|;
comment|/**      * Password to use with the ConnectionFactory. You can also configure      * username/password directly on the ConnectionFactory.      */
DECL|field|password
specifier|private
name|String
name|password
decl_stmt|;
comment|/**      * Specifies whether persistent delivery is used by default.      */
DECL|field|deliveryPersistent
specifier|private
name|Boolean
name|deliveryPersistent
init|=
literal|true
decl_stmt|;
comment|/**      * Specifies the delivery mode to be used. Possibles values are those      * defined by javax.jms.DeliveryMode. NON_PERSISTENT = 1 and PERSISTENT = 2.      */
DECL|field|deliveryMode
specifier|private
name|Integer
name|deliveryMode
decl_stmt|;
comment|/**      * The durable subscriber name for specifying durable topic subscriptions.      * The clientId option must be configured as well.      */
DECL|field|durableSubscriptionName
specifier|private
name|String
name|durableSubscriptionName
decl_stmt|;
comment|/**      * Specifies the JMS Exception Listener that is to be notified of any      * underlying JMS exceptions. The option is a javax.jms.ExceptionListener      * type.      */
DECL|field|exceptionListener
specifier|private
name|String
name|exceptionListener
decl_stmt|;
comment|/**      * Specifies a org.springframework.util.ErrorHandler to be invoked in case      * of any uncaught exceptions thrown while processing a Message. By default      * these exceptions will be logged at the WARN level, if no errorHandler has      * been configured. You can configure logging level and whether stack traces      * should be logged using errorHandlerLoggingLevel and      * errorHandlerLogStackTrace options. This makes it much easier to      * configure, than having to code a custom errorHandler. The option is a      * org.springframework.util.ErrorHandler type.      */
DECL|field|errorHandler
specifier|private
name|String
name|errorHandler
decl_stmt|;
comment|/**      * Allows to configure the default errorHandler logging level for logging      * uncaught exceptions.      */
DECL|field|errorHandlerLoggingLevel
specifier|private
name|LoggingLevel
name|errorHandlerLoggingLevel
init|=
name|LoggingLevel
operator|.
name|WARN
decl_stmt|;
comment|/**      * Allows to control whether stacktraces should be logged or not, by the      * default errorHandler.      */
DECL|field|errorHandlerLogStackTrace
specifier|private
name|Boolean
name|errorHandlerLogStackTrace
init|=
literal|true
decl_stmt|;
comment|/**      * Set if the deliveryMode, priority or timeToLive qualities of service      * should be used when sending messages. This option is based on Spring's      * JmsTemplate. The deliveryMode, priority and timeToLive options are      * applied to the current endpoint. This contrasts with the      * preserveMessageQos option, which operates at message granularity, reading      * QoS properties exclusively from the Camel In message headers.      */
DECL|field|explicitQosEnabled
specifier|private
name|Boolean
name|explicitQosEnabled
init|=
literal|false
decl_stmt|;
comment|/**      * Specifies whether the listener session should be exposed when consuming      * messages.      */
DECL|field|exposeListenerSession
specifier|private
name|Boolean
name|exposeListenerSession
init|=
literal|false
decl_stmt|;
comment|/**      * Specifies the limit for idle executions of a receive task, not having      * received any message within its execution. If this limit is reached, the      * task will shut down and leave receiving to other executing tasks (in the      * case of dynamic scheduling; see the maxConcurrentConsumers setting).      * There is additional doc available from Spring.      */
DECL|field|idleTaskExecutionLimit
specifier|private
name|Integer
name|idleTaskExecutionLimit
init|=
literal|1
decl_stmt|;
comment|/**      * Specify the limit for the number of consumers that are allowed to be idle      * at any given time.      */
DECL|field|idleConsumerLimit
specifier|private
name|Integer
name|idleConsumerLimit
init|=
literal|1
decl_stmt|;
comment|/**      * Specifies the maximum number of concurrent consumers when consuming from      * JMS (not for request/reply over JMS). See also the maxMessagesPerTask      * option to control dynamic scaling up/down of threads. When doing      * request/reply over JMS then the option replyToMaxConcurrentConsumers is      * used to control number of concurrent consumers on the reply message      * listener.      */
DECL|field|maxConcurrentConsumers
specifier|private
name|Integer
name|maxConcurrentConsumers
decl_stmt|;
comment|/**      * Specifies the maximum number of concurrent consumers when using      * request/reply over JMS. See also the maxMessagesPerTask option to control      * dynamic scaling up/down of threads.      */
DECL|field|replyToMaxConcurrentConsumers
specifier|private
name|Integer
name|replyToMaxConcurrentConsumers
decl_stmt|;
comment|/**      * Specifies the maximum number of concurrent consumers for continue routing      * when timeout occurred when using request/reply over JMS.      */
DECL|field|replyOnTimeoutToMaxConcurrentConsumers
specifier|private
name|Integer
name|replyOnTimeoutToMaxConcurrentConsumers
init|=
literal|1
decl_stmt|;
comment|/**      * The number of messages per task. -1 is unlimited. If you use a range for      * concurrent consumers (eg min max), then this option can be used to set a      * value to eg 100 to control how fast the consumers will shrink when less      * work is required.      */
DECL|field|maxMessagesPerTask
specifier|private
name|Integer
name|maxMessagesPerTask
init|=
operator|-
literal|1
decl_stmt|;
comment|/**      * To use a custom Spring      * org.springframework.jms.support.converter.MessageConverter so you can be      * in control how to map to/from a javax.jms.Message. The option is a      * org.springframework.jms.support.converter.MessageConverter type.      */
DECL|field|messageConverter
specifier|private
name|String
name|messageConverter
decl_stmt|;
comment|/**      * Specifies whether Camel should auto map the received JMS message to a      * suited payload type, such as javax.jms.TextMessage to a String etc.      */
DECL|field|mapJmsMessage
specifier|private
name|Boolean
name|mapJmsMessage
init|=
literal|true
decl_stmt|;
comment|/**      * When sending, specifies whether message IDs should be added. This is just      * an hint to the JMS broker.If the JMS provider accepts this hint, these      * messages must have the message ID set to null; if the provider ignores      * the hint, the message ID must be set to its normal unique value      */
DECL|field|messageIdEnabled
specifier|private
name|Boolean
name|messageIdEnabled
init|=
literal|true
decl_stmt|;
comment|/**      * Specifies whether timestamps should be enabled by default on sending      * messages. This is just an hint to the JMS broker.If the JMS provider      * accepts this hint, these messages must have the timestamp set to zero; if      * the provider ignores the hint the timestamp must be set to its normal      * value      */
DECL|field|messageTimestampEnabled
specifier|private
name|Boolean
name|messageTimestampEnabled
init|=
literal|true
decl_stmt|;
comment|/**      * If true, Camel will always make a JMS message copy of the message when it      * is passed to the producer for sending. Copying the message is needed in      * some situations, such as when a replyToDestinationSelectorName is set      * (incidentally, Camel will set the alwaysCopyMessage option to true, if a      * replyToDestinationSelectorName is set)      */
DECL|field|alwaysCopyMessage
specifier|private
name|Boolean
name|alwaysCopyMessage
init|=
literal|false
decl_stmt|;
comment|/**      * Specifies whether JMSMessageID should always be used as JMSCorrelationID      * for InOut messages.      */
DECL|field|useMessageIDAsCorrelationID
specifier|private
name|Boolean
name|useMessageIDAsCorrelationID
init|=
literal|false
decl_stmt|;
comment|/**      * Values greater than 1 specify the message priority when sending (where 0      * is the lowest priority and 9 is the highest). The explicitQosEnabled      * option must also be enabled in order for this option to have any effect.      */
DECL|field|priority
specifier|private
name|Integer
name|priority
init|=
literal|4
decl_stmt|;
comment|/**      * Specifies whether to inhibit the delivery of messages published by its      * own connection.      */
DECL|field|pubSubNoLocal
specifier|private
name|Boolean
name|pubSubNoLocal
init|=
literal|false
decl_stmt|;
comment|/**      * The timeout for receiving messages (in milliseconds).      */
DECL|field|receiveTimeout
specifier|private
name|Long
name|receiveTimeout
init|=
literal|1000L
decl_stmt|;
comment|/**      * Specifies the interval between recovery attempts, i.e. when a connection      * is being refreshed, in milliseconds. The default is 5000 ms, that is, 5      * seconds.      */
DECL|field|recoveryInterval
specifier|private
name|Long
name|recoveryInterval
init|=
literal|5000L
decl_stmt|;
comment|/**      * Allows you to specify a custom task executor for consuming messages. The      * option is a org.springframework.core.task.TaskExecutor type.      */
DECL|field|taskExecutor
specifier|private
name|String
name|taskExecutor
decl_stmt|;
comment|/**      * When sending messages, specifies the time-to-live of the message (in      * milliseconds).      */
DECL|field|timeToLive
specifier|private
name|Long
name|timeToLive
init|=
operator|-
literal|1L
decl_stmt|;
comment|/**      * Specifies whether to use transacted mode      */
DECL|field|transacted
specifier|private
name|Boolean
name|transacted
init|=
literal|false
decl_stmt|;
comment|/**      * If true, Camel will create a JmsTransactionManager, if there is no      * transactionManager injected when option transacted=true.      */
DECL|field|lazyCreateTransactionManager
specifier|private
name|Boolean
name|lazyCreateTransactionManager
init|=
literal|true
decl_stmt|;
comment|/**      * The Spring transaction manager to use. The option is a      * org.springframework.transaction.PlatformTransactionManager type.      */
DECL|field|transactionManager
specifier|private
name|String
name|transactionManager
decl_stmt|;
comment|/**      * The name of the transaction to use.      */
DECL|field|transactionName
specifier|private
name|String
name|transactionName
decl_stmt|;
comment|/**      * The timeout value of the transaction (in seconds), if using transacted      * mode.      */
DECL|field|transactionTimeout
specifier|private
name|Integer
name|transactionTimeout
init|=
operator|-
literal|1
decl_stmt|;
comment|/**      * Specifies whether to test the connection on startup. This ensures that      * when Camel starts that all the JMS consumers have a valid connection to      * the JMS broker. If a connection cannot be granted then Camel throws an      * exception on startup. This ensures that Camel is not started with failed      * connections. The JMS producers is tested as well.      */
DECL|field|testConnectionOnStartup
specifier|private
name|Boolean
name|testConnectionOnStartup
init|=
literal|false
decl_stmt|;
comment|/**      * Whether to startup the JmsConsumer message listener asynchronously, when      * starting a route. For example if a JmsConsumer cannot get a connection to      * a remote JMS broker, then it may block while retrying and/or failover.      * This will cause Camel to block while starting routes. By setting this      * option to true, you will let routes startup, while the JmsConsumer      * connects to the JMS broker using a dedicated thread in asynchronous mode.      * If this option is used, then beware that if the connection could not be      * established, then an exception is logged at WARN level, and the consumer      * will not be able to receive messages; You can then restart the route to      * retry.      */
DECL|field|asyncStartListener
specifier|private
name|Boolean
name|asyncStartListener
init|=
literal|false
decl_stmt|;
comment|/**      * Whether to stop the JmsConsumer message listener asynchronously, when      * stopping a route.      */
DECL|field|asyncStopListener
specifier|private
name|Boolean
name|asyncStopListener
init|=
literal|false
decl_stmt|;
comment|/**      * When using mapJmsMessage=false Camel will create a new JMS message to      * send to a new JMS destination if you touch the headers (get or set)      * during the route. Set this option to true to force Camel to send the      * original JMS message that was received.      */
DECL|field|forceSendOriginalMessage
specifier|private
name|Boolean
name|forceSendOriginalMessage
init|=
literal|false
decl_stmt|;
comment|/**      * The timeout for waiting for a reply when using the InOut Exchange Pattern      * (in milliseconds). The default is 20 seconds. You can include the header      * CamelJmsRequestTimeout to override this endpoint configured timeout      * value, and thus have per message individual timeout values. See also the      * requestTimeoutCheckerInterval option.      */
DECL|field|requestTimeout
specifier|private
name|Long
name|requestTimeout
init|=
literal|20000L
decl_stmt|;
comment|/**      * Configures how often Camel should check for timed out Exchanges when      * doing request/reply over JMS. By default Camel checks once per second.      * But if you must react faster when a timeout occurs, then you can lower      * this interval, to check more frequently. The timeout is determined by the      * option requestTimeout.      */
DECL|field|requestTimeoutCheckerInterval
specifier|private
name|Long
name|requestTimeoutCheckerInterval
init|=
literal|1000L
decl_stmt|;
comment|/**      * You can transfer the exchange over the wire instead of just the body and      * headers. The following fields are transferred: In body, Out body, Fault      * body, In headers, Out headers, Fault headers, exchange properties,      * exchange exception. This requires that the objects are serializable.      * Camel will exclude any non-serializable objects and log it at WARN level.      * You must enable this option on both the producer and consumer side, so      * Camel knows the payloads is an Exchange and not a regular payload.      */
DECL|field|transferExchange
specifier|private
name|Boolean
name|transferExchange
init|=
literal|false
decl_stmt|;
comment|/**      * If enabled and you are using Request Reply messaging (InOut) and an      * Exchange failed on the consumer side, then the caused Exception will be      * send back in response as a javax.jms.ObjectMessage. If the client is      * Camel, the returned Exception is rethrown. This allows you to use Camel      * JMS as a bridge in your routing - for example, using persistent queues to      * enable robust routing. Notice that if you also have transferExchange      * enabled, this option takes precedence. The caught exception is required      * to be serializable. The original Exception on the consumer side can be      * wrapped in an outer exception such as      * org.apache.camel.RuntimeCamelException when returned to the producer.      */
DECL|field|transferException
specifier|private
name|Boolean
name|transferException
init|=
literal|false
decl_stmt|;
comment|/**      * If enabled and you are using Request Reply messaging (InOut) and an      * Exchange failed with a SOAP fault (not exception) on the consumer side,      * then the fault flag on MessageisFault() will be send back in the response      * as a JMS header with the key org.apache.camel.component.jms.      * JmsConstantsJMS_TRANSFER_FAULTJMS_TRANSFER_FAULT. If the client is Camel,      * the returned fault flag will be set on the link      * org.apache.camel.MessagesetFault(boolean). You may want to enable this      * when using Camel components that support faults such as SOAP based such      * as cxf or spring-ws.      */
DECL|field|transferFault
specifier|private
name|Boolean
name|transferFault
init|=
literal|false
decl_stmt|;
comment|/**      * Allows you to use your own implementation of the      * org.springframework.jms.core.JmsOperations interface. Camel uses      * JmsTemplate as default. Can be used for testing purpose, but not used      * much as stated in the spring API docs. The option is a      * org.springframework.jms.core.JmsOperations type.      */
DECL|field|jmsOperations
specifier|private
name|String
name|jmsOperations
decl_stmt|;
comment|/**      * A pluggable      * org.springframework.jms.support.destination.DestinationResolver that      * allows you to use your own resolver (for example, to lookup the real      * destination in a JNDI registry). The option is a      * org.springframework.jms.support.destination.DestinationResolver type.      */
DECL|field|destinationResolver
specifier|private
name|String
name|destinationResolver
decl_stmt|;
comment|/**      * Allows for explicitly specifying which kind of strategy to use for      * replyTo queues when doing request/reply over JMS. Possible values are:      * Temporary, Shared, or Exclusive. By default Camel will use temporary      * queues. However if replyTo has been configured, then Shared is used by      * default. This option allows you to use exclusive queues instead of shared      * ones. See Camel JMS documentation for more details, and especially the      * notes about the implications if running in a clustered environment, and      * the fact that Shared reply queues has lower performance than its      * alternatives Temporary and Exclusive.      */
DECL|field|replyToType
specifier|private
name|ReplyToType
name|replyToType
decl_stmt|;
comment|/**      * Set to true, if you want to send message using the QoS settings specified      * on the message, instead of the QoS settings on the JMS endpoint. The      * following three headers are considered JMSPriority, JMSDeliveryMode, and      * JMSExpiration. You can provide all or only some of them. If not provided,      * Camel will fall back to use the values from the endpoint instead. So,      * when using this option, the headers override the values from the      * endpoint. The explicitQosEnabled option, by contrast, will only use      * options set on the endpoint, and not values from the message header.      */
DECL|field|preserveMessageQos
specifier|private
name|Boolean
name|preserveMessageQos
init|=
literal|false
decl_stmt|;
comment|/**      * Whether the JmsConsumer processes the Exchange asynchronously. If enabled      * then the JmsConsumer may pickup the next message from the JMS queue,      * while the previous message is being processed asynchronously (by the      * Asynchronous Routing Engine). This means that messages may be processed      * not 100% strictly in order. If disabled (as default) then the Exchange is      * fully processed before the JmsConsumer will pickup the next message from      * the JMS queue. Note if transacted has been enabled, then      * asyncConsumer=true does not run asynchronously, as transaction must be      * executed synchronously (Camel 3.0 may support async transactions).      */
DECL|field|asyncConsumer
specifier|private
name|Boolean
name|asyncConsumer
init|=
literal|false
decl_stmt|;
comment|/**      * Whether to allow sending messages with no body. If this option is false      * and the message body is null, then an JMSException is thrown.      */
DECL|field|allowNullBody
specifier|private
name|Boolean
name|allowNullBody
init|=
literal|true
decl_stmt|;
comment|/**      * Only applicable when sending to JMS destination using InOnly (eg fire and      * forget). Enabling this option will enrich the Camel Exchange with the      * actual JMSMessageID that was used by the JMS client when the message was      * sent to the JMS destination.      */
DECL|field|includeSentJMSMessageID
specifier|private
name|Boolean
name|includeSentJMSMessageID
init|=
literal|false
decl_stmt|;
comment|/**      * Whether to include all JMSXxxx properties when mapping from JMS to Camel      * Message. Setting this to true will include properties such as JMSXAppID,      * and JMSXUserID etc. Note: If you are using a custom headerFilterStrategy      * then this option does not apply.      */
DECL|field|includeAllJMSXProperties
specifier|private
name|Boolean
name|includeAllJMSXProperties
init|=
literal|false
decl_stmt|;
comment|/**      * Specifies what default TaskExecutor type to use in the      * DefaultMessageListenerContainer, for both consumer endpoints and the      * ReplyTo consumer of producer endpoints. Possible values: SimpleAsync      * (uses Spring's SimpleAsyncTaskExecutor) or ThreadPool (uses Spring's      * ThreadPoolTaskExecutor with optimal values - cached threadpool-like). If      * not set, it defaults to the previous behaviour, which uses a cached      * thread pool for consumer endpoints and SimpleAsync for reply consumers.      * The use of ThreadPool is recommended to reduce thread trash in elastic      * configurations with dynamically increasing and decreasing concurrent      * consumers.      */
DECL|field|defaultTaskExecutorType
specifier|private
name|DefaultTaskExecutorType
name|defaultTaskExecutorType
decl_stmt|;
comment|/**      * Pluggable strategy for encoding and decoding JMS keys so they can be      * compliant with the JMS specification. Camel provides two implementations      * out of the box: default and passthrough. The default strategy will safely      * marshal dots and hyphens (. and -). The passthrough strategy leaves the      * key as is. Can be used for JMS brokers which do not care whether JMS      * header keys contain illegal characters. You can provide your own      * implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy      * and refer to it using the notation. The option is a      * org.apache.camel.component.jms.JmsKeyFormatStrategy type.      */
DECL|field|jmsKeyFormatStrategy
specifier|private
name|String
name|jmsKeyFormatStrategy
decl_stmt|;
comment|/**      * This option is used to allow additional headers which may have values      * that are invalid according to JMS specification. For example some message      * systems such as WMQ do this with header names using prefix JMS_IBM_MQMD_      * containing values with byte array or other invalid types. You can specify      * multiple header names separated by comma, and use as suffix for wildcard      * matching.      */
DECL|field|allowAdditionalHeaders
specifier|private
name|String
name|allowAdditionalHeaders
decl_stmt|;
comment|/**      * To use a custom QueueBrowseStrategy when browsing queues. The option is a      * org.apache.camel.component.jms.QueueBrowseStrategy type.      */
DECL|field|queueBrowseStrategy
specifier|private
name|String
name|queueBrowseStrategy
decl_stmt|;
comment|/**      * To use the given MessageCreatedStrategy which are invoked when Camel      * creates new instances of javax.jms.Message objects when Camel is sending      * a JMS message. The option is a      * org.apache.camel.component.jms.MessageCreatedStrategy type.      */
DECL|field|messageCreatedStrategy
specifier|private
name|String
name|messageCreatedStrategy
decl_stmt|;
comment|/**      * Number of times to wait for provisional correlation id to be updated to      * the actual correlation id when doing request/reply over JMS and when the      * option useMessageIDAsCorrelationID is enabled.      */
DECL|field|waitForProvisionCorrelationToBeUpdatedCounter
specifier|private
name|Integer
name|waitForProvisionCorrelationToBeUpdatedCounter
init|=
literal|50
decl_stmt|;
comment|/**      * Interval in millis to sleep each time while waiting for provisional      * correlation id to be updated.      */
DECL|field|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
specifier|private
name|Long
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
init|=
literal|100L
decl_stmt|;
comment|/**      * Use this JMS property to correlate messages in InOut exchange pattern      * (request-reply) instead of JMSCorrelationID property. This allows you to      * exchange messages with systems that do not correlate messages using      * JMSCorrelationID JMS property. If used JMSCorrelationID will not be used      * or set by Camel. The value of here named property will be generated if      * not supplied in the header of the message under the same name.      */
DECL|field|correlationProperty
specifier|private
name|String
name|correlationProperty
decl_stmt|;
comment|/**      * Set whether to make the subscription durable. The durable subscription      * name to be used can be specified through the subscriptionName property.      * Default is false. Set this to true to register a durable subscription,      * typically in combination with a subscriptionName value (unless your      * message listener class name is good enough as subscription name). Only      * makes sense when listening to a topic (pub-sub domain), therefore this      * method switches the pubSubDomain flag as well.      */
DECL|field|subscriptionDurable
specifier|private
name|Boolean
name|subscriptionDurable
init|=
literal|false
decl_stmt|;
comment|/**      * Set whether to make the subscription shared. The shared subscription name      * to be used can be specified through the subscriptionName property.      * Default is false. Set this to true to register a shared subscription,      * typically in combination with a subscriptionName value (unless your      * message listener class name is good enough as subscription name). Note      * that shared subscriptions may also be durable, so this flag can (and      * often will) be combined with subscriptionDurable as well. Only makes      * sense when listening to a topic (pub-sub domain), therefore this method      * switches the pubSubDomain flag as well. Requires a JMS 2.0 compatible      * message broker.      */
DECL|field|subscriptionShared
specifier|private
name|Boolean
name|subscriptionShared
init|=
literal|false
decl_stmt|;
comment|/**      * Set the name of a subscription to create. To be applied in case of a      * topic (pub-sub domain) with a shared or durable subscription. The      * subscription name needs to be unique within this client's JMS client id.      * Default is the class name of the specified message listener. Note: Only 1      * concurrent consumer (which is the default of this message listener      * container) is allowed for each subscription, except for a shared      * subscription (which requires JMS 2.0).      */
DECL|field|subscriptionName
specifier|private
name|String
name|subscriptionName
decl_stmt|;
comment|/**      * Sets whether StreamMessage type is enabled or not. Message payloads of      * streaming kind such as files, InputStream, etc will either by sent as      * BytesMessage or StreamMessage. This option controls which kind will be      * used. By default BytesMessage is used which enforces the entire message      * payload to be read into memory. By enabling this option the message      * payload is read into memory in chunks and each chunk is then written to      * the StreamMessage until no more data.      */
DECL|field|streamMessageTypeEnabled
specifier|private
name|Boolean
name|streamMessageTypeEnabled
init|=
literal|false
decl_stmt|;
comment|/**      * Sets whether date headers should be formatted according to the ISO 8601      * standard.      */
DECL|field|formatDateHeadersToIso8601
specifier|private
name|Boolean
name|formatDateHeadersToIso8601
init|=
literal|false
decl_stmt|;
comment|/**      * To use a custom org.apache.camel.spi.HeaderFilterStrategy to filter      * header to and from Camel message. The option is a      * org.apache.camel.spi.HeaderFilterStrategy type.      */
DECL|field|headerFilterStrategy
specifier|private
name|String
name|headerFilterStrategy
decl_stmt|;
comment|/**      * Whether the component should resolve property placeholders on itself when      * starting. Only properties which are of String type can use property      * placeholders.      */
DECL|field|resolvePropertyPlaceholders
specifier|private
name|Boolean
name|resolvePropertyPlaceholders
init|=
literal|true
decl_stmt|;
DECL|method|getConfiguration ()
specifier|public
name|String
name|getConfiguration
parameter_list|()
block|{
return|return
name|configuration
return|;
block|}
DECL|method|setConfiguration (String configuration)
specifier|public
name|void
name|setConfiguration
parameter_list|(
name|String
name|configuration
parameter_list|)
block|{
name|this
operator|.
name|configuration
operator|=
name|configuration
expr_stmt|;
block|}
DECL|method|getAcceptMessagesWhileStopping ()
specifier|public
name|Boolean
name|getAcceptMessagesWhileStopping
parameter_list|()
block|{
return|return
name|acceptMessagesWhileStopping
return|;
block|}
DECL|method|setAcceptMessagesWhileStopping ( Boolean acceptMessagesWhileStopping)
specifier|public
name|void
name|setAcceptMessagesWhileStopping
parameter_list|(
name|Boolean
name|acceptMessagesWhileStopping
parameter_list|)
block|{
name|this
operator|.
name|acceptMessagesWhileStopping
operator|=
name|acceptMessagesWhileStopping
expr_stmt|;
block|}
DECL|method|getAllowReplyManagerQuickStop ()
specifier|public
name|Boolean
name|getAllowReplyManagerQuickStop
parameter_list|()
block|{
return|return
name|allowReplyManagerQuickStop
return|;
block|}
DECL|method|setAllowReplyManagerQuickStop (Boolean allowReplyManagerQuickStop)
specifier|public
name|void
name|setAllowReplyManagerQuickStop
parameter_list|(
name|Boolean
name|allowReplyManagerQuickStop
parameter_list|)
block|{
name|this
operator|.
name|allowReplyManagerQuickStop
operator|=
name|allowReplyManagerQuickStop
expr_stmt|;
block|}
DECL|method|getAcknowledgementMode ()
specifier|public
name|Integer
name|getAcknowledgementMode
parameter_list|()
block|{
return|return
name|acknowledgementMode
return|;
block|}
DECL|method|setAcknowledgementMode (Integer acknowledgementMode)
specifier|public
name|void
name|setAcknowledgementMode
parameter_list|(
name|Integer
name|acknowledgementMode
parameter_list|)
block|{
name|this
operator|.
name|acknowledgementMode
operator|=
name|acknowledgementMode
expr_stmt|;
block|}
DECL|method|getEagerLoadingOfProperties ()
specifier|public
name|Boolean
name|getEagerLoadingOfProperties
parameter_list|()
block|{
return|return
name|eagerLoadingOfProperties
return|;
block|}
DECL|method|setEagerLoadingOfProperties (Boolean eagerLoadingOfProperties)
specifier|public
name|void
name|setEagerLoadingOfProperties
parameter_list|(
name|Boolean
name|eagerLoadingOfProperties
parameter_list|)
block|{
name|this
operator|.
name|eagerLoadingOfProperties
operator|=
name|eagerLoadingOfProperties
expr_stmt|;
block|}
DECL|method|getAcknowledgementModeName ()
specifier|public
name|String
name|getAcknowledgementModeName
parameter_list|()
block|{
return|return
name|acknowledgementModeName
return|;
block|}
DECL|method|setAcknowledgementModeName (String acknowledgementModeName)
specifier|public
name|void
name|setAcknowledgementModeName
parameter_list|(
name|String
name|acknowledgementModeName
parameter_list|)
block|{
name|this
operator|.
name|acknowledgementModeName
operator|=
name|acknowledgementModeName
expr_stmt|;
block|}
DECL|method|getAutoStartup ()
specifier|public
name|Boolean
name|getAutoStartup
parameter_list|()
block|{
return|return
name|autoStartup
return|;
block|}
DECL|method|setAutoStartup (Boolean autoStartup)
specifier|public
name|void
name|setAutoStartup
parameter_list|(
name|Boolean
name|autoStartup
parameter_list|)
block|{
name|this
operator|.
name|autoStartup
operator|=
name|autoStartup
expr_stmt|;
block|}
DECL|method|getCacheLevel ()
specifier|public
name|Integer
name|getCacheLevel
parameter_list|()
block|{
return|return
name|cacheLevel
return|;
block|}
DECL|method|setCacheLevel (Integer cacheLevel)
specifier|public
name|void
name|setCacheLevel
parameter_list|(
name|Integer
name|cacheLevel
parameter_list|)
block|{
name|this
operator|.
name|cacheLevel
operator|=
name|cacheLevel
expr_stmt|;
block|}
DECL|method|getCacheLevelName ()
specifier|public
name|String
name|getCacheLevelName
parameter_list|()
block|{
return|return
name|cacheLevelName
return|;
block|}
DECL|method|setCacheLevelName (String cacheLevelName)
specifier|public
name|void
name|setCacheLevelName
parameter_list|(
name|String
name|cacheLevelName
parameter_list|)
block|{
name|this
operator|.
name|cacheLevelName
operator|=
name|cacheLevelName
expr_stmt|;
block|}
DECL|method|getReplyToCacheLevelName ()
specifier|public
name|String
name|getReplyToCacheLevelName
parameter_list|()
block|{
return|return
name|replyToCacheLevelName
return|;
block|}
DECL|method|setReplyToCacheLevelName (String replyToCacheLevelName)
specifier|public
name|void
name|setReplyToCacheLevelName
parameter_list|(
name|String
name|replyToCacheLevelName
parameter_list|)
block|{
name|this
operator|.
name|replyToCacheLevelName
operator|=
name|replyToCacheLevelName
expr_stmt|;
block|}
DECL|method|getClientId ()
specifier|public
name|String
name|getClientId
parameter_list|()
block|{
return|return
name|clientId
return|;
block|}
DECL|method|setClientId (String clientId)
specifier|public
name|void
name|setClientId
parameter_list|(
name|String
name|clientId
parameter_list|)
block|{
name|this
operator|.
name|clientId
operator|=
name|clientId
expr_stmt|;
block|}
DECL|method|getConcurrentConsumers ()
specifier|public
name|Integer
name|getConcurrentConsumers
parameter_list|()
block|{
return|return
name|concurrentConsumers
return|;
block|}
DECL|method|setConcurrentConsumers (Integer concurrentConsumers)
specifier|public
name|void
name|setConcurrentConsumers
parameter_list|(
name|Integer
name|concurrentConsumers
parameter_list|)
block|{
name|this
operator|.
name|concurrentConsumers
operator|=
name|concurrentConsumers
expr_stmt|;
block|}
DECL|method|getReplyToConcurrentConsumers ()
specifier|public
name|Integer
name|getReplyToConcurrentConsumers
parameter_list|()
block|{
return|return
name|replyToConcurrentConsumers
return|;
block|}
DECL|method|setReplyToConcurrentConsumers (Integer replyToConcurrentConsumers)
specifier|public
name|void
name|setReplyToConcurrentConsumers
parameter_list|(
name|Integer
name|replyToConcurrentConsumers
parameter_list|)
block|{
name|this
operator|.
name|replyToConcurrentConsumers
operator|=
name|replyToConcurrentConsumers
expr_stmt|;
block|}
DECL|method|getConnectionFactory ()
specifier|public
name|String
name|getConnectionFactory
parameter_list|()
block|{
return|return
name|connectionFactory
return|;
block|}
DECL|method|setConnectionFactory (String connectionFactory)
specifier|public
name|void
name|setConnectionFactory
parameter_list|(
name|String
name|connectionFactory
parameter_list|)
block|{
name|this
operator|.
name|connectionFactory
operator|=
name|connectionFactory
expr_stmt|;
block|}
DECL|method|getUsername ()
specifier|public
name|String
name|getUsername
parameter_list|()
block|{
return|return
name|username
return|;
block|}
DECL|method|setUsername (String username)
specifier|public
name|void
name|setUsername
parameter_list|(
name|String
name|username
parameter_list|)
block|{
name|this
operator|.
name|username
operator|=
name|username
expr_stmt|;
block|}
DECL|method|getPassword ()
specifier|public
name|String
name|getPassword
parameter_list|()
block|{
return|return
name|password
return|;
block|}
DECL|method|setPassword (String password)
specifier|public
name|void
name|setPassword
parameter_list|(
name|String
name|password
parameter_list|)
block|{
name|this
operator|.
name|password
operator|=
name|password
expr_stmt|;
block|}
DECL|method|getDeliveryPersistent ()
specifier|public
name|Boolean
name|getDeliveryPersistent
parameter_list|()
block|{
return|return
name|deliveryPersistent
return|;
block|}
DECL|method|setDeliveryPersistent (Boolean deliveryPersistent)
specifier|public
name|void
name|setDeliveryPersistent
parameter_list|(
name|Boolean
name|deliveryPersistent
parameter_list|)
block|{
name|this
operator|.
name|deliveryPersistent
operator|=
name|deliveryPersistent
expr_stmt|;
block|}
DECL|method|getDeliveryMode ()
specifier|public
name|Integer
name|getDeliveryMode
parameter_list|()
block|{
return|return
name|deliveryMode
return|;
block|}
DECL|method|setDeliveryMode (Integer deliveryMode)
specifier|public
name|void
name|setDeliveryMode
parameter_list|(
name|Integer
name|deliveryMode
parameter_list|)
block|{
name|this
operator|.
name|deliveryMode
operator|=
name|deliveryMode
expr_stmt|;
block|}
DECL|method|getDurableSubscriptionName ()
specifier|public
name|String
name|getDurableSubscriptionName
parameter_list|()
block|{
return|return
name|durableSubscriptionName
return|;
block|}
DECL|method|setDurableSubscriptionName (String durableSubscriptionName)
specifier|public
name|void
name|setDurableSubscriptionName
parameter_list|(
name|String
name|durableSubscriptionName
parameter_list|)
block|{
name|this
operator|.
name|durableSubscriptionName
operator|=
name|durableSubscriptionName
expr_stmt|;
block|}
DECL|method|getExceptionListener ()
specifier|public
name|String
name|getExceptionListener
parameter_list|()
block|{
return|return
name|exceptionListener
return|;
block|}
DECL|method|setExceptionListener (String exceptionListener)
specifier|public
name|void
name|setExceptionListener
parameter_list|(
name|String
name|exceptionListener
parameter_list|)
block|{
name|this
operator|.
name|exceptionListener
operator|=
name|exceptionListener
expr_stmt|;
block|}
DECL|method|getErrorHandler ()
specifier|public
name|String
name|getErrorHandler
parameter_list|()
block|{
return|return
name|errorHandler
return|;
block|}
DECL|method|setErrorHandler (String errorHandler)
specifier|public
name|void
name|setErrorHandler
parameter_list|(
name|String
name|errorHandler
parameter_list|)
block|{
name|this
operator|.
name|errorHandler
operator|=
name|errorHandler
expr_stmt|;
block|}
DECL|method|getErrorHandlerLoggingLevel ()
specifier|public
name|LoggingLevel
name|getErrorHandlerLoggingLevel
parameter_list|()
block|{
return|return
name|errorHandlerLoggingLevel
return|;
block|}
DECL|method|setErrorHandlerLoggingLevel ( LoggingLevel errorHandlerLoggingLevel)
specifier|public
name|void
name|setErrorHandlerLoggingLevel
parameter_list|(
name|LoggingLevel
name|errorHandlerLoggingLevel
parameter_list|)
block|{
name|this
operator|.
name|errorHandlerLoggingLevel
operator|=
name|errorHandlerLoggingLevel
expr_stmt|;
block|}
DECL|method|getErrorHandlerLogStackTrace ()
specifier|public
name|Boolean
name|getErrorHandlerLogStackTrace
parameter_list|()
block|{
return|return
name|errorHandlerLogStackTrace
return|;
block|}
DECL|method|setErrorHandlerLogStackTrace (Boolean errorHandlerLogStackTrace)
specifier|public
name|void
name|setErrorHandlerLogStackTrace
parameter_list|(
name|Boolean
name|errorHandlerLogStackTrace
parameter_list|)
block|{
name|this
operator|.
name|errorHandlerLogStackTrace
operator|=
name|errorHandlerLogStackTrace
expr_stmt|;
block|}
DECL|method|getExplicitQosEnabled ()
specifier|public
name|Boolean
name|getExplicitQosEnabled
parameter_list|()
block|{
return|return
name|explicitQosEnabled
return|;
block|}
DECL|method|setExplicitQosEnabled (Boolean explicitQosEnabled)
specifier|public
name|void
name|setExplicitQosEnabled
parameter_list|(
name|Boolean
name|explicitQosEnabled
parameter_list|)
block|{
name|this
operator|.
name|explicitQosEnabled
operator|=
name|explicitQosEnabled
expr_stmt|;
block|}
DECL|method|getExposeListenerSession ()
specifier|public
name|Boolean
name|getExposeListenerSession
parameter_list|()
block|{
return|return
name|exposeListenerSession
return|;
block|}
DECL|method|setExposeListenerSession (Boolean exposeListenerSession)
specifier|public
name|void
name|setExposeListenerSession
parameter_list|(
name|Boolean
name|exposeListenerSession
parameter_list|)
block|{
name|this
operator|.
name|exposeListenerSession
operator|=
name|exposeListenerSession
expr_stmt|;
block|}
DECL|method|getIdleTaskExecutionLimit ()
specifier|public
name|Integer
name|getIdleTaskExecutionLimit
parameter_list|()
block|{
return|return
name|idleTaskExecutionLimit
return|;
block|}
DECL|method|setIdleTaskExecutionLimit (Integer idleTaskExecutionLimit)
specifier|public
name|void
name|setIdleTaskExecutionLimit
parameter_list|(
name|Integer
name|idleTaskExecutionLimit
parameter_list|)
block|{
name|this
operator|.
name|idleTaskExecutionLimit
operator|=
name|idleTaskExecutionLimit
expr_stmt|;
block|}
DECL|method|getIdleConsumerLimit ()
specifier|public
name|Integer
name|getIdleConsumerLimit
parameter_list|()
block|{
return|return
name|idleConsumerLimit
return|;
block|}
DECL|method|setIdleConsumerLimit (Integer idleConsumerLimit)
specifier|public
name|void
name|setIdleConsumerLimit
parameter_list|(
name|Integer
name|idleConsumerLimit
parameter_list|)
block|{
name|this
operator|.
name|idleConsumerLimit
operator|=
name|idleConsumerLimit
expr_stmt|;
block|}
DECL|method|getMaxConcurrentConsumers ()
specifier|public
name|Integer
name|getMaxConcurrentConsumers
parameter_list|()
block|{
return|return
name|maxConcurrentConsumers
return|;
block|}
DECL|method|setMaxConcurrentConsumers (Integer maxConcurrentConsumers)
specifier|public
name|void
name|setMaxConcurrentConsumers
parameter_list|(
name|Integer
name|maxConcurrentConsumers
parameter_list|)
block|{
name|this
operator|.
name|maxConcurrentConsumers
operator|=
name|maxConcurrentConsumers
expr_stmt|;
block|}
DECL|method|getReplyToMaxConcurrentConsumers ()
specifier|public
name|Integer
name|getReplyToMaxConcurrentConsumers
parameter_list|()
block|{
return|return
name|replyToMaxConcurrentConsumers
return|;
block|}
DECL|method|setReplyToMaxConcurrentConsumers ( Integer replyToMaxConcurrentConsumers)
specifier|public
name|void
name|setReplyToMaxConcurrentConsumers
parameter_list|(
name|Integer
name|replyToMaxConcurrentConsumers
parameter_list|)
block|{
name|this
operator|.
name|replyToMaxConcurrentConsumers
operator|=
name|replyToMaxConcurrentConsumers
expr_stmt|;
block|}
DECL|method|getReplyOnTimeoutToMaxConcurrentConsumers ()
specifier|public
name|Integer
name|getReplyOnTimeoutToMaxConcurrentConsumers
parameter_list|()
block|{
return|return
name|replyOnTimeoutToMaxConcurrentConsumers
return|;
block|}
DECL|method|setReplyOnTimeoutToMaxConcurrentConsumers ( Integer replyOnTimeoutToMaxConcurrentConsumers)
specifier|public
name|void
name|setReplyOnTimeoutToMaxConcurrentConsumers
parameter_list|(
name|Integer
name|replyOnTimeoutToMaxConcurrentConsumers
parameter_list|)
block|{
name|this
operator|.
name|replyOnTimeoutToMaxConcurrentConsumers
operator|=
name|replyOnTimeoutToMaxConcurrentConsumers
expr_stmt|;
block|}
DECL|method|getMaxMessagesPerTask ()
specifier|public
name|Integer
name|getMaxMessagesPerTask
parameter_list|()
block|{
return|return
name|maxMessagesPerTask
return|;
block|}
DECL|method|setMaxMessagesPerTask (Integer maxMessagesPerTask)
specifier|public
name|void
name|setMaxMessagesPerTask
parameter_list|(
name|Integer
name|maxMessagesPerTask
parameter_list|)
block|{
name|this
operator|.
name|maxMessagesPerTask
operator|=
name|maxMessagesPerTask
expr_stmt|;
block|}
DECL|method|getMessageConverter ()
specifier|public
name|String
name|getMessageConverter
parameter_list|()
block|{
return|return
name|messageConverter
return|;
block|}
DECL|method|setMessageConverter (String messageConverter)
specifier|public
name|void
name|setMessageConverter
parameter_list|(
name|String
name|messageConverter
parameter_list|)
block|{
name|this
operator|.
name|messageConverter
operator|=
name|messageConverter
expr_stmt|;
block|}
DECL|method|getMapJmsMessage ()
specifier|public
name|Boolean
name|getMapJmsMessage
parameter_list|()
block|{
return|return
name|mapJmsMessage
return|;
block|}
DECL|method|setMapJmsMessage (Boolean mapJmsMessage)
specifier|public
name|void
name|setMapJmsMessage
parameter_list|(
name|Boolean
name|mapJmsMessage
parameter_list|)
block|{
name|this
operator|.
name|mapJmsMessage
operator|=
name|mapJmsMessage
expr_stmt|;
block|}
DECL|method|getMessageIdEnabled ()
specifier|public
name|Boolean
name|getMessageIdEnabled
parameter_list|()
block|{
return|return
name|messageIdEnabled
return|;
block|}
DECL|method|setMessageIdEnabled (Boolean messageIdEnabled)
specifier|public
name|void
name|setMessageIdEnabled
parameter_list|(
name|Boolean
name|messageIdEnabled
parameter_list|)
block|{
name|this
operator|.
name|messageIdEnabled
operator|=
name|messageIdEnabled
expr_stmt|;
block|}
DECL|method|getMessageTimestampEnabled ()
specifier|public
name|Boolean
name|getMessageTimestampEnabled
parameter_list|()
block|{
return|return
name|messageTimestampEnabled
return|;
block|}
DECL|method|setMessageTimestampEnabled (Boolean messageTimestampEnabled)
specifier|public
name|void
name|setMessageTimestampEnabled
parameter_list|(
name|Boolean
name|messageTimestampEnabled
parameter_list|)
block|{
name|this
operator|.
name|messageTimestampEnabled
operator|=
name|messageTimestampEnabled
expr_stmt|;
block|}
DECL|method|getAlwaysCopyMessage ()
specifier|public
name|Boolean
name|getAlwaysCopyMessage
parameter_list|()
block|{
return|return
name|alwaysCopyMessage
return|;
block|}
DECL|method|setAlwaysCopyMessage (Boolean alwaysCopyMessage)
specifier|public
name|void
name|setAlwaysCopyMessage
parameter_list|(
name|Boolean
name|alwaysCopyMessage
parameter_list|)
block|{
name|this
operator|.
name|alwaysCopyMessage
operator|=
name|alwaysCopyMessage
expr_stmt|;
block|}
DECL|method|getUseMessageIDAsCorrelationID ()
specifier|public
name|Boolean
name|getUseMessageIDAsCorrelationID
parameter_list|()
block|{
return|return
name|useMessageIDAsCorrelationID
return|;
block|}
DECL|method|setUseMessageIDAsCorrelationID ( Boolean useMessageIDAsCorrelationID)
specifier|public
name|void
name|setUseMessageIDAsCorrelationID
parameter_list|(
name|Boolean
name|useMessageIDAsCorrelationID
parameter_list|)
block|{
name|this
operator|.
name|useMessageIDAsCorrelationID
operator|=
name|useMessageIDAsCorrelationID
expr_stmt|;
block|}
DECL|method|getPriority ()
specifier|public
name|Integer
name|getPriority
parameter_list|()
block|{
return|return
name|priority
return|;
block|}
DECL|method|setPriority (Integer priority)
specifier|public
name|void
name|setPriority
parameter_list|(
name|Integer
name|priority
parameter_list|)
block|{
name|this
operator|.
name|priority
operator|=
name|priority
expr_stmt|;
block|}
DECL|method|getPubSubNoLocal ()
specifier|public
name|Boolean
name|getPubSubNoLocal
parameter_list|()
block|{
return|return
name|pubSubNoLocal
return|;
block|}
DECL|method|setPubSubNoLocal (Boolean pubSubNoLocal)
specifier|public
name|void
name|setPubSubNoLocal
parameter_list|(
name|Boolean
name|pubSubNoLocal
parameter_list|)
block|{
name|this
operator|.
name|pubSubNoLocal
operator|=
name|pubSubNoLocal
expr_stmt|;
block|}
DECL|method|getReceiveTimeout ()
specifier|public
name|Long
name|getReceiveTimeout
parameter_list|()
block|{
return|return
name|receiveTimeout
return|;
block|}
DECL|method|setReceiveTimeout (Long receiveTimeout)
specifier|public
name|void
name|setReceiveTimeout
parameter_list|(
name|Long
name|receiveTimeout
parameter_list|)
block|{
name|this
operator|.
name|receiveTimeout
operator|=
name|receiveTimeout
expr_stmt|;
block|}
DECL|method|getRecoveryInterval ()
specifier|public
name|Long
name|getRecoveryInterval
parameter_list|()
block|{
return|return
name|recoveryInterval
return|;
block|}
DECL|method|setRecoveryInterval (Long recoveryInterval)
specifier|public
name|void
name|setRecoveryInterval
parameter_list|(
name|Long
name|recoveryInterval
parameter_list|)
block|{
name|this
operator|.
name|recoveryInterval
operator|=
name|recoveryInterval
expr_stmt|;
block|}
DECL|method|getTaskExecutor ()
specifier|public
name|String
name|getTaskExecutor
parameter_list|()
block|{
return|return
name|taskExecutor
return|;
block|}
DECL|method|setTaskExecutor (String taskExecutor)
specifier|public
name|void
name|setTaskExecutor
parameter_list|(
name|String
name|taskExecutor
parameter_list|)
block|{
name|this
operator|.
name|taskExecutor
operator|=
name|taskExecutor
expr_stmt|;
block|}
DECL|method|getTimeToLive ()
specifier|public
name|Long
name|getTimeToLive
parameter_list|()
block|{
return|return
name|timeToLive
return|;
block|}
DECL|method|setTimeToLive (Long timeToLive)
specifier|public
name|void
name|setTimeToLive
parameter_list|(
name|Long
name|timeToLive
parameter_list|)
block|{
name|this
operator|.
name|timeToLive
operator|=
name|timeToLive
expr_stmt|;
block|}
DECL|method|getTransacted ()
specifier|public
name|Boolean
name|getTransacted
parameter_list|()
block|{
return|return
name|transacted
return|;
block|}
DECL|method|setTransacted (Boolean transacted)
specifier|public
name|void
name|setTransacted
parameter_list|(
name|Boolean
name|transacted
parameter_list|)
block|{
name|this
operator|.
name|transacted
operator|=
name|transacted
expr_stmt|;
block|}
DECL|method|getLazyCreateTransactionManager ()
specifier|public
name|Boolean
name|getLazyCreateTransactionManager
parameter_list|()
block|{
return|return
name|lazyCreateTransactionManager
return|;
block|}
DECL|method|setLazyCreateTransactionManager ( Boolean lazyCreateTransactionManager)
specifier|public
name|void
name|setLazyCreateTransactionManager
parameter_list|(
name|Boolean
name|lazyCreateTransactionManager
parameter_list|)
block|{
name|this
operator|.
name|lazyCreateTransactionManager
operator|=
name|lazyCreateTransactionManager
expr_stmt|;
block|}
DECL|method|getTransactionManager ()
specifier|public
name|String
name|getTransactionManager
parameter_list|()
block|{
return|return
name|transactionManager
return|;
block|}
DECL|method|setTransactionManager (String transactionManager)
specifier|public
name|void
name|setTransactionManager
parameter_list|(
name|String
name|transactionManager
parameter_list|)
block|{
name|this
operator|.
name|transactionManager
operator|=
name|transactionManager
expr_stmt|;
block|}
DECL|method|getTransactionName ()
specifier|public
name|String
name|getTransactionName
parameter_list|()
block|{
return|return
name|transactionName
return|;
block|}
DECL|method|setTransactionName (String transactionName)
specifier|public
name|void
name|setTransactionName
parameter_list|(
name|String
name|transactionName
parameter_list|)
block|{
name|this
operator|.
name|transactionName
operator|=
name|transactionName
expr_stmt|;
block|}
DECL|method|getTransactionTimeout ()
specifier|public
name|Integer
name|getTransactionTimeout
parameter_list|()
block|{
return|return
name|transactionTimeout
return|;
block|}
DECL|method|setTransactionTimeout (Integer transactionTimeout)
specifier|public
name|void
name|setTransactionTimeout
parameter_list|(
name|Integer
name|transactionTimeout
parameter_list|)
block|{
name|this
operator|.
name|transactionTimeout
operator|=
name|transactionTimeout
expr_stmt|;
block|}
DECL|method|getTestConnectionOnStartup ()
specifier|public
name|Boolean
name|getTestConnectionOnStartup
parameter_list|()
block|{
return|return
name|testConnectionOnStartup
return|;
block|}
DECL|method|setTestConnectionOnStartup (Boolean testConnectionOnStartup)
specifier|public
name|void
name|setTestConnectionOnStartup
parameter_list|(
name|Boolean
name|testConnectionOnStartup
parameter_list|)
block|{
name|this
operator|.
name|testConnectionOnStartup
operator|=
name|testConnectionOnStartup
expr_stmt|;
block|}
DECL|method|getAsyncStartListener ()
specifier|public
name|Boolean
name|getAsyncStartListener
parameter_list|()
block|{
return|return
name|asyncStartListener
return|;
block|}
DECL|method|setAsyncStartListener (Boolean asyncStartListener)
specifier|public
name|void
name|setAsyncStartListener
parameter_list|(
name|Boolean
name|asyncStartListener
parameter_list|)
block|{
name|this
operator|.
name|asyncStartListener
operator|=
name|asyncStartListener
expr_stmt|;
block|}
DECL|method|getAsyncStopListener ()
specifier|public
name|Boolean
name|getAsyncStopListener
parameter_list|()
block|{
return|return
name|asyncStopListener
return|;
block|}
DECL|method|setAsyncStopListener (Boolean asyncStopListener)
specifier|public
name|void
name|setAsyncStopListener
parameter_list|(
name|Boolean
name|asyncStopListener
parameter_list|)
block|{
name|this
operator|.
name|asyncStopListener
operator|=
name|asyncStopListener
expr_stmt|;
block|}
DECL|method|getForceSendOriginalMessage ()
specifier|public
name|Boolean
name|getForceSendOriginalMessage
parameter_list|()
block|{
return|return
name|forceSendOriginalMessage
return|;
block|}
DECL|method|setForceSendOriginalMessage (Boolean forceSendOriginalMessage)
specifier|public
name|void
name|setForceSendOriginalMessage
parameter_list|(
name|Boolean
name|forceSendOriginalMessage
parameter_list|)
block|{
name|this
operator|.
name|forceSendOriginalMessage
operator|=
name|forceSendOriginalMessage
expr_stmt|;
block|}
DECL|method|getRequestTimeout ()
specifier|public
name|Long
name|getRequestTimeout
parameter_list|()
block|{
return|return
name|requestTimeout
return|;
block|}
DECL|method|setRequestTimeout (Long requestTimeout)
specifier|public
name|void
name|setRequestTimeout
parameter_list|(
name|Long
name|requestTimeout
parameter_list|)
block|{
name|this
operator|.
name|requestTimeout
operator|=
name|requestTimeout
expr_stmt|;
block|}
DECL|method|getRequestTimeoutCheckerInterval ()
specifier|public
name|Long
name|getRequestTimeoutCheckerInterval
parameter_list|()
block|{
return|return
name|requestTimeoutCheckerInterval
return|;
block|}
DECL|method|setRequestTimeoutCheckerInterval ( Long requestTimeoutCheckerInterval)
specifier|public
name|void
name|setRequestTimeoutCheckerInterval
parameter_list|(
name|Long
name|requestTimeoutCheckerInterval
parameter_list|)
block|{
name|this
operator|.
name|requestTimeoutCheckerInterval
operator|=
name|requestTimeoutCheckerInterval
expr_stmt|;
block|}
DECL|method|getTransferExchange ()
specifier|public
name|Boolean
name|getTransferExchange
parameter_list|()
block|{
return|return
name|transferExchange
return|;
block|}
DECL|method|setTransferExchange (Boolean transferExchange)
specifier|public
name|void
name|setTransferExchange
parameter_list|(
name|Boolean
name|transferExchange
parameter_list|)
block|{
name|this
operator|.
name|transferExchange
operator|=
name|transferExchange
expr_stmt|;
block|}
DECL|method|getTransferException ()
specifier|public
name|Boolean
name|getTransferException
parameter_list|()
block|{
return|return
name|transferException
return|;
block|}
DECL|method|setTransferException (Boolean transferException)
specifier|public
name|void
name|setTransferException
parameter_list|(
name|Boolean
name|transferException
parameter_list|)
block|{
name|this
operator|.
name|transferException
operator|=
name|transferException
expr_stmt|;
block|}
DECL|method|getTransferFault ()
specifier|public
name|Boolean
name|getTransferFault
parameter_list|()
block|{
return|return
name|transferFault
return|;
block|}
DECL|method|setTransferFault (Boolean transferFault)
specifier|public
name|void
name|setTransferFault
parameter_list|(
name|Boolean
name|transferFault
parameter_list|)
block|{
name|this
operator|.
name|transferFault
operator|=
name|transferFault
expr_stmt|;
block|}
DECL|method|getJmsOperations ()
specifier|public
name|String
name|getJmsOperations
parameter_list|()
block|{
return|return
name|jmsOperations
return|;
block|}
DECL|method|setJmsOperations (String jmsOperations)
specifier|public
name|void
name|setJmsOperations
parameter_list|(
name|String
name|jmsOperations
parameter_list|)
block|{
name|this
operator|.
name|jmsOperations
operator|=
name|jmsOperations
expr_stmt|;
block|}
DECL|method|getDestinationResolver ()
specifier|public
name|String
name|getDestinationResolver
parameter_list|()
block|{
return|return
name|destinationResolver
return|;
block|}
DECL|method|setDestinationResolver (String destinationResolver)
specifier|public
name|void
name|setDestinationResolver
parameter_list|(
name|String
name|destinationResolver
parameter_list|)
block|{
name|this
operator|.
name|destinationResolver
operator|=
name|destinationResolver
expr_stmt|;
block|}
DECL|method|getReplyToType ()
specifier|public
name|ReplyToType
name|getReplyToType
parameter_list|()
block|{
return|return
name|replyToType
return|;
block|}
DECL|method|setReplyToType (ReplyToType replyToType)
specifier|public
name|void
name|setReplyToType
parameter_list|(
name|ReplyToType
name|replyToType
parameter_list|)
block|{
name|this
operator|.
name|replyToType
operator|=
name|replyToType
expr_stmt|;
block|}
DECL|method|getPreserveMessageQos ()
specifier|public
name|Boolean
name|getPreserveMessageQos
parameter_list|()
block|{
return|return
name|preserveMessageQos
return|;
block|}
DECL|method|setPreserveMessageQos (Boolean preserveMessageQos)
specifier|public
name|void
name|setPreserveMessageQos
parameter_list|(
name|Boolean
name|preserveMessageQos
parameter_list|)
block|{
name|this
operator|.
name|preserveMessageQos
operator|=
name|preserveMessageQos
expr_stmt|;
block|}
DECL|method|getAsyncConsumer ()
specifier|public
name|Boolean
name|getAsyncConsumer
parameter_list|()
block|{
return|return
name|asyncConsumer
return|;
block|}
DECL|method|setAsyncConsumer (Boolean asyncConsumer)
specifier|public
name|void
name|setAsyncConsumer
parameter_list|(
name|Boolean
name|asyncConsumer
parameter_list|)
block|{
name|this
operator|.
name|asyncConsumer
operator|=
name|asyncConsumer
expr_stmt|;
block|}
DECL|method|getAllowNullBody ()
specifier|public
name|Boolean
name|getAllowNullBody
parameter_list|()
block|{
return|return
name|allowNullBody
return|;
block|}
DECL|method|setAllowNullBody (Boolean allowNullBody)
specifier|public
name|void
name|setAllowNullBody
parameter_list|(
name|Boolean
name|allowNullBody
parameter_list|)
block|{
name|this
operator|.
name|allowNullBody
operator|=
name|allowNullBody
expr_stmt|;
block|}
DECL|method|getIncludeSentJMSMessageID ()
specifier|public
name|Boolean
name|getIncludeSentJMSMessageID
parameter_list|()
block|{
return|return
name|includeSentJMSMessageID
return|;
block|}
DECL|method|setIncludeSentJMSMessageID (Boolean includeSentJMSMessageID)
specifier|public
name|void
name|setIncludeSentJMSMessageID
parameter_list|(
name|Boolean
name|includeSentJMSMessageID
parameter_list|)
block|{
name|this
operator|.
name|includeSentJMSMessageID
operator|=
name|includeSentJMSMessageID
expr_stmt|;
block|}
DECL|method|getIncludeAllJMSXProperties ()
specifier|public
name|Boolean
name|getIncludeAllJMSXProperties
parameter_list|()
block|{
return|return
name|includeAllJMSXProperties
return|;
block|}
DECL|method|setIncludeAllJMSXProperties (Boolean includeAllJMSXProperties)
specifier|public
name|void
name|setIncludeAllJMSXProperties
parameter_list|(
name|Boolean
name|includeAllJMSXProperties
parameter_list|)
block|{
name|this
operator|.
name|includeAllJMSXProperties
operator|=
name|includeAllJMSXProperties
expr_stmt|;
block|}
DECL|method|getDefaultTaskExecutorType ()
specifier|public
name|DefaultTaskExecutorType
name|getDefaultTaskExecutorType
parameter_list|()
block|{
return|return
name|defaultTaskExecutorType
return|;
block|}
DECL|method|setDefaultTaskExecutorType ( DefaultTaskExecutorType defaultTaskExecutorType)
specifier|public
name|void
name|setDefaultTaskExecutorType
parameter_list|(
name|DefaultTaskExecutorType
name|defaultTaskExecutorType
parameter_list|)
block|{
name|this
operator|.
name|defaultTaskExecutorType
operator|=
name|defaultTaskExecutorType
expr_stmt|;
block|}
DECL|method|getJmsKeyFormatStrategy ()
specifier|public
name|String
name|getJmsKeyFormatStrategy
parameter_list|()
block|{
return|return
name|jmsKeyFormatStrategy
return|;
block|}
DECL|method|setJmsKeyFormatStrategy (String jmsKeyFormatStrategy)
specifier|public
name|void
name|setJmsKeyFormatStrategy
parameter_list|(
name|String
name|jmsKeyFormatStrategy
parameter_list|)
block|{
name|this
operator|.
name|jmsKeyFormatStrategy
operator|=
name|jmsKeyFormatStrategy
expr_stmt|;
block|}
DECL|method|getAllowAdditionalHeaders ()
specifier|public
name|String
name|getAllowAdditionalHeaders
parameter_list|()
block|{
return|return
name|allowAdditionalHeaders
return|;
block|}
DECL|method|setAllowAdditionalHeaders (String allowAdditionalHeaders)
specifier|public
name|void
name|setAllowAdditionalHeaders
parameter_list|(
name|String
name|allowAdditionalHeaders
parameter_list|)
block|{
name|this
operator|.
name|allowAdditionalHeaders
operator|=
name|allowAdditionalHeaders
expr_stmt|;
block|}
DECL|method|getQueueBrowseStrategy ()
specifier|public
name|String
name|getQueueBrowseStrategy
parameter_list|()
block|{
return|return
name|queueBrowseStrategy
return|;
block|}
DECL|method|setQueueBrowseStrategy (String queueBrowseStrategy)
specifier|public
name|void
name|setQueueBrowseStrategy
parameter_list|(
name|String
name|queueBrowseStrategy
parameter_list|)
block|{
name|this
operator|.
name|queueBrowseStrategy
operator|=
name|queueBrowseStrategy
expr_stmt|;
block|}
DECL|method|getMessageCreatedStrategy ()
specifier|public
name|String
name|getMessageCreatedStrategy
parameter_list|()
block|{
return|return
name|messageCreatedStrategy
return|;
block|}
DECL|method|setMessageCreatedStrategy (String messageCreatedStrategy)
specifier|public
name|void
name|setMessageCreatedStrategy
parameter_list|(
name|String
name|messageCreatedStrategy
parameter_list|)
block|{
name|this
operator|.
name|messageCreatedStrategy
operator|=
name|messageCreatedStrategy
expr_stmt|;
block|}
DECL|method|getWaitForProvisionCorrelationToBeUpdatedCounter ()
specifier|public
name|Integer
name|getWaitForProvisionCorrelationToBeUpdatedCounter
parameter_list|()
block|{
return|return
name|waitForProvisionCorrelationToBeUpdatedCounter
return|;
block|}
DECL|method|setWaitForProvisionCorrelationToBeUpdatedCounter ( Integer waitForProvisionCorrelationToBeUpdatedCounter)
specifier|public
name|void
name|setWaitForProvisionCorrelationToBeUpdatedCounter
parameter_list|(
name|Integer
name|waitForProvisionCorrelationToBeUpdatedCounter
parameter_list|)
block|{
name|this
operator|.
name|waitForProvisionCorrelationToBeUpdatedCounter
operator|=
name|waitForProvisionCorrelationToBeUpdatedCounter
expr_stmt|;
block|}
DECL|method|getWaitForProvisionCorrelationToBeUpdatedThreadSleepingTime ()
specifier|public
name|Long
name|getWaitForProvisionCorrelationToBeUpdatedThreadSleepingTime
parameter_list|()
block|{
return|return
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
return|;
block|}
DECL|method|setWaitForProvisionCorrelationToBeUpdatedThreadSleepingTime ( Long waitForProvisionCorrelationToBeUpdatedThreadSleepingTime)
specifier|public
name|void
name|setWaitForProvisionCorrelationToBeUpdatedThreadSleepingTime
parameter_list|(
name|Long
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
parameter_list|)
block|{
name|this
operator|.
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
operator|=
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
expr_stmt|;
block|}
DECL|method|getCorrelationProperty ()
specifier|public
name|String
name|getCorrelationProperty
parameter_list|()
block|{
return|return
name|correlationProperty
return|;
block|}
DECL|method|setCorrelationProperty (String correlationProperty)
specifier|public
name|void
name|setCorrelationProperty
parameter_list|(
name|String
name|correlationProperty
parameter_list|)
block|{
name|this
operator|.
name|correlationProperty
operator|=
name|correlationProperty
expr_stmt|;
block|}
DECL|method|getSubscriptionDurable ()
specifier|public
name|Boolean
name|getSubscriptionDurable
parameter_list|()
block|{
return|return
name|subscriptionDurable
return|;
block|}
DECL|method|setSubscriptionDurable (Boolean subscriptionDurable)
specifier|public
name|void
name|setSubscriptionDurable
parameter_list|(
name|Boolean
name|subscriptionDurable
parameter_list|)
block|{
name|this
operator|.
name|subscriptionDurable
operator|=
name|subscriptionDurable
expr_stmt|;
block|}
DECL|method|getSubscriptionShared ()
specifier|public
name|Boolean
name|getSubscriptionShared
parameter_list|()
block|{
return|return
name|subscriptionShared
return|;
block|}
DECL|method|setSubscriptionShared (Boolean subscriptionShared)
specifier|public
name|void
name|setSubscriptionShared
parameter_list|(
name|Boolean
name|subscriptionShared
parameter_list|)
block|{
name|this
operator|.
name|subscriptionShared
operator|=
name|subscriptionShared
expr_stmt|;
block|}
DECL|method|getSubscriptionName ()
specifier|public
name|String
name|getSubscriptionName
parameter_list|()
block|{
return|return
name|subscriptionName
return|;
block|}
DECL|method|setSubscriptionName (String subscriptionName)
specifier|public
name|void
name|setSubscriptionName
parameter_list|(
name|String
name|subscriptionName
parameter_list|)
block|{
name|this
operator|.
name|subscriptionName
operator|=
name|subscriptionName
expr_stmt|;
block|}
DECL|method|getStreamMessageTypeEnabled ()
specifier|public
name|Boolean
name|getStreamMessageTypeEnabled
parameter_list|()
block|{
return|return
name|streamMessageTypeEnabled
return|;
block|}
DECL|method|setStreamMessageTypeEnabled (Boolean streamMessageTypeEnabled)
specifier|public
name|void
name|setStreamMessageTypeEnabled
parameter_list|(
name|Boolean
name|streamMessageTypeEnabled
parameter_list|)
block|{
name|this
operator|.
name|streamMessageTypeEnabled
operator|=
name|streamMessageTypeEnabled
expr_stmt|;
block|}
DECL|method|getFormatDateHeadersToIso8601 ()
specifier|public
name|Boolean
name|getFormatDateHeadersToIso8601
parameter_list|()
block|{
return|return
name|formatDateHeadersToIso8601
return|;
block|}
DECL|method|setFormatDateHeadersToIso8601 (Boolean formatDateHeadersToIso8601)
specifier|public
name|void
name|setFormatDateHeadersToIso8601
parameter_list|(
name|Boolean
name|formatDateHeadersToIso8601
parameter_list|)
block|{
name|this
operator|.
name|formatDateHeadersToIso8601
operator|=
name|formatDateHeadersToIso8601
expr_stmt|;
block|}
DECL|method|getHeaderFilterStrategy ()
specifier|public
name|String
name|getHeaderFilterStrategy
parameter_list|()
block|{
return|return
name|headerFilterStrategy
return|;
block|}
DECL|method|setHeaderFilterStrategy (String headerFilterStrategy)
specifier|public
name|void
name|setHeaderFilterStrategy
parameter_list|(
name|String
name|headerFilterStrategy
parameter_list|)
block|{
name|this
operator|.
name|headerFilterStrategy
operator|=
name|headerFilterStrategy
expr_stmt|;
block|}
DECL|method|getResolvePropertyPlaceholders ()
specifier|public
name|Boolean
name|getResolvePropertyPlaceholders
parameter_list|()
block|{
return|return
name|resolvePropertyPlaceholders
return|;
block|}
DECL|method|setResolvePropertyPlaceholders ( Boolean resolvePropertyPlaceholders)
specifier|public
name|void
name|setResolvePropertyPlaceholders
parameter_list|(
name|Boolean
name|resolvePropertyPlaceholders
parameter_list|)
block|{
name|this
operator|.
name|resolvePropertyPlaceholders
operator|=
name|resolvePropertyPlaceholders
expr_stmt|;
block|}
block|}
end_class

end_unit

