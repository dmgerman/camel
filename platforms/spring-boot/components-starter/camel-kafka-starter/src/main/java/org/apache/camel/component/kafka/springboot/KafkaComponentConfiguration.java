begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.component.kafka.springboot
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|kafka
operator|.
name|springboot
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Generated
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|kafka
operator|.
name|serde
operator|.
name|KafkaHeaderDeserializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|kafka
operator|.
name|serde
operator|.
name|KafkaHeaderSerializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|HeaderFilterStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|StateRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spring
operator|.
name|boot
operator|.
name|ComponentConfigurationPropertiesCommon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|jsse
operator|.
name|SSLContextParameters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|springframework
operator|.
name|boot
operator|.
name|context
operator|.
name|properties
operator|.
name|ConfigurationProperties
import|;
end_import

begin_comment
comment|/**  * The kafka component allows messages to be sent to (or consumed from) Apache  * Kafka brokers.  *   * Generated by camel-package-maven-plugin - do not edit this file!  */
end_comment

begin_class
annotation|@
name|Generated
argument_list|(
literal|"org.apache.camel.maven.packaging.SpringBootAutoConfigurationMojo"
argument_list|)
annotation|@
name|ConfigurationProperties
argument_list|(
name|prefix
operator|=
literal|"camel.component.kafka"
argument_list|)
DECL|class|KafkaComponentConfiguration
specifier|public
class|class
name|KafkaComponentConfiguration
extends|extends
name|ComponentConfigurationPropertiesCommon
block|{
comment|/**      * Whether to enable auto configuration of the kafka component. This is      * enabled by default.      */
DECL|field|enabled
specifier|private
name|Boolean
name|enabled
decl_stmt|;
comment|/**      * Allows to pre-configure the Kafka component with common options that the      * endpoints will reuse.      */
DECL|field|configuration
specifier|private
name|KafkaConfigurationNestedConfiguration
name|configuration
decl_stmt|;
comment|/**      * URL of the Kafka brokers to use. The format is host1:port1,host2:port2,      * and the list can be a subset of brokers or a VIP pointing to a subset of      * brokers. This option is known as bootstrap.servers in the Kafka      * documentation.      */
DECL|field|brokers
specifier|private
name|String
name|brokers
decl_stmt|;
comment|/**      * To use a shared custom worker pool for continue routing Exchange after      * kafka server has acknowledge the message that was sent to it from      * KafkaProducer using asynchronous non-blocking processing. If using this      * option then you must handle the lifecycle of the thread pool to shut the      * pool down when no longer needed. The option is a      * java.util.concurrent.ExecutorService type.      */
DECL|field|workerPool
specifier|private
name|String
name|workerPool
decl_stmt|;
comment|/**      * Enable usage of global SSL context parameters.      */
DECL|field|useGlobalSslContextParameters
specifier|private
name|Boolean
name|useGlobalSslContextParameters
init|=
literal|false
decl_stmt|;
comment|/**      * This options controls what happens when a consumer is processing an      * exchange and it fails. If the option is false then the consumer continues      * to the next message and processes it. If the option is true then the      * consumer breaks out, and will seek back to offset of the message that      * caused a failure, and then re-attempt to process this message. However      * this can lead to endless processing of the same message if its bound to      * fail every time, eg a poison message. Therefore its recommended to deal      * with that for example by using Camel's error handler.      */
DECL|field|breakOnFirstError
specifier|private
name|Boolean
name|breakOnFirstError
init|=
literal|false
decl_stmt|;
comment|/**      * Whether to allow doing manual commits via KafkaManualCommit. If this      * option is enabled then an instance of KafkaManualCommit is stored on the      * Exchange message header, which allows end users to access this API and      * perform manual offset commits via the Kafka consumer.      */
DECL|field|allowManualCommit
specifier|private
name|Boolean
name|allowManualCommit
init|=
literal|false
decl_stmt|;
comment|/**      * Factory to use for creating KafkaManualCommit instances. This allows to      * plugin a custom factory to create custom KafkaManualCommit instances in      * case special logic is needed when doing manual commits that deviates from      * the default implementation that comes out of the box. The option is a      * org.apache.camel.component.kafka.KafkaManualCommitFactory type.      */
DECL|field|kafkaManualCommitFactory
specifier|private
name|String
name|kafkaManualCommitFactory
decl_stmt|;
comment|/**      * Whether the component should resolve property placeholders on itself when      * starting. Only properties which are of String type can use property      * placeholders.      */
DECL|field|resolvePropertyPlaceholders
specifier|private
name|Boolean
name|resolvePropertyPlaceholders
init|=
literal|true
decl_stmt|;
DECL|method|getConfiguration ()
specifier|public
name|KafkaConfigurationNestedConfiguration
name|getConfiguration
parameter_list|()
block|{
return|return
name|configuration
return|;
block|}
DECL|method|setConfiguration ( KafkaConfigurationNestedConfiguration configuration)
specifier|public
name|void
name|setConfiguration
parameter_list|(
name|KafkaConfigurationNestedConfiguration
name|configuration
parameter_list|)
block|{
name|this
operator|.
name|configuration
operator|=
name|configuration
expr_stmt|;
block|}
DECL|method|getBrokers ()
specifier|public
name|String
name|getBrokers
parameter_list|()
block|{
return|return
name|brokers
return|;
block|}
DECL|method|setBrokers (String brokers)
specifier|public
name|void
name|setBrokers
parameter_list|(
name|String
name|brokers
parameter_list|)
block|{
name|this
operator|.
name|brokers
operator|=
name|brokers
expr_stmt|;
block|}
DECL|method|getWorkerPool ()
specifier|public
name|String
name|getWorkerPool
parameter_list|()
block|{
return|return
name|workerPool
return|;
block|}
DECL|method|setWorkerPool (String workerPool)
specifier|public
name|void
name|setWorkerPool
parameter_list|(
name|String
name|workerPool
parameter_list|)
block|{
name|this
operator|.
name|workerPool
operator|=
name|workerPool
expr_stmt|;
block|}
DECL|method|getUseGlobalSslContextParameters ()
specifier|public
name|Boolean
name|getUseGlobalSslContextParameters
parameter_list|()
block|{
return|return
name|useGlobalSslContextParameters
return|;
block|}
DECL|method|setUseGlobalSslContextParameters ( Boolean useGlobalSslContextParameters)
specifier|public
name|void
name|setUseGlobalSslContextParameters
parameter_list|(
name|Boolean
name|useGlobalSslContextParameters
parameter_list|)
block|{
name|this
operator|.
name|useGlobalSslContextParameters
operator|=
name|useGlobalSslContextParameters
expr_stmt|;
block|}
DECL|method|getBreakOnFirstError ()
specifier|public
name|Boolean
name|getBreakOnFirstError
parameter_list|()
block|{
return|return
name|breakOnFirstError
return|;
block|}
DECL|method|setBreakOnFirstError (Boolean breakOnFirstError)
specifier|public
name|void
name|setBreakOnFirstError
parameter_list|(
name|Boolean
name|breakOnFirstError
parameter_list|)
block|{
name|this
operator|.
name|breakOnFirstError
operator|=
name|breakOnFirstError
expr_stmt|;
block|}
DECL|method|getAllowManualCommit ()
specifier|public
name|Boolean
name|getAllowManualCommit
parameter_list|()
block|{
return|return
name|allowManualCommit
return|;
block|}
DECL|method|setAllowManualCommit (Boolean allowManualCommit)
specifier|public
name|void
name|setAllowManualCommit
parameter_list|(
name|Boolean
name|allowManualCommit
parameter_list|)
block|{
name|this
operator|.
name|allowManualCommit
operator|=
name|allowManualCommit
expr_stmt|;
block|}
DECL|method|getKafkaManualCommitFactory ()
specifier|public
name|String
name|getKafkaManualCommitFactory
parameter_list|()
block|{
return|return
name|kafkaManualCommitFactory
return|;
block|}
DECL|method|setKafkaManualCommitFactory (String kafkaManualCommitFactory)
specifier|public
name|void
name|setKafkaManualCommitFactory
parameter_list|(
name|String
name|kafkaManualCommitFactory
parameter_list|)
block|{
name|this
operator|.
name|kafkaManualCommitFactory
operator|=
name|kafkaManualCommitFactory
expr_stmt|;
block|}
DECL|method|getResolvePropertyPlaceholders ()
specifier|public
name|Boolean
name|getResolvePropertyPlaceholders
parameter_list|()
block|{
return|return
name|resolvePropertyPlaceholders
return|;
block|}
DECL|method|setResolvePropertyPlaceholders ( Boolean resolvePropertyPlaceholders)
specifier|public
name|void
name|setResolvePropertyPlaceholders
parameter_list|(
name|Boolean
name|resolvePropertyPlaceholders
parameter_list|)
block|{
name|this
operator|.
name|resolvePropertyPlaceholders
operator|=
name|resolvePropertyPlaceholders
expr_stmt|;
block|}
DECL|class|KafkaConfigurationNestedConfiguration
specifier|public
specifier|static
class|class
name|KafkaConfigurationNestedConfiguration
block|{
DECL|field|CAMEL_NESTED_CLASS
specifier|public
specifier|static
specifier|final
name|Class
name|CAMEL_NESTED_CLASS
init|=
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|kafka
operator|.
name|KafkaConfiguration
operator|.
name|class
decl_stmt|;
comment|/**          * Whether the topic is a pattern (regular expression). This can be used          * to subscribe to dynamic number of topics matching the pattern.          */
DECL|field|topicIsPattern
specifier|private
name|Boolean
name|topicIsPattern
init|=
literal|false
decl_stmt|;
comment|/**          * A string that uniquely identifies the group of consumer processes to          * which this consumer belongs. By setting the same group id multiple          * processes indicate that they are all part of the same consumer group.          * This option is required for consumers.          */
DECL|field|groupId
specifier|private
name|String
name|groupId
decl_stmt|;
comment|/**          * If the option is true, then KafkaProducer will ignore the          * KafkaConstants.TOPIC header setting of the inbound message.          */
DECL|field|bridgeEndpoint
specifier|private
name|Boolean
name|bridgeEndpoint
init|=
literal|false
decl_stmt|;
comment|/**          * If the option is true, then KafkaProducer will detect if the message          * is attempted to be sent back to the same topic it may come from, if          * the message was original from a kafka consumer. If the          * KafkaConstants.TOPIC header is the same as the original kafka          * consumer topic, then the header setting is ignored, and the topic of          * the producer endpoint is used. In other words this avoids sending the          * same message back to where it came from. This option is not in use if          * the option bridgeEndpoint is set to true.          */
DECL|field|circularTopicDetection
specifier|private
name|Boolean
name|circularTopicDetection
init|=
literal|true
decl_stmt|;
comment|/**          * The partitioner class for partitioning messages amongst sub-topics.          * The default partitioner is based on the hash of the key.          */
DECL|field|partitioner
specifier|private
name|String
name|partitioner
init|=
literal|"org.apache.kafka.clients.producer.internals.DefaultPartitioner"
decl_stmt|;
comment|/**          * Name of the topic to use. On the consumer you can use comma to          * separate multiple topics. A producer can only send a message to a          * single topic.          */
DECL|field|topic
specifier|private
name|String
name|topic
decl_stmt|;
comment|/**          * Number of concurrent consumers on the consumer          */
DECL|field|consumerStreams
specifier|private
name|Integer
name|consumerStreams
init|=
literal|10
decl_stmt|;
comment|/**          * The number of consumers that connect to kafka server          */
DECL|field|consumersCount
specifier|private
name|Integer
name|consumersCount
init|=
literal|1
decl_stmt|;
comment|/**          * The client id is a user-specified string sent in each request to help          * trace calls. It should logically identify the application making the          * request.          */
DECL|field|clientId
specifier|private
name|String
name|clientId
decl_stmt|;
comment|/**          * If true, periodically commit to ZooKeeper the offset of messages          * already fetched by the consumer. This committed offset will be used          * when the process fails as the position from which the new consumer          * will begin.          */
DECL|field|autoCommitEnable
specifier|private
name|Boolean
name|autoCommitEnable
init|=
literal|true
decl_stmt|;
comment|/**          * Whether to allow doing manual commits via KafkaManualCommit. If this          * option is enabled then an instance of KafkaManualCommit is stored on          * the Exchange message header, which allows end users to access this          * API and perform manual offset commits via the Kafka consumer.          */
DECL|field|allowManualCommit
specifier|private
name|Boolean
name|allowManualCommit
init|=
literal|false
decl_stmt|;
comment|/**          * The offset repository to use in order to locally store the offset of          * each partition of the topic. Defining one will disable the          * autocommit.          */
DECL|field|offsetRepository
specifier|private
name|StateRepository
name|offsetRepository
decl_stmt|;
comment|/**          * The frequency in ms that the consumer offsets are committed to          * zookeeper.          */
DECL|field|autoCommitIntervalMs
specifier|private
name|Integer
name|autoCommitIntervalMs
init|=
literal|5000
decl_stmt|;
comment|/**          * The minimum amount of data the server should return for a fetch          * request. If insufficient data is available the request will wait for          * that much data to accumulate before answering the request.          */
DECL|field|fetchMinBytes
specifier|private
name|Integer
name|fetchMinBytes
init|=
literal|1
decl_stmt|;
comment|/**          * The maximum amount of data the server should return for a fetch          * request This is not an absolute maximum, if the first message in the          * first non-empty partition of the fetch is larger than this value, the          * message will still be returned to ensure that the consumer can make          * progress. The maximum message size accepted by the broker is defined          * via message.max.bytes (broker config) or max.message.bytes (topic          * config). Note that the consumer performs multiple fetches in          * parallel.          */
DECL|field|fetchMaxBytes
specifier|private
name|Integer
name|fetchMaxBytes
init|=
literal|52428800
decl_stmt|;
comment|/**          * The maximum amount of time the server will block before answering the          * fetch request if there isn't sufficient data to immediately satisfy          * fetch.min.bytes          */
DECL|field|fetchWaitMaxMs
specifier|private
name|Integer
name|fetchWaitMaxMs
init|=
literal|500
decl_stmt|;
comment|/**          * What to do when there is no initial offset in ZooKeeper or if an          * offset is out of range: earliest : automatically reset the offset to          * the earliest offset latest : automatically reset the offset to the          * latest offset fail: throw exception to the consumer          */
DECL|field|autoOffsetReset
specifier|private
name|String
name|autoOffsetReset
init|=
literal|"latest"
decl_stmt|;
comment|/**          * Whether to perform an explicit auto commit when the consumer stops to          * ensure the broker has a commit from the last consumed message. This          * requires the option autoCommitEnable is turned on. The possible          * values are: sync, async, or none. And sync is the default value.          */
DECL|field|autoCommitOnStop
specifier|private
name|String
name|autoCommitOnStop
init|=
literal|"sync"
decl_stmt|;
comment|/**          * This options controls what happens when a consumer is processing an          * exchange and it fails. If the option is false then the consumer          * continues to the next message and processes it. If the option is true          * then the consumer breaks out, and will seek back to offset of the          * message that caused a failure, and then re-attempt to process this          * message. However this can lead to endless processing of the same          * message if its bound to fail every time, eg a poison message.          * Therefore its recommended to deal with that for example by using          * Camel's error handler.          */
DECL|field|breakOnFirstError
specifier|private
name|Boolean
name|breakOnFirstError
init|=
literal|false
decl_stmt|;
comment|/**          * URL of the Kafka brokers to use. The format is          * host1:port1,host2:port2, and the list can be a subset of brokers or a          * VIP pointing to a subset of brokers. This option is known as          * bootstrap.servers in the Kafka documentation.          */
DECL|field|brokers
specifier|private
name|String
name|brokers
decl_stmt|;
comment|/**          * URL of the Kafka schema registry to use. The format is          * host1:port1,host2:port2. This option is known as schema.registry.url          * in the Kafka documentation.          */
DECL|field|schemaRegistryURL
specifier|private
name|String
name|schemaRegistryURL
decl_stmt|;
comment|/**          * This parameter allows you to specify the compression codec for all          * data generated by this producer. Valid values are none, gzip and          * snappy.          */
DECL|field|compressionCodec
specifier|private
name|String
name|compressionCodec
init|=
literal|"none"
decl_stmt|;
comment|/**          * Before each retry, the producer refreshes the metadata of relevant          * topics to see if a new leader has been elected. Since leader election          * takes a bit of time, this property specifies the amount of time that          * the producer waits before refreshing the metadata.          */
DECL|field|retryBackoffMs
specifier|private
name|Integer
name|retryBackoffMs
init|=
literal|100
decl_stmt|;
comment|/**          * Socket write buffer size          */
DECL|field|sendBufferBytes
specifier|private
name|Integer
name|sendBufferBytes
init|=
literal|131072
decl_stmt|;
comment|/**          * The amount of time the broker will wait trying to meet the          * request.required.acks requirement before sending back an error to the          * client.          */
DECL|field|requestTimeoutMs
specifier|private
name|Integer
name|requestTimeoutMs
init|=
literal|305000
decl_stmt|;
comment|/**          * The maximum number of unsent messages that can be queued up the          * producer when using async mode before either the producer must be          * blocked or data must be dropped.          */
DECL|field|queueBufferingMaxMessages
specifier|private
name|Integer
name|queueBufferingMaxMessages
init|=
literal|10000
decl_stmt|;
comment|/**          * The serializer class for messages.          */
DECL|field|serializerClass
specifier|private
name|String
name|serializerClass
init|=
literal|"org.apache.kafka.common.serialization.StringSerializer"
decl_stmt|;
comment|/**          * The serializer class for keys (defaults to the same as for messages          * if nothing is given).          */
DECL|field|keySerializerClass
specifier|private
name|String
name|keySerializerClass
init|=
literal|"org.apache.kafka.common.serialization.StringSerializer"
decl_stmt|;
comment|/**          * Kerberos kinit command path. Default is /usr/bin/kinit          */
DECL|field|kerberosInitCmd
specifier|private
name|String
name|kerberosInitCmd
init|=
literal|"/usr/bin/kinit"
decl_stmt|;
comment|/**          * Login thread sleep time between refresh attempts.          */
DECL|field|kerberosBeforeReloginMinTime
specifier|private
name|Integer
name|kerberosBeforeReloginMinTime
init|=
literal|60000
decl_stmt|;
comment|/**          * Percentage of random jitter added to the renewal time.          */
DECL|field|kerberosRenewJitter
specifier|private
name|Double
name|kerberosRenewJitter
decl_stmt|;
comment|/**          * Login thread will sleep until the specified window factor of time          * from last refresh to ticket's expiry has been reached, at which time          * it will try to renew the ticket.          */
DECL|field|kerberosRenewWindowFactor
specifier|private
name|Double
name|kerberosRenewWindowFactor
decl_stmt|;
comment|/**          * A list of rules for mapping from principal names to short names          * (typically operating system usernames). The rules are evaluated in          * order and the first rule that matches a principal name is used to map          * it to a short name. Any later rules in the list are ignored. By          * default, principal names of the form {username}/{hostname}{REALM} are          * mapped to {username}. For more details on the format please see a          * href=\#security_authz\ security authorization and acls. Multiple          * values can be separated by comma          */
DECL|field|kerberosPrincipalToLocalRules
specifier|private
name|String
name|kerberosPrincipalToLocalRules
init|=
literal|"DEFAULT"
decl_stmt|;
comment|/**          * A list of cipher suites. This is a named combination of          * authentication, encryption, MAC and key exchange algorithm used to          * negotiate the security settings for a network connection using TLS or          * SSL network protocol.By default all the available cipher suites are          * supported.          */
DECL|field|sslCipherSuites
specifier|private
name|String
name|sslCipherSuites
decl_stmt|;
comment|/**          * The endpoint identification algorithm to validate server hostname          * using server certificate.          */
DECL|field|sslEndpointAlgorithm
specifier|private
name|String
name|sslEndpointAlgorithm
decl_stmt|;
comment|/**          * The algorithm used by key manager factory for SSL connections.          * Default value is the key manager factory algorithm configured for the          * Java Virtual Machine.          */
DECL|field|sslKeymanagerAlgorithm
specifier|private
name|String
name|sslKeymanagerAlgorithm
init|=
literal|"SunX509"
decl_stmt|;
comment|/**          * The algorithm used by trust manager factory for SSL connections.          * Default value is the trust manager factory algorithm configured for          * the Java Virtual Machine.          */
DECL|field|sslTrustmanagerAlgorithm
specifier|private
name|String
name|sslTrustmanagerAlgorithm
init|=
literal|"PKIX"
decl_stmt|;
comment|/**          * The list of protocols enabled for SSL connections. TLSv1.2, TLSv1.1          * and TLSv1 are enabled by default.          */
DECL|field|sslEnabledProtocols
specifier|private
name|String
name|sslEnabledProtocols
init|=
literal|"TLSv1.2,TLSv1.1,TLSv1"
decl_stmt|;
comment|/**          * The file format of the key store file. This is optional for client.          * Default value is JKS          */
DECL|field|sslKeystoreType
specifier|private
name|String
name|sslKeystoreType
init|=
literal|"JKS"
decl_stmt|;
comment|/**          * The SSL protocol used to generate the SSLContext. Default setting is          * TLS, which is fine for most cases. Allowed values in recent JVMs are          * TLS, TLSv1.1 and TLSv1.2. SSL, SSLv2 and SSLv3 may be supported in          * older JVMs, but their usage is discouraged due to known security          * vulnerabilities.          */
DECL|field|sslProtocol
specifier|private
name|String
name|sslProtocol
init|=
literal|"TLS"
decl_stmt|;
comment|/**          * The name of the security provider used for SSL connections. Default          * value is the default security provider of the JVM.          */
DECL|field|sslProvider
specifier|private
name|String
name|sslProvider
decl_stmt|;
comment|/**          * The file format of the trust store file. Default value is JKS.          */
DECL|field|sslTruststoreType
specifier|private
name|String
name|sslTruststoreType
init|=
literal|"JKS"
decl_stmt|;
comment|/**          * The Kerberos principal name that Kafka runs as. This can be defined          * either in Kafka's JAAS config or in Kafka's config.          */
DECL|field|saslKerberosServiceName
specifier|private
name|String
name|saslKerberosServiceName
decl_stmt|;
comment|/**          * The Simple Authentication and Security Layer (SASL) Mechanism used.          * For the valid values see a href=          * http://www.iana.org/assignments/sasl-          * mechanisms/sasl-mechanisms.xhtmlhttp          * ://www.iana.org/assignments/sasl-mechanisms/sasl-mechanisms.xhtml          */
DECL|field|saslMechanism
specifier|private
name|String
name|saslMechanism
init|=
literal|"GSSAPI"
decl_stmt|;
comment|/**          * Expose the kafka sasl.jaas.config parameter Example:          * org.apache.kafka.common.security.plain.PlainLoginModule required          * username=USERNAME password=PASSWORD;          */
DECL|field|saslJaasConfig
specifier|private
name|String
name|saslJaasConfig
decl_stmt|;
comment|/**          * Protocol used to communicate with brokers. SASL_PLAINTEXT, PLAINTEXT          * and SSL are supported          */
DECL|field|securityProtocol
specifier|private
name|String
name|securityProtocol
init|=
literal|"PLAINTEXT"
decl_stmt|;
comment|/**          * SSL configuration using a Camel SSLContextParameters object. If          * configured it's applied before the other SSL endpoint parameters.          */
DECL|field|sslContextParameters
specifier|private
name|SSLContextParameters
name|sslContextParameters
decl_stmt|;
comment|/**          * The password of the private key in the key store file. This is          * optional for client.          */
DECL|field|sslKeyPassword
specifier|private
name|String
name|sslKeyPassword
decl_stmt|;
comment|/**          * The location of the key store file. This is optional for client and          * can be used for two-way authentication for client.          */
DECL|field|sslKeystoreLocation
specifier|private
name|String
name|sslKeystoreLocation
decl_stmt|;
comment|/**          * The store password for the key store file.This is optional for client          * and only needed if ssl.keystore.location is configured.          */
DECL|field|sslKeystorePassword
specifier|private
name|String
name|sslKeystorePassword
decl_stmt|;
comment|/**          * The location of the trust store file.          */
DECL|field|sslTruststoreLocation
specifier|private
name|String
name|sslTruststoreLocation
decl_stmt|;
comment|/**          * The password for the trust store file.          */
DECL|field|sslTruststorePassword
specifier|private
name|String
name|sslTruststorePassword
decl_stmt|;
comment|/**          * The total bytes of memory the producer can use to buffer records          * waiting to be sent to the server. If records are sent faster than          * they can be delivered to the server the producer will either block or          * throw an exception based on the preference specified by          * block.on.buffer.full.This setting should correspond roughly to the          * total memory the producer will use, but is not a hard bound since not          * all memory the producer uses is used for buffering. Some additional          * memory will be used for compression (if compression is enabled) as          * well as for maintaining in-flight requests.          */
DECL|field|bufferMemorySize
specifier|private
name|Integer
name|bufferMemorySize
init|=
literal|33554432
decl_stmt|;
comment|/**          * The record key (or null if no key is specified). If this option has          * been configured then it take precedence over header          * KafkaConstants#KEY          */
DECL|field|key
specifier|private
name|String
name|key
decl_stmt|;
comment|/**          * The partition to which the record will be sent (or null if no          * partition was specified). If this option has been configured then it          * take precedence over header KafkaConstants#PARTITION_KEY          */
DECL|field|partitionKey
specifier|private
name|Integer
name|partitionKey
decl_stmt|;
comment|/**          * The number of acknowledgments the producer requires the leader to          * have received before considering a request complete. This controls          * the durability of records that are sent. The following settings are          * common: acks=0 If set to zero then the producer will not wait for any          * acknowledgment from the server at all. The record will be immediately          * added to the socket buffer and considered sent. No guarantee can be          * made that the server has received the record in this case, and the          * retries configuration will not take effect (as the client won't          * generally know of any failures). The offset given back for each          * record will always be set to -1. acks=1 This will mean the leader          * will write the record to its local log but will respond without          * awaiting full acknowledgement from all followers. In this case should          * the leader fail immediately after acknowledging the record but before          * the followers have replicated it then the record will be lost.          * acks=all This means the leader will wait for the full set of in-sync          * replicas to acknowledge the record. This guarantees that the record          * will not be lost as long as at least one in-sync replica remains          * alive. This is the strongest available guarantee.          */
DECL|field|requestRequiredAcks
specifier|private
name|String
name|requestRequiredAcks
init|=
literal|"1"
decl_stmt|;
comment|/**          * Setting a value greater than zero will cause the client to resend any          * record whose send fails with a potentially transient error. Note that          * this retry is no different than if the client resent the record upon          * receiving the error. Allowing retries will potentially change the          * ordering of records because if two records are sent to a single          * partition, and the first fails and is retried but the second          * succeeds, then the second record may appear first.          */
DECL|field|retries
specifier|private
name|Integer
name|retries
init|=
literal|0
decl_stmt|;
comment|/**          * The producer will attempt to batch records together into fewer          * requests whenever multiple records are being sent to the same          * partition. This helps performance on both the client and the server.          * This configuration controls the default batch size in bytes. No          * attempt will be made to batch records larger than this size.Requests          * sent to brokers will contain multiple batches, one for each partition          * with data available to be sent.A small batch size will make batching          * less common and may reduce throughput (a batch size of zero will          * disable batching entirely). A very large batch size may use memory a          * bit more wastefully as we will always allocate a buffer of the          * specified batch size in anticipation of additional records.          */
DECL|field|producerBatchSize
specifier|private
name|Integer
name|producerBatchSize
init|=
literal|16384
decl_stmt|;
comment|/**          * Close idle connections after the number of milliseconds specified by          * this config.          */
DECL|field|connectionMaxIdleMs
specifier|private
name|Integer
name|connectionMaxIdleMs
init|=
literal|540000
decl_stmt|;
comment|/**          * The producer groups together any records that arrive in between          * request transmissions into a single batched request. Normally this          * occurs only under load when records arrive faster than they can be          * sent out. However in some circumstances the client may want to reduce          * the number of requests even under moderate load. This setting          * accomplishes this by adding a small amount of artificial delaythat          * is, rather than immediately sending out a record the producer will          * wait for up to the given delay to allow other records to be sent so          * that the sends can be batched together. This can be thought of as          * analogous to Nagle's algorithm in TCP. This setting gives the upper          * bound on the delay for batching: once we get batch.size worth of          * records for a partition it will be sent immediately regardless of          * this setting, however if we have fewer than this many bytes          * accumulated for this partition we will 'linger' for the specified          * time waiting for more records to show up. This setting defaults to 0          * (i.e. no delay). Setting linger.ms=5, for example, would have the          * effect of reducing the number of requests sent but would add up to          * 5ms of latency to records sent in the absense of load.          */
DECL|field|lingerMs
specifier|private
name|Integer
name|lingerMs
init|=
literal|0
decl_stmt|;
comment|/**          * The configuration controls how long sending to kafka will block.          * These methods can be blocked for multiple reasons. For e.g: buffer          * full, metadata unavailable.This configuration imposes maximum limit          * on the total time spent in fetching metadata, serialization of key          * and value, partitioning and allocation of buffer memory when doing a          * send(). In case of partitionsFor(), this configuration imposes a          * maximum time threshold on waiting for metadata          */
DECL|field|maxBlockMs
specifier|private
name|Integer
name|maxBlockMs
init|=
literal|60000
decl_stmt|;
comment|/**          * The maximum size of a request. This is also effectively a cap on the          * maximum record size. Note that the server has its own cap on record          * size which may be different from this. This setting will limit the          * number of record batches the producer will send in a single request          * to avoid sending huge requests.          */
DECL|field|maxRequestSize
specifier|private
name|Integer
name|maxRequestSize
init|=
literal|1048576
decl_stmt|;
comment|/**          * The size of the TCP receive buffer (SO_RCVBUF) to use when reading          * data.          */
DECL|field|receiveBufferBytes
specifier|private
name|Integer
name|receiveBufferBytes
init|=
literal|65536
decl_stmt|;
comment|/**          * The maximum number of unacknowledged requests the client will send on          * a single connection before blocking. Note that if this setting is set          * to be greater than 1 and there are failed sends, there is a risk of          * message re-ordering due to retries (i.e., if retries are enabled).          */
DECL|field|maxInFlightRequest
specifier|private
name|Integer
name|maxInFlightRequest
init|=
literal|5
decl_stmt|;
comment|/**          * The period of time in milliseconds after which we force a refresh of          * metadata even if we haven't seen any partition leadership changes to          * proactively discover any new brokers or partitions.          */
DECL|field|metadataMaxAgeMs
specifier|private
name|Integer
name|metadataMaxAgeMs
init|=
literal|300000
decl_stmt|;
comment|/**          * A list of classes to use as metrics reporters. Implementing the          * MetricReporter interface allows plugging in classes that will be          * notified of new metric creation. The JmxReporter is always included          * to register JMX statistics.          */
DECL|field|metricReporters
specifier|private
name|String
name|metricReporters
decl_stmt|;
comment|/**          * The number of samples maintained to compute metrics.          */
DECL|field|noOfMetricsSample
specifier|private
name|Integer
name|noOfMetricsSample
init|=
literal|2
decl_stmt|;
comment|/**          * The number of samples maintained to compute metrics.          */
DECL|field|metricsSampleWindowMs
specifier|private
name|Integer
name|metricsSampleWindowMs
init|=
literal|30000
decl_stmt|;
comment|/**          * The amount of time to wait before attempting to reconnect to a given          * host. This avoids repeatedly connecting to a host in a tight loop.          * This backoff applies to all requests sent by the consumer to the          * broker.          */
DECL|field|reconnectBackoffMs
specifier|private
name|Integer
name|reconnectBackoffMs
init|=
literal|50
decl_stmt|;
comment|/**          * The expected time between heartbeats to the consumer coordinator when          * using Kafka's group management facilities. Heartbeats are used to          * ensure that the consumer's session stays active and to facilitate          * rebalancing when new consumers join or leave the group. The value          * must be set lower than session.timeout.ms, but typically should be          * set no higher than 1/3 of that value. It can be adjusted even lower          * to control the expected time for normal rebalances.          */
DECL|field|heartbeatIntervalMs
specifier|private
name|Integer
name|heartbeatIntervalMs
init|=
literal|3000
decl_stmt|;
comment|/**          * The maximum amount of data per-partition the server will return. The          * maximum total memory used for a request will be #partitions          * max.partition.fetch.bytes. This size must be at least as large as the          * maximum message size the server allows or else it is possible for the          * producer to send messages larger than the consumer can fetch. If that          * happens, the consumer can get stuck trying to fetch a large message          * on a certain partition.          */
DECL|field|maxPartitionFetchBytes
specifier|private
name|Integer
name|maxPartitionFetchBytes
init|=
literal|1048576
decl_stmt|;
comment|/**          * The timeout used to detect failures when using Kafka's group          * management facilities.          */
DECL|field|sessionTimeoutMs
specifier|private
name|Integer
name|sessionTimeoutMs
init|=
literal|10000
decl_stmt|;
comment|/**          * The maximum number of records returned in a single call to poll()          */
DECL|field|maxPollRecords
specifier|private
name|Integer
name|maxPollRecords
init|=
literal|500
decl_stmt|;
comment|/**          * The timeout used when polling the KafkaConsumer.          */
DECL|field|pollTimeoutMs
specifier|private
name|Long
name|pollTimeoutMs
init|=
literal|5000L
decl_stmt|;
comment|/**          * The maximum delay between invocations of poll() when using consumer          * group management. This places an upper bound on the amount of time          * that the consumer can be idle before fetching more records. If poll()          * is not called before expiration of this timeout, then the consumer is          * considered failed and the group will rebalance in order to reassign          * the partitions to another member.          */
DECL|field|maxPollIntervalMs
specifier|private
name|Long
name|maxPollIntervalMs
decl_stmt|;
comment|/**          * The class name of the partition assignment strategy that the client          * will use to distribute partition ownership amongst consumer instances          * when group management is used          */
DECL|field|partitionAssignor
specifier|private
name|String
name|partitionAssignor
init|=
literal|"org.apache.kafka.clients.consumer.RangeAssignor"
decl_stmt|;
comment|/**          * The configuration controls the maximum amount of time the client will          * wait for the response of a request. If the response is not received          * before the timeout elapses the client will resend the request if          * necessary or fail the request if retries are exhausted.          */
DECL|field|consumerRequestTimeoutMs
specifier|private
name|Integer
name|consumerRequestTimeoutMs
init|=
literal|40000
decl_stmt|;
comment|/**          * Automatically check the CRC32 of the records consumed. This ensures          * no on-the-wire or on-disk corruption to the messages occurred. This          * check adds some overhead, so it may be disabled in cases seeking          * extreme performance.          */
DECL|field|checkCrcs
specifier|private
name|Boolean
name|checkCrcs
init|=
literal|true
decl_stmt|;
comment|/**          * Deserializer class for key that implements the Deserializer          * interface.          */
DECL|field|keyDeserializer
specifier|private
name|String
name|keyDeserializer
init|=
literal|"org.apache.kafka.common.serialization.StringDeserializer"
decl_stmt|;
comment|/**          * Deserializer class for value that implements the Deserializer          * interface.          */
DECL|field|valueDeserializer
specifier|private
name|String
name|valueDeserializer
init|=
literal|"org.apache.kafka.common.serialization.StringDeserializer"
decl_stmt|;
comment|/**          * Set if KafkaConsumer will read from beginning or end on startup:          * beginning : read from beginning end : read from end This is replacing          * the earlier property seekToBeginning          */
DECL|field|seekTo
specifier|private
name|String
name|seekTo
decl_stmt|;
comment|/**          * To use a custom worker pool for continue routing Exchange after kafka          * server has acknowledge the message that was sent to it from          * KafkaProducer using asynchronous non-blocking processing.          */
DECL|field|workerPool
specifier|private
name|ExecutorService
name|workerPool
decl_stmt|;
comment|/**          * Number of core threads for the worker pool for continue routing          * Exchange after kafka server has acknowledge the message that was sent          * to it from KafkaProducer using asynchronous non-blocking processing.          */
DECL|field|workerPoolCoreSize
specifier|private
name|Integer
name|workerPoolCoreSize
init|=
literal|10
decl_stmt|;
comment|/**          * Maximum number of threads for the worker pool for continue routing          * Exchange after kafka server has acknowledge the message that was sent          * to it from KafkaProducer using asynchronous non-blocking processing.          */
DECL|field|workerPoolMaxSize
specifier|private
name|Integer
name|workerPoolMaxSize
init|=
literal|20
decl_stmt|;
comment|/**          * Whether the producer should store the RecordMetadata results from          * sending to Kafka. The results are stored in a List containing the          * RecordMetadata metadata's. The list is stored on a header with the          * key KafkaConstants#KAFKA_RECORDMETA          */
DECL|field|recordMetadata
specifier|private
name|Boolean
name|recordMetadata
init|=
literal|true
decl_stmt|;
comment|/**          * Sets interceptors for producer or consumers. Producer interceptors          * have to be classes implementing          * org.apache.kafka.clients.producer.ProducerInterceptor Consumer          * interceptors have to be classes implementing          * org.apache.kafka.clients.consumer.ConsumerInterceptor Note that if          * you use Producer interceptor on a consumer it will throw a class cast          * exception in runtime          */
DECL|field|interceptorClasses
specifier|private
name|String
name|interceptorClasses
decl_stmt|;
comment|/**          * If set to 'true' the producer will ensure that exactly one copy of          * each message is written in the stream. If 'false', producer retries          * may write duplicates of the retried message in the stream. If set to          * true this option will require max.in.flight.requests.per.connection          * to be set to 1 and retries cannot be zero and additionally acks must          * be set to 'all'.          */
DECL|field|enableIdempotence
specifier|private
name|Boolean
name|enableIdempotence
init|=
literal|false
decl_stmt|;
comment|/**          * The maximum amount of time in milliseconds to wait when reconnecting          * to a broker that has repeatedly failed to connect. If provided, the          * backoff per host will increase exponentially for each consecutive          * connection failure, up to this maximum. After calculating the backoff          * increase, 20% random jitter is added to avoid connection storms.          */
DECL|field|reconnectBackoffMaxMs
specifier|private
name|Integer
name|reconnectBackoffMaxMs
init|=
literal|1000
decl_stmt|;
comment|/**          * To use a custom HeaderFilterStrategy to filter header to and from          * Camel message.          */
DECL|field|headerFilterStrategy
specifier|private
name|HeaderFilterStrategy
name|headerFilterStrategy
decl_stmt|;
comment|/**          * Sets custom KafkaHeaderDeserializer for deserialization kafka headers          * values to camel headers values.          */
DECL|field|kafkaHeaderDeserializer
specifier|private
name|KafkaHeaderDeserializer
name|kafkaHeaderDeserializer
decl_stmt|;
comment|/**          * Sets custom KafkaHeaderDeserializer for serialization camel headers          * values to kafka headers values.          */
DECL|field|kafkaHeaderSerializer
specifier|private
name|KafkaHeaderSerializer
name|kafkaHeaderSerializer
decl_stmt|;
DECL|method|getTopicIsPattern ()
specifier|public
name|Boolean
name|getTopicIsPattern
parameter_list|()
block|{
return|return
name|topicIsPattern
return|;
block|}
DECL|method|setTopicIsPattern (Boolean topicIsPattern)
specifier|public
name|void
name|setTopicIsPattern
parameter_list|(
name|Boolean
name|topicIsPattern
parameter_list|)
block|{
name|this
operator|.
name|topicIsPattern
operator|=
name|topicIsPattern
expr_stmt|;
block|}
DECL|method|getGroupId ()
specifier|public
name|String
name|getGroupId
parameter_list|()
block|{
return|return
name|groupId
return|;
block|}
DECL|method|setGroupId (String groupId)
specifier|public
name|void
name|setGroupId
parameter_list|(
name|String
name|groupId
parameter_list|)
block|{
name|this
operator|.
name|groupId
operator|=
name|groupId
expr_stmt|;
block|}
DECL|method|getBridgeEndpoint ()
specifier|public
name|Boolean
name|getBridgeEndpoint
parameter_list|()
block|{
return|return
name|bridgeEndpoint
return|;
block|}
DECL|method|setBridgeEndpoint (Boolean bridgeEndpoint)
specifier|public
name|void
name|setBridgeEndpoint
parameter_list|(
name|Boolean
name|bridgeEndpoint
parameter_list|)
block|{
name|this
operator|.
name|bridgeEndpoint
operator|=
name|bridgeEndpoint
expr_stmt|;
block|}
DECL|method|getCircularTopicDetection ()
specifier|public
name|Boolean
name|getCircularTopicDetection
parameter_list|()
block|{
return|return
name|circularTopicDetection
return|;
block|}
DECL|method|setCircularTopicDetection (Boolean circularTopicDetection)
specifier|public
name|void
name|setCircularTopicDetection
parameter_list|(
name|Boolean
name|circularTopicDetection
parameter_list|)
block|{
name|this
operator|.
name|circularTopicDetection
operator|=
name|circularTopicDetection
expr_stmt|;
block|}
DECL|method|getPartitioner ()
specifier|public
name|String
name|getPartitioner
parameter_list|()
block|{
return|return
name|partitioner
return|;
block|}
DECL|method|setPartitioner (String partitioner)
specifier|public
name|void
name|setPartitioner
parameter_list|(
name|String
name|partitioner
parameter_list|)
block|{
name|this
operator|.
name|partitioner
operator|=
name|partitioner
expr_stmt|;
block|}
DECL|method|getTopic ()
specifier|public
name|String
name|getTopic
parameter_list|()
block|{
return|return
name|topic
return|;
block|}
DECL|method|setTopic (String topic)
specifier|public
name|void
name|setTopic
parameter_list|(
name|String
name|topic
parameter_list|)
block|{
name|this
operator|.
name|topic
operator|=
name|topic
expr_stmt|;
block|}
DECL|method|getConsumerStreams ()
specifier|public
name|Integer
name|getConsumerStreams
parameter_list|()
block|{
return|return
name|consumerStreams
return|;
block|}
DECL|method|setConsumerStreams (Integer consumerStreams)
specifier|public
name|void
name|setConsumerStreams
parameter_list|(
name|Integer
name|consumerStreams
parameter_list|)
block|{
name|this
operator|.
name|consumerStreams
operator|=
name|consumerStreams
expr_stmt|;
block|}
DECL|method|getConsumersCount ()
specifier|public
name|Integer
name|getConsumersCount
parameter_list|()
block|{
return|return
name|consumersCount
return|;
block|}
DECL|method|setConsumersCount (Integer consumersCount)
specifier|public
name|void
name|setConsumersCount
parameter_list|(
name|Integer
name|consumersCount
parameter_list|)
block|{
name|this
operator|.
name|consumersCount
operator|=
name|consumersCount
expr_stmt|;
block|}
DECL|method|getClientId ()
specifier|public
name|String
name|getClientId
parameter_list|()
block|{
return|return
name|clientId
return|;
block|}
DECL|method|setClientId (String clientId)
specifier|public
name|void
name|setClientId
parameter_list|(
name|String
name|clientId
parameter_list|)
block|{
name|this
operator|.
name|clientId
operator|=
name|clientId
expr_stmt|;
block|}
DECL|method|getAutoCommitEnable ()
specifier|public
name|Boolean
name|getAutoCommitEnable
parameter_list|()
block|{
return|return
name|autoCommitEnable
return|;
block|}
DECL|method|setAutoCommitEnable (Boolean autoCommitEnable)
specifier|public
name|void
name|setAutoCommitEnable
parameter_list|(
name|Boolean
name|autoCommitEnable
parameter_list|)
block|{
name|this
operator|.
name|autoCommitEnable
operator|=
name|autoCommitEnable
expr_stmt|;
block|}
DECL|method|getAllowManualCommit ()
specifier|public
name|Boolean
name|getAllowManualCommit
parameter_list|()
block|{
return|return
name|allowManualCommit
return|;
block|}
DECL|method|setAllowManualCommit (Boolean allowManualCommit)
specifier|public
name|void
name|setAllowManualCommit
parameter_list|(
name|Boolean
name|allowManualCommit
parameter_list|)
block|{
name|this
operator|.
name|allowManualCommit
operator|=
name|allowManualCommit
expr_stmt|;
block|}
DECL|method|getOffsetRepository ()
specifier|public
name|StateRepository
name|getOffsetRepository
parameter_list|()
block|{
return|return
name|offsetRepository
return|;
block|}
DECL|method|setOffsetRepository (StateRepository offsetRepository)
specifier|public
name|void
name|setOffsetRepository
parameter_list|(
name|StateRepository
name|offsetRepository
parameter_list|)
block|{
name|this
operator|.
name|offsetRepository
operator|=
name|offsetRepository
expr_stmt|;
block|}
DECL|method|getAutoCommitIntervalMs ()
specifier|public
name|Integer
name|getAutoCommitIntervalMs
parameter_list|()
block|{
return|return
name|autoCommitIntervalMs
return|;
block|}
DECL|method|setAutoCommitIntervalMs (Integer autoCommitIntervalMs)
specifier|public
name|void
name|setAutoCommitIntervalMs
parameter_list|(
name|Integer
name|autoCommitIntervalMs
parameter_list|)
block|{
name|this
operator|.
name|autoCommitIntervalMs
operator|=
name|autoCommitIntervalMs
expr_stmt|;
block|}
DECL|method|getFetchMinBytes ()
specifier|public
name|Integer
name|getFetchMinBytes
parameter_list|()
block|{
return|return
name|fetchMinBytes
return|;
block|}
DECL|method|setFetchMinBytes (Integer fetchMinBytes)
specifier|public
name|void
name|setFetchMinBytes
parameter_list|(
name|Integer
name|fetchMinBytes
parameter_list|)
block|{
name|this
operator|.
name|fetchMinBytes
operator|=
name|fetchMinBytes
expr_stmt|;
block|}
DECL|method|getFetchMaxBytes ()
specifier|public
name|Integer
name|getFetchMaxBytes
parameter_list|()
block|{
return|return
name|fetchMaxBytes
return|;
block|}
DECL|method|setFetchMaxBytes (Integer fetchMaxBytes)
specifier|public
name|void
name|setFetchMaxBytes
parameter_list|(
name|Integer
name|fetchMaxBytes
parameter_list|)
block|{
name|this
operator|.
name|fetchMaxBytes
operator|=
name|fetchMaxBytes
expr_stmt|;
block|}
DECL|method|getFetchWaitMaxMs ()
specifier|public
name|Integer
name|getFetchWaitMaxMs
parameter_list|()
block|{
return|return
name|fetchWaitMaxMs
return|;
block|}
DECL|method|setFetchWaitMaxMs (Integer fetchWaitMaxMs)
specifier|public
name|void
name|setFetchWaitMaxMs
parameter_list|(
name|Integer
name|fetchWaitMaxMs
parameter_list|)
block|{
name|this
operator|.
name|fetchWaitMaxMs
operator|=
name|fetchWaitMaxMs
expr_stmt|;
block|}
DECL|method|getAutoOffsetReset ()
specifier|public
name|String
name|getAutoOffsetReset
parameter_list|()
block|{
return|return
name|autoOffsetReset
return|;
block|}
DECL|method|setAutoOffsetReset (String autoOffsetReset)
specifier|public
name|void
name|setAutoOffsetReset
parameter_list|(
name|String
name|autoOffsetReset
parameter_list|)
block|{
name|this
operator|.
name|autoOffsetReset
operator|=
name|autoOffsetReset
expr_stmt|;
block|}
DECL|method|getAutoCommitOnStop ()
specifier|public
name|String
name|getAutoCommitOnStop
parameter_list|()
block|{
return|return
name|autoCommitOnStop
return|;
block|}
DECL|method|setAutoCommitOnStop (String autoCommitOnStop)
specifier|public
name|void
name|setAutoCommitOnStop
parameter_list|(
name|String
name|autoCommitOnStop
parameter_list|)
block|{
name|this
operator|.
name|autoCommitOnStop
operator|=
name|autoCommitOnStop
expr_stmt|;
block|}
DECL|method|getBreakOnFirstError ()
specifier|public
name|Boolean
name|getBreakOnFirstError
parameter_list|()
block|{
return|return
name|breakOnFirstError
return|;
block|}
DECL|method|setBreakOnFirstError (Boolean breakOnFirstError)
specifier|public
name|void
name|setBreakOnFirstError
parameter_list|(
name|Boolean
name|breakOnFirstError
parameter_list|)
block|{
name|this
operator|.
name|breakOnFirstError
operator|=
name|breakOnFirstError
expr_stmt|;
block|}
DECL|method|getBrokers ()
specifier|public
name|String
name|getBrokers
parameter_list|()
block|{
return|return
name|brokers
return|;
block|}
DECL|method|setBrokers (String brokers)
specifier|public
name|void
name|setBrokers
parameter_list|(
name|String
name|brokers
parameter_list|)
block|{
name|this
operator|.
name|brokers
operator|=
name|brokers
expr_stmt|;
block|}
DECL|method|getSchemaRegistryURL ()
specifier|public
name|String
name|getSchemaRegistryURL
parameter_list|()
block|{
return|return
name|schemaRegistryURL
return|;
block|}
DECL|method|setSchemaRegistryURL (String schemaRegistryURL)
specifier|public
name|void
name|setSchemaRegistryURL
parameter_list|(
name|String
name|schemaRegistryURL
parameter_list|)
block|{
name|this
operator|.
name|schemaRegistryURL
operator|=
name|schemaRegistryURL
expr_stmt|;
block|}
DECL|method|getCompressionCodec ()
specifier|public
name|String
name|getCompressionCodec
parameter_list|()
block|{
return|return
name|compressionCodec
return|;
block|}
DECL|method|setCompressionCodec (String compressionCodec)
specifier|public
name|void
name|setCompressionCodec
parameter_list|(
name|String
name|compressionCodec
parameter_list|)
block|{
name|this
operator|.
name|compressionCodec
operator|=
name|compressionCodec
expr_stmt|;
block|}
DECL|method|getRetryBackoffMs ()
specifier|public
name|Integer
name|getRetryBackoffMs
parameter_list|()
block|{
return|return
name|retryBackoffMs
return|;
block|}
DECL|method|setRetryBackoffMs (Integer retryBackoffMs)
specifier|public
name|void
name|setRetryBackoffMs
parameter_list|(
name|Integer
name|retryBackoffMs
parameter_list|)
block|{
name|this
operator|.
name|retryBackoffMs
operator|=
name|retryBackoffMs
expr_stmt|;
block|}
DECL|method|getSendBufferBytes ()
specifier|public
name|Integer
name|getSendBufferBytes
parameter_list|()
block|{
return|return
name|sendBufferBytes
return|;
block|}
DECL|method|setSendBufferBytes (Integer sendBufferBytes)
specifier|public
name|void
name|setSendBufferBytes
parameter_list|(
name|Integer
name|sendBufferBytes
parameter_list|)
block|{
name|this
operator|.
name|sendBufferBytes
operator|=
name|sendBufferBytes
expr_stmt|;
block|}
DECL|method|getRequestTimeoutMs ()
specifier|public
name|Integer
name|getRequestTimeoutMs
parameter_list|()
block|{
return|return
name|requestTimeoutMs
return|;
block|}
DECL|method|setRequestTimeoutMs (Integer requestTimeoutMs)
specifier|public
name|void
name|setRequestTimeoutMs
parameter_list|(
name|Integer
name|requestTimeoutMs
parameter_list|)
block|{
name|this
operator|.
name|requestTimeoutMs
operator|=
name|requestTimeoutMs
expr_stmt|;
block|}
DECL|method|getQueueBufferingMaxMessages ()
specifier|public
name|Integer
name|getQueueBufferingMaxMessages
parameter_list|()
block|{
return|return
name|queueBufferingMaxMessages
return|;
block|}
DECL|method|setQueueBufferingMaxMessages ( Integer queueBufferingMaxMessages)
specifier|public
name|void
name|setQueueBufferingMaxMessages
parameter_list|(
name|Integer
name|queueBufferingMaxMessages
parameter_list|)
block|{
name|this
operator|.
name|queueBufferingMaxMessages
operator|=
name|queueBufferingMaxMessages
expr_stmt|;
block|}
DECL|method|getSerializerClass ()
specifier|public
name|String
name|getSerializerClass
parameter_list|()
block|{
return|return
name|serializerClass
return|;
block|}
DECL|method|setSerializerClass (String serializerClass)
specifier|public
name|void
name|setSerializerClass
parameter_list|(
name|String
name|serializerClass
parameter_list|)
block|{
name|this
operator|.
name|serializerClass
operator|=
name|serializerClass
expr_stmt|;
block|}
DECL|method|getKeySerializerClass ()
specifier|public
name|String
name|getKeySerializerClass
parameter_list|()
block|{
return|return
name|keySerializerClass
return|;
block|}
DECL|method|setKeySerializerClass (String keySerializerClass)
specifier|public
name|void
name|setKeySerializerClass
parameter_list|(
name|String
name|keySerializerClass
parameter_list|)
block|{
name|this
operator|.
name|keySerializerClass
operator|=
name|keySerializerClass
expr_stmt|;
block|}
DECL|method|getKerberosInitCmd ()
specifier|public
name|String
name|getKerberosInitCmd
parameter_list|()
block|{
return|return
name|kerberosInitCmd
return|;
block|}
DECL|method|setKerberosInitCmd (String kerberosInitCmd)
specifier|public
name|void
name|setKerberosInitCmd
parameter_list|(
name|String
name|kerberosInitCmd
parameter_list|)
block|{
name|this
operator|.
name|kerberosInitCmd
operator|=
name|kerberosInitCmd
expr_stmt|;
block|}
DECL|method|getKerberosBeforeReloginMinTime ()
specifier|public
name|Integer
name|getKerberosBeforeReloginMinTime
parameter_list|()
block|{
return|return
name|kerberosBeforeReloginMinTime
return|;
block|}
DECL|method|setKerberosBeforeReloginMinTime ( Integer kerberosBeforeReloginMinTime)
specifier|public
name|void
name|setKerberosBeforeReloginMinTime
parameter_list|(
name|Integer
name|kerberosBeforeReloginMinTime
parameter_list|)
block|{
name|this
operator|.
name|kerberosBeforeReloginMinTime
operator|=
name|kerberosBeforeReloginMinTime
expr_stmt|;
block|}
DECL|method|getKerberosRenewJitter ()
specifier|public
name|Double
name|getKerberosRenewJitter
parameter_list|()
block|{
return|return
name|kerberosRenewJitter
return|;
block|}
DECL|method|setKerberosRenewJitter (Double kerberosRenewJitter)
specifier|public
name|void
name|setKerberosRenewJitter
parameter_list|(
name|Double
name|kerberosRenewJitter
parameter_list|)
block|{
name|this
operator|.
name|kerberosRenewJitter
operator|=
name|kerberosRenewJitter
expr_stmt|;
block|}
DECL|method|getKerberosRenewWindowFactor ()
specifier|public
name|Double
name|getKerberosRenewWindowFactor
parameter_list|()
block|{
return|return
name|kerberosRenewWindowFactor
return|;
block|}
DECL|method|setKerberosRenewWindowFactor ( Double kerberosRenewWindowFactor)
specifier|public
name|void
name|setKerberosRenewWindowFactor
parameter_list|(
name|Double
name|kerberosRenewWindowFactor
parameter_list|)
block|{
name|this
operator|.
name|kerberosRenewWindowFactor
operator|=
name|kerberosRenewWindowFactor
expr_stmt|;
block|}
DECL|method|getKerberosPrincipalToLocalRules ()
specifier|public
name|String
name|getKerberosPrincipalToLocalRules
parameter_list|()
block|{
return|return
name|kerberosPrincipalToLocalRules
return|;
block|}
DECL|method|setKerberosPrincipalToLocalRules ( String kerberosPrincipalToLocalRules)
specifier|public
name|void
name|setKerberosPrincipalToLocalRules
parameter_list|(
name|String
name|kerberosPrincipalToLocalRules
parameter_list|)
block|{
name|this
operator|.
name|kerberosPrincipalToLocalRules
operator|=
name|kerberosPrincipalToLocalRules
expr_stmt|;
block|}
DECL|method|getSslCipherSuites ()
specifier|public
name|String
name|getSslCipherSuites
parameter_list|()
block|{
return|return
name|sslCipherSuites
return|;
block|}
DECL|method|setSslCipherSuites (String sslCipherSuites)
specifier|public
name|void
name|setSslCipherSuites
parameter_list|(
name|String
name|sslCipherSuites
parameter_list|)
block|{
name|this
operator|.
name|sslCipherSuites
operator|=
name|sslCipherSuites
expr_stmt|;
block|}
DECL|method|getSslEndpointAlgorithm ()
specifier|public
name|String
name|getSslEndpointAlgorithm
parameter_list|()
block|{
return|return
name|sslEndpointAlgorithm
return|;
block|}
DECL|method|setSslEndpointAlgorithm (String sslEndpointAlgorithm)
specifier|public
name|void
name|setSslEndpointAlgorithm
parameter_list|(
name|String
name|sslEndpointAlgorithm
parameter_list|)
block|{
name|this
operator|.
name|sslEndpointAlgorithm
operator|=
name|sslEndpointAlgorithm
expr_stmt|;
block|}
DECL|method|getSslKeymanagerAlgorithm ()
specifier|public
name|String
name|getSslKeymanagerAlgorithm
parameter_list|()
block|{
return|return
name|sslKeymanagerAlgorithm
return|;
block|}
DECL|method|setSslKeymanagerAlgorithm (String sslKeymanagerAlgorithm)
specifier|public
name|void
name|setSslKeymanagerAlgorithm
parameter_list|(
name|String
name|sslKeymanagerAlgorithm
parameter_list|)
block|{
name|this
operator|.
name|sslKeymanagerAlgorithm
operator|=
name|sslKeymanagerAlgorithm
expr_stmt|;
block|}
DECL|method|getSslTrustmanagerAlgorithm ()
specifier|public
name|String
name|getSslTrustmanagerAlgorithm
parameter_list|()
block|{
return|return
name|sslTrustmanagerAlgorithm
return|;
block|}
DECL|method|setSslTrustmanagerAlgorithm (String sslTrustmanagerAlgorithm)
specifier|public
name|void
name|setSslTrustmanagerAlgorithm
parameter_list|(
name|String
name|sslTrustmanagerAlgorithm
parameter_list|)
block|{
name|this
operator|.
name|sslTrustmanagerAlgorithm
operator|=
name|sslTrustmanagerAlgorithm
expr_stmt|;
block|}
DECL|method|getSslEnabledProtocols ()
specifier|public
name|String
name|getSslEnabledProtocols
parameter_list|()
block|{
return|return
name|sslEnabledProtocols
return|;
block|}
DECL|method|setSslEnabledProtocols (String sslEnabledProtocols)
specifier|public
name|void
name|setSslEnabledProtocols
parameter_list|(
name|String
name|sslEnabledProtocols
parameter_list|)
block|{
name|this
operator|.
name|sslEnabledProtocols
operator|=
name|sslEnabledProtocols
expr_stmt|;
block|}
DECL|method|getSslKeystoreType ()
specifier|public
name|String
name|getSslKeystoreType
parameter_list|()
block|{
return|return
name|sslKeystoreType
return|;
block|}
DECL|method|setSslKeystoreType (String sslKeystoreType)
specifier|public
name|void
name|setSslKeystoreType
parameter_list|(
name|String
name|sslKeystoreType
parameter_list|)
block|{
name|this
operator|.
name|sslKeystoreType
operator|=
name|sslKeystoreType
expr_stmt|;
block|}
DECL|method|getSslProtocol ()
specifier|public
name|String
name|getSslProtocol
parameter_list|()
block|{
return|return
name|sslProtocol
return|;
block|}
DECL|method|setSslProtocol (String sslProtocol)
specifier|public
name|void
name|setSslProtocol
parameter_list|(
name|String
name|sslProtocol
parameter_list|)
block|{
name|this
operator|.
name|sslProtocol
operator|=
name|sslProtocol
expr_stmt|;
block|}
DECL|method|getSslProvider ()
specifier|public
name|String
name|getSslProvider
parameter_list|()
block|{
return|return
name|sslProvider
return|;
block|}
DECL|method|setSslProvider (String sslProvider)
specifier|public
name|void
name|setSslProvider
parameter_list|(
name|String
name|sslProvider
parameter_list|)
block|{
name|this
operator|.
name|sslProvider
operator|=
name|sslProvider
expr_stmt|;
block|}
DECL|method|getSslTruststoreType ()
specifier|public
name|String
name|getSslTruststoreType
parameter_list|()
block|{
return|return
name|sslTruststoreType
return|;
block|}
DECL|method|setSslTruststoreType (String sslTruststoreType)
specifier|public
name|void
name|setSslTruststoreType
parameter_list|(
name|String
name|sslTruststoreType
parameter_list|)
block|{
name|this
operator|.
name|sslTruststoreType
operator|=
name|sslTruststoreType
expr_stmt|;
block|}
DECL|method|getSaslKerberosServiceName ()
specifier|public
name|String
name|getSaslKerberosServiceName
parameter_list|()
block|{
return|return
name|saslKerberosServiceName
return|;
block|}
DECL|method|setSaslKerberosServiceName (String saslKerberosServiceName)
specifier|public
name|void
name|setSaslKerberosServiceName
parameter_list|(
name|String
name|saslKerberosServiceName
parameter_list|)
block|{
name|this
operator|.
name|saslKerberosServiceName
operator|=
name|saslKerberosServiceName
expr_stmt|;
block|}
DECL|method|getSaslMechanism ()
specifier|public
name|String
name|getSaslMechanism
parameter_list|()
block|{
return|return
name|saslMechanism
return|;
block|}
DECL|method|setSaslMechanism (String saslMechanism)
specifier|public
name|void
name|setSaslMechanism
parameter_list|(
name|String
name|saslMechanism
parameter_list|)
block|{
name|this
operator|.
name|saslMechanism
operator|=
name|saslMechanism
expr_stmt|;
block|}
DECL|method|getSaslJaasConfig ()
specifier|public
name|String
name|getSaslJaasConfig
parameter_list|()
block|{
return|return
name|saslJaasConfig
return|;
block|}
DECL|method|setSaslJaasConfig (String saslJaasConfig)
specifier|public
name|void
name|setSaslJaasConfig
parameter_list|(
name|String
name|saslJaasConfig
parameter_list|)
block|{
name|this
operator|.
name|saslJaasConfig
operator|=
name|saslJaasConfig
expr_stmt|;
block|}
DECL|method|getSecurityProtocol ()
specifier|public
name|String
name|getSecurityProtocol
parameter_list|()
block|{
return|return
name|securityProtocol
return|;
block|}
DECL|method|setSecurityProtocol (String securityProtocol)
specifier|public
name|void
name|setSecurityProtocol
parameter_list|(
name|String
name|securityProtocol
parameter_list|)
block|{
name|this
operator|.
name|securityProtocol
operator|=
name|securityProtocol
expr_stmt|;
block|}
DECL|method|getSslContextParameters ()
specifier|public
name|SSLContextParameters
name|getSslContextParameters
parameter_list|()
block|{
return|return
name|sslContextParameters
return|;
block|}
DECL|method|setSslContextParameters ( SSLContextParameters sslContextParameters)
specifier|public
name|void
name|setSslContextParameters
parameter_list|(
name|SSLContextParameters
name|sslContextParameters
parameter_list|)
block|{
name|this
operator|.
name|sslContextParameters
operator|=
name|sslContextParameters
expr_stmt|;
block|}
DECL|method|getSslKeyPassword ()
specifier|public
name|String
name|getSslKeyPassword
parameter_list|()
block|{
return|return
name|sslKeyPassword
return|;
block|}
DECL|method|setSslKeyPassword (String sslKeyPassword)
specifier|public
name|void
name|setSslKeyPassword
parameter_list|(
name|String
name|sslKeyPassword
parameter_list|)
block|{
name|this
operator|.
name|sslKeyPassword
operator|=
name|sslKeyPassword
expr_stmt|;
block|}
DECL|method|getSslKeystoreLocation ()
specifier|public
name|String
name|getSslKeystoreLocation
parameter_list|()
block|{
return|return
name|sslKeystoreLocation
return|;
block|}
DECL|method|setSslKeystoreLocation (String sslKeystoreLocation)
specifier|public
name|void
name|setSslKeystoreLocation
parameter_list|(
name|String
name|sslKeystoreLocation
parameter_list|)
block|{
name|this
operator|.
name|sslKeystoreLocation
operator|=
name|sslKeystoreLocation
expr_stmt|;
block|}
DECL|method|getSslKeystorePassword ()
specifier|public
name|String
name|getSslKeystorePassword
parameter_list|()
block|{
return|return
name|sslKeystorePassword
return|;
block|}
DECL|method|setSslKeystorePassword (String sslKeystorePassword)
specifier|public
name|void
name|setSslKeystorePassword
parameter_list|(
name|String
name|sslKeystorePassword
parameter_list|)
block|{
name|this
operator|.
name|sslKeystorePassword
operator|=
name|sslKeystorePassword
expr_stmt|;
block|}
DECL|method|getSslTruststoreLocation ()
specifier|public
name|String
name|getSslTruststoreLocation
parameter_list|()
block|{
return|return
name|sslTruststoreLocation
return|;
block|}
DECL|method|setSslTruststoreLocation (String sslTruststoreLocation)
specifier|public
name|void
name|setSslTruststoreLocation
parameter_list|(
name|String
name|sslTruststoreLocation
parameter_list|)
block|{
name|this
operator|.
name|sslTruststoreLocation
operator|=
name|sslTruststoreLocation
expr_stmt|;
block|}
DECL|method|getSslTruststorePassword ()
specifier|public
name|String
name|getSslTruststorePassword
parameter_list|()
block|{
return|return
name|sslTruststorePassword
return|;
block|}
DECL|method|setSslTruststorePassword (String sslTruststorePassword)
specifier|public
name|void
name|setSslTruststorePassword
parameter_list|(
name|String
name|sslTruststorePassword
parameter_list|)
block|{
name|this
operator|.
name|sslTruststorePassword
operator|=
name|sslTruststorePassword
expr_stmt|;
block|}
DECL|method|getBufferMemorySize ()
specifier|public
name|Integer
name|getBufferMemorySize
parameter_list|()
block|{
return|return
name|bufferMemorySize
return|;
block|}
DECL|method|setBufferMemorySize (Integer bufferMemorySize)
specifier|public
name|void
name|setBufferMemorySize
parameter_list|(
name|Integer
name|bufferMemorySize
parameter_list|)
block|{
name|this
operator|.
name|bufferMemorySize
operator|=
name|bufferMemorySize
expr_stmt|;
block|}
DECL|method|getKey ()
specifier|public
name|String
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
DECL|method|setKey (String key)
specifier|public
name|void
name|setKey
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
block|}
DECL|method|getPartitionKey ()
specifier|public
name|Integer
name|getPartitionKey
parameter_list|()
block|{
return|return
name|partitionKey
return|;
block|}
DECL|method|setPartitionKey (Integer partitionKey)
specifier|public
name|void
name|setPartitionKey
parameter_list|(
name|Integer
name|partitionKey
parameter_list|)
block|{
name|this
operator|.
name|partitionKey
operator|=
name|partitionKey
expr_stmt|;
block|}
DECL|method|getRequestRequiredAcks ()
specifier|public
name|String
name|getRequestRequiredAcks
parameter_list|()
block|{
return|return
name|requestRequiredAcks
return|;
block|}
DECL|method|setRequestRequiredAcks (String requestRequiredAcks)
specifier|public
name|void
name|setRequestRequiredAcks
parameter_list|(
name|String
name|requestRequiredAcks
parameter_list|)
block|{
name|this
operator|.
name|requestRequiredAcks
operator|=
name|requestRequiredAcks
expr_stmt|;
block|}
DECL|method|getRetries ()
specifier|public
name|Integer
name|getRetries
parameter_list|()
block|{
return|return
name|retries
return|;
block|}
DECL|method|setRetries (Integer retries)
specifier|public
name|void
name|setRetries
parameter_list|(
name|Integer
name|retries
parameter_list|)
block|{
name|this
operator|.
name|retries
operator|=
name|retries
expr_stmt|;
block|}
DECL|method|getProducerBatchSize ()
specifier|public
name|Integer
name|getProducerBatchSize
parameter_list|()
block|{
return|return
name|producerBatchSize
return|;
block|}
DECL|method|setProducerBatchSize (Integer producerBatchSize)
specifier|public
name|void
name|setProducerBatchSize
parameter_list|(
name|Integer
name|producerBatchSize
parameter_list|)
block|{
name|this
operator|.
name|producerBatchSize
operator|=
name|producerBatchSize
expr_stmt|;
block|}
DECL|method|getConnectionMaxIdleMs ()
specifier|public
name|Integer
name|getConnectionMaxIdleMs
parameter_list|()
block|{
return|return
name|connectionMaxIdleMs
return|;
block|}
DECL|method|setConnectionMaxIdleMs (Integer connectionMaxIdleMs)
specifier|public
name|void
name|setConnectionMaxIdleMs
parameter_list|(
name|Integer
name|connectionMaxIdleMs
parameter_list|)
block|{
name|this
operator|.
name|connectionMaxIdleMs
operator|=
name|connectionMaxIdleMs
expr_stmt|;
block|}
DECL|method|getLingerMs ()
specifier|public
name|Integer
name|getLingerMs
parameter_list|()
block|{
return|return
name|lingerMs
return|;
block|}
DECL|method|setLingerMs (Integer lingerMs)
specifier|public
name|void
name|setLingerMs
parameter_list|(
name|Integer
name|lingerMs
parameter_list|)
block|{
name|this
operator|.
name|lingerMs
operator|=
name|lingerMs
expr_stmt|;
block|}
DECL|method|getMaxBlockMs ()
specifier|public
name|Integer
name|getMaxBlockMs
parameter_list|()
block|{
return|return
name|maxBlockMs
return|;
block|}
DECL|method|setMaxBlockMs (Integer maxBlockMs)
specifier|public
name|void
name|setMaxBlockMs
parameter_list|(
name|Integer
name|maxBlockMs
parameter_list|)
block|{
name|this
operator|.
name|maxBlockMs
operator|=
name|maxBlockMs
expr_stmt|;
block|}
DECL|method|getMaxRequestSize ()
specifier|public
name|Integer
name|getMaxRequestSize
parameter_list|()
block|{
return|return
name|maxRequestSize
return|;
block|}
DECL|method|setMaxRequestSize (Integer maxRequestSize)
specifier|public
name|void
name|setMaxRequestSize
parameter_list|(
name|Integer
name|maxRequestSize
parameter_list|)
block|{
name|this
operator|.
name|maxRequestSize
operator|=
name|maxRequestSize
expr_stmt|;
block|}
DECL|method|getReceiveBufferBytes ()
specifier|public
name|Integer
name|getReceiveBufferBytes
parameter_list|()
block|{
return|return
name|receiveBufferBytes
return|;
block|}
DECL|method|setReceiveBufferBytes (Integer receiveBufferBytes)
specifier|public
name|void
name|setReceiveBufferBytes
parameter_list|(
name|Integer
name|receiveBufferBytes
parameter_list|)
block|{
name|this
operator|.
name|receiveBufferBytes
operator|=
name|receiveBufferBytes
expr_stmt|;
block|}
DECL|method|getMaxInFlightRequest ()
specifier|public
name|Integer
name|getMaxInFlightRequest
parameter_list|()
block|{
return|return
name|maxInFlightRequest
return|;
block|}
DECL|method|setMaxInFlightRequest (Integer maxInFlightRequest)
specifier|public
name|void
name|setMaxInFlightRequest
parameter_list|(
name|Integer
name|maxInFlightRequest
parameter_list|)
block|{
name|this
operator|.
name|maxInFlightRequest
operator|=
name|maxInFlightRequest
expr_stmt|;
block|}
DECL|method|getMetadataMaxAgeMs ()
specifier|public
name|Integer
name|getMetadataMaxAgeMs
parameter_list|()
block|{
return|return
name|metadataMaxAgeMs
return|;
block|}
DECL|method|setMetadataMaxAgeMs (Integer metadataMaxAgeMs)
specifier|public
name|void
name|setMetadataMaxAgeMs
parameter_list|(
name|Integer
name|metadataMaxAgeMs
parameter_list|)
block|{
name|this
operator|.
name|metadataMaxAgeMs
operator|=
name|metadataMaxAgeMs
expr_stmt|;
block|}
DECL|method|getMetricReporters ()
specifier|public
name|String
name|getMetricReporters
parameter_list|()
block|{
return|return
name|metricReporters
return|;
block|}
DECL|method|setMetricReporters (String metricReporters)
specifier|public
name|void
name|setMetricReporters
parameter_list|(
name|String
name|metricReporters
parameter_list|)
block|{
name|this
operator|.
name|metricReporters
operator|=
name|metricReporters
expr_stmt|;
block|}
DECL|method|getNoOfMetricsSample ()
specifier|public
name|Integer
name|getNoOfMetricsSample
parameter_list|()
block|{
return|return
name|noOfMetricsSample
return|;
block|}
DECL|method|setNoOfMetricsSample (Integer noOfMetricsSample)
specifier|public
name|void
name|setNoOfMetricsSample
parameter_list|(
name|Integer
name|noOfMetricsSample
parameter_list|)
block|{
name|this
operator|.
name|noOfMetricsSample
operator|=
name|noOfMetricsSample
expr_stmt|;
block|}
DECL|method|getMetricsSampleWindowMs ()
specifier|public
name|Integer
name|getMetricsSampleWindowMs
parameter_list|()
block|{
return|return
name|metricsSampleWindowMs
return|;
block|}
DECL|method|setMetricsSampleWindowMs (Integer metricsSampleWindowMs)
specifier|public
name|void
name|setMetricsSampleWindowMs
parameter_list|(
name|Integer
name|metricsSampleWindowMs
parameter_list|)
block|{
name|this
operator|.
name|metricsSampleWindowMs
operator|=
name|metricsSampleWindowMs
expr_stmt|;
block|}
DECL|method|getReconnectBackoffMs ()
specifier|public
name|Integer
name|getReconnectBackoffMs
parameter_list|()
block|{
return|return
name|reconnectBackoffMs
return|;
block|}
DECL|method|setReconnectBackoffMs (Integer reconnectBackoffMs)
specifier|public
name|void
name|setReconnectBackoffMs
parameter_list|(
name|Integer
name|reconnectBackoffMs
parameter_list|)
block|{
name|this
operator|.
name|reconnectBackoffMs
operator|=
name|reconnectBackoffMs
expr_stmt|;
block|}
DECL|method|getHeartbeatIntervalMs ()
specifier|public
name|Integer
name|getHeartbeatIntervalMs
parameter_list|()
block|{
return|return
name|heartbeatIntervalMs
return|;
block|}
DECL|method|setHeartbeatIntervalMs (Integer heartbeatIntervalMs)
specifier|public
name|void
name|setHeartbeatIntervalMs
parameter_list|(
name|Integer
name|heartbeatIntervalMs
parameter_list|)
block|{
name|this
operator|.
name|heartbeatIntervalMs
operator|=
name|heartbeatIntervalMs
expr_stmt|;
block|}
DECL|method|getMaxPartitionFetchBytes ()
specifier|public
name|Integer
name|getMaxPartitionFetchBytes
parameter_list|()
block|{
return|return
name|maxPartitionFetchBytes
return|;
block|}
DECL|method|setMaxPartitionFetchBytes (Integer maxPartitionFetchBytes)
specifier|public
name|void
name|setMaxPartitionFetchBytes
parameter_list|(
name|Integer
name|maxPartitionFetchBytes
parameter_list|)
block|{
name|this
operator|.
name|maxPartitionFetchBytes
operator|=
name|maxPartitionFetchBytes
expr_stmt|;
block|}
DECL|method|getSessionTimeoutMs ()
specifier|public
name|Integer
name|getSessionTimeoutMs
parameter_list|()
block|{
return|return
name|sessionTimeoutMs
return|;
block|}
DECL|method|setSessionTimeoutMs (Integer sessionTimeoutMs)
specifier|public
name|void
name|setSessionTimeoutMs
parameter_list|(
name|Integer
name|sessionTimeoutMs
parameter_list|)
block|{
name|this
operator|.
name|sessionTimeoutMs
operator|=
name|sessionTimeoutMs
expr_stmt|;
block|}
DECL|method|getMaxPollRecords ()
specifier|public
name|Integer
name|getMaxPollRecords
parameter_list|()
block|{
return|return
name|maxPollRecords
return|;
block|}
DECL|method|setMaxPollRecords (Integer maxPollRecords)
specifier|public
name|void
name|setMaxPollRecords
parameter_list|(
name|Integer
name|maxPollRecords
parameter_list|)
block|{
name|this
operator|.
name|maxPollRecords
operator|=
name|maxPollRecords
expr_stmt|;
block|}
DECL|method|getPollTimeoutMs ()
specifier|public
name|Long
name|getPollTimeoutMs
parameter_list|()
block|{
return|return
name|pollTimeoutMs
return|;
block|}
DECL|method|setPollTimeoutMs (Long pollTimeoutMs)
specifier|public
name|void
name|setPollTimeoutMs
parameter_list|(
name|Long
name|pollTimeoutMs
parameter_list|)
block|{
name|this
operator|.
name|pollTimeoutMs
operator|=
name|pollTimeoutMs
expr_stmt|;
block|}
DECL|method|getMaxPollIntervalMs ()
specifier|public
name|Long
name|getMaxPollIntervalMs
parameter_list|()
block|{
return|return
name|maxPollIntervalMs
return|;
block|}
DECL|method|setMaxPollIntervalMs (Long maxPollIntervalMs)
specifier|public
name|void
name|setMaxPollIntervalMs
parameter_list|(
name|Long
name|maxPollIntervalMs
parameter_list|)
block|{
name|this
operator|.
name|maxPollIntervalMs
operator|=
name|maxPollIntervalMs
expr_stmt|;
block|}
DECL|method|getPartitionAssignor ()
specifier|public
name|String
name|getPartitionAssignor
parameter_list|()
block|{
return|return
name|partitionAssignor
return|;
block|}
DECL|method|setPartitionAssignor (String partitionAssignor)
specifier|public
name|void
name|setPartitionAssignor
parameter_list|(
name|String
name|partitionAssignor
parameter_list|)
block|{
name|this
operator|.
name|partitionAssignor
operator|=
name|partitionAssignor
expr_stmt|;
block|}
DECL|method|getConsumerRequestTimeoutMs ()
specifier|public
name|Integer
name|getConsumerRequestTimeoutMs
parameter_list|()
block|{
return|return
name|consumerRequestTimeoutMs
return|;
block|}
DECL|method|setConsumerRequestTimeoutMs (Integer consumerRequestTimeoutMs)
specifier|public
name|void
name|setConsumerRequestTimeoutMs
parameter_list|(
name|Integer
name|consumerRequestTimeoutMs
parameter_list|)
block|{
name|this
operator|.
name|consumerRequestTimeoutMs
operator|=
name|consumerRequestTimeoutMs
expr_stmt|;
block|}
DECL|method|getCheckCrcs ()
specifier|public
name|Boolean
name|getCheckCrcs
parameter_list|()
block|{
return|return
name|checkCrcs
return|;
block|}
DECL|method|setCheckCrcs (Boolean checkCrcs)
specifier|public
name|void
name|setCheckCrcs
parameter_list|(
name|Boolean
name|checkCrcs
parameter_list|)
block|{
name|this
operator|.
name|checkCrcs
operator|=
name|checkCrcs
expr_stmt|;
block|}
DECL|method|getKeyDeserializer ()
specifier|public
name|String
name|getKeyDeserializer
parameter_list|()
block|{
return|return
name|keyDeserializer
return|;
block|}
DECL|method|setKeyDeserializer (String keyDeserializer)
specifier|public
name|void
name|setKeyDeserializer
parameter_list|(
name|String
name|keyDeserializer
parameter_list|)
block|{
name|this
operator|.
name|keyDeserializer
operator|=
name|keyDeserializer
expr_stmt|;
block|}
DECL|method|getValueDeserializer ()
specifier|public
name|String
name|getValueDeserializer
parameter_list|()
block|{
return|return
name|valueDeserializer
return|;
block|}
DECL|method|setValueDeserializer (String valueDeserializer)
specifier|public
name|void
name|setValueDeserializer
parameter_list|(
name|String
name|valueDeserializer
parameter_list|)
block|{
name|this
operator|.
name|valueDeserializer
operator|=
name|valueDeserializer
expr_stmt|;
block|}
DECL|method|getSeekTo ()
specifier|public
name|String
name|getSeekTo
parameter_list|()
block|{
return|return
name|seekTo
return|;
block|}
DECL|method|setSeekTo (String seekTo)
specifier|public
name|void
name|setSeekTo
parameter_list|(
name|String
name|seekTo
parameter_list|)
block|{
name|this
operator|.
name|seekTo
operator|=
name|seekTo
expr_stmt|;
block|}
DECL|method|getWorkerPool ()
specifier|public
name|ExecutorService
name|getWorkerPool
parameter_list|()
block|{
return|return
name|workerPool
return|;
block|}
DECL|method|setWorkerPool (ExecutorService workerPool)
specifier|public
name|void
name|setWorkerPool
parameter_list|(
name|ExecutorService
name|workerPool
parameter_list|)
block|{
name|this
operator|.
name|workerPool
operator|=
name|workerPool
expr_stmt|;
block|}
DECL|method|getWorkerPoolCoreSize ()
specifier|public
name|Integer
name|getWorkerPoolCoreSize
parameter_list|()
block|{
return|return
name|workerPoolCoreSize
return|;
block|}
DECL|method|setWorkerPoolCoreSize (Integer workerPoolCoreSize)
specifier|public
name|void
name|setWorkerPoolCoreSize
parameter_list|(
name|Integer
name|workerPoolCoreSize
parameter_list|)
block|{
name|this
operator|.
name|workerPoolCoreSize
operator|=
name|workerPoolCoreSize
expr_stmt|;
block|}
DECL|method|getWorkerPoolMaxSize ()
specifier|public
name|Integer
name|getWorkerPoolMaxSize
parameter_list|()
block|{
return|return
name|workerPoolMaxSize
return|;
block|}
DECL|method|setWorkerPoolMaxSize (Integer workerPoolMaxSize)
specifier|public
name|void
name|setWorkerPoolMaxSize
parameter_list|(
name|Integer
name|workerPoolMaxSize
parameter_list|)
block|{
name|this
operator|.
name|workerPoolMaxSize
operator|=
name|workerPoolMaxSize
expr_stmt|;
block|}
DECL|method|getRecordMetadata ()
specifier|public
name|Boolean
name|getRecordMetadata
parameter_list|()
block|{
return|return
name|recordMetadata
return|;
block|}
DECL|method|setRecordMetadata (Boolean recordMetadata)
specifier|public
name|void
name|setRecordMetadata
parameter_list|(
name|Boolean
name|recordMetadata
parameter_list|)
block|{
name|this
operator|.
name|recordMetadata
operator|=
name|recordMetadata
expr_stmt|;
block|}
DECL|method|getInterceptorClasses ()
specifier|public
name|String
name|getInterceptorClasses
parameter_list|()
block|{
return|return
name|interceptorClasses
return|;
block|}
DECL|method|setInterceptorClasses (String interceptorClasses)
specifier|public
name|void
name|setInterceptorClasses
parameter_list|(
name|String
name|interceptorClasses
parameter_list|)
block|{
name|this
operator|.
name|interceptorClasses
operator|=
name|interceptorClasses
expr_stmt|;
block|}
DECL|method|getEnableIdempotence ()
specifier|public
name|Boolean
name|getEnableIdempotence
parameter_list|()
block|{
return|return
name|enableIdempotence
return|;
block|}
DECL|method|setEnableIdempotence (Boolean enableIdempotence)
specifier|public
name|void
name|setEnableIdempotence
parameter_list|(
name|Boolean
name|enableIdempotence
parameter_list|)
block|{
name|this
operator|.
name|enableIdempotence
operator|=
name|enableIdempotence
expr_stmt|;
block|}
DECL|method|getReconnectBackoffMaxMs ()
specifier|public
name|Integer
name|getReconnectBackoffMaxMs
parameter_list|()
block|{
return|return
name|reconnectBackoffMaxMs
return|;
block|}
DECL|method|setReconnectBackoffMaxMs (Integer reconnectBackoffMaxMs)
specifier|public
name|void
name|setReconnectBackoffMaxMs
parameter_list|(
name|Integer
name|reconnectBackoffMaxMs
parameter_list|)
block|{
name|this
operator|.
name|reconnectBackoffMaxMs
operator|=
name|reconnectBackoffMaxMs
expr_stmt|;
block|}
DECL|method|getHeaderFilterStrategy ()
specifier|public
name|HeaderFilterStrategy
name|getHeaderFilterStrategy
parameter_list|()
block|{
return|return
name|headerFilterStrategy
return|;
block|}
DECL|method|setHeaderFilterStrategy ( HeaderFilterStrategy headerFilterStrategy)
specifier|public
name|void
name|setHeaderFilterStrategy
parameter_list|(
name|HeaderFilterStrategy
name|headerFilterStrategy
parameter_list|)
block|{
name|this
operator|.
name|headerFilterStrategy
operator|=
name|headerFilterStrategy
expr_stmt|;
block|}
DECL|method|getKafkaHeaderDeserializer ()
specifier|public
name|KafkaHeaderDeserializer
name|getKafkaHeaderDeserializer
parameter_list|()
block|{
return|return
name|kafkaHeaderDeserializer
return|;
block|}
DECL|method|setKafkaHeaderDeserializer ( KafkaHeaderDeserializer kafkaHeaderDeserializer)
specifier|public
name|void
name|setKafkaHeaderDeserializer
parameter_list|(
name|KafkaHeaderDeserializer
name|kafkaHeaderDeserializer
parameter_list|)
block|{
name|this
operator|.
name|kafkaHeaderDeserializer
operator|=
name|kafkaHeaderDeserializer
expr_stmt|;
block|}
DECL|method|getKafkaHeaderSerializer ()
specifier|public
name|KafkaHeaderSerializer
name|getKafkaHeaderSerializer
parameter_list|()
block|{
return|return
name|kafkaHeaderSerializer
return|;
block|}
DECL|method|setKafkaHeaderSerializer ( KafkaHeaderSerializer kafkaHeaderSerializer)
specifier|public
name|void
name|setKafkaHeaderSerializer
parameter_list|(
name|KafkaHeaderSerializer
name|kafkaHeaderSerializer
parameter_list|)
block|{
name|this
operator|.
name|kafkaHeaderSerializer
operator|=
name|kafkaHeaderSerializer
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

