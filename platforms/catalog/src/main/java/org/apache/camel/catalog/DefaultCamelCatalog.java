begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.catalog
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|catalog
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|PatternSyntaxException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|DocumentBuilderFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathConstants
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|catalog
operator|.
name|CatalogHelper
operator|.
name|after
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|catalog
operator|.
name|JSonSchemaHelper
operator|.
name|getPropertyDefaultValue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|catalog
operator|.
name|JSonSchemaHelper
operator|.
name|getPropertyEnum
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|catalog
operator|.
name|JSonSchemaHelper
operator|.
name|getRow
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|catalog
operator|.
name|JSonSchemaHelper
operator|.
name|isPropertyBoolean
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|catalog
operator|.
name|JSonSchemaHelper
operator|.
name|isPropertyInteger
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|catalog
operator|.
name|JSonSchemaHelper
operator|.
name|isPropertyNumber
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|catalog
operator|.
name|JSonSchemaHelper
operator|.
name|isPropertyRequired
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|catalog
operator|.
name|URISupport
operator|.
name|createQueryString
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|catalog
operator|.
name|URISupport
operator|.
name|isEmpty
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|catalog
operator|.
name|URISupport
operator|.
name|normalizeUri
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|catalog
operator|.
name|URISupport
operator|.
name|stripQuery
import|;
end_import

begin_comment
comment|/**  * Default {@link CamelCatalog}.  */
end_comment

begin_class
DECL|class|DefaultCamelCatalog
specifier|public
class|class
name|DefaultCamelCatalog
implements|implements
name|CamelCatalog
block|{
DECL|field|MODELS_CATALOG
specifier|private
specifier|static
specifier|final
name|String
name|MODELS_CATALOG
init|=
literal|"org/apache/camel/catalog/models.properties"
decl_stmt|;
DECL|field|COMPONENTS_CATALOG
specifier|private
specifier|static
specifier|final
name|String
name|COMPONENTS_CATALOG
init|=
literal|"org/apache/camel/catalog/components.properties"
decl_stmt|;
DECL|field|DATA_FORMATS_CATALOG
specifier|private
specifier|static
specifier|final
name|String
name|DATA_FORMATS_CATALOG
init|=
literal|"org/apache/camel/catalog/dataformats.properties"
decl_stmt|;
DECL|field|LANGUAGE_CATALOG
specifier|private
specifier|static
specifier|final
name|String
name|LANGUAGE_CATALOG
init|=
literal|"org/apache/camel/catalog/languages.properties"
decl_stmt|;
DECL|field|MODEL_JSON
specifier|private
specifier|static
specifier|final
name|String
name|MODEL_JSON
init|=
literal|"org/apache/camel/catalog/models"
decl_stmt|;
DECL|field|COMPONENTS_JSON
specifier|private
specifier|static
specifier|final
name|String
name|COMPONENTS_JSON
init|=
literal|"org/apache/camel/catalog/components"
decl_stmt|;
DECL|field|DATA_FORMATS_JSON
specifier|private
specifier|static
specifier|final
name|String
name|DATA_FORMATS_JSON
init|=
literal|"org/apache/camel/catalog/dataformats"
decl_stmt|;
DECL|field|LANGUAGE_JSON
specifier|private
specifier|static
specifier|final
name|String
name|LANGUAGE_JSON
init|=
literal|"org/apache/camel/catalog/languages"
decl_stmt|;
DECL|field|ARCHETYPES_CATALOG
specifier|private
specifier|static
specifier|final
name|String
name|ARCHETYPES_CATALOG
init|=
literal|"org/apache/camel/catalog/archetypes/archetype-catalog.xml"
decl_stmt|;
DECL|field|SCHEMAS_XML
specifier|private
specifier|static
specifier|final
name|String
name|SCHEMAS_XML
init|=
literal|"org/apache/camel/catalog/schemas"
decl_stmt|;
DECL|field|SYNTAX_PATTERN
specifier|private
specifier|static
specifier|final
name|Pattern
name|SYNTAX_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"(\\w+)"
argument_list|)
decl_stmt|;
DECL|field|version
specifier|private
specifier|final
name|VersionHelper
name|version
init|=
operator|new
name|VersionHelper
argument_list|()
decl_stmt|;
comment|// cache of operation -> result
DECL|field|cache
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|cache
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|caching
specifier|private
name|boolean
name|caching
decl_stmt|;
comment|/**      * Creates the {@link CamelCatalog} without caching enabled.      */
DECL|method|DefaultCamelCatalog ()
specifier|public
name|DefaultCamelCatalog
parameter_list|()
block|{     }
comment|/**      * Creates the {@link CamelCatalog}      *      * @param caching  whether to use cache      */
DECL|method|DefaultCamelCatalog (boolean caching)
specifier|public
name|DefaultCamelCatalog
parameter_list|(
name|boolean
name|caching
parameter_list|)
block|{
name|this
operator|.
name|caching
operator|=
name|caching
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|enableCache ()
specifier|public
name|void
name|enableCache
parameter_list|()
block|{
name|caching
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getCatalogVersion ()
specifier|public
name|String
name|getCatalogVersion
parameter_list|()
block|{
return|return
name|version
operator|.
name|getVersion
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|findComponentNames ()
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|findComponentNames
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|names
operator|=
operator|(
name|List
argument_list|<
name|String
argument_list|>
operator|)
name|cache
operator|.
name|get
argument_list|(
literal|"findComponentNames"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|names
operator|==
literal|null
condition|)
block|{
name|names
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|InputStream
name|is
init|=
name|DefaultCamelCatalog
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
name|COMPONENTS_CATALOG
argument_list|)
decl_stmt|;
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|CatalogHelper
operator|.
name|loadLines
argument_list|(
name|is
argument_list|,
name|names
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
if|if
condition|(
name|caching
condition|)
block|{
name|cache
operator|.
name|put
argument_list|(
literal|"findComponentNames"
argument_list|,
name|names
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|names
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|findDataFormatNames ()
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|findDataFormatNames
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|names
operator|=
operator|(
name|List
argument_list|<
name|String
argument_list|>
operator|)
name|cache
operator|.
name|get
argument_list|(
literal|"findDataFormatNames"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|names
operator|==
literal|null
condition|)
block|{
name|names
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|InputStream
name|is
init|=
name|DefaultCamelCatalog
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
name|DATA_FORMATS_CATALOG
argument_list|)
decl_stmt|;
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|CatalogHelper
operator|.
name|loadLines
argument_list|(
name|is
argument_list|,
name|names
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
if|if
condition|(
name|caching
condition|)
block|{
name|cache
operator|.
name|put
argument_list|(
literal|"findDataFormatNames"
argument_list|,
name|names
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|names
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|findLanguageNames ()
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|findLanguageNames
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|names
operator|=
operator|(
name|List
argument_list|<
name|String
argument_list|>
operator|)
name|cache
operator|.
name|get
argument_list|(
literal|"findLanguageNames"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|names
operator|==
literal|null
condition|)
block|{
name|names
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|InputStream
name|is
init|=
name|DefaultCamelCatalog
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
name|LANGUAGE_CATALOG
argument_list|)
decl_stmt|;
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|CatalogHelper
operator|.
name|loadLines
argument_list|(
name|is
argument_list|,
name|names
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
if|if
condition|(
name|caching
condition|)
block|{
name|cache
operator|.
name|put
argument_list|(
literal|"findLanguageNames"
argument_list|,
name|names
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|names
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|findModelNames ()
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|findModelNames
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|names
operator|=
operator|(
name|List
argument_list|<
name|String
argument_list|>
operator|)
name|cache
operator|.
name|get
argument_list|(
literal|"findModelNames"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|names
operator|==
literal|null
condition|)
block|{
name|names
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|InputStream
name|is
init|=
name|DefaultCamelCatalog
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
name|MODELS_CATALOG
argument_list|)
decl_stmt|;
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|CatalogHelper
operator|.
name|loadLines
argument_list|(
name|is
argument_list|,
name|names
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
if|if
condition|(
name|caching
condition|)
block|{
name|cache
operator|.
name|put
argument_list|(
literal|"findModelNames"
argument_list|,
name|names
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|names
return|;
block|}
annotation|@
name|Override
DECL|method|findModelNames (String filter)
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|findModelNames
parameter_list|(
name|String
name|filter
parameter_list|)
block|{
comment|// should not cache when filter parameter can by any kind of value
name|List
argument_list|<
name|String
argument_list|>
name|answer
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|findModelNames
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
name|String
name|json
init|=
name|modelJSonSchema
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|json
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|rows
init|=
name|JSonSchemaHelper
operator|.
name|parseJsonSchema
argument_list|(
literal|"model"
argument_list|,
name|json
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|row
range|:
name|rows
control|)
block|{
if|if
condition|(
name|row
operator|.
name|containsKey
argument_list|(
literal|"label"
argument_list|)
condition|)
block|{
name|String
name|label
init|=
name|row
operator|.
name|get
argument_list|(
literal|"label"
argument_list|)
decl_stmt|;
name|String
index|[]
name|parts
init|=
name|label
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|part
range|:
name|parts
control|)
block|{
try|try
block|{
if|if
condition|(
name|part
operator|.
name|equalsIgnoreCase
argument_list|(
name|filter
argument_list|)
operator|||
name|CatalogHelper
operator|.
name|matchWildcard
argument_list|(
name|part
argument_list|,
name|filter
argument_list|)
operator|||
name|part
operator|.
name|matches
argument_list|(
name|filter
argument_list|)
condition|)
block|{
name|answer
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|PatternSyntaxException
name|e
parameter_list|)
block|{
comment|// ignore as filter is maybe not a pattern
block|}
block|}
block|}
block|}
block|}
block|}
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|findComponentNames (String filter)
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|findComponentNames
parameter_list|(
name|String
name|filter
parameter_list|)
block|{
comment|// should not cache when filter parameter can by any kind of value
name|List
argument_list|<
name|String
argument_list|>
name|answer
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|findComponentNames
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
name|String
name|json
init|=
name|componentJSonSchema
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|json
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|rows
init|=
name|JSonSchemaHelper
operator|.
name|parseJsonSchema
argument_list|(
literal|"component"
argument_list|,
name|json
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|row
range|:
name|rows
control|)
block|{
if|if
condition|(
name|row
operator|.
name|containsKey
argument_list|(
literal|"label"
argument_list|)
condition|)
block|{
name|String
name|label
init|=
name|row
operator|.
name|get
argument_list|(
literal|"label"
argument_list|)
decl_stmt|;
name|String
index|[]
name|parts
init|=
name|label
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|part
range|:
name|parts
control|)
block|{
try|try
block|{
if|if
condition|(
name|part
operator|.
name|equalsIgnoreCase
argument_list|(
name|filter
argument_list|)
operator|||
name|CatalogHelper
operator|.
name|matchWildcard
argument_list|(
name|part
argument_list|,
name|filter
argument_list|)
operator|||
name|part
operator|.
name|matches
argument_list|(
name|filter
argument_list|)
condition|)
block|{
name|answer
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|PatternSyntaxException
name|e
parameter_list|)
block|{
comment|// ignore as filter is maybe not a pattern
block|}
block|}
block|}
block|}
block|}
block|}
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|findDataFormatNames (String filter)
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|findDataFormatNames
parameter_list|(
name|String
name|filter
parameter_list|)
block|{
comment|// should not cache when filter parameter can by any kind of value
name|List
argument_list|<
name|String
argument_list|>
name|answer
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|findDataFormatNames
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
name|String
name|json
init|=
name|dataFormatJSonSchema
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|json
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|rows
init|=
name|JSonSchemaHelper
operator|.
name|parseJsonSchema
argument_list|(
literal|"dataformat"
argument_list|,
name|json
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|row
range|:
name|rows
control|)
block|{
if|if
condition|(
name|row
operator|.
name|containsKey
argument_list|(
literal|"label"
argument_list|)
condition|)
block|{
name|String
name|label
init|=
name|row
operator|.
name|get
argument_list|(
literal|"label"
argument_list|)
decl_stmt|;
name|String
index|[]
name|parts
init|=
name|label
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|part
range|:
name|parts
control|)
block|{
try|try
block|{
if|if
condition|(
name|part
operator|.
name|equalsIgnoreCase
argument_list|(
name|filter
argument_list|)
operator|||
name|CatalogHelper
operator|.
name|matchWildcard
argument_list|(
name|part
argument_list|,
name|filter
argument_list|)
operator|||
name|part
operator|.
name|matches
argument_list|(
name|filter
argument_list|)
condition|)
block|{
name|answer
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|PatternSyntaxException
name|e
parameter_list|)
block|{
comment|// ignore as filter is maybe not a pattern
block|}
block|}
block|}
block|}
block|}
block|}
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|findLanguageNames (String filter)
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|findLanguageNames
parameter_list|(
name|String
name|filter
parameter_list|)
block|{
comment|// should not cache when filter parameter can by any kind of value
name|List
argument_list|<
name|String
argument_list|>
name|answer
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|findLanguageNames
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
name|String
name|json
init|=
name|languageJSonSchema
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|json
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|rows
init|=
name|JSonSchemaHelper
operator|.
name|parseJsonSchema
argument_list|(
literal|"language"
argument_list|,
name|json
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|row
range|:
name|rows
control|)
block|{
if|if
condition|(
name|row
operator|.
name|containsKey
argument_list|(
literal|"label"
argument_list|)
condition|)
block|{
name|String
name|label
init|=
name|row
operator|.
name|get
argument_list|(
literal|"label"
argument_list|)
decl_stmt|;
name|String
index|[]
name|parts
init|=
name|label
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|part
range|:
name|parts
control|)
block|{
try|try
block|{
if|if
condition|(
name|part
operator|.
name|equalsIgnoreCase
argument_list|(
name|filter
argument_list|)
operator|||
name|CatalogHelper
operator|.
name|matchWildcard
argument_list|(
name|part
argument_list|,
name|filter
argument_list|)
operator|||
name|part
operator|.
name|matches
argument_list|(
name|filter
argument_list|)
condition|)
block|{
name|answer
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|PatternSyntaxException
name|e
parameter_list|)
block|{
comment|// ignore as filter is maybe not a pattern
block|}
block|}
block|}
block|}
block|}
block|}
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|modelJSonSchema (String name)
specifier|public
name|String
name|modelJSonSchema
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
name|file
init|=
name|MODEL_JSON
operator|+
literal|"/"
operator|+
name|name
operator|+
literal|".json"
decl_stmt|;
name|String
name|answer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|answer
operator|=
operator|(
name|String
operator|)
name|cache
operator|.
name|get
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
name|InputStream
name|is
init|=
name|DefaultCamelCatalog
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|answer
operator|=
name|CatalogHelper
operator|.
name|loadText
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
if|if
condition|(
name|caching
condition|)
block|{
name|cache
operator|.
name|put
argument_list|(
name|file
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|componentJSonSchema (String name)
specifier|public
name|String
name|componentJSonSchema
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
name|file
init|=
name|COMPONENTS_JSON
operator|+
literal|"/"
operator|+
name|name
operator|+
literal|".json"
decl_stmt|;
name|String
name|answer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|answer
operator|=
operator|(
name|String
operator|)
name|cache
operator|.
name|get
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
name|InputStream
name|is
init|=
name|DefaultCamelCatalog
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|answer
operator|=
name|CatalogHelper
operator|.
name|loadText
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
if|if
condition|(
name|caching
condition|)
block|{
name|cache
operator|.
name|put
argument_list|(
name|file
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|dataFormatJSonSchema (String name)
specifier|public
name|String
name|dataFormatJSonSchema
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
name|file
init|=
name|DATA_FORMATS_JSON
operator|+
literal|"/"
operator|+
name|name
operator|+
literal|".json"
decl_stmt|;
name|String
name|answer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|answer
operator|=
operator|(
name|String
operator|)
name|cache
operator|.
name|get
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
name|InputStream
name|is
init|=
name|DefaultCamelCatalog
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|answer
operator|=
name|CatalogHelper
operator|.
name|loadText
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
if|if
condition|(
name|caching
condition|)
block|{
name|cache
operator|.
name|put
argument_list|(
name|file
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|languageJSonSchema (String name)
specifier|public
name|String
name|languageJSonSchema
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
name|file
init|=
name|LANGUAGE_JSON
operator|+
literal|"/"
operator|+
name|name
operator|+
literal|".json"
decl_stmt|;
name|String
name|answer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|answer
operator|=
operator|(
name|String
operator|)
name|cache
operator|.
name|get
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
name|InputStream
name|is
init|=
name|DefaultCamelCatalog
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|answer
operator|=
name|CatalogHelper
operator|.
name|loadText
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
if|if
condition|(
name|caching
condition|)
block|{
name|cache
operator|.
name|put
argument_list|(
name|file
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|findModelLabels ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|findModelLabels
parameter_list|()
block|{
name|SortedSet
argument_list|<
name|String
argument_list|>
name|answer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|answer
operator|=
operator|(
name|TreeSet
argument_list|<
name|String
argument_list|>
operator|)
name|cache
operator|.
name|get
argument_list|(
literal|"findModelLabels"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
name|answer
operator|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|findModelNames
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
name|String
name|json
init|=
name|modelJSonSchema
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|json
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|rows
init|=
name|JSonSchemaHelper
operator|.
name|parseJsonSchema
argument_list|(
literal|"model"
argument_list|,
name|json
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|row
range|:
name|rows
control|)
block|{
if|if
condition|(
name|row
operator|.
name|containsKey
argument_list|(
literal|"label"
argument_list|)
condition|)
block|{
name|String
name|label
init|=
name|row
operator|.
name|get
argument_list|(
literal|"label"
argument_list|)
decl_stmt|;
name|String
index|[]
name|parts
init|=
name|label
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|part
range|:
name|parts
control|)
block|{
name|answer
operator|.
name|add
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|caching
condition|)
block|{
name|cache
operator|.
name|put
argument_list|(
literal|"findModelLabels"
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|findComponentLabels ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|findComponentLabels
parameter_list|()
block|{
name|SortedSet
argument_list|<
name|String
argument_list|>
name|answer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|answer
operator|=
operator|(
name|TreeSet
argument_list|<
name|String
argument_list|>
operator|)
name|cache
operator|.
name|get
argument_list|(
literal|"findComponentLabels"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
name|answer
operator|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|findComponentNames
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
name|String
name|json
init|=
name|componentJSonSchema
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|json
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|rows
init|=
name|JSonSchemaHelper
operator|.
name|parseJsonSchema
argument_list|(
literal|"component"
argument_list|,
name|json
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|row
range|:
name|rows
control|)
block|{
if|if
condition|(
name|row
operator|.
name|containsKey
argument_list|(
literal|"label"
argument_list|)
condition|)
block|{
name|String
name|label
init|=
name|row
operator|.
name|get
argument_list|(
literal|"label"
argument_list|)
decl_stmt|;
name|String
index|[]
name|parts
init|=
name|label
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|part
range|:
name|parts
control|)
block|{
name|answer
operator|.
name|add
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|caching
condition|)
block|{
name|cache
operator|.
name|put
argument_list|(
literal|"findComponentLabels"
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|findDataFormatLabels ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|findDataFormatLabels
parameter_list|()
block|{
name|SortedSet
argument_list|<
name|String
argument_list|>
name|answer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|answer
operator|=
operator|(
name|TreeSet
argument_list|<
name|String
argument_list|>
operator|)
name|cache
operator|.
name|get
argument_list|(
literal|"findDataFormatLabels"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
name|answer
operator|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|findDataFormatNames
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
name|String
name|json
init|=
name|dataFormatJSonSchema
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|json
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|rows
init|=
name|JSonSchemaHelper
operator|.
name|parseJsonSchema
argument_list|(
literal|"dataformat"
argument_list|,
name|json
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|row
range|:
name|rows
control|)
block|{
if|if
condition|(
name|row
operator|.
name|containsKey
argument_list|(
literal|"label"
argument_list|)
condition|)
block|{
name|String
name|label
init|=
name|row
operator|.
name|get
argument_list|(
literal|"label"
argument_list|)
decl_stmt|;
name|String
index|[]
name|parts
init|=
name|label
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|part
range|:
name|parts
control|)
block|{
name|answer
operator|.
name|add
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|caching
condition|)
block|{
name|cache
operator|.
name|put
argument_list|(
literal|"findDataFormatLabels"
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|findLanguageLabels ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|findLanguageLabels
parameter_list|()
block|{
name|SortedSet
argument_list|<
name|String
argument_list|>
name|answer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|answer
operator|=
operator|(
name|TreeSet
argument_list|<
name|String
argument_list|>
operator|)
name|cache
operator|.
name|get
argument_list|(
literal|"findLanguageLabels"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
name|answer
operator|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|findLanguageNames
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
name|String
name|json
init|=
name|languageJSonSchema
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|json
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|rows
init|=
name|JSonSchemaHelper
operator|.
name|parseJsonSchema
argument_list|(
literal|"language"
argument_list|,
name|json
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|row
range|:
name|rows
control|)
block|{
if|if
condition|(
name|row
operator|.
name|containsKey
argument_list|(
literal|"label"
argument_list|)
condition|)
block|{
name|String
name|label
init|=
name|row
operator|.
name|get
argument_list|(
literal|"label"
argument_list|)
decl_stmt|;
name|String
index|[]
name|parts
init|=
name|label
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|part
range|:
name|parts
control|)
block|{
name|answer
operator|.
name|add
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|caching
condition|)
block|{
name|cache
operator|.
name|put
argument_list|(
literal|"findLanguageLabels"
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|archetypeCatalogAsXml ()
specifier|public
name|String
name|archetypeCatalogAsXml
parameter_list|()
block|{
name|String
name|file
init|=
name|ARCHETYPES_CATALOG
decl_stmt|;
name|String
name|answer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|answer
operator|=
operator|(
name|String
operator|)
name|cache
operator|.
name|get
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
name|InputStream
name|is
init|=
name|DefaultCamelCatalog
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|answer
operator|=
name|CatalogHelper
operator|.
name|loadText
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
if|if
condition|(
name|caching
condition|)
block|{
name|cache
operator|.
name|put
argument_list|(
name|file
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|springSchemaAsXml ()
specifier|public
name|String
name|springSchemaAsXml
parameter_list|()
block|{
name|String
name|file
init|=
name|SCHEMAS_XML
operator|+
literal|"/camel-spring.xsd"
decl_stmt|;
name|String
name|answer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|answer
operator|=
operator|(
name|String
operator|)
name|cache
operator|.
name|get
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
name|InputStream
name|is
init|=
name|DefaultCamelCatalog
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|answer
operator|=
name|CatalogHelper
operator|.
name|loadText
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
if|if
condition|(
name|caching
condition|)
block|{
name|cache
operator|.
name|put
argument_list|(
name|file
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|blueprintSchemaAsXml ()
specifier|public
name|String
name|blueprintSchemaAsXml
parameter_list|()
block|{
name|String
name|file
init|=
name|SCHEMAS_XML
operator|+
literal|"/camel-blueprint.xsd"
decl_stmt|;
name|String
name|answer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|answer
operator|=
operator|(
name|String
operator|)
name|cache
operator|.
name|get
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
name|InputStream
name|is
init|=
name|DefaultCamelCatalog
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|answer
operator|=
name|CatalogHelper
operator|.
name|loadText
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
if|if
condition|(
name|caching
condition|)
block|{
name|cache
operator|.
name|put
argument_list|(
name|file
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|validateProperties (String uri)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|validateProperties
parameter_list|(
name|String
name|uri
parameter_list|)
throws|throws
name|URISyntaxException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|answer
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// parse the uri
name|URI
name|u
init|=
name|normalizeUri
argument_list|(
name|uri
argument_list|)
decl_stmt|;
name|String
name|scheme
init|=
name|u
operator|.
name|getScheme
argument_list|()
decl_stmt|;
name|String
name|json
init|=
name|componentJSonSchema
argument_list|(
name|scheme
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|rows
init|=
name|JSonSchemaHelper
operator|.
name|parseJsonSchema
argument_list|(
literal|"properties"
argument_list|,
name|json
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// parse into a map of properties of the uri, and look for options that are invalid
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|properties
init|=
name|endpointProperties
argument_list|(
name|uri
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|property
range|:
name|properties
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|property
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|value
init|=
name|property
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|boolean
name|placeholder
init|=
name|value
operator|.
name|startsWith
argument_list|(
literal|"{{"
argument_list|)
operator|||
name|value
operator|.
name|startsWith
argument_list|(
literal|"${"
argument_list|)
operator|||
name|value
operator|.
name|startsWith
argument_list|(
literal|"$simple{"
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|row
init|=
name|getRow
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
comment|// unknown option
if|if
condition|(
name|row
operator|==
literal|null
condition|)
block|{
name|answer
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|property
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// invalid value/type
comment|// is required but the value is empty
name|boolean
name|required
init|=
name|isPropertyRequired
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|required
operator|&&
name|isEmpty
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|answer
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|// is enum but the value is not within the enum range
comment|// but we can only check if the value is not a placeholder
name|String
name|enums
init|=
name|getPropertyEnum
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|placeholder
operator|&&
name|enums
operator|!=
literal|null
condition|)
block|{
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|enums
operator|.
name|split
argument_list|(
literal|","
argument_list|)
control|)
block|{
if|if
condition|(
name|value
operator|.
name|equalsIgnoreCase
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|answer
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|// is boolean
if|if
condition|(
operator|!
name|placeholder
operator|&&
name|isPropertyBoolean
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
condition|)
block|{
comment|// value must be a boolean
name|boolean
name|bool
init|=
literal|"true"
operator|.
name|equalsIgnoreCase
argument_list|(
name|value
argument_list|)
operator|||
literal|"false"
operator|.
name|equalsIgnoreCase
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bool
condition|)
block|{
name|answer
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|// is integer
if|if
condition|(
operator|!
name|placeholder
operator|&&
name|isPropertyInteger
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
condition|)
block|{
comment|// value must be an integer
name|boolean
name|valid
init|=
literal|false
decl_stmt|;
try|try
block|{
name|valid
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
operator|!=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// ignore
block|}
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|answer
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|// is number
if|if
condition|(
operator|!
name|placeholder
operator|&&
name|isPropertyNumber
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
condition|)
block|{
comment|// value must be an number
name|boolean
name|valid
init|=
literal|false
decl_stmt|;
try|try
block|{
name|valid
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
operator|.
name|isNaN
argument_list|()
operator|==
literal|false
operator|||
name|Float
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
operator|.
name|isNaN
argument_list|()
operator|==
literal|false
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// ignore
block|}
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|answer
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// now check if all required values are there, and that a default value does not exists
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|row
range|:
name|rows
control|)
block|{
name|String
name|name
init|=
name|row
operator|.
name|get
argument_list|(
literal|"name"
argument_list|)
decl_stmt|;
name|boolean
name|required
init|=
name|isPropertyRequired
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|required
condition|)
block|{
name|String
name|value
init|=
name|properties
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|isEmpty
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|value
operator|=
name|getPropertyDefaultValue
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isEmpty
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|answer
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|endpointProperties (String uri)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|endpointProperties
parameter_list|(
name|String
name|uri
parameter_list|)
throws|throws
name|URISyntaxException
block|{
comment|// NOTICE: This logic is similar to org.apache.camel.util.EndpointHelper#endpointProperties
comment|// as the catalog also offers similar functionality (without having camel-core on classpath)
comment|// need to normalize uri first
comment|// parse the uri
name|URI
name|u
init|=
name|normalizeUri
argument_list|(
name|uri
argument_list|)
decl_stmt|;
name|String
name|scheme
init|=
name|u
operator|.
name|getScheme
argument_list|()
decl_stmt|;
name|String
name|json
init|=
name|componentJSonSchema
argument_list|(
name|scheme
argument_list|)
decl_stmt|;
if|if
condition|(
name|json
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot find endpoint with scheme "
operator|+
name|scheme
argument_list|)
throw|;
block|}
comment|// grab the syntax
name|String
name|syntax
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|rows
init|=
name|JSonSchemaHelper
operator|.
name|parseJsonSchema
argument_list|(
literal|"component"
argument_list|,
name|json
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|row
range|:
name|rows
control|)
block|{
if|if
condition|(
name|row
operator|.
name|containsKey
argument_list|(
literal|"syntax"
argument_list|)
condition|)
block|{
name|syntax
operator|=
name|row
operator|.
name|get
argument_list|(
literal|"syntax"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|syntax
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Endpoint with scheme "
operator|+
name|scheme
operator|+
literal|" has no syntax defined in the json schema"
argument_list|)
throw|;
block|}
comment|// clip the scheme from the syntax
name|syntax
operator|=
name|after
argument_list|(
name|syntax
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
comment|// clip the scheme from the uri
name|uri
operator|=
name|after
argument_list|(
name|uri
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|String
name|uriPath
init|=
name|stripQuery
argument_list|(
name|uri
argument_list|)
decl_stmt|;
comment|// parse the syntax and find the names of each option
name|Matcher
name|matcher
init|=
name|SYNTAX_PATTERN
operator|.
name|matcher
argument_list|(
name|syntax
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|word
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|s
init|=
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|scheme
operator|.
name|equals
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|word
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|// parse the syntax and find each token between each option
name|String
index|[]
name|tokens
init|=
name|SYNTAX_PATTERN
operator|.
name|split
argument_list|(
name|syntax
argument_list|)
decl_stmt|;
comment|// find the position where each option start/end
name|List
argument_list|<
name|String
argument_list|>
name|word2
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|prev
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|token
range|:
name|tokens
control|)
block|{
if|if
condition|(
name|token
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
comment|// special for some tokens where :// can be used also, eg http://foo
name|int
name|idx
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
literal|":"
operator|.
name|equals
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|idx
operator|=
name|uriPath
operator|.
name|indexOf
argument_list|(
literal|"://"
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|len
operator|=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
block|{
name|idx
operator|=
name|uriPath
operator|.
name|indexOf
argument_list|(
name|token
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|len
operator|=
name|token
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|>
literal|0
condition|)
block|{
name|String
name|option
init|=
name|uriPath
operator|.
name|substring
argument_list|(
name|prev
argument_list|,
name|idx
argument_list|)
decl_stmt|;
name|word2
operator|.
name|add
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|prev
operator|=
name|idx
operator|+
name|len
expr_stmt|;
block|}
block|}
comment|// special for last or if we did not add anyone
if|if
condition|(
name|prev
operator|>
literal|0
operator|||
name|word2
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|option
init|=
name|uriPath
operator|.
name|substring
argument_list|(
name|prev
argument_list|)
decl_stmt|;
name|word2
operator|.
name|add
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
name|rows
operator|=
name|JSonSchemaHelper
operator|.
name|parseJsonSchema
argument_list|(
literal|"properties"
argument_list|,
name|json
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|boolean
name|defaultValueAdded
init|=
literal|false
decl_stmt|;
comment|// now parse the uri to know which part isw what
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|options
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// word contains the syntax path elements
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|word2
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|word
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|key
init|=
name|word
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|boolean
name|allOptions
init|=
name|word
operator|.
name|size
argument_list|()
operator|==
name|word2
operator|.
name|size
argument_list|()
decl_stmt|;
name|boolean
name|required
init|=
name|isPropertyRequired
argument_list|(
name|rows
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|String
name|defaultValue
init|=
name|getPropertyDefaultValue
argument_list|(
name|rows
argument_list|,
name|key
argument_list|)
decl_stmt|;
comment|// we have all options so no problem
if|if
condition|(
name|allOptions
condition|)
block|{
name|String
name|value
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|options
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we have a little problem as we do not not have all options
if|if
condition|(
operator|!
name|required
condition|)
block|{
name|String
name|value
init|=
name|defaultValue
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|defaultValueAdded
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|String
name|value
init|=
name|it
operator|.
name|hasNext
argument_list|()
condition|?
name|it
operator|.
name|next
argument_list|()
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|answer
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// remove all options which are using default values and are not required
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|options
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|defaultValueAdded
condition|)
block|{
name|boolean
name|required
init|=
name|isPropertyRequired
argument_list|(
name|rows
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|String
name|defaultValue
init|=
name|getPropertyDefaultValue
argument_list|(
name|rows
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|required
operator|&&
name|defaultValue
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|defaultValue
operator|.
name|equals
argument_list|(
name|value
argument_list|)
condition|)
block|{
continue|continue;
block|}
block|}
block|}
comment|// we should keep this in the answer
name|answer
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|// now parse the uri parameters
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|parameters
init|=
name|URISupport
operator|.
name|parseParameters
argument_list|(
name|u
argument_list|)
decl_stmt|;
comment|// and covert the values to String so its JMX friendly
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|parameters
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
condition|?
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
else|:
literal|""
decl_stmt|;
name|answer
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|endpointComponentName (String uri)
specifier|public
name|String
name|endpointComponentName
parameter_list|(
name|String
name|uri
parameter_list|)
block|{
if|if
condition|(
name|uri
operator|!=
literal|null
condition|)
block|{
name|int
name|idx
init|=
name|uri
operator|.
name|indexOf
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|>
literal|0
condition|)
block|{
return|return
name|uri
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|idx
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|asEndpointUri (String scheme, String json, boolean encode)
specifier|public
name|String
name|asEndpointUri
parameter_list|(
name|String
name|scheme
parameter_list|,
name|String
name|json
parameter_list|,
name|boolean
name|encode
parameter_list|)
throws|throws
name|URISyntaxException
block|{
return|return
name|doAsEndpointUri
argument_list|(
name|scheme
argument_list|,
name|json
argument_list|,
literal|"&"
argument_list|,
name|encode
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|asEndpointUriXml (String scheme, String json, boolean encode)
specifier|public
name|String
name|asEndpointUriXml
parameter_list|(
name|String
name|scheme
parameter_list|,
name|String
name|json
parameter_list|,
name|boolean
name|encode
parameter_list|)
throws|throws
name|URISyntaxException
block|{
return|return
name|doAsEndpointUri
argument_list|(
name|scheme
argument_list|,
name|json
argument_list|,
literal|"&amp;"
argument_list|,
name|encode
argument_list|)
return|;
block|}
DECL|method|doAsEndpointUri (String scheme, String json, String ampersand, boolean encode)
specifier|private
name|String
name|doAsEndpointUri
parameter_list|(
name|String
name|scheme
parameter_list|,
name|String
name|json
parameter_list|,
name|String
name|ampersand
parameter_list|,
name|boolean
name|encode
parameter_list|)
throws|throws
name|URISyntaxException
block|{
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|rows
init|=
name|JSonSchemaHelper
operator|.
name|parseJsonSchema
argument_list|(
literal|"properties"
argument_list|,
name|json
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|copy
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|row
range|:
name|rows
control|)
block|{
name|String
name|name
init|=
name|row
operator|.
name|get
argument_list|(
literal|"name"
argument_list|)
decl_stmt|;
name|String
name|required
init|=
name|row
operator|.
name|get
argument_list|(
literal|"required"
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|row
operator|.
name|get
argument_list|(
literal|"value"
argument_list|)
decl_stmt|;
name|String
name|defaultValue
init|=
name|row
operator|.
name|get
argument_list|(
literal|"defaultValue"
argument_list|)
decl_stmt|;
comment|// only add if either required, or the value is != default value
name|String
name|valueToAdd
init|=
literal|null
decl_stmt|;
if|if
condition|(
literal|"true"
operator|.
name|equals
argument_list|(
name|required
argument_list|)
condition|)
block|{
name|valueToAdd
operator|=
name|value
operator|!=
literal|null
condition|?
name|value
else|:
name|defaultValue
expr_stmt|;
if|if
condition|(
name|valueToAdd
operator|==
literal|null
condition|)
block|{
name|valueToAdd
operator|=
literal|""
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// if we have a value and no default then add it
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|defaultValue
operator|==
literal|null
condition|)
block|{
name|valueToAdd
operator|=
name|value
expr_stmt|;
block|}
comment|// otherwise only add if the value is != default value
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|defaultValue
operator|!=
literal|null
operator|&&
operator|!
name|value
operator|.
name|equals
argument_list|(
name|defaultValue
argument_list|)
condition|)
block|{
name|valueToAdd
operator|=
name|value
expr_stmt|;
block|}
block|}
if|if
condition|(
name|valueToAdd
operator|!=
literal|null
condition|)
block|{
name|copy
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|valueToAdd
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|doAsEndpointUri
argument_list|(
name|scheme
argument_list|,
name|copy
argument_list|,
name|ampersand
argument_list|,
name|encode
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|asEndpointUri (String scheme, Map<String, String> properties, boolean encode)
specifier|public
name|String
name|asEndpointUri
parameter_list|(
name|String
name|scheme
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|properties
parameter_list|,
name|boolean
name|encode
parameter_list|)
throws|throws
name|URISyntaxException
block|{
return|return
name|doAsEndpointUri
argument_list|(
name|scheme
argument_list|,
name|properties
argument_list|,
literal|"&"
argument_list|,
name|encode
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|asEndpointUriXml (String scheme, Map<String, String> properties, boolean encode)
specifier|public
name|String
name|asEndpointUriXml
parameter_list|(
name|String
name|scheme
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|properties
parameter_list|,
name|boolean
name|encode
parameter_list|)
throws|throws
name|URISyntaxException
block|{
return|return
name|doAsEndpointUri
argument_list|(
name|scheme
argument_list|,
name|properties
argument_list|,
literal|"&amp;"
argument_list|,
name|encode
argument_list|)
return|;
block|}
DECL|method|doAsEndpointUri (String scheme, Map<String, String> properties, String ampersand, boolean encode)
specifier|private
name|String
name|doAsEndpointUri
parameter_list|(
name|String
name|scheme
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|properties
parameter_list|,
name|String
name|ampersand
parameter_list|,
name|boolean
name|encode
parameter_list|)
throws|throws
name|URISyntaxException
block|{
name|String
name|json
init|=
name|componentJSonSchema
argument_list|(
name|scheme
argument_list|)
decl_stmt|;
if|if
condition|(
name|json
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot find endpoint with scheme "
operator|+
name|scheme
argument_list|)
throw|;
block|}
comment|// grab the syntax
name|String
name|syntax
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|rows
init|=
name|JSonSchemaHelper
operator|.
name|parseJsonSchema
argument_list|(
literal|"component"
argument_list|,
name|json
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|row
range|:
name|rows
control|)
block|{
if|if
condition|(
name|row
operator|.
name|containsKey
argument_list|(
literal|"syntax"
argument_list|)
condition|)
block|{
name|syntax
operator|=
name|row
operator|.
name|get
argument_list|(
literal|"syntax"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|syntax
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Endpoint with scheme "
operator|+
name|scheme
operator|+
literal|" has no syntax defined in the json schema"
argument_list|)
throw|;
block|}
comment|// do any properties filtering which can be needed for some special components
name|properties
operator|=
name|filterProperties
argument_list|(
name|scheme
argument_list|,
name|properties
argument_list|)
expr_stmt|;
name|rows
operator|=
name|JSonSchemaHelper
operator|.
name|parseJsonSchema
argument_list|(
literal|"properties"
argument_list|,
name|json
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// clip the scheme from the syntax
name|syntax
operator|=
name|after
argument_list|(
name|syntax
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|String
name|originalSyntax
init|=
name|syntax
decl_stmt|;
comment|// build at first according to syntax (use a tree map as we want the uri options sorted)
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|copy
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|properties
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
condition|?
name|entry
operator|.
name|getValue
argument_list|()
else|:
literal|""
decl_stmt|;
if|if
condition|(
name|syntax
operator|!=
literal|null
operator|&&
name|syntax
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|syntax
operator|=
name|syntax
operator|.
name|replace
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|copy
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|// the tokens between the options in the path
name|String
index|[]
name|tokens
init|=
name|syntax
operator|.
name|split
argument_list|(
literal|"\\w+"
argument_list|)
decl_stmt|;
comment|// parse the syntax into each options
name|Matcher
name|matcher
init|=
name|SYNTAX_PATTERN
operator|.
name|matcher
argument_list|(
name|originalSyntax
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|options
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|s
init|=
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|options
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|// parse the syntax into each options
name|Matcher
name|matcher2
init|=
name|SYNTAX_PATTERN
operator|.
name|matcher
argument_list|(
name|syntax
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|options2
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|matcher2
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|s
init|=
name|matcher2
operator|.
name|group
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|options2
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|// build the endpoint
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|scheme
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|int
name|range
init|=
literal|0
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
name|boolean
name|hasQuestionmark
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|options
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|key
init|=
name|options
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|key2
init|=
name|options2
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|token
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|tokens
operator|.
name|length
operator|>
name|i
condition|)
block|{
name|token
operator|=
name|tokens
index|[
name|i
index|]
expr_stmt|;
block|}
name|boolean
name|contains
init|=
name|properties
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|contains
condition|)
block|{
comment|// if the key are similar we have no explicit value and can try to find a default value if the option is required
if|if
condition|(
name|isPropertyRequired
argument_list|(
name|rows
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|String
name|value
init|=
name|getPropertyDefaultValue
argument_list|(
name|rows
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|properties
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|key2
operator|=
name|value
expr_stmt|;
block|}
block|}
block|}
comment|// was the option provided?
if|if
condition|(
name|properties
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
operator|&&
name|token
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
name|hasQuestionmark
operator||=
name|key
operator|.
name|contains
argument_list|(
literal|"?"
argument_list|)
operator|||
operator|(
name|token
operator|!=
literal|null
operator|&&
name|token
operator|.
name|contains
argument_list|(
literal|"?"
argument_list|)
operator|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|key2
argument_list|)
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
block|}
name|range
operator|++
expr_stmt|;
block|}
comment|// append any extra options that was in surplus for the last
while|while
condition|(
name|range
operator|<
name|options2
operator|.
name|size
argument_list|()
condition|)
block|{
name|String
name|token
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|tokens
operator|.
name|length
operator|>
name|range
condition|)
block|{
name|token
operator|=
name|tokens
index|[
name|range
index|]
expr_stmt|;
block|}
name|String
name|key2
init|=
name|options2
operator|.
name|get
argument_list|(
name|range
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|key2
argument_list|)
expr_stmt|;
name|hasQuestionmark
operator||=
name|key2
operator|.
name|contains
argument_list|(
literal|"?"
argument_list|)
operator|||
operator|(
name|token
operator|!=
literal|null
operator|&&
name|token
operator|.
name|contains
argument_list|(
literal|"?"
argument_list|)
operator|)
expr_stmt|;
name|range
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|copy
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// the last option may already contain a ? char, if so we should use& instead of ?
name|sb
operator|.
name|append
argument_list|(
name|hasQuestionmark
condition|?
name|ampersand
else|:
literal|'?'
argument_list|)
expr_stmt|;
name|String
name|query
init|=
name|createQueryString
argument_list|(
name|copy
argument_list|,
name|ampersand
argument_list|,
name|encode
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Special logic for log endpoints to deal when showAll=true      */
DECL|method|filterProperties (String scheme, Map<String, String> options)
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|filterProperties
parameter_list|(
name|String
name|scheme
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|options
parameter_list|)
block|{
if|if
condition|(
literal|"log"
operator|.
name|equals
argument_list|(
name|scheme
argument_list|)
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|answer
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|showAll
init|=
name|options
operator|.
name|get
argument_list|(
literal|"showAll"
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"true"
operator|.
name|equals
argument_list|(
name|showAll
argument_list|)
condition|)
block|{
comment|// remove all the other showXXX options when showAll=true
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|options
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|boolean
name|skip
init|=
name|key
operator|.
name|startsWith
argument_list|(
literal|"show"
argument_list|)
operator|&&
operator|!
name|key
operator|.
name|equals
argument_list|(
literal|"showAll"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|skip
condition|)
block|{
name|answer
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|answer
return|;
block|}
else|else
block|{
comment|// use as-is
return|return
name|options
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|listComponentsAsJson ()
specifier|public
name|String
name|listComponentsAsJson
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|findComponentNames
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|names
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|scheme
init|=
name|names
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|json
init|=
name|componentJSonSchema
argument_list|(
name|scheme
argument_list|)
decl_stmt|;
comment|// skip first line
name|json
operator|=
name|CatalogHelper
operator|.
name|between
argument_list|(
name|json
argument_list|,
literal|"\"component\": {"
argument_list|,
literal|"\"componentProperties\": {"
argument_list|)
expr_stmt|;
name|json
operator|=
name|json
operator|!=
literal|null
condition|?
name|json
operator|.
name|trim
argument_list|()
else|:
literal|""
expr_stmt|;
comment|// skip last comma if not the last
if|if
condition|(
name|i
operator|==
name|names
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|json
operator|=
name|json
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|json
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"  {\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|json
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"\n]"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|listDataFormatsAsJson ()
specifier|public
name|String
name|listDataFormatsAsJson
parameter_list|()
block|{
name|String
name|answer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|answer
operator|=
operator|(
name|String
operator|)
name|cache
operator|.
name|get
argument_list|(
literal|"listDataFormatsAsJson"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|findDataFormatNames
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|names
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|scheme
init|=
name|names
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|json
init|=
name|dataFormatJSonSchema
argument_list|(
name|scheme
argument_list|)
decl_stmt|;
comment|// skip first line
name|json
operator|=
name|CatalogHelper
operator|.
name|between
argument_list|(
name|json
argument_list|,
literal|"\"dataformat\": {"
argument_list|,
literal|"\"properties\": {"
argument_list|)
expr_stmt|;
name|json
operator|=
name|json
operator|!=
literal|null
condition|?
name|json
operator|.
name|trim
argument_list|()
else|:
literal|""
expr_stmt|;
comment|// skip last comma if not the last
if|if
condition|(
name|i
operator|==
name|names
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|json
operator|=
name|json
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|json
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"  {\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|json
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"\n]"
argument_list|)
expr_stmt|;
name|answer
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|cache
operator|.
name|put
argument_list|(
literal|"listDataFormatsAsJson"
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|listLanguagesAsJson ()
specifier|public
name|String
name|listLanguagesAsJson
parameter_list|()
block|{
name|String
name|answer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|answer
operator|=
operator|(
name|String
operator|)
name|cache
operator|.
name|get
argument_list|(
literal|"listLanguagesAsJson"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|findLanguageNames
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|names
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|scheme
init|=
name|names
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|json
init|=
name|languageJSonSchema
argument_list|(
name|scheme
argument_list|)
decl_stmt|;
comment|// skip first line
name|json
operator|=
name|CatalogHelper
operator|.
name|between
argument_list|(
name|json
argument_list|,
literal|"\"language\": {"
argument_list|,
literal|"\"properties\": {"
argument_list|)
expr_stmt|;
name|json
operator|=
name|json
operator|!=
literal|null
condition|?
name|json
operator|.
name|trim
argument_list|()
else|:
literal|""
expr_stmt|;
comment|// skip last comma if not the last
if|if
condition|(
name|i
operator|==
name|names
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|json
operator|=
name|json
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|json
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"  {\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|json
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"\n]"
argument_list|)
expr_stmt|;
name|answer
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|cache
operator|.
name|put
argument_list|(
literal|"listLanguagesAsJson"
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|listModelsAsJson ()
specifier|public
name|String
name|listModelsAsJson
parameter_list|()
block|{
name|String
name|answer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|answer
operator|=
operator|(
name|String
operator|)
name|cache
operator|.
name|get
argument_list|(
literal|"listModelsAsJson"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|findModelNames
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|names
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|scheme
init|=
name|names
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|json
init|=
name|modelJSonSchema
argument_list|(
name|scheme
argument_list|)
decl_stmt|;
comment|// skip first line
name|json
operator|=
name|CatalogHelper
operator|.
name|between
argument_list|(
name|json
argument_list|,
literal|"\"model\": {"
argument_list|,
literal|"\"properties\": {"
argument_list|)
expr_stmt|;
name|json
operator|=
name|json
operator|!=
literal|null
condition|?
name|json
operator|.
name|trim
argument_list|()
else|:
literal|""
expr_stmt|;
comment|// skip last comma if not the last
if|if
condition|(
name|i
operator|==
name|names
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|json
operator|=
name|json
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|json
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"  {\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|json
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"\n]"
argument_list|)
expr_stmt|;
name|answer
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|cache
operator|.
name|put
argument_list|(
literal|"listModelsAsJson"
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|summaryAsJson ()
specifier|public
name|String
name|summaryAsJson
parameter_list|()
block|{
name|String
name|answer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|answer
operator|=
operator|(
name|String
operator|)
name|cache
operator|.
name|get
argument_list|(
literal|"summaryAsJson"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
name|int
name|archetypes
init|=
literal|0
decl_stmt|;
try|try
block|{
name|String
name|xml
init|=
name|archetypeCatalogAsXml
argument_list|()
decl_stmt|;
name|Document
name|dom
init|=
name|DocumentBuilderFactory
operator|.
name|newInstance
argument_list|()
operator|.
name|newDocumentBuilder
argument_list|()
operator|.
name|parse
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|xml
operator|.
name|getBytes
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|Object
name|val
init|=
name|XPathFactory
operator|.
name|newInstance
argument_list|()
operator|.
name|newXPath
argument_list|()
operator|.
name|evaluate
argument_list|(
literal|"count(/archetype-catalog/archetypes/archetype)"
argument_list|,
name|dom
argument_list|,
name|XPathConstants
operator|.
name|NUMBER
argument_list|)
decl_stmt|;
name|double
name|num
init|=
operator|(
name|double
operator|)
name|val
decl_stmt|;
name|archetypes
operator|=
operator|(
name|int
operator|)
name|num
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// ignore
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"  \"version\": \""
argument_list|)
operator|.
name|append
argument_list|(
name|getCatalogVersion
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\",\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"  \"eips\": "
argument_list|)
operator|.
name|append
argument_list|(
name|findModelNames
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|",\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"  \"components\": "
argument_list|)
operator|.
name|append
argument_list|(
name|findComponentNames
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|",\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"  \"dataformats\": "
argument_list|)
operator|.
name|append
argument_list|(
name|findDataFormatNames
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|",\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"  \"languages\": "
argument_list|)
operator|.
name|append
argument_list|(
name|findLanguageNames
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|",\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"  \"archetypes\": "
argument_list|)
operator|.
name|append
argument_list|(
name|archetypes
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|answer
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
if|if
condition|(
name|caching
condition|)
block|{
name|cache
operator|.
name|put
argument_list|(
literal|"summaryAsJson"
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
block|}
end_class

end_unit

