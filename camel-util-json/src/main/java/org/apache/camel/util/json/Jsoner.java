begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2016 Clifton Labs  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  * http://www.apache.org/licenses/LICENSE-2.0  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License. */
end_comment

begin_package
DECL|package|org.apache.camel.util.json
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|json
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/** Jsoner provides JSON utilities for escaping strings to be JSON compatible, thread safe parsing (RFC 4627) JSON  * strings, and serializing data to strings in JSON format.  * @since 2.0.0 */
end_comment

begin_class
DECL|class|Jsoner
specifier|public
class|class
name|Jsoner
block|{
comment|/** Flags to tweak the behavior of the primary deserialization method. */
DECL|enum|DeserializationOptions
specifier|private
specifier|static
enum|enum
name|DeserializationOptions
block|{
comment|/** Whether a multiple JSON values can be deserialized as a root element. */
DECL|enumConstant|ALLOW_CONCATENATED_JSON_VALUES
name|ALLOW_CONCATENATED_JSON_VALUES
block|,
comment|/** Whether a JsonArray can be deserialized as a root element. */
DECL|enumConstant|ALLOW_JSON_ARRAYS
name|ALLOW_JSON_ARRAYS
block|,
comment|/** Whether a boolean, null, Number, or String can be deserialized as a root element. */
DECL|enumConstant|ALLOW_JSON_DATA
name|ALLOW_JSON_DATA
block|,
comment|/** Whether a JsonObject can be deserialized as a root element. */
DECL|enumConstant|ALLOW_JSON_OBJECTS
name|ALLOW_JSON_OBJECTS
block|; 	}
comment|/** Flags to tweak the behavior of the primary serialization method. */
DECL|enum|SerializationOptions
specifier|private
specifier|static
enum|enum
name|SerializationOptions
block|{
comment|/** Instead of aborting serialization on non-JSON values that are Enums it will continue serialization with the 		 * Enums' "${PACKAGE}.${DECLARING_CLASS}.${NAME}". 		 * @see Enum */
DECL|enumConstant|ALLOW_FULLY_QUALIFIED_ENUMERATIONS
name|ALLOW_FULLY_QUALIFIED_ENUMERATIONS
block|,
comment|/** Instead of aborting serialization on non-JSON values it will continue serialization by serializing the 		 * non-JSON value directly into the now invalid JSON. Be mindful that invalid JSON will not successfully 		 * deserialize. */
DECL|enumConstant|ALLOW_INVALIDS
name|ALLOW_INVALIDS
block|,
comment|/** Instead of aborting serialization on non-JSON values that implement Jsonable it will continue serialization 		 * by deferring serialization to the Jsonable. 		 * @see Jsonable */
DECL|enumConstant|ALLOW_JSONABLES
name|ALLOW_JSONABLES
block|,
comment|/** Instead of aborting serialization on non-JSON values it will continue serialization by using reflection to 		 * best describe the value as a JsonObject. */
DECL|enumConstant|ALLOW_UNDEFINEDS
name|ALLOW_UNDEFINEDS
block|; 	}
comment|/** The possible States of a JSON deserializer. */
DECL|enum|States
specifier|private
specifier|static
enum|enum
name|States
block|{
comment|/** Post-parsing state. */
DECL|enumConstant|DONE
name|DONE
block|,
comment|/** Pre-parsing state. */
DECL|enumConstant|INITIAL
name|INITIAL
block|,
comment|/** Parsing error, ParsingException should be thrown. */
DECL|enumConstant|PARSED_ERROR
name|PARSED_ERROR
block|,
DECL|enumConstant|PARSING_ARRAY
name|PARSING_ARRAY
block|,
comment|/** Parsing a key-value pair inside of an object. */
DECL|enumConstant|PARSING_ENTRY
name|PARSING_ENTRY
block|,
DECL|enumConstant|PARSING_OBJECT
name|PARSING_OBJECT
block|; 	}
DECL|method|Jsoner ()
specifier|private
name|Jsoner
parameter_list|()
block|{
comment|/* Keeping it classy. */
block|}
comment|/** Deserializes a readable stream according to the RFC 4627 JSON specification. 	 * @param readableDeserializable representing content to be deserialized as JSON. 	 * @return either a boolean, null, Number, String, JsonObject, or JsonArray that best represents the deserializable. 	 * @throws DeserializationException if an unexpected token is encountered in the deserializable. To recover from a 	 *         DeserializationException: fix the deserializable 	 *         to no longer have an unexpected token and try again. 	 * @throws IOException if the underlying reader encounters an I/O error. Ensure the reader is properly instantiated, 	 *         isn't closed, or that it is ready before trying again. */
DECL|method|deserialize (final Reader readableDeserializable)
specifier|public
specifier|static
name|Object
name|deserialize
parameter_list|(
specifier|final
name|Reader
name|readableDeserializable
parameter_list|)
throws|throws
name|DeserializationException
throws|,
name|IOException
block|{
return|return
name|Jsoner
operator|.
name|deserialize
argument_list|(
name|readableDeserializable
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|DeserializationOptions
operator|.
name|ALLOW_JSON_ARRAYS
argument_list|,
name|DeserializationOptions
operator|.
name|ALLOW_JSON_OBJECTS
argument_list|,
name|DeserializationOptions
operator|.
name|ALLOW_JSON_DATA
argument_list|)
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/** Deserialize a stream with all deserialized JSON values are wrapped in a JsonArray. 	 * @param deserializable representing content to be deserialized as JSON. 	 * @param flags representing the allowances and restrictions on deserialization. 	 * @return the allowable object best represented by the deserializable. 	 * @throws DeserializationException if a disallowed or unexpected token is encountered in the deserializable. To 	 *         recover from a DeserializationException: fix the 	 *         deserializable to no longer have a disallowed or unexpected token and try again. 	 * @throws IOException if the underlying reader encounters an I/O error. Ensure the reader is properly instantiated, 	 *         isn't closed, or that it is ready before trying again. */
DECL|method|deserialize (final Reader deserializable, final Set<DeserializationOptions> flags)
specifier|private
specifier|static
name|JsonArray
name|deserialize
parameter_list|(
specifier|final
name|Reader
name|deserializable
parameter_list|,
specifier|final
name|Set
argument_list|<
name|DeserializationOptions
argument_list|>
name|flags
parameter_list|)
throws|throws
name|DeserializationException
throws|,
name|IOException
block|{
specifier|final
name|Yylex
name|lexer
init|=
operator|new
name|Yylex
argument_list|(
name|deserializable
argument_list|)
decl_stmt|;
name|Yytoken
name|token
decl_stmt|;
name|States
name|currentState
decl_stmt|;
name|int
name|returnCount
init|=
literal|1
decl_stmt|;
specifier|final
name|LinkedList
argument_list|<
name|States
argument_list|>
name|stateStack
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|LinkedList
argument_list|<
name|Object
argument_list|>
name|valueStack
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|stateStack
operator|.
name|addLast
argument_list|(
name|States
operator|.
name|INITIAL
argument_list|)
expr_stmt|;
comment|//System.out.println("//////////DESERIALIZING//////////");
do|do
block|{
comment|/* Parse through the parsable string's tokens. */
name|currentState
operator|=
name|Jsoner
operator|.
name|popNextState
argument_list|(
name|stateStack
argument_list|)
expr_stmt|;
name|token
operator|=
name|Jsoner
operator|.
name|lexNextToken
argument_list|(
name|lexer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|currentState
condition|)
block|{
case|case
name|DONE
case|:
comment|/* The parse has finished a JSON value. */
if|if
condition|(
operator|!
name|flags
operator|.
name|contains
argument_list|(
name|DeserializationOptions
operator|.
name|ALLOW_CONCATENATED_JSON_VALUES
argument_list|)
operator|||
name|Yytoken
operator|.
name|Types
operator|.
name|END
operator|.
name|equals
argument_list|(
name|token
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
comment|/* Break if concatenated values are not allowed or if an END token is read. */
break|break;
block|}
comment|/* Increment the amount of returned JSON values and treat the token as if it were a fresh parse. */
name|returnCount
operator|+=
literal|1
expr_stmt|;
comment|/* Fall through to the case for the initial state. */
comment|//$FALL-THROUGH$
case|case
name|INITIAL
case|:
comment|/* The parse has just started. */
switch|switch
condition|(
name|token
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|DATUM
case|:
comment|/* A boolean, null, Number, or String could be detected. */
if|if
condition|(
name|flags
operator|.
name|contains
argument_list|(
name|DeserializationOptions
operator|.
name|ALLOW_JSON_DATA
argument_list|)
condition|)
block|{
name|valueStack
operator|.
name|addLast
argument_list|(
name|token
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|stateStack
operator|.
name|addLast
argument_list|(
name|States
operator|.
name|DONE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|DeserializationException
argument_list|(
name|lexer
operator|.
name|getPosition
argument_list|()
argument_list|,
name|DeserializationException
operator|.
name|Problems
operator|.
name|DISALLOWED_TOKEN
argument_list|,
name|token
argument_list|)
throw|;
block|}
break|break;
case|case
name|LEFT_BRACE
case|:
comment|/* An object is detected. */
if|if
condition|(
name|flags
operator|.
name|contains
argument_list|(
name|DeserializationOptions
operator|.
name|ALLOW_JSON_OBJECTS
argument_list|)
condition|)
block|{
name|valueStack
operator|.
name|addLast
argument_list|(
operator|new
name|JsonObject
argument_list|()
argument_list|)
expr_stmt|;
name|stateStack
operator|.
name|addLast
argument_list|(
name|States
operator|.
name|PARSING_OBJECT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|DeserializationException
argument_list|(
name|lexer
operator|.
name|getPosition
argument_list|()
argument_list|,
name|DeserializationException
operator|.
name|Problems
operator|.
name|DISALLOWED_TOKEN
argument_list|,
name|token
argument_list|)
throw|;
block|}
break|break;
case|case
name|LEFT_SQUARE
case|:
comment|/* An array is detected. */
if|if
condition|(
name|flags
operator|.
name|contains
argument_list|(
name|DeserializationOptions
operator|.
name|ALLOW_JSON_ARRAYS
argument_list|)
condition|)
block|{
name|valueStack
operator|.
name|addLast
argument_list|(
operator|new
name|JsonArray
argument_list|()
argument_list|)
expr_stmt|;
name|stateStack
operator|.
name|addLast
argument_list|(
name|States
operator|.
name|PARSING_ARRAY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|DeserializationException
argument_list|(
name|lexer
operator|.
name|getPosition
argument_list|()
argument_list|,
name|DeserializationException
operator|.
name|Problems
operator|.
name|DISALLOWED_TOKEN
argument_list|,
name|token
argument_list|)
throw|;
block|}
break|break;
default|default:
comment|/* Neither a JSON array or object was detected. */
throw|throw
operator|new
name|DeserializationException
argument_list|(
name|lexer
operator|.
name|getPosition
argument_list|()
argument_list|,
name|DeserializationException
operator|.
name|Problems
operator|.
name|UNEXPECTED_TOKEN
argument_list|,
name|token
argument_list|)
throw|;
block|}
break|break;
case|case
name|PARSED_ERROR
case|:
comment|/* The parse could be in this state due to the state stack not having a state to pop off. */
throw|throw
operator|new
name|DeserializationException
argument_list|(
name|lexer
operator|.
name|getPosition
argument_list|()
argument_list|,
name|DeserializationException
operator|.
name|Problems
operator|.
name|UNEXPECTED_TOKEN
argument_list|,
name|token
argument_list|)
throw|;
case|case
name|PARSING_ARRAY
case|:
switch|switch
condition|(
name|token
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|COMMA
case|:
comment|/* The parse could detect a comma while parsing an array since it separates each element. */
name|stateStack
operator|.
name|addLast
argument_list|(
name|currentState
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATUM
case|:
comment|/* The parse found an element of the array. */
name|JsonArray
name|val
init|=
operator|(
name|JsonArray
operator|)
name|valueStack
operator|.
name|getLast
argument_list|()
decl_stmt|;
name|val
operator|.
name|add
argument_list|(
name|token
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|stateStack
operator|.
name|addLast
argument_list|(
name|currentState
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEFT_BRACE
case|:
comment|/* The parse found an object in the array. */
name|val
operator|=
operator|(
name|JsonArray
operator|)
name|valueStack
operator|.
name|getLast
argument_list|()
expr_stmt|;
specifier|final
name|JsonObject
name|object
init|=
operator|new
name|JsonObject
argument_list|()
decl_stmt|;
name|val
operator|.
name|add
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|valueStack
operator|.
name|addLast
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|stateStack
operator|.
name|addLast
argument_list|(
name|currentState
argument_list|)
expr_stmt|;
name|stateStack
operator|.
name|addLast
argument_list|(
name|States
operator|.
name|PARSING_OBJECT
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEFT_SQUARE
case|:
comment|/* The parse found another array in the array. */
name|val
operator|=
operator|(
name|JsonArray
operator|)
name|valueStack
operator|.
name|getLast
argument_list|()
expr_stmt|;
specifier|final
name|JsonArray
name|array
init|=
operator|new
name|JsonArray
argument_list|()
decl_stmt|;
name|val
operator|.
name|add
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|valueStack
operator|.
name|addLast
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|stateStack
operator|.
name|addLast
argument_list|(
name|currentState
argument_list|)
expr_stmt|;
name|stateStack
operator|.
name|addLast
argument_list|(
name|States
operator|.
name|PARSING_ARRAY
argument_list|)
expr_stmt|;
break|break;
case|case
name|RIGHT_SQUARE
case|:
comment|/* The parse found the end of the array. */
if|if
condition|(
name|valueStack
operator|.
name|size
argument_list|()
operator|>
name|returnCount
condition|)
block|{
name|valueStack
operator|.
name|removeLast
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* The parse has been fully resolved. */
name|stateStack
operator|.
name|addLast
argument_list|(
name|States
operator|.
name|DONE
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Any other token is invalid in an array. */
throw|throw
operator|new
name|DeserializationException
argument_list|(
name|lexer
operator|.
name|getPosition
argument_list|()
argument_list|,
name|DeserializationException
operator|.
name|Problems
operator|.
name|UNEXPECTED_TOKEN
argument_list|,
name|token
argument_list|)
throw|;
block|}
break|break;
case|case
name|PARSING_OBJECT
case|:
comment|/* The parse has detected the start of an object. */
switch|switch
condition|(
name|token
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|COMMA
case|:
comment|/* The parse could detect a comma while parsing an object since it separates each key value 							 * pair. Continue parsing the object. */
name|stateStack
operator|.
name|addLast
argument_list|(
name|currentState
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATUM
case|:
comment|/* The token ought to be a key. */
if|if
condition|(
name|token
operator|.
name|getValue
argument_list|()
operator|instanceof
name|String
condition|)
block|{
comment|/* JSON keys are always strings, strings are not always JSON keys but it is going to be 								 * treated as one. Continue parsing the object. */
specifier|final
name|String
name|key
init|=
operator|(
name|String
operator|)
name|token
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|valueStack
operator|.
name|addLast
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|stateStack
operator|.
name|addLast
argument_list|(
name|currentState
argument_list|)
expr_stmt|;
name|stateStack
operator|.
name|addLast
argument_list|(
name|States
operator|.
name|PARSING_ENTRY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Abort! JSON keys are always strings and it wasn't a string. */
throw|throw
operator|new
name|DeserializationException
argument_list|(
name|lexer
operator|.
name|getPosition
argument_list|()
argument_list|,
name|DeserializationException
operator|.
name|Problems
operator|.
name|UNEXPECTED_TOKEN
argument_list|,
name|token
argument_list|)
throw|;
block|}
break|break;
case|case
name|RIGHT_BRACE
case|:
comment|/* The parse has found the end of the object. */
if|if
condition|(
name|valueStack
operator|.
name|size
argument_list|()
operator|>
name|returnCount
condition|)
block|{
comment|/* There are unresolved values remaining. */
name|valueStack
operator|.
name|removeLast
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* The parse has been fully resolved. */
name|stateStack
operator|.
name|addLast
argument_list|(
name|States
operator|.
name|DONE
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* The parse didn't detect the end of an object or a key. */
throw|throw
operator|new
name|DeserializationException
argument_list|(
name|lexer
operator|.
name|getPosition
argument_list|()
argument_list|,
name|DeserializationException
operator|.
name|Problems
operator|.
name|UNEXPECTED_TOKEN
argument_list|,
name|token
argument_list|)
throw|;
block|}
break|break;
case|case
name|PARSING_ENTRY
case|:
switch|switch
condition|(
name|token
operator|.
name|getType
argument_list|()
condition|)
block|{
comment|/* Parsed pair keys can only happen while parsing objects. */
case|case
name|COLON
case|:
comment|/* The parse could detect a colon while parsing a key value pair since it separates the key 							 * and value from each other. Continue parsing the entry. */
name|stateStack
operator|.
name|addLast
argument_list|(
name|currentState
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATUM
case|:
comment|/* The parse has found a value for the parsed pair key. */
name|String
name|key
init|=
operator|(
name|String
operator|)
name|valueStack
operator|.
name|removeLast
argument_list|()
decl_stmt|;
name|JsonObject
name|parent
init|=
operator|(
name|JsonObject
operator|)
name|valueStack
operator|.
name|getLast
argument_list|()
decl_stmt|;
name|parent
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|token
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEFT_BRACE
case|:
comment|/* The parse has found an object for the parsed pair key. */
name|key
operator|=
operator|(
name|String
operator|)
name|valueStack
operator|.
name|removeLast
argument_list|()
expr_stmt|;
name|parent
operator|=
operator|(
name|JsonObject
operator|)
name|valueStack
operator|.
name|getLast
argument_list|()
expr_stmt|;
specifier|final
name|JsonObject
name|object
init|=
operator|new
name|JsonObject
argument_list|()
decl_stmt|;
name|parent
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|valueStack
operator|.
name|addLast
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|stateStack
operator|.
name|addLast
argument_list|(
name|States
operator|.
name|PARSING_OBJECT
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEFT_SQUARE
case|:
comment|/* The parse has found an array for the parsed pair key. */
name|key
operator|=
operator|(
name|String
operator|)
name|valueStack
operator|.
name|removeLast
argument_list|()
expr_stmt|;
name|parent
operator|=
operator|(
name|JsonObject
operator|)
name|valueStack
operator|.
name|getLast
argument_list|()
expr_stmt|;
specifier|final
name|JsonArray
name|array
init|=
operator|new
name|JsonArray
argument_list|()
decl_stmt|;
name|parent
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|array
argument_list|)
expr_stmt|;
name|valueStack
operator|.
name|addLast
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|stateStack
operator|.
name|addLast
argument_list|(
name|States
operator|.
name|PARSING_ARRAY
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* The parse didn't find anything for the parsed pair key. */
throw|throw
operator|new
name|DeserializationException
argument_list|(
name|lexer
operator|.
name|getPosition
argument_list|()
argument_list|,
name|DeserializationException
operator|.
name|Problems
operator|.
name|UNEXPECTED_TOKEN
argument_list|,
name|token
argument_list|)
throw|;
block|}
break|break;
default|default:
break|break;
block|}
comment|//System.out.println("~~~~~~~~~~~~~~~~~~~~~~~~~~~");
comment|//System.out.println(currentState);
comment|//System.out.println(token);
comment|//System.out.println(valueStack);
comment|//System.out.println(stateStack);
comment|/* If we're not at the END and DONE then do the above again. */
block|}
do|while
condition|(
operator|!
operator|(
name|States
operator|.
name|DONE
operator|.
name|equals
argument_list|(
name|currentState
argument_list|)
operator|&&
name|Yytoken
operator|.
name|Types
operator|.
name|END
operator|.
name|equals
argument_list|(
name|token
operator|.
name|getType
argument_list|()
argument_list|)
operator|)
condition|)
do|;
comment|//System.out.println("!!!!!!!!!!DESERIALIZED!!!!!!!!!!");
return|return
operator|new
name|JsonArray
argument_list|(
name|valueStack
argument_list|)
return|;
block|}
comment|/** A convenience method that assumes a StringReader to deserialize a string. 	 * @param deserializable representing content to be deserialized as JSON. 	 * @return either a boolean, null, Number, String, JsonObject, or JsonArray that best represents the deserializable. 	 * @throws DeserializationException if an unexpected token is encountered in the deserializable. To recover from a 	 *         DeserializationException: fix the deserializable 	 *         to no longer have an unexpected token and try again. 	 * @see Jsoner#deserialize(Reader) 	 * @see StringReader */
DECL|method|deserialize (final String deserializable)
specifier|public
specifier|static
name|Object
name|deserialize
parameter_list|(
specifier|final
name|String
name|deserializable
parameter_list|)
throws|throws
name|DeserializationException
block|{
name|Object
name|returnable
decl_stmt|;
name|StringReader
name|readableDeserializable
init|=
literal|null
decl_stmt|;
try|try
block|{
name|readableDeserializable
operator|=
operator|new
name|StringReader
argument_list|(
name|deserializable
argument_list|)
expr_stmt|;
name|returnable
operator|=
name|Jsoner
operator|.
name|deserialize
argument_list|(
name|readableDeserializable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|NullPointerException
name|caught
parameter_list|)
block|{
comment|/* They both have the same recovery scenario. 			 * See StringReader. 			 * If deserializable is null, it should be reasonable to expect null back. */
name|returnable
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|readableDeserializable
operator|!=
literal|null
condition|)
block|{
name|readableDeserializable
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|returnable
return|;
block|}
comment|/** A convenience method that assumes a JsonArray must be deserialized. 	 * @param deserializable representing content to be deserializable as a JsonArray. 	 * @param defaultValue representing what would be returned if deserializable isn't a JsonArray or an IOException, 	 *        NullPointerException, or DeserializationException occurs during deserialization. 	 * @return a JsonArray that represents the deserializable, or the defaultValue if there isn't a JsonArray that 	 *         represents deserializable. 	 * @see Jsoner#deserialize(Reader) */
DECL|method|deserialize (final String deserializable, final JsonArray defaultValue)
specifier|public
specifier|static
name|JsonArray
name|deserialize
parameter_list|(
specifier|final
name|String
name|deserializable
parameter_list|,
specifier|final
name|JsonArray
name|defaultValue
parameter_list|)
block|{
name|StringReader
name|readable
init|=
literal|null
decl_stmt|;
name|JsonArray
name|returnable
decl_stmt|;
try|try
block|{
name|readable
operator|=
operator|new
name|StringReader
argument_list|(
name|deserializable
argument_list|)
expr_stmt|;
name|returnable
operator|=
name|Jsoner
operator|.
name|deserialize
argument_list|(
name|readable
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|DeserializationOptions
operator|.
name|ALLOW_JSON_ARRAYS
argument_list|)
argument_list|)
operator|.
operator|<
name|JsonArray
operator|>
name|getCollection
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
decl||
name|IOException
decl||
name|DeserializationException
name|caught
parameter_list|)
block|{
comment|/* Don't care, just return the default value. */
name|returnable
operator|=
name|defaultValue
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|readable
operator|!=
literal|null
condition|)
block|{
name|readable
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|returnable
return|;
block|}
comment|/** A convenience method that assumes a JsonObject must be deserialized. 	 * @param deserializable representing content to be deserializable as a JsonObject. 	 * @param defaultValue representing what would be returned if deserializable isn't a JsonObject or an IOException, 	 *        NullPointerException, or DeserializationException occurs during deserialization. 	 * @return a JsonObject that represents the deserializable, or the defaultValue if there isn't a JsonObject that 	 *         represents deserializable. 	 * @see Jsoner#deserialize(Reader) */
DECL|method|deserialize (final String deserializable, final JsonObject defaultValue)
specifier|public
specifier|static
name|JsonObject
name|deserialize
parameter_list|(
specifier|final
name|String
name|deserializable
parameter_list|,
specifier|final
name|JsonObject
name|defaultValue
parameter_list|)
block|{
name|StringReader
name|readable
init|=
literal|null
decl_stmt|;
name|JsonObject
name|returnable
decl_stmt|;
try|try
block|{
name|readable
operator|=
operator|new
name|StringReader
argument_list|(
name|deserializable
argument_list|)
expr_stmt|;
name|returnable
operator|=
name|Jsoner
operator|.
name|deserialize
argument_list|(
name|readable
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|DeserializationOptions
operator|.
name|ALLOW_JSON_OBJECTS
argument_list|)
argument_list|)
operator|.
operator|<
name|JsonObject
operator|>
name|getMap
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
decl||
name|IOException
decl||
name|DeserializationException
name|caught
parameter_list|)
block|{
comment|/* Don't care, just return the default value. */
name|returnable
operator|=
name|defaultValue
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|readable
operator|!=
literal|null
condition|)
block|{
name|readable
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|returnable
return|;
block|}
comment|/** A convenience method that assumes multiple RFC 4627 JSON values (except numbers) have been concatenated together 	 * for deserilization which will be collectively returned in a JsonArray wrapper. 	 * There may be numbers included, they just must not be concatenated together as it is prone to 	 * NumberFormatExceptions (thus causing a DeserializationException) or the numbers no longer represent their 	 * respective values. 	 * Examples: 	 * "123null321" returns [123, null, 321] 	 * "nullnullnulltruefalse\"\"{}[]" returns [null, null, null, true, false, "", {}, []] 	 * "123" appended to "321" returns [123321] 	 * "12.3" appended to "3.21" throws DeserializationException(NumberFormatException) 	 * "123" appended to "-321" throws DeserializationException(NumberFormatException) 	 * "123e321" appended to "-1" throws DeserializationException(NumberFormatException) 	 * "null12.33.21null" throws DeserializationException(NumberFormatException) 	 * @param deserializable representing concatenated content to be deserialized as JSON in one reader. Its contents 	 *        may 	 *        not contain two numbers concatenated together. 	 * @return a JsonArray that contains each of the concatenated objects as its elements. Each concatenated element is 	 *         either a boolean, null, Number, String, JsonArray, or JsonObject that best represents the concatenated 	 *         content inside deserializable. 	 * @throws DeserializationException if an unexpected token is encountered in the deserializable. To recover from a 	 *         DeserializationException: fix the deserializable to no longer have an unexpected token and try again. 	 * @throws IOException when the underlying reader encounters an I/O error. Ensure the reader is properly 	 *         instantiated, isn't closed, or that it is ready before trying again. */
DECL|method|deserializeMany (final Reader deserializable)
specifier|public
specifier|static
name|JsonArray
name|deserializeMany
parameter_list|(
specifier|final
name|Reader
name|deserializable
parameter_list|)
throws|throws
name|DeserializationException
throws|,
name|IOException
block|{
return|return
name|Jsoner
operator|.
name|deserialize
argument_list|(
name|deserializable
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|DeserializationOptions
operator|.
name|ALLOW_JSON_ARRAYS
argument_list|,
name|DeserializationOptions
operator|.
name|ALLOW_JSON_OBJECTS
argument_list|,
name|DeserializationOptions
operator|.
name|ALLOW_JSON_DATA
argument_list|,
name|DeserializationOptions
operator|.
name|ALLOW_CONCATENATED_JSON_VALUES
argument_list|)
argument_list|)
return|;
block|}
comment|/** Escapes potentially confusing or important characters in the String provided. 	 * @param escapable an unescaped string. 	 * @return an escaped string for usage in JSON; An escaped string is one that has escaped all of the quotes ("), 	 *         backslashes (\), return character (\r), new line character (\n), tab character (\t), 	 *         backspace character (\b), form feed character (\f) and other control characters [u0000..u001F] or 	 *         characters [u007F..u009F], [u2000..u20FF] with a 	 *         backslash (\) which itself must be escaped by the backslash in a java string. */
DECL|method|escape (final String escapable)
specifier|public
specifier|static
name|String
name|escape
parameter_list|(
specifier|final
name|String
name|escapable
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
specifier|final
name|int
name|characters
init|=
name|escapable
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|characters
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|char
name|character
init|=
name|escapable
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|character
condition|)
block|{
case|case
literal|'"'
case|:
name|builder
operator|.
name|append
argument_list|(
literal|"\\\""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|builder
operator|.
name|append
argument_list|(
literal|"\\\\"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|builder
operator|.
name|append
argument_list|(
literal|"\\b"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|builder
operator|.
name|append
argument_list|(
literal|"\\f"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|builder
operator|.
name|append
argument_list|(
literal|"\\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|builder
operator|.
name|append
argument_list|(
literal|"\\r"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|builder
operator|.
name|append
argument_list|(
literal|"\\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|builder
operator|.
name|append
argument_list|(
literal|"\\/"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* The many characters that get replaced are benign to software but could be mistaken by people 					 * reading it for a JSON relevant character. */
if|if
condition|(
operator|(
operator|(
name|character
operator|>=
literal|'\u0000'
operator|)
operator|&&
operator|(
name|character
operator|<=
literal|'\u001F'
operator|)
operator|)
operator|||
operator|(
operator|(
name|character
operator|>=
literal|'\u007F'
operator|)
operator|&&
operator|(
name|character
operator|<=
literal|'\u009F'
operator|)
operator|)
operator|||
operator|(
operator|(
name|character
operator|>=
literal|'\u2000'
operator|)
operator|&&
operator|(
name|character
operator|<=
literal|'\u20FF'
operator|)
operator|)
condition|)
block|{
specifier|final
name|String
name|characterHexCode
init|=
name|Integer
operator|.
name|toHexString
argument_list|(
name|character
argument_list|)
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"\\u"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
operator|(
literal|4
operator|-
name|characterHexCode
operator|.
name|length
argument_list|()
operator|)
condition|;
name|k
operator|++
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|append
argument_list|(
name|characterHexCode
operator|.
name|toUpperCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Character didn't need escaping. */
name|builder
operator|.
name|append
argument_list|(
name|character
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Processes the lexer's reader for the next token. 	 * @param lexer represents a text processor being used in the deserialization process. 	 * @return a token representing a meaningful element encountered by the lexer. 	 * @throws DeserializationException if an unexpected character is encountered while processing the text. 	 * @throws IOException if the underlying reader inside the lexer encounters an I/O problem, like being prematurely 	 *         closed. */
DECL|method|lexNextToken (final Yylex lexer)
specifier|private
specifier|static
name|Yytoken
name|lexNextToken
parameter_list|(
specifier|final
name|Yylex
name|lexer
parameter_list|)
throws|throws
name|DeserializationException
throws|,
name|IOException
block|{
name|Yytoken
name|returnable
decl_stmt|;
comment|/* Parse through the next token. */
name|returnable
operator|=
name|lexer
operator|.
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|returnable
operator|==
literal|null
condition|)
block|{
comment|/* If there isn't another token, it must be the end. */
name|returnable
operator|=
operator|new
name|Yytoken
argument_list|(
name|Yytoken
operator|.
name|Types
operator|.
name|END
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|returnable
return|;
block|}
comment|/** Used for state transitions while deserializing. 	 * @param stateStack represents the deserialization states saved for future processing. 	 * @return a state for deserialization context so it knows how to consume the next token. */
DECL|method|popNextState (final LinkedList<States> stateStack)
specifier|private
specifier|static
name|States
name|popNextState
parameter_list|(
specifier|final
name|LinkedList
argument_list|<
name|States
argument_list|>
name|stateStack
parameter_list|)
block|{
if|if
condition|(
name|stateStack
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return
name|stateStack
operator|.
name|removeLast
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|States
operator|.
name|PARSED_ERROR
return|;
block|}
block|}
comment|/** Formats the JSON string to be more easily human readable using tabs for indentation. 	 * @param printable representing a JSON formatted string with out extraneous characters, like one returned from 	 *        Jsoner#serialize(Object). 	 * @return printable except it will have '\n' then '\t' characters inserted after '[', '{', ',' and before ']' '}' 	 *         tokens in the JSON. It will return null if printable isn't a JSON string. */
DECL|method|prettyPrint (final String printable)
specifier|public
specifier|static
name|String
name|prettyPrint
parameter_list|(
specifier|final
name|String
name|printable
parameter_list|)
block|{
return|return
name|Jsoner
operator|.
name|prettyPrint
argument_list|(
name|printable
argument_list|,
literal|"\t"
argument_list|)
return|;
block|}
comment|/** Formats the JSON string to be more easily human readable using an arbitrary amount of spaces for indentation. 	 * @param printable representing a JSON formatted string with out extraneous characters, like one returned from 	 *        Jsoner#serialize(Object). 	 * @param spaces representing the amount of spaces to use for indentation. Must be between 2 and 10. 	 * @return printable except it will have '\n' then space characters inserted after '[', '{', ',' and before ']' '}' 	 *         tokens in the JSON. It will return null if printable isn't a JSON string. 	 * @throws IllegalArgumentException if spaces isn't between [2..10]. 	 * @see Jsoner#prettyPrint(String) 	 * @since 2.2.0 to allow pretty printing with spaces instead of tabs. */
DECL|method|prettyPrint (final String printable, final int spaces)
specifier|public
specifier|static
name|String
name|prettyPrint
parameter_list|(
specifier|final
name|String
name|printable
parameter_list|,
specifier|final
name|int
name|spaces
parameter_list|)
block|{
if|if
condition|(
operator|(
name|spaces
operator|>
literal|10
operator|)
operator|||
operator|(
name|spaces
operator|<
literal|2
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Indentation with spaces must be between 2 and 10."
argument_list|)
throw|;
block|}
specifier|final
name|StringBuilder
name|indentation
init|=
operator|new
name|StringBuilder
argument_list|(
literal|""
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|spaces
condition|;
name|i
operator|++
control|)
block|{
name|indentation
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
return|return
name|Jsoner
operator|.
name|prettyPrint
argument_list|(
name|printable
argument_list|,
name|indentation
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/** Makes the JSON string more easily human readable using indentation of the caller's choice. 	 * @param printable representing a JSON formatted string with out extraneous characters, like one returned from 	 *        Jsoner#serialize(Object). 	 * @param indentation representing the indentation used to format the JSON string. 	 * @return printable except it will have '\n' then indentation characters inserted after '[', '{', ',' and before 	 *         ']' '}' 	 *         tokens in the JSON. It will return null if printable isn't a JSON string. */
DECL|method|prettyPrint (final String printable, final String indentation)
specifier|private
specifier|static
name|String
name|prettyPrint
parameter_list|(
specifier|final
name|String
name|printable
parameter_list|,
specifier|final
name|String
name|indentation
parameter_list|)
block|{
specifier|final
name|Yylex
name|lexer
init|=
operator|new
name|Yylex
argument_list|(
operator|new
name|StringReader
argument_list|(
name|printable
argument_list|)
argument_list|)
decl_stmt|;
name|Yytoken
name|lexed
decl_stmt|;
specifier|final
name|StringBuilder
name|returnable
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|level
init|=
literal|0
decl_stmt|;
try|try
block|{
do|do
block|{
name|lexed
operator|=
name|Jsoner
operator|.
name|lexNextToken
argument_list|(
name|lexer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lexed
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|COLON
case|:
name|returnable
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMMA
case|:
name|returnable
operator|.
name|append
argument_list|(
name|lexed
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|returnable
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|level
condition|;
name|i
operator|++
control|)
block|{
name|returnable
operator|.
name|append
argument_list|(
name|indentation
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|END
case|:
break|break;
case|case
name|LEFT_BRACE
case|:
case|case
name|LEFT_SQUARE
case|:
name|returnable
operator|.
name|append
argument_list|(
name|lexed
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|returnable
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|level
condition|;
name|i
operator|++
control|)
block|{
name|returnable
operator|.
name|append
argument_list|(
name|indentation
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RIGHT_BRACE
case|:
case|case
name|RIGHT_SQUARE
case|:
name|returnable
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|level
operator|--
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|level
condition|;
name|i
operator|++
control|)
block|{
name|returnable
operator|.
name|append
argument_list|(
name|indentation
argument_list|)
expr_stmt|;
block|}
name|returnable
operator|.
name|append
argument_list|(
name|lexed
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|lexed
operator|.
name|getValue
argument_list|()
operator|instanceof
name|String
condition|)
block|{
name|returnable
operator|.
name|append
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
name|returnable
operator|.
name|append
argument_list|(
name|Jsoner
operator|.
name|escape
argument_list|(
operator|(
name|String
operator|)
name|lexed
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|returnable
operator|.
name|append
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|returnable
operator|.
name|append
argument_list|(
name|lexed
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|//System.out.println(lexed);
block|}
do|while
condition|(
operator|!
name|lexed
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|Yytoken
operator|.
name|Types
operator|.
name|END
argument_list|)
condition|)
do|;
block|}
catch|catch
parameter_list|(
specifier|final
name|DeserializationException
name|caught
parameter_list|)
block|{
comment|/* This is according to the method's contract. */
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|caught
parameter_list|)
block|{
comment|/* See StringReader. */
return|return
literal|null
return|;
block|}
comment|//System.out.println(printable);
comment|//System.out.println(returnable);
comment|//System.out.println(Jsoner.escape(returnable.toString()));
return|return
name|returnable
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** A convenience method that assumes a StringWriter. 	 * @param jsonSerializable represents the object that should be serialized as a string in JSON format. 	 * @return a string, in JSON format, that represents the object provided. 	 * @throws IllegalArgumentException if the jsonSerializable isn't serializable in JSON. 	 * @see Jsoner#serialize(Object, Writer) 	 * @see StringWriter */
DECL|method|serialize (final Object jsonSerializable)
specifier|public
specifier|static
name|String
name|serialize
parameter_list|(
specifier|final
name|Object
name|jsonSerializable
parameter_list|)
block|{
specifier|final
name|StringWriter
name|writableDestination
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
try|try
block|{
name|Jsoner
operator|.
name|serialize
argument_list|(
name|jsonSerializable
argument_list|,
name|writableDestination
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|caught
parameter_list|)
block|{
comment|/* See StringWriter. */
block|}
return|return
name|writableDestination
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Serializes values according to the RFC 4627 JSON specification. It will also trust the serialization provided by 	 * any Jsonables it serializes and serializes Enums that don't implement Jsonable as a string of their fully 	 * qualified name. 	 * @param jsonSerializable represents the object that should be serialized in JSON format. 	 * @param writableDestination represents where the resulting JSON text is written to. 	 * @throws IOException if the writableDestination encounters an I/O problem, like being closed while in use. 	 * @throws IllegalArgumentException if the jsonSerializable isn't serializable in JSON. */
DECL|method|serialize (final Object jsonSerializable, final Writer writableDestination)
specifier|public
specifier|static
name|void
name|serialize
parameter_list|(
specifier|final
name|Object
name|jsonSerializable
parameter_list|,
specifier|final
name|Writer
name|writableDestination
parameter_list|)
throws|throws
name|IOException
block|{
name|Jsoner
operator|.
name|serialize
argument_list|(
name|jsonSerializable
argument_list|,
name|writableDestination
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|SerializationOptions
operator|.
name|ALLOW_JSONABLES
argument_list|,
name|SerializationOptions
operator|.
name|ALLOW_FULLY_QUALIFIED_ENUMERATIONS
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Serialize values to JSON and write them to the provided writer based on behavior flags. 	 * @param jsonSerializable represents the object that should be serialized to a string in JSON format. 	 * @param writableDestination represents where the resulting JSON text is written to. 	 * @param replacement represents what is serialized instead of a non-JSON value when replacements are allowed. 	 * @param flags represents the allowances and restrictions on serialization. 	 * @throws IOException if the writableDestination encounters an I/O problem. 	 * @throws IllegalArgumentException if the jsonSerializable isn't serializable in JSON. 	 * @see SerializationOptions */
DECL|method|serialize (final Object jsonSerializable, final Writer writableDestination, final Set<SerializationOptions> flags)
specifier|private
specifier|static
name|void
name|serialize
parameter_list|(
specifier|final
name|Object
name|jsonSerializable
parameter_list|,
specifier|final
name|Writer
name|writableDestination
parameter_list|,
specifier|final
name|Set
argument_list|<
name|SerializationOptions
argument_list|>
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|jsonSerializable
operator|==
literal|null
condition|)
block|{
comment|/* When a null is passed in the word null is supported in JSON. */
name|writableDestination
operator|.
name|write
argument_list|(
literal|"null"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|jsonSerializable
operator|instanceof
name|Jsonable
operator|)
operator|&&
name|flags
operator|.
name|contains
argument_list|(
name|SerializationOptions
operator|.
name|ALLOW_JSONABLES
argument_list|)
operator|)
condition|)
block|{
comment|/* Writes the writable as defined by the writable. */
name|writableDestination
operator|.
name|write
argument_list|(
operator|(
operator|(
name|Jsonable
operator|)
name|jsonSerializable
operator|)
operator|.
name|toJson
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|jsonSerializable
operator|instanceof
name|Enum
operator|)
operator|&&
name|flags
operator|.
name|contains
argument_list|(
name|SerializationOptions
operator|.
name|ALLOW_FULLY_QUALIFIED_ENUMERATIONS
argument_list|)
condition|)
block|{
comment|/* Writes the enum as a special case of string. All enums (unless they implement Jsonable) will be the 			 * string literal "${DECLARING_CLASS_NAME}.${ENUM_NAME}" as their value. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
specifier|final
name|Enum
name|e
init|=
operator|(
name|Enum
operator|)
name|jsonSerializable
decl_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
name|e
operator|.
name|getDeclaringClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
name|e
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jsonSerializable
operator|instanceof
name|String
condition|)
block|{
comment|/* Make sure the string is properly escaped. */
name|writableDestination
operator|.
name|write
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
name|Jsoner
operator|.
name|escape
argument_list|(
operator|(
name|String
operator|)
name|jsonSerializable
argument_list|)
argument_list|)
expr_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jsonSerializable
operator|instanceof
name|Double
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|Double
operator|)
name|jsonSerializable
operator|)
operator|.
name|isInfinite
argument_list|()
operator|||
operator|(
operator|(
name|Double
operator|)
name|jsonSerializable
operator|)
operator|.
name|isNaN
argument_list|()
condition|)
block|{
comment|/* Infinite and not a number are not supported by the JSON specification, so null is used instead. */
name|writableDestination
operator|.
name|write
argument_list|(
literal|"null"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writableDestination
operator|.
name|write
argument_list|(
name|jsonSerializable
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|jsonSerializable
operator|instanceof
name|Float
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|Float
operator|)
name|jsonSerializable
operator|)
operator|.
name|isInfinite
argument_list|()
operator|||
operator|(
operator|(
name|Float
operator|)
name|jsonSerializable
operator|)
operator|.
name|isNaN
argument_list|()
condition|)
block|{
comment|/* Infinite and not a number are not supported by the JSON specification, so null is used instead. */
name|writableDestination
operator|.
name|write
argument_list|(
literal|"null"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writableDestination
operator|.
name|write
argument_list|(
name|jsonSerializable
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|jsonSerializable
operator|instanceof
name|Number
condition|)
block|{
name|writableDestination
operator|.
name|write
argument_list|(
name|jsonSerializable
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jsonSerializable
operator|instanceof
name|Boolean
condition|)
block|{
name|writableDestination
operator|.
name|write
argument_list|(
name|jsonSerializable
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jsonSerializable
operator|instanceof
name|Map
condition|)
block|{
comment|/* Writes the map in JSON object format. */
name|boolean
name|isFirstEntry
init|=
literal|true
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
specifier|final
name|Iterator
name|entries
init|=
operator|(
operator|(
name|Map
operator|)
name|jsonSerializable
operator|)
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
while|while
condition|(
name|entries
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|isFirstEntry
condition|)
block|{
name|isFirstEntry
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|writableDestination
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
specifier|final
name|Map
operator|.
name|Entry
name|entry
init|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|entries
operator|.
name|next
argument_list|()
decl_stmt|;
name|Jsoner
operator|.
name|serialize
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|writableDestination
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|Jsoner
operator|.
name|serialize
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|writableDestination
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|writableDestination
operator|.
name|write
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jsonSerializable
operator|instanceof
name|Collection
condition|)
block|{
comment|/* Writes the collection in JSON array format. */
name|boolean
name|isFirstElement
init|=
literal|true
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
specifier|final
name|Iterator
name|elements
init|=
operator|(
operator|(
name|Collection
operator|)
name|jsonSerializable
operator|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
while|while
condition|(
name|elements
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|isFirstElement
condition|)
block|{
name|isFirstElement
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|writableDestination
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|Jsoner
operator|.
name|serialize
argument_list|(
name|elements
operator|.
name|next
argument_list|()
argument_list|,
name|writableDestination
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|writableDestination
operator|.
name|write
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jsonSerializable
operator|instanceof
name|byte
index|[]
condition|)
block|{
comment|/* Writes the array in JSON array format. */
specifier|final
name|byte
index|[]
name|writableArray
init|=
operator|(
name|byte
index|[]
operator|)
name|jsonSerializable
decl_stmt|;
specifier|final
name|int
name|numberOfElements
init|=
name|writableArray
operator|.
name|length
decl_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|numberOfElements
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|numberOfElements
condition|)
block|{
name|Jsoner
operator|.
name|serialize
argument_list|(
name|writableArray
index|[
name|i
index|]
argument_list|,
name|writableDestination
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Jsoner
operator|.
name|serialize
argument_list|(
name|writableArray
index|[
name|i
index|]
argument_list|,
name|writableDestination
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
block|}
name|writableDestination
operator|.
name|write
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jsonSerializable
operator|instanceof
name|short
index|[]
condition|)
block|{
comment|/* Writes the array in JSON array format. */
specifier|final
name|short
index|[]
name|writableArray
init|=
operator|(
name|short
index|[]
operator|)
name|jsonSerializable
decl_stmt|;
specifier|final
name|int
name|numberOfElements
init|=
name|writableArray
operator|.
name|length
decl_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|numberOfElements
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|numberOfElements
condition|)
block|{
name|Jsoner
operator|.
name|serialize
argument_list|(
name|writableArray
index|[
name|i
index|]
argument_list|,
name|writableDestination
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Jsoner
operator|.
name|serialize
argument_list|(
name|writableArray
index|[
name|i
index|]
argument_list|,
name|writableDestination
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
block|}
name|writableDestination
operator|.
name|write
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jsonSerializable
operator|instanceof
name|int
index|[]
condition|)
block|{
comment|/* Writes the array in JSON array format. */
specifier|final
name|int
index|[]
name|writableArray
init|=
operator|(
name|int
index|[]
operator|)
name|jsonSerializable
decl_stmt|;
specifier|final
name|int
name|numberOfElements
init|=
name|writableArray
operator|.
name|length
decl_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|numberOfElements
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|numberOfElements
condition|)
block|{
name|Jsoner
operator|.
name|serialize
argument_list|(
name|writableArray
index|[
name|i
index|]
argument_list|,
name|writableDestination
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Jsoner
operator|.
name|serialize
argument_list|(
name|writableArray
index|[
name|i
index|]
argument_list|,
name|writableDestination
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
block|}
name|writableDestination
operator|.
name|write
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jsonSerializable
operator|instanceof
name|long
index|[]
condition|)
block|{
comment|/* Writes the array in JSON array format. */
specifier|final
name|long
index|[]
name|writableArray
init|=
operator|(
name|long
index|[]
operator|)
name|jsonSerializable
decl_stmt|;
specifier|final
name|int
name|numberOfElements
init|=
name|writableArray
operator|.
name|length
decl_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|numberOfElements
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|numberOfElements
condition|)
block|{
name|Jsoner
operator|.
name|serialize
argument_list|(
name|writableArray
index|[
name|i
index|]
argument_list|,
name|writableDestination
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Jsoner
operator|.
name|serialize
argument_list|(
name|writableArray
index|[
name|i
index|]
argument_list|,
name|writableDestination
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
block|}
name|writableDestination
operator|.
name|write
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jsonSerializable
operator|instanceof
name|float
index|[]
condition|)
block|{
comment|/* Writes the array in JSON array format. */
specifier|final
name|float
index|[]
name|writableArray
init|=
operator|(
name|float
index|[]
operator|)
name|jsonSerializable
decl_stmt|;
specifier|final
name|int
name|numberOfElements
init|=
name|writableArray
operator|.
name|length
decl_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|numberOfElements
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|numberOfElements
condition|)
block|{
name|Jsoner
operator|.
name|serialize
argument_list|(
name|writableArray
index|[
name|i
index|]
argument_list|,
name|writableDestination
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Jsoner
operator|.
name|serialize
argument_list|(
name|writableArray
index|[
name|i
index|]
argument_list|,
name|writableDestination
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
block|}
name|writableDestination
operator|.
name|write
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jsonSerializable
operator|instanceof
name|double
index|[]
condition|)
block|{
comment|/* Writes the array in JSON array format. */
specifier|final
name|double
index|[]
name|writableArray
init|=
operator|(
name|double
index|[]
operator|)
name|jsonSerializable
decl_stmt|;
specifier|final
name|int
name|numberOfElements
init|=
name|writableArray
operator|.
name|length
decl_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|numberOfElements
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|numberOfElements
condition|)
block|{
name|Jsoner
operator|.
name|serialize
argument_list|(
name|writableArray
index|[
name|i
index|]
argument_list|,
name|writableDestination
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Jsoner
operator|.
name|serialize
argument_list|(
name|writableArray
index|[
name|i
index|]
argument_list|,
name|writableDestination
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
block|}
name|writableDestination
operator|.
name|write
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jsonSerializable
operator|instanceof
name|boolean
index|[]
condition|)
block|{
comment|/* Writes the array in JSON array format. */
specifier|final
name|boolean
index|[]
name|writableArray
init|=
operator|(
name|boolean
index|[]
operator|)
name|jsonSerializable
decl_stmt|;
specifier|final
name|int
name|numberOfElements
init|=
name|writableArray
operator|.
name|length
decl_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|numberOfElements
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|numberOfElements
condition|)
block|{
name|Jsoner
operator|.
name|serialize
argument_list|(
name|writableArray
index|[
name|i
index|]
argument_list|,
name|writableDestination
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Jsoner
operator|.
name|serialize
argument_list|(
name|writableArray
index|[
name|i
index|]
argument_list|,
name|writableDestination
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
block|}
name|writableDestination
operator|.
name|write
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jsonSerializable
operator|instanceof
name|char
index|[]
condition|)
block|{
comment|/* Writes the array in JSON array format. */
specifier|final
name|char
index|[]
name|writableArray
init|=
operator|(
name|char
index|[]
operator|)
name|jsonSerializable
decl_stmt|;
specifier|final
name|int
name|numberOfElements
init|=
name|writableArray
operator|.
name|length
decl_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|"[\""
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|numberOfElements
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|numberOfElements
condition|)
block|{
name|Jsoner
operator|.
name|serialize
argument_list|(
name|writableArray
index|[
name|i
index|]
argument_list|,
name|writableDestination
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Jsoner
operator|.
name|serialize
argument_list|(
name|writableArray
index|[
name|i
index|]
argument_list|,
name|writableDestination
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|"\",\""
argument_list|)
expr_stmt|;
block|}
block|}
name|writableDestination
operator|.
name|write
argument_list|(
literal|"\"]"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jsonSerializable
operator|instanceof
name|Object
index|[]
condition|)
block|{
comment|/* Writes the array in JSON array format. */
specifier|final
name|Object
index|[]
name|writableArray
init|=
operator|(
name|Object
index|[]
operator|)
name|jsonSerializable
decl_stmt|;
specifier|final
name|int
name|numberOfElements
init|=
name|writableArray
operator|.
name|length
decl_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|numberOfElements
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|numberOfElements
condition|)
block|{
name|Jsoner
operator|.
name|serialize
argument_list|(
name|writableArray
index|[
name|i
index|]
argument_list|,
name|writableDestination
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Jsoner
operator|.
name|serialize
argument_list|(
name|writableArray
index|[
name|i
index|]
argument_list|,
name|writableDestination
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|writableDestination
operator|.
name|write
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
name|writableDestination
operator|.
name|write
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* TODO a potential feature for future release since POJOs are often represented as JsonObjects. It would be 			 * nice to have a flag that tries to reflectively figure out what a non-Jsonable POJO's fields are and use 			 * their names as keys and their respective values for the keys' values in the JsonObject? 			 * Naturally implementing Jsonable is safer and in many ways makes this feature a convenience for not 			 * needing 			 * to implement Jsonable for very simple POJOs. 			 * If it fails to produce a JsonObject to serialize it should defer to replacements if allowed. 			 * If replacement fails it should defer to invalids if allowed. 			 * This feature would require another serialize method exposed to allow this serialization. 			 * This feature (although perhaps useful on its own) would also include a method in the JsonObject where you 			 * pass it a class and it would do its best to instantiate a POJO of the class using the keys in the 			 * JsonObject. */
comment|/* It cannot by any measure be safely serialized according to specification. */
if|if
condition|(
name|flags
operator|.
name|contains
argument_list|(
name|SerializationOptions
operator|.
name|ALLOW_INVALIDS
argument_list|)
condition|)
block|{
comment|/* Can be helpful for debugging how it isn't valid. */
name|writableDestination
operator|.
name|write
argument_list|(
name|jsonSerializable
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Notify the caller the cause of failure for the serialization. */
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Encountered a: "
operator|+
name|jsonSerializable
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" as: "
operator|+
name|jsonSerializable
operator|.
name|toString
argument_list|()
operator|+
literal|"  that isn't JSON serializable.\n  Try:\n    1) Implementing the Jsonable interface for the object to return valid JSON. If it already does it probably has a bug.\n    2) If you cannot edit the source of the object or couple it with this library consider wrapping it in a class that does implement the Jsonable interface.\n    3) Otherwise convert it to a boolean, null, number, JsonArray, JsonObject, or String value before serializing it.\n    4) If you feel it should have serialized you could use a more tolerant serialization for debugging purposes."
argument_list|)
throw|;
block|}
block|}
comment|//System.out.println(writableDestination.toString());
block|}
comment|/** Serializes like the first version of this library. 	 * It has been adapted to use Jsonable for serializing custom objects, but otherwise works like the old JSON string 	 * serializer. It 	 * will allow non-JSON values in its output like the old one. It can be helpful for last resort log statements and 	 * debugging errors in self generated JSON. Anything serialized using this method isn't guaranteed to be 	 * deserializable. 	 * @param jsonSerializable represents the object that should be serialized in JSON format. 	 * @param writableDestination represents where the resulting JSON text is written to. 	 * @throws IOException if the writableDestination encounters an I/O problem, like being closed while in use. */
DECL|method|serializeCarelessly (final Object jsonSerializable, final Writer writableDestination)
specifier|public
specifier|static
name|void
name|serializeCarelessly
parameter_list|(
specifier|final
name|Object
name|jsonSerializable
parameter_list|,
specifier|final
name|Writer
name|writableDestination
parameter_list|)
throws|throws
name|IOException
block|{
name|Jsoner
operator|.
name|serialize
argument_list|(
name|jsonSerializable
argument_list|,
name|writableDestination
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|SerializationOptions
operator|.
name|ALLOW_JSONABLES
argument_list|,
name|SerializationOptions
operator|.
name|ALLOW_INVALIDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Serializes JSON values and only JSON values according to the RFC 4627 JSON specification. 	 * @param jsonSerializable represents the object that should be serialized in JSON format. 	 * @param writableDestination represents where the resulting JSON text is written to. 	 * @throws IOException if the writableDestination encounters an I/O problem, like being closed while in use. 	 * @throws IllegalArgumentException if the jsonSerializable isn't serializable in JSON. */
DECL|method|serializeStrictly (final Object jsonSerializable, final Writer writableDestination)
specifier|public
specifier|static
name|void
name|serializeStrictly
parameter_list|(
specifier|final
name|Object
name|jsonSerializable
parameter_list|,
specifier|final
name|Writer
name|writableDestination
parameter_list|)
throws|throws
name|IOException
block|{
name|Jsoner
operator|.
name|serialize
argument_list|(
name|jsonSerializable
argument_list|,
name|writableDestination
argument_list|,
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|SerializationOptions
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

