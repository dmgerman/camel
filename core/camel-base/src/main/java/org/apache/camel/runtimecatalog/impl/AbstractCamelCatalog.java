begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.runtimecatalog.impl
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|runtimecatalog
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|runtimecatalog
operator|.
name|EndpointValidationResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|runtimecatalog
operator|.
name|JSonSchemaResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|runtimecatalog
operator|.
name|LanguageValidationResult
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|runtimecatalog
operator|.
name|impl
operator|.
name|CatalogHelper
operator|.
name|after
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|runtimecatalog
operator|.
name|impl
operator|.
name|URISupport
operator|.
name|createQueryString
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|runtimecatalog
operator|.
name|impl
operator|.
name|URISupport
operator|.
name|isEmpty
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|runtimecatalog
operator|.
name|impl
operator|.
name|URISupport
operator|.
name|normalizeUri
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|runtimecatalog
operator|.
name|impl
operator|.
name|URISupport
operator|.
name|stripQuery
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|JSonSchemaHelper
operator|.
name|getNames
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|JSonSchemaHelper
operator|.
name|getPropertyDefaultValue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|JSonSchemaHelper
operator|.
name|getPropertyEnum
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|JSonSchemaHelper
operator|.
name|getPropertyKind
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|JSonSchemaHelper
operator|.
name|getPropertyNameFromNameWithPrefix
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|JSonSchemaHelper
operator|.
name|getPropertyPrefix
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|JSonSchemaHelper
operator|.
name|getRow
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|JSonSchemaHelper
operator|.
name|isComponentConsumerOnly
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|JSonSchemaHelper
operator|.
name|isComponentLenientProperties
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|JSonSchemaHelper
operator|.
name|isComponentProducerOnly
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|JSonSchemaHelper
operator|.
name|isPropertyBoolean
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|JSonSchemaHelper
operator|.
name|isPropertyConsumerOnly
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|JSonSchemaHelper
operator|.
name|isPropertyDeprecated
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|JSonSchemaHelper
operator|.
name|isPropertyInteger
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|JSonSchemaHelper
operator|.
name|isPropertyMultiValue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|JSonSchemaHelper
operator|.
name|isPropertyNumber
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|JSonSchemaHelper
operator|.
name|isPropertyObject
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|JSonSchemaHelper
operator|.
name|isPropertyProducerOnly
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|JSonSchemaHelper
operator|.
name|isPropertyRequired
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|JSonSchemaHelper
operator|.
name|parseJsonSchema
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|JSonSchemaHelper
operator|.
name|stripOptionalPrefixFromName
import|;
end_import

begin_comment
comment|/**  * Base class for both the runtime RuntimeCamelCatalog from camel-core and the complete CamelCatalog from camel-catalog.  */
end_comment

begin_class
DECL|class|AbstractCamelCatalog
specifier|public
specifier|abstract
class|class
name|AbstractCamelCatalog
block|{
comment|// CHECKSTYLE:OFF
DECL|field|SYNTAX_PATTERN
specifier|private
specifier|static
specifier|final
name|Pattern
name|SYNTAX_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"([\\w.]+)"
argument_list|)
decl_stmt|;
DECL|field|SYNTAX_DASH_PATTERN
specifier|private
specifier|static
specifier|final
name|Pattern
name|SYNTAX_DASH_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"([\\w.-]+)"
argument_list|)
decl_stmt|;
DECL|field|COMPONENT_SYNTAX_PARSER
specifier|private
specifier|static
specifier|final
name|Pattern
name|COMPONENT_SYNTAX_PARSER
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"([^\\w-]*)([\\w-]+)"
argument_list|)
decl_stmt|;
DECL|field|suggestionStrategy
specifier|private
name|SuggestionStrategy
name|suggestionStrategy
decl_stmt|;
DECL|field|jsonSchemaResolver
specifier|private
name|JSonSchemaResolver
name|jsonSchemaResolver
decl_stmt|;
DECL|method|getSuggestionStrategy ()
specifier|public
name|SuggestionStrategy
name|getSuggestionStrategy
parameter_list|()
block|{
return|return
name|suggestionStrategy
return|;
block|}
DECL|method|setSuggestionStrategy (SuggestionStrategy suggestionStrategy)
specifier|public
name|void
name|setSuggestionStrategy
parameter_list|(
name|SuggestionStrategy
name|suggestionStrategy
parameter_list|)
block|{
name|this
operator|.
name|suggestionStrategy
operator|=
name|suggestionStrategy
expr_stmt|;
block|}
DECL|method|getJSonSchemaResolver ()
specifier|public
name|JSonSchemaResolver
name|getJSonSchemaResolver
parameter_list|()
block|{
return|return
name|jsonSchemaResolver
return|;
block|}
DECL|method|setJSonSchemaResolver (JSonSchemaResolver resolver)
specifier|public
name|void
name|setJSonSchemaResolver
parameter_list|(
name|JSonSchemaResolver
name|resolver
parameter_list|)
block|{
name|this
operator|.
name|jsonSchemaResolver
operator|=
name|resolver
expr_stmt|;
block|}
DECL|method|validateTimePattern (String pattern)
specifier|public
name|boolean
name|validateTimePattern
parameter_list|(
name|String
name|pattern
parameter_list|)
block|{
return|return
name|validateInteger
argument_list|(
name|pattern
argument_list|)
return|;
block|}
DECL|method|validateEndpointProperties (String uri)
specifier|public
name|EndpointValidationResult
name|validateEndpointProperties
parameter_list|(
name|String
name|uri
parameter_list|)
block|{
return|return
name|validateEndpointProperties
argument_list|(
name|uri
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|validateEndpointProperties (String uri, boolean ignoreLenientProperties)
specifier|public
name|EndpointValidationResult
name|validateEndpointProperties
parameter_list|(
name|String
name|uri
parameter_list|,
name|boolean
name|ignoreLenientProperties
parameter_list|)
block|{
return|return
name|validateEndpointProperties
argument_list|(
name|uri
argument_list|,
name|ignoreLenientProperties
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|validateProperties (String scheme, Map<String, String> properties)
specifier|public
name|EndpointValidationResult
name|validateProperties
parameter_list|(
name|String
name|scheme
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|properties
parameter_list|)
block|{
name|EndpointValidationResult
name|result
init|=
operator|new
name|EndpointValidationResult
argument_list|(
name|scheme
argument_list|)
decl_stmt|;
name|String
name|json
init|=
name|jsonSchemaResolver
operator|.
name|getComponentJSonSchema
argument_list|(
name|scheme
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|rows
init|=
name|parseJsonSchema
argument_list|(
literal|"properties"
argument_list|,
name|json
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|componentProps
init|=
name|parseJsonSchema
argument_list|(
literal|"componentProperties"
argument_list|,
name|json
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// endpoint options have higher priority so remove those from component
comment|// that may clash
name|componentProps
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|c
lambda|->
name|rows
operator|.
name|stream
argument_list|()
operator|.
name|noneMatch
argument_list|(
name|e
lambda|->
name|Objects
operator|.
name|equals
argument_list|(
name|e
operator|.
name|get
argument_list|(
literal|"name"
argument_list|)
argument_list|,
name|c
operator|.
name|get
argument_list|(
literal|"name"
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|forEach
argument_list|(
name|rows
operator|::
name|add
argument_list|)
expr_stmt|;
name|boolean
name|lenient
init|=
name|Boolean
operator|.
name|getBoolean
argument_list|(
name|properties
operator|.
name|getOrDefault
argument_list|(
literal|"lenient"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
decl_stmt|;
comment|// the dataformat component refers to a data format so lets add the properties for the selected
comment|// data format to the list of rows
if|if
condition|(
literal|"dataformat"
operator|.
name|equals
argument_list|(
name|scheme
argument_list|)
condition|)
block|{
name|String
name|dfName
init|=
name|properties
operator|.
name|get
argument_list|(
literal|"name"
argument_list|)
decl_stmt|;
if|if
condition|(
name|dfName
operator|!=
literal|null
condition|)
block|{
name|String
name|dfJson
init|=
name|jsonSchemaResolver
operator|.
name|getDataFormatJSonSchema
argument_list|(
name|dfName
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|dfRows
init|=
name|parseJsonSchema
argument_list|(
literal|"properties"
argument_list|,
name|dfJson
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|dfRows
operator|!=
literal|null
operator|&&
operator|!
name|dfRows
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|rows
operator|.
name|addAll
argument_list|(
name|dfRows
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|property
range|:
name|properties
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|value
init|=
name|property
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|originalName
init|=
name|property
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|property
operator|.
name|getKey
argument_list|()
decl_stmt|;
comment|// the name may be using an optional prefix, so lets strip that because the options
comment|// in the schema are listed without the prefix
name|name
operator|=
name|stripOptionalPrefixFromName
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|// the name may be using a prefix, so lets see if we can find the real property name
name|String
name|propertyName
init|=
name|getPropertyNameFromNameWithPrefix
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|propertyName
operator|!=
literal|null
condition|)
block|{
name|name
operator|=
name|propertyName
expr_stmt|;
block|}
name|String
name|prefix
init|=
name|getPropertyPrefix
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|String
name|kind
init|=
name|getPropertyKind
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|boolean
name|namePlaceholder
init|=
name|name
operator|.
name|startsWith
argument_list|(
literal|"{{"
argument_list|)
operator|&&
name|name
operator|.
name|endsWith
argument_list|(
literal|"}}"
argument_list|)
decl_stmt|;
name|boolean
name|valuePlaceholder
init|=
name|value
operator|.
name|startsWith
argument_list|(
literal|"{{"
argument_list|)
operator|||
name|value
operator|.
name|startsWith
argument_list|(
literal|"${"
argument_list|)
operator|||
name|value
operator|.
name|startsWith
argument_list|(
literal|"$simple{"
argument_list|)
decl_stmt|;
name|boolean
name|lookup
init|=
name|value
operator|.
name|startsWith
argument_list|(
literal|"#"
argument_list|)
operator|&&
name|value
operator|.
name|length
argument_list|()
operator|>
literal|1
decl_stmt|;
comment|// we cannot evaluate multi values as strict as the others, as we don't know their expected types
name|boolean
name|multiValue
init|=
name|prefix
operator|!=
literal|null
operator|&&
name|originalName
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
operator|&&
name|isPropertyMultiValue
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|row
init|=
name|getRow
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|row
operator|==
literal|null
condition|)
block|{
comment|// unknown option
comment|// only add as error if the component is not lenient properties, or not stub component
comment|// and the name is not a property placeholder for one or more values
if|if
condition|(
operator|!
name|namePlaceholder
operator|&&
operator|!
literal|"stub"
operator|.
name|equals
argument_list|(
name|scheme
argument_list|)
condition|)
block|{
if|if
condition|(
name|lenient
condition|)
block|{
comment|// as if we are lenient then the option is a dynamic extra option which we cannot validate
name|result
operator|.
name|addLenient
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// its unknown
name|result
operator|.
name|addUnknown
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|suggestionStrategy
operator|!=
literal|null
condition|)
block|{
name|String
index|[]
name|suggestions
init|=
name|suggestionStrategy
operator|.
name|suggestEndpointOptions
argument_list|(
name|getNames
argument_list|(
name|rows
argument_list|)
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|suggestions
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|addUnknownSuggestions
argument_list|(
name|name
argument_list|,
name|suggestions
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* TODO: we may need to add something in the properties to know if they are related to a producer or consumer                 if ("parameter".equals(kind)) {                     // consumer only or producer only mode for parameters                     if (consumerOnly) {                         boolean producer = isPropertyProducerOnly(rows, name);                         if (producer) {                             // the option is only for producer so you cannot use it in consumer mode                             result.addNotConsumerOnly(name);                         }                     } else if (producerOnly) {                         boolean consumer = isPropertyConsumerOnly(rows, name);                         if (consumer) {                             // the option is only for consumer so you cannot use it in producer mode                             result.addNotProducerOnly(name);                         }                     }                 }                 */
comment|// default value
name|String
name|defaultValue
init|=
name|getPropertyDefaultValue
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|defaultValue
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|addDefaultValue
argument_list|(
name|name
argument_list|,
name|defaultValue
argument_list|)
expr_stmt|;
block|}
comment|// is required but the value is empty
name|boolean
name|required
init|=
name|isPropertyRequired
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|required
operator|&&
name|isEmpty
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|result
operator|.
name|addRequired
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|// is the option deprecated
name|boolean
name|deprecated
init|=
name|isPropertyDeprecated
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|deprecated
condition|)
block|{
name|result
operator|.
name|addDeprecated
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|// is enum but the value is not within the enum range
comment|// but we can only check if the value is not a placeholder
name|String
name|enums
init|=
name|getPropertyEnum
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|multiValue
operator|&&
operator|!
name|valuePlaceholder
operator|&&
operator|!
name|lookup
operator|&&
name|enums
operator|!=
literal|null
condition|)
block|{
name|String
index|[]
name|choices
init|=
name|enums
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|choices
control|)
block|{
if|if
condition|(
name|value
operator|.
name|equalsIgnoreCase
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|result
operator|.
name|addInvalidEnum
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|result
operator|.
name|addInvalidEnumChoices
argument_list|(
name|name
argument_list|,
name|choices
argument_list|)
expr_stmt|;
if|if
condition|(
name|suggestionStrategy
operator|!=
literal|null
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|names
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|names
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|choices
argument_list|)
argument_list|)
expr_stmt|;
name|String
index|[]
name|suggestions
init|=
name|suggestionStrategy
operator|.
name|suggestEndpointOptions
argument_list|(
name|names
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|suggestions
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|addInvalidEnumSuggestions
argument_list|(
name|name
argument_list|,
name|suggestions
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// is reference lookup of bean (not applicable for @UriPath, enums, or multi-valued)
if|if
condition|(
operator|!
name|multiValue
operator|&&
name|enums
operator|==
literal|null
operator|&&
operator|!
literal|"path"
operator|.
name|equals
argument_list|(
name|kind
argument_list|)
operator|&&
name|isPropertyObject
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
condition|)
block|{
comment|// must start with # and be at least 2 characters
if|if
condition|(
operator|!
name|value
operator|.
name|startsWith
argument_list|(
literal|"#"
argument_list|)
operator|||
name|value
operator|.
name|length
argument_list|()
operator|<=
literal|1
condition|)
block|{
name|result
operator|.
name|addInvalidReference
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|// is boolean
if|if
condition|(
operator|!
name|multiValue
operator|&&
operator|!
name|valuePlaceholder
operator|&&
operator|!
name|lookup
operator|&&
name|isPropertyBoolean
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
condition|)
block|{
comment|// value must be a boolean
name|boolean
name|bool
init|=
literal|"true"
operator|.
name|equalsIgnoreCase
argument_list|(
name|value
argument_list|)
operator|||
literal|"false"
operator|.
name|equalsIgnoreCase
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bool
condition|)
block|{
name|result
operator|.
name|addInvalidBoolean
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|// is integer
if|if
condition|(
operator|!
name|multiValue
operator|&&
operator|!
name|valuePlaceholder
operator|&&
operator|!
name|lookup
operator|&&
name|isPropertyInteger
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
condition|)
block|{
comment|// value must be an integer
name|boolean
name|valid
init|=
name|validateInteger
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|result
operator|.
name|addInvalidInteger
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|// is number
if|if
condition|(
operator|!
name|multiValue
operator|&&
operator|!
name|valuePlaceholder
operator|&&
operator|!
name|lookup
operator|&&
name|isPropertyNumber
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
condition|)
block|{
comment|// value must be an number
name|boolean
name|valid
init|=
literal|false
decl_stmt|;
try|try
block|{
name|valid
operator|=
operator|!
name|Double
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
operator|.
name|isNaN
argument_list|()
operator|||
operator|!
name|Float
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
operator|.
name|isNaN
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// ignore
block|}
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|result
operator|.
name|addInvalidNumber
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// now check if all required values are there, and that a default value does not exists
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|row
range|:
name|rows
control|)
block|{
name|String
name|name
init|=
name|row
operator|.
name|get
argument_list|(
literal|"name"
argument_list|)
decl_stmt|;
name|boolean
name|required
init|=
name|isPropertyRequired
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|required
condition|)
block|{
name|String
name|value
init|=
name|properties
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|isEmpty
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|value
operator|=
name|getPropertyDefaultValue
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isEmpty
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|result
operator|.
name|addRequired
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
DECL|method|validateEndpointProperties (String uri, boolean ignoreLenientProperties, boolean consumerOnly, boolean producerOnly)
specifier|public
name|EndpointValidationResult
name|validateEndpointProperties
parameter_list|(
name|String
name|uri
parameter_list|,
name|boolean
name|ignoreLenientProperties
parameter_list|,
name|boolean
name|consumerOnly
parameter_list|,
name|boolean
name|producerOnly
parameter_list|)
block|{
name|EndpointValidationResult
name|result
init|=
operator|new
name|EndpointValidationResult
argument_list|(
name|uri
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|properties
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|rows
decl_stmt|;
name|boolean
name|lenientProperties
decl_stmt|;
name|String
name|scheme
decl_stmt|;
try|try
block|{
name|String
name|json
init|=
literal|null
decl_stmt|;
comment|// parse the uri
name|URI
name|u
init|=
name|normalizeUri
argument_list|(
name|uri
argument_list|)
decl_stmt|;
name|scheme
operator|=
name|u
operator|.
name|getScheme
argument_list|()
expr_stmt|;
if|if
condition|(
name|scheme
operator|!=
literal|null
condition|)
block|{
name|json
operator|=
name|jsonSchemaResolver
operator|.
name|getComponentJSonSchema
argument_list|(
name|scheme
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|json
operator|==
literal|null
condition|)
block|{
comment|// if the uri starts with a placeholder then we are also incapable of parsing it as we wasn't able to resolve the component name
if|if
condition|(
name|uri
operator|.
name|startsWith
argument_list|(
literal|"{{"
argument_list|)
condition|)
block|{
name|result
operator|.
name|addIncapable
argument_list|(
name|uri
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scheme
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|addUnknownComponent
argument_list|(
name|scheme
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|addUnknownComponent
argument_list|(
name|uri
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
name|rows
operator|=
name|parseJsonSchema
argument_list|(
literal|"component"
argument_list|,
name|json
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// is the component capable of both consumer and producer?
name|boolean
name|canConsumeAndProduce
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|isComponentConsumerOnly
argument_list|(
name|rows
argument_list|)
operator|&&
operator|!
name|isComponentProducerOnly
argument_list|(
name|rows
argument_list|)
condition|)
block|{
name|canConsumeAndProduce
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|canConsumeAndProduce
operator|&&
name|consumerOnly
condition|)
block|{
comment|// lenient properties is not support in consumer only mode if the component can do both of them
name|lenientProperties
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|// only enable lenient properties if we should not ignore
name|lenientProperties
operator|=
operator|!
name|ignoreLenientProperties
operator|&&
name|isComponentLenientProperties
argument_list|(
name|rows
argument_list|)
expr_stmt|;
block|}
name|rows
operator|=
name|parseJsonSchema
argument_list|(
literal|"properties"
argument_list|,
name|json
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|properties
operator|=
name|endpointProperties
argument_list|(
name|uri
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
if|if
condition|(
name|uri
operator|.
name|startsWith
argument_list|(
literal|"{{"
argument_list|)
condition|)
block|{
comment|// if the uri starts with a placeholder then we are also incapable of parsing it as we wasn't able to resolve the component name
name|result
operator|.
name|addIncapable
argument_list|(
name|uri
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|addSyntaxError
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|// the dataformat component refers to a data format so lets add the properties for the selected
comment|// data format to the list of rows
if|if
condition|(
literal|"dataformat"
operator|.
name|equals
argument_list|(
name|scheme
argument_list|)
condition|)
block|{
name|String
name|dfName
init|=
name|properties
operator|.
name|get
argument_list|(
literal|"name"
argument_list|)
decl_stmt|;
if|if
condition|(
name|dfName
operator|!=
literal|null
condition|)
block|{
name|String
name|dfJson
init|=
name|jsonSchemaResolver
operator|.
name|getDataFormatJSonSchema
argument_list|(
name|dfName
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|dfRows
init|=
name|parseJsonSchema
argument_list|(
literal|"properties"
argument_list|,
name|dfJson
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|dfRows
operator|!=
literal|null
operator|&&
operator|!
name|dfRows
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|rows
operator|.
name|addAll
argument_list|(
name|dfRows
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|property
range|:
name|properties
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|value
init|=
name|property
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|originalName
init|=
name|property
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|property
operator|.
name|getKey
argument_list|()
decl_stmt|;
comment|// the name may be using an optional prefix, so lets strip that because the options
comment|// in the schema are listed without the prefix
name|name
operator|=
name|stripOptionalPrefixFromName
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|// the name may be using a prefix, so lets see if we can find the real property name
name|String
name|propertyName
init|=
name|getPropertyNameFromNameWithPrefix
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|propertyName
operator|!=
literal|null
condition|)
block|{
name|name
operator|=
name|propertyName
expr_stmt|;
block|}
name|String
name|prefix
init|=
name|getPropertyPrefix
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|String
name|kind
init|=
name|getPropertyKind
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|boolean
name|namePlaceholder
init|=
name|name
operator|.
name|startsWith
argument_list|(
literal|"{{"
argument_list|)
operator|&&
name|name
operator|.
name|endsWith
argument_list|(
literal|"}}"
argument_list|)
decl_stmt|;
name|boolean
name|valuePlaceholder
init|=
name|value
operator|.
name|startsWith
argument_list|(
literal|"{{"
argument_list|)
operator|||
name|value
operator|.
name|startsWith
argument_list|(
literal|"${"
argument_list|)
operator|||
name|value
operator|.
name|startsWith
argument_list|(
literal|"$simple{"
argument_list|)
decl_stmt|;
name|boolean
name|lookup
init|=
name|value
operator|.
name|startsWith
argument_list|(
literal|"#"
argument_list|)
operator|&&
name|value
operator|.
name|length
argument_list|()
operator|>
literal|1
decl_stmt|;
comment|// we cannot evaluate multi values as strict as the others, as we don't know their expected types
name|boolean
name|mulitValue
init|=
name|prefix
operator|!=
literal|null
operator|&&
name|originalName
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
operator|&&
name|isPropertyMultiValue
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|row
init|=
name|getRow
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|row
operator|==
literal|null
condition|)
block|{
comment|// unknown option
comment|// only add as error if the component is not lenient properties, or not stub component
comment|// and the name is not a property placeholder for one or more values
if|if
condition|(
operator|!
name|namePlaceholder
operator|&&
operator|!
literal|"stub"
operator|.
name|equals
argument_list|(
name|scheme
argument_list|)
condition|)
block|{
if|if
condition|(
name|lenientProperties
condition|)
block|{
comment|// as if we are lenient then the option is a dynamic extra option which we cannot validate
name|result
operator|.
name|addLenient
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// its unknown
name|result
operator|.
name|addUnknown
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|suggestionStrategy
operator|!=
literal|null
condition|)
block|{
name|String
index|[]
name|suggestions
init|=
name|suggestionStrategy
operator|.
name|suggestEndpointOptions
argument_list|(
name|getNames
argument_list|(
name|rows
argument_list|)
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|suggestions
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|addUnknownSuggestions
argument_list|(
name|name
argument_list|,
name|suggestions
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
literal|"parameter"
operator|.
name|equals
argument_list|(
name|kind
argument_list|)
condition|)
block|{
comment|// consumer only or producer only mode for parameters
if|if
condition|(
name|consumerOnly
condition|)
block|{
name|boolean
name|producer
init|=
name|isPropertyProducerOnly
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|producer
condition|)
block|{
comment|// the option is only for producer so you cannot use it in consumer mode
name|result
operator|.
name|addNotConsumerOnly
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|producerOnly
condition|)
block|{
name|boolean
name|consumer
init|=
name|isPropertyConsumerOnly
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|consumer
condition|)
block|{
comment|// the option is only for consumer so you cannot use it in producer mode
name|result
operator|.
name|addNotProducerOnly
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// default value
name|String
name|defaultValue
init|=
name|getPropertyDefaultValue
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|defaultValue
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|addDefaultValue
argument_list|(
name|name
argument_list|,
name|defaultValue
argument_list|)
expr_stmt|;
block|}
comment|// is required but the value is empty
name|boolean
name|required
init|=
name|isPropertyRequired
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|required
operator|&&
name|isEmpty
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|result
operator|.
name|addRequired
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|// is the option deprecated
name|boolean
name|deprecated
init|=
name|isPropertyDeprecated
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|deprecated
condition|)
block|{
name|result
operator|.
name|addDeprecated
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|// is enum but the value is not within the enum range
comment|// but we can only check if the value is not a placeholder
name|String
name|enums
init|=
name|getPropertyEnum
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mulitValue
operator|&&
operator|!
name|valuePlaceholder
operator|&&
operator|!
name|lookup
operator|&&
name|enums
operator|!=
literal|null
condition|)
block|{
name|String
index|[]
name|choices
init|=
name|enums
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|choices
control|)
block|{
if|if
condition|(
name|value
operator|.
name|equalsIgnoreCase
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|result
operator|.
name|addInvalidEnum
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|result
operator|.
name|addInvalidEnumChoices
argument_list|(
name|name
argument_list|,
name|choices
argument_list|)
expr_stmt|;
if|if
condition|(
name|suggestionStrategy
operator|!=
literal|null
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|names
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|names
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|choices
argument_list|)
argument_list|)
expr_stmt|;
name|String
index|[]
name|suggestions
init|=
name|suggestionStrategy
operator|.
name|suggestEndpointOptions
argument_list|(
name|names
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|suggestions
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|addInvalidEnumSuggestions
argument_list|(
name|name
argument_list|,
name|suggestions
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// is reference lookup of bean (not applicable for @UriPath, enums, or multi-valued)
if|if
condition|(
operator|!
name|mulitValue
operator|&&
name|enums
operator|==
literal|null
operator|&&
operator|!
literal|"path"
operator|.
name|equals
argument_list|(
name|kind
argument_list|)
operator|&&
name|isPropertyObject
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
condition|)
block|{
comment|// must start with # and be at least 2 characters
if|if
condition|(
operator|!
name|value
operator|.
name|startsWith
argument_list|(
literal|"#"
argument_list|)
operator|||
name|value
operator|.
name|length
argument_list|()
operator|<=
literal|1
condition|)
block|{
name|result
operator|.
name|addInvalidReference
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|// is boolean
if|if
condition|(
operator|!
name|mulitValue
operator|&&
operator|!
name|valuePlaceholder
operator|&&
operator|!
name|lookup
operator|&&
name|isPropertyBoolean
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
condition|)
block|{
comment|// value must be a boolean
name|boolean
name|bool
init|=
literal|"true"
operator|.
name|equalsIgnoreCase
argument_list|(
name|value
argument_list|)
operator|||
literal|"false"
operator|.
name|equalsIgnoreCase
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bool
condition|)
block|{
name|result
operator|.
name|addInvalidBoolean
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|// is integer
if|if
condition|(
operator|!
name|mulitValue
operator|&&
operator|!
name|valuePlaceholder
operator|&&
operator|!
name|lookup
operator|&&
name|isPropertyInteger
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
condition|)
block|{
comment|// value must be an integer
name|boolean
name|valid
init|=
name|validateInteger
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|result
operator|.
name|addInvalidInteger
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|// is number
if|if
condition|(
operator|!
name|mulitValue
operator|&&
operator|!
name|valuePlaceholder
operator|&&
operator|!
name|lookup
operator|&&
name|isPropertyNumber
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
condition|)
block|{
comment|// value must be an number
name|boolean
name|valid
init|=
literal|false
decl_stmt|;
try|try
block|{
name|valid
operator|=
operator|!
name|Double
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
operator|.
name|isNaN
argument_list|()
operator|||
operator|!
name|Float
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
operator|.
name|isNaN
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// ignore
block|}
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|result
operator|.
name|addInvalidNumber
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// now check if all required values are there, and that a default value does not exists
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|row
range|:
name|rows
control|)
block|{
name|String
name|name
init|=
name|row
operator|.
name|get
argument_list|(
literal|"name"
argument_list|)
decl_stmt|;
name|boolean
name|required
init|=
name|isPropertyRequired
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|required
condition|)
block|{
name|String
name|value
init|=
name|properties
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|isEmpty
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|value
operator|=
name|getPropertyDefaultValue
argument_list|(
name|rows
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isEmpty
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|result
operator|.
name|addRequired
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
DECL|method|endpointProperties (String uri)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|endpointProperties
parameter_list|(
name|String
name|uri
parameter_list|)
throws|throws
name|URISyntaxException
block|{
comment|// need to normalize uri first
name|URI
name|u
init|=
name|normalizeUri
argument_list|(
name|uri
argument_list|)
decl_stmt|;
name|String
name|scheme
init|=
name|u
operator|.
name|getScheme
argument_list|()
decl_stmt|;
name|String
name|json
init|=
name|jsonSchemaResolver
operator|.
name|getComponentJSonSchema
argument_list|(
name|scheme
argument_list|)
decl_stmt|;
if|if
condition|(
name|json
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot find endpoint with scheme "
operator|+
name|scheme
argument_list|)
throw|;
block|}
comment|// grab the syntax
name|String
name|syntax
init|=
literal|null
decl_stmt|;
name|String
name|alternativeSyntax
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|rows
init|=
name|parseJsonSchema
argument_list|(
literal|"component"
argument_list|,
name|json
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|row
range|:
name|rows
control|)
block|{
if|if
condition|(
name|row
operator|.
name|containsKey
argument_list|(
literal|"syntax"
argument_list|)
condition|)
block|{
name|syntax
operator|=
name|row
operator|.
name|get
argument_list|(
literal|"syntax"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|row
operator|.
name|containsKey
argument_list|(
literal|"alternativeSyntax"
argument_list|)
condition|)
block|{
name|alternativeSyntax
operator|=
name|row
operator|.
name|get
argument_list|(
literal|"alternativeSyntax"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|syntax
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Endpoint with scheme "
operator|+
name|scheme
operator|+
literal|" has no syntax defined in the json schema"
argument_list|)
throw|;
block|}
comment|// only if we support alternative syntax, and the uri contains the username and password in the authority
comment|// part of the uri, then we would need some special logic to capture that information and strip those
comment|// details from the uri, so we can continue parsing the uri using the normal syntax
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|userInfoOptions
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|alternativeSyntax
operator|!=
literal|null
operator|&&
name|alternativeSyntax
operator|.
name|contains
argument_list|(
literal|"@"
argument_list|)
condition|)
block|{
comment|// clip the scheme from the syntax
name|alternativeSyntax
operator|=
name|after
argument_list|(
name|alternativeSyntax
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
comment|// trim so only userinfo
name|int
name|idx
init|=
name|alternativeSyntax
operator|.
name|indexOf
argument_list|(
literal|"@"
argument_list|)
decl_stmt|;
name|String
name|fields
init|=
name|alternativeSyntax
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|idx
argument_list|)
decl_stmt|;
name|String
index|[]
name|names
init|=
name|fields
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
comment|// grab authority part and grab username and/or password
name|String
name|authority
init|=
name|u
operator|.
name|getAuthority
argument_list|()
decl_stmt|;
if|if
condition|(
name|authority
operator|!=
literal|null
operator|&&
name|authority
operator|.
name|contains
argument_list|(
literal|"@"
argument_list|)
condition|)
block|{
name|String
name|username
init|=
literal|null
decl_stmt|;
name|String
name|password
init|=
literal|null
decl_stmt|;
comment|// grab unserinfo part before @
name|String
name|userInfo
init|=
name|authority
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|authority
operator|.
name|indexOf
argument_list|(
literal|"@"
argument_list|)
argument_list|)
decl_stmt|;
name|String
index|[]
name|parts
init|=
name|userInfo
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|length
operator|==
literal|2
condition|)
block|{
name|username
operator|=
name|parts
index|[
literal|0
index|]
expr_stmt|;
name|password
operator|=
name|parts
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
comment|// only username
name|username
operator|=
name|userInfo
expr_stmt|;
block|}
comment|// remember the username and/or password which we add later to the options
if|if
condition|(
name|names
operator|.
name|length
operator|==
literal|2
condition|)
block|{
name|userInfoOptions
operator|.
name|put
argument_list|(
name|names
index|[
literal|0
index|]
argument_list|,
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|password
operator|!=
literal|null
condition|)
block|{
comment|// password is optional
name|userInfoOptions
operator|.
name|put
argument_list|(
name|names
index|[
literal|1
index|]
argument_list|,
name|password
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// clip the scheme from the syntax
name|syntax
operator|=
name|after
argument_list|(
name|syntax
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
comment|// clip the scheme from the uri
name|uri
operator|=
name|after
argument_list|(
name|uri
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|String
name|uriPath
init|=
name|stripQuery
argument_list|(
name|uri
argument_list|)
decl_stmt|;
comment|// strip user info from uri path
if|if
condition|(
operator|!
name|userInfoOptions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|idx
init|=
name|uriPath
operator|.
name|indexOf
argument_list|(
literal|'@'
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|>
operator|-
literal|1
condition|)
block|{
name|uriPath
operator|=
name|uriPath
operator|.
name|substring
argument_list|(
name|idx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|// strip double slash in the start
if|if
condition|(
name|uriPath
operator|!=
literal|null
operator|&&
name|uriPath
operator|.
name|startsWith
argument_list|(
literal|"//"
argument_list|)
condition|)
block|{
name|uriPath
operator|=
name|uriPath
operator|.
name|substring
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
comment|// parse the syntax and find the names of each option
name|Matcher
name|matcher
init|=
name|SYNTAX_PATTERN
operator|.
name|matcher
argument_list|(
name|syntax
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|word
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|s
init|=
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|scheme
operator|.
name|equals
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|word
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|// parse the syntax and find each token between each option
name|String
index|[]
name|tokens
init|=
name|SYNTAX_PATTERN
operator|.
name|split
argument_list|(
name|syntax
argument_list|)
decl_stmt|;
comment|// find the position where each option start/end
name|List
argument_list|<
name|String
argument_list|>
name|word2
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|prev
init|=
literal|0
decl_stmt|;
name|int
name|prevPath
init|=
literal|0
decl_stmt|;
comment|// special for activemq/jms where the enum for destinationType causes a token issue as it includes a colon
comment|// for 'temp:queue' and 'temp:topic' values
if|if
condition|(
literal|"activemq"
operator|.
name|equals
argument_list|(
name|scheme
argument_list|)
operator|||
literal|"jms"
operator|.
name|equals
argument_list|(
name|scheme
argument_list|)
condition|)
block|{
if|if
condition|(
name|uriPath
operator|.
name|startsWith
argument_list|(
literal|"temp:"
argument_list|)
condition|)
block|{
name|prevPath
operator|=
literal|5
expr_stmt|;
block|}
block|}
for|for
control|(
name|String
name|token
range|:
name|tokens
control|)
block|{
if|if
condition|(
name|token
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
comment|// special for some tokens where :// can be used also, eg http://foo
name|int
name|idx
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
literal|":"
operator|.
name|equals
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|idx
operator|=
name|uriPath
operator|.
name|indexOf
argument_list|(
literal|"://"
argument_list|,
name|prevPath
argument_list|)
expr_stmt|;
name|len
operator|=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
block|{
name|idx
operator|=
name|uriPath
operator|.
name|indexOf
argument_list|(
name|token
argument_list|,
name|prevPath
argument_list|)
expr_stmt|;
name|len
operator|=
name|token
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|>
literal|0
condition|)
block|{
name|String
name|option
init|=
name|uriPath
operator|.
name|substring
argument_list|(
name|prev
argument_list|,
name|idx
argument_list|)
decl_stmt|;
name|word2
operator|.
name|add
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|prev
operator|=
name|idx
operator|+
name|len
expr_stmt|;
name|prevPath
operator|=
name|prev
expr_stmt|;
block|}
block|}
comment|// special for last or if we did not add anyone
if|if
condition|(
name|prev
operator|>
literal|0
operator|||
name|word2
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|option
init|=
name|uriPath
operator|.
name|substring
argument_list|(
name|prev
argument_list|)
decl_stmt|;
name|word2
operator|.
name|add
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
name|rows
operator|=
name|parseJsonSchema
argument_list|(
literal|"properties"
argument_list|,
name|json
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|boolean
name|defaultValueAdded
init|=
literal|false
decl_stmt|;
comment|// now parse the uri to know which part isw what
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|options
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// include the username and password from the userinfo section
if|if
condition|(
operator|!
name|userInfoOptions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|options
operator|.
name|putAll
argument_list|(
name|userInfoOptions
argument_list|)
expr_stmt|;
block|}
comment|// word contains the syntax path elements
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|word2
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|word
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|key
init|=
name|word
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|boolean
name|allOptions
init|=
name|word
operator|.
name|size
argument_list|()
operator|==
name|word2
operator|.
name|size
argument_list|()
decl_stmt|;
name|boolean
name|required
init|=
name|isPropertyRequired
argument_list|(
name|rows
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|String
name|defaultValue
init|=
name|getPropertyDefaultValue
argument_list|(
name|rows
argument_list|,
name|key
argument_list|)
decl_stmt|;
comment|// we have all options so no problem
if|if
condition|(
name|allOptions
condition|)
block|{
name|String
name|value
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|options
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we have a little problem as we do not not have all options
if|if
condition|(
operator|!
name|required
condition|)
block|{
name|String
name|value
init|=
literal|null
decl_stmt|;
name|boolean
name|last
init|=
name|i
operator|==
name|word
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|last
condition|)
block|{
comment|// if its the last value then use it instead of the default value
name|value
operator|=
name|it
operator|.
name|hasNext
argument_list|()
condition|?
name|it
operator|.
name|next
argument_list|()
else|:
literal|null
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|defaultValue
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|defaultValueAdded
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|String
name|value
init|=
name|it
operator|.
name|hasNext
argument_list|()
condition|?
name|it
operator|.
name|next
argument_list|()
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|answer
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// remove all options which are using default values and are not required
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|options
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|defaultValueAdded
condition|)
block|{
name|boolean
name|required
init|=
name|isPropertyRequired
argument_list|(
name|rows
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|String
name|defaultValue
init|=
name|getPropertyDefaultValue
argument_list|(
name|rows
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|required
operator|&&
name|defaultValue
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|defaultValue
operator|.
name|equals
argument_list|(
name|value
argument_list|)
condition|)
block|{
continue|continue;
block|}
block|}
block|}
comment|// we should keep this in the answer
name|answer
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|// now parse the uri parameters
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|parameters
init|=
name|URISupport
operator|.
name|parseParameters
argument_list|(
name|u
argument_list|)
decl_stmt|;
comment|// and covert the values to String so its JMX friendly
while|while
condition|(
operator|!
name|parameters
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|entry
init|=
name|parameters
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
condition|?
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
else|:
literal|""
decl_stmt|;
name|boolean
name|multiValued
init|=
name|isPropertyMultiValue
argument_list|(
name|rows
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|multiValued
condition|)
block|{
name|String
name|prefix
init|=
name|getPropertyPrefix
argument_list|(
name|rows
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|prefix
operator|!=
literal|null
condition|)
block|{
comment|// extra all the multi valued options
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|values
init|=
name|URISupport
operator|.
name|extractProperties
argument_list|(
name|parameters
argument_list|,
name|prefix
argument_list|)
decl_stmt|;
comment|// build a string with the extra multi valued options with the prefix and& as separator
name|String
name|csb
init|=
name|values
operator|.
name|entrySet
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|multi
lambda|->
name|prefix
operator|+
name|multi
operator|.
name|getKey
argument_list|()
operator|+
literal|"="
operator|+
operator|(
name|multi
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
condition|?
name|multi
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
else|:
literal|""
operator|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|joining
argument_list|(
literal|"&"
argument_list|)
argument_list|)
decl_stmt|;
comment|// append the extra multi-values to the existing (which contains the first multi value)
if|if
condition|(
operator|!
name|csb
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|value
operator|=
name|value
operator|+
literal|"&"
operator|+
name|csb
expr_stmt|;
block|}
block|}
block|}
name|answer
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|// remove the parameter as we run in a while loop until no more parameters
name|parameters
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
DECL|method|endpointLenientProperties (String uri)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|endpointLenientProperties
parameter_list|(
name|String
name|uri
parameter_list|)
throws|throws
name|URISyntaxException
block|{
comment|// need to normalize uri first
comment|// parse the uri
name|URI
name|u
init|=
name|normalizeUri
argument_list|(
name|uri
argument_list|)
decl_stmt|;
name|String
name|scheme
init|=
name|u
operator|.
name|getScheme
argument_list|()
decl_stmt|;
name|String
name|json
init|=
name|jsonSchemaResolver
operator|.
name|getComponentJSonSchema
argument_list|(
name|scheme
argument_list|)
decl_stmt|;
if|if
condition|(
name|json
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot find endpoint with scheme "
operator|+
name|scheme
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|rows
init|=
name|parseJsonSchema
argument_list|(
literal|"properties"
argument_list|,
name|json
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// now parse the uri parameters
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|parameters
init|=
name|URISupport
operator|.
name|parseParameters
argument_list|(
name|u
argument_list|)
decl_stmt|;
comment|// all the known options
name|Set
argument_list|<
name|String
argument_list|>
name|names
init|=
name|getNames
argument_list|(
name|rows
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|answer
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// and covert the values to String so its JMX friendly
name|parameters
operator|.
name|forEach
argument_list|(
parameter_list|(
name|k
parameter_list|,
name|v
parameter_list|)
lambda|->
block|{
name|String
name|key
init|=
name|k
decl_stmt|;
name|String
name|value
init|=
name|v
operator|!=
literal|null
condition|?
name|v
operator|.
name|toString
argument_list|()
else|:
literal|""
decl_stmt|;
comment|// is the key a prefix property
name|int
name|dot
init|=
name|key
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
name|dot
operator|!=
operator|-
literal|1
condition|)
block|{
name|String
name|prefix
init|=
name|key
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|dot
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|// include dot in prefix
name|String
name|option
init|=
name|getPropertyNameFromNameWithPrefix
argument_list|(
name|rows
argument_list|,
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|option
operator|==
literal|null
operator|||
operator|!
name|isPropertyMultiValue
argument_list|(
name|rows
argument_list|,
name|option
argument_list|)
condition|)
block|{
name|answer
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|names
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|answer
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
DECL|method|endpointComponentName (String uri)
specifier|public
name|String
name|endpointComponentName
parameter_list|(
name|String
name|uri
parameter_list|)
block|{
if|if
condition|(
name|uri
operator|!=
literal|null
condition|)
block|{
name|int
name|idx
init|=
name|uri
operator|.
name|indexOf
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|>
literal|0
condition|)
block|{
return|return
name|uri
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|idx
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|doAsEndpointUri (String scheme, String json, String ampersand, boolean encode)
specifier|private
name|String
name|doAsEndpointUri
parameter_list|(
name|String
name|scheme
parameter_list|,
name|String
name|json
parameter_list|,
name|String
name|ampersand
parameter_list|,
name|boolean
name|encode
parameter_list|)
throws|throws
name|URISyntaxException
block|{
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|rows
init|=
name|parseJsonSchema
argument_list|(
literal|"properties"
argument_list|,
name|json
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|copy
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|row
range|:
name|rows
control|)
block|{
name|String
name|name
init|=
name|row
operator|.
name|get
argument_list|(
literal|"name"
argument_list|)
decl_stmt|;
name|String
name|required
init|=
name|row
operator|.
name|get
argument_list|(
literal|"required"
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|row
operator|.
name|get
argument_list|(
literal|"value"
argument_list|)
decl_stmt|;
name|String
name|defaultValue
init|=
name|row
operator|.
name|get
argument_list|(
literal|"defaultValue"
argument_list|)
decl_stmt|;
comment|// only add if either required, or the value is != default value
name|String
name|valueToAdd
init|=
literal|null
decl_stmt|;
if|if
condition|(
literal|"true"
operator|.
name|equals
argument_list|(
name|required
argument_list|)
condition|)
block|{
name|valueToAdd
operator|=
name|value
operator|!=
literal|null
condition|?
name|value
else|:
name|defaultValue
expr_stmt|;
if|if
condition|(
name|valueToAdd
operator|==
literal|null
condition|)
block|{
name|valueToAdd
operator|=
literal|""
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// if we have a value and no default then add it
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|defaultValue
operator|==
literal|null
condition|)
block|{
name|valueToAdd
operator|=
name|value
expr_stmt|;
block|}
comment|// otherwise only add if the value is != default value
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|defaultValue
operator|!=
literal|null
operator|&&
operator|!
name|value
operator|.
name|equals
argument_list|(
name|defaultValue
argument_list|)
condition|)
block|{
name|valueToAdd
operator|=
name|value
expr_stmt|;
block|}
block|}
if|if
condition|(
name|valueToAdd
operator|!=
literal|null
condition|)
block|{
name|copy
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|valueToAdd
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|doAsEndpointUri
argument_list|(
name|scheme
argument_list|,
name|copy
argument_list|,
name|ampersand
argument_list|,
name|encode
argument_list|)
return|;
block|}
DECL|method|asEndpointUri (String scheme, Map<String, String> properties, boolean encode)
specifier|public
name|String
name|asEndpointUri
parameter_list|(
name|String
name|scheme
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|properties
parameter_list|,
name|boolean
name|encode
parameter_list|)
throws|throws
name|URISyntaxException
block|{
return|return
name|doAsEndpointUri
argument_list|(
name|scheme
argument_list|,
name|properties
argument_list|,
literal|"&"
argument_list|,
name|encode
argument_list|)
return|;
block|}
DECL|method|asEndpointUriXml (String scheme, Map<String, String> properties, boolean encode)
specifier|public
name|String
name|asEndpointUriXml
parameter_list|(
name|String
name|scheme
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|properties
parameter_list|,
name|boolean
name|encode
parameter_list|)
throws|throws
name|URISyntaxException
block|{
return|return
name|doAsEndpointUri
argument_list|(
name|scheme
argument_list|,
name|properties
argument_list|,
literal|"&amp;"
argument_list|,
name|encode
argument_list|)
return|;
block|}
DECL|method|doAsEndpointUri (String scheme, Map<String, String> properties, String ampersand, boolean encode)
name|String
name|doAsEndpointUri
parameter_list|(
name|String
name|scheme
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|properties
parameter_list|,
name|String
name|ampersand
parameter_list|,
name|boolean
name|encode
parameter_list|)
throws|throws
name|URISyntaxException
block|{
name|String
name|json
init|=
name|jsonSchemaResolver
operator|.
name|getComponentJSonSchema
argument_list|(
name|scheme
argument_list|)
decl_stmt|;
if|if
condition|(
name|json
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot find endpoint with scheme "
operator|+
name|scheme
argument_list|)
throw|;
block|}
comment|// grab the syntax
name|String
name|originalSyntax
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|rows
init|=
name|parseJsonSchema
argument_list|(
literal|"component"
argument_list|,
name|json
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|row
range|:
name|rows
control|)
block|{
if|if
condition|(
name|row
operator|.
name|containsKey
argument_list|(
literal|"syntax"
argument_list|)
condition|)
block|{
name|originalSyntax
operator|=
name|row
operator|.
name|get
argument_list|(
literal|"syntax"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|originalSyntax
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Endpoint with scheme "
operator|+
name|scheme
operator|+
literal|" has no syntax defined in the json schema"
argument_list|)
throw|;
block|}
comment|// do any properties filtering which can be needed for some special components
name|properties
operator|=
name|filterProperties
argument_list|(
name|scheme
argument_list|,
name|properties
argument_list|)
expr_stmt|;
name|rows
operator|=
name|parseJsonSchema
argument_list|(
literal|"properties"
argument_list|,
name|json
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// clip the scheme from the syntax
name|String
name|syntax
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|originalSyntax
operator|.
name|contains
argument_list|(
literal|":"
argument_list|)
condition|)
block|{
name|originalSyntax
operator|=
name|after
argument_list|(
name|originalSyntax
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
comment|// build at first according to syntax (use a tree map as we want the uri options sorted)
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|copy
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|properties
argument_list|)
decl_stmt|;
name|Matcher
name|syntaxMatcher
init|=
name|COMPONENT_SYNTAX_PARSER
operator|.
name|matcher
argument_list|(
name|originalSyntax
argument_list|)
decl_stmt|;
while|while
condition|(
name|syntaxMatcher
operator|.
name|find
argument_list|()
condition|)
block|{
name|syntax
operator|+=
name|syntaxMatcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|String
name|propertyName
init|=
name|syntaxMatcher
operator|.
name|group
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|String
name|propertyValue
init|=
name|copy
operator|.
name|remove
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
name|syntax
operator|+=
name|propertyValue
operator|!=
literal|null
condition|?
name|propertyValue
else|:
name|propertyName
expr_stmt|;
block|}
comment|// do we have all the options the original syntax needs (easy way)
name|String
index|[]
name|keys
init|=
name|syntaxKeys
argument_list|(
name|originalSyntax
argument_list|)
decl_stmt|;
name|boolean
name|hasAllKeys
init|=
name|properties
operator|.
name|keySet
argument_list|()
operator|.
name|containsAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|keys
argument_list|)
argument_list|)
decl_stmt|;
comment|// build endpoint uri
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// add scheme later as we need to take care if there is any context-path or query parameters which
comment|// affect how the URI should be constructed
if|if
condition|(
name|hasAllKeys
condition|)
block|{
comment|// we have all the keys for the syntax so we can build the uri the easy way
name|sb
operator|.
name|append
argument_list|(
name|syntax
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|copy
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|boolean
name|hasQuestionmark
init|=
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
literal|"?"
argument_list|)
decl_stmt|;
comment|// the last option may already contain a ? char, if so we should use& instead of ?
name|sb
operator|.
name|append
argument_list|(
name|hasQuestionmark
condition|?
name|ampersand
else|:
literal|'?'
argument_list|)
expr_stmt|;
name|String
name|query
init|=
name|createQueryString
argument_list|(
name|copy
argument_list|,
name|ampersand
argument_list|,
name|encode
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// TODO: revisit this and see if we can do this in another way
comment|// oh darn some options is missing, so we need a complex way of building the uri
comment|// the tokens between the options in the path
name|String
index|[]
name|tokens
init|=
name|SYNTAX_DASH_PATTERN
operator|.
name|split
argument_list|(
name|syntax
argument_list|)
decl_stmt|;
comment|// parse the syntax into each options
name|Matcher
name|matcher
init|=
name|SYNTAX_PATTERN
operator|.
name|matcher
argument_list|(
name|originalSyntax
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|options
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|s
init|=
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|options
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|// need to preserve {{ and }} from the syntax
comment|// (we need to use words only as its provisional placeholders)
name|syntax
operator|=
name|syntax
operator|.
name|replaceAll
argument_list|(
literal|"\\{\\{"
argument_list|,
literal|"BEGINCAMELPLACEHOLDER"
argument_list|)
expr_stmt|;
name|syntax
operator|=
name|syntax
operator|.
name|replaceAll
argument_list|(
literal|"\\}\\}"
argument_list|,
literal|"ENDCAMELPLACEHOLDER"
argument_list|)
expr_stmt|;
comment|// parse the syntax into each options
name|Matcher
name|matcher2
init|=
name|SYNTAX_DASH_PATTERN
operator|.
name|matcher
argument_list|(
name|syntax
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|options2
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|matcher2
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|s
init|=
name|matcher2
operator|.
name|group
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|s
operator|=
name|s
operator|.
name|replaceAll
argument_list|(
literal|"BEGINCAMELPLACEHOLDER"
argument_list|,
literal|"\\{\\{"
argument_list|)
expr_stmt|;
name|s
operator|=
name|s
operator|.
name|replaceAll
argument_list|(
literal|"ENDCAMELPLACEHOLDER"
argument_list|,
literal|"\\}\\}"
argument_list|)
expr_stmt|;
name|options2
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|// build the endpoint
name|int
name|range
init|=
literal|0
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
name|boolean
name|hasQuestionmark
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|options
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|key
init|=
name|options
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|key2
init|=
name|options2
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|token
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|tokens
operator|.
name|length
operator|>
name|i
condition|)
block|{
name|token
operator|=
name|tokens
index|[
name|i
index|]
expr_stmt|;
block|}
name|boolean
name|contains
init|=
name|properties
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|contains
condition|)
block|{
comment|// if the key are similar we have no explicit value and can try to find a default value if the option is required
if|if
condition|(
name|isPropertyRequired
argument_list|(
name|rows
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|String
name|value
init|=
name|getPropertyDefaultValue
argument_list|(
name|rows
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|properties
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|key2
operator|=
name|value
expr_stmt|;
block|}
block|}
block|}
comment|// was the option provided?
if|if
condition|(
name|properties
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
operator|&&
name|token
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
name|hasQuestionmark
operator||=
name|key
operator|.
name|contains
argument_list|(
literal|"?"
argument_list|)
operator|||
operator|(
name|token
operator|!=
literal|null
operator|&&
name|token
operator|.
name|contains
argument_list|(
literal|"?"
argument_list|)
operator|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|key2
argument_list|)
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
block|}
name|range
operator|++
expr_stmt|;
block|}
comment|// append any extra options that was in surplus for the last
while|while
condition|(
name|range
operator|<
name|options2
operator|.
name|size
argument_list|()
condition|)
block|{
name|String
name|token
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|tokens
operator|.
name|length
operator|>
name|range
condition|)
block|{
name|token
operator|=
name|tokens
index|[
name|range
index|]
expr_stmt|;
block|}
name|String
name|key2
init|=
name|options2
operator|.
name|get
argument_list|(
name|range
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|key2
argument_list|)
expr_stmt|;
name|hasQuestionmark
operator||=
name|key2
operator|.
name|contains
argument_list|(
literal|"?"
argument_list|)
operator|||
operator|(
name|token
operator|!=
literal|null
operator|&&
name|token
operator|.
name|contains
argument_list|(
literal|"?"
argument_list|)
operator|)
expr_stmt|;
name|range
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|copy
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// the last option may already contain a ? char, if so we should use& instead of ?
name|sb
operator|.
name|append
argument_list|(
name|hasQuestionmark
condition|?
name|ampersand
else|:
literal|'?'
argument_list|)
expr_stmt|;
name|String
name|query
init|=
name|createQueryString
argument_list|(
name|copy
argument_list|,
name|ampersand
argument_list|,
name|encode
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|remainder
init|=
name|sb
operator|.
name|toString
argument_list|()
decl_stmt|;
name|boolean
name|queryOnly
init|=
name|remainder
operator|.
name|startsWith
argument_list|(
literal|"?"
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryOnly
condition|)
block|{
comment|// it has only query parameters
return|return
name|scheme
operator|+
name|remainder
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|remainder
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// it has context path and possible query parameters
return|return
name|scheme
operator|+
literal|":"
operator|+
name|remainder
return|;
block|}
else|else
block|{
comment|// its empty without anything
return|return
name|scheme
return|;
block|}
block|}
DECL|method|syntaxKeys (String syntax)
specifier|private
specifier|static
name|String
index|[]
name|syntaxKeys
parameter_list|(
name|String
name|syntax
parameter_list|)
block|{
comment|// build tokens between the separators
name|List
argument_list|<
name|String
argument_list|>
name|tokens
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|syntax
operator|!=
literal|null
condition|)
block|{
name|String
name|current
init|=
literal|""
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|syntax
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|ch
init|=
name|syntax
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|Character
operator|.
name|isLetterOrDigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|current
operator|+=
name|ch
expr_stmt|;
block|}
else|else
block|{
comment|// reset for new current tokens
if|if
condition|(
name|current
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|tokens
operator|.
name|add
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|current
operator|=
literal|""
expr_stmt|;
block|}
block|}
block|}
comment|// anything left over?
if|if
condition|(
name|current
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|tokens
operator|.
name|add
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tokens
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|tokens
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
DECL|method|doValidateSimple (ClassLoader classLoader, String simple, boolean predicate)
specifier|private
name|LanguageValidationResult
name|doValidateSimple
parameter_list|(
name|ClassLoader
name|classLoader
parameter_list|,
name|String
name|simple
parameter_list|,
name|boolean
name|predicate
parameter_list|)
block|{
if|if
condition|(
name|classLoader
operator|==
literal|null
condition|)
block|{
name|classLoader
operator|=
name|getClass
argument_list|()
operator|.
name|getClassLoader
argument_list|()
expr_stmt|;
block|}
comment|// if there are {{ }}} property placeholders then we need to resolve them to something else
comment|// as the simple parse cannot resolve them before parsing as we dont run the actual Camel application
comment|// with property placeholders setup so we need to dummy this by replace the {{ }} to something else
comment|// therefore we use an more unlikely character: {{XXX}} to ~^XXX^~
name|String
name|resolved
init|=
name|simple
operator|.
name|replaceAll
argument_list|(
literal|"\\{\\{(.+)\\}\\}"
argument_list|,
literal|"~^$1^~"
argument_list|)
decl_stmt|;
name|LanguageValidationResult
name|answer
init|=
operator|new
name|LanguageValidationResult
argument_list|(
name|simple
argument_list|)
decl_stmt|;
name|Object
name|instance
init|=
literal|null
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
literal|null
decl_stmt|;
try|try
block|{
name|clazz
operator|=
name|classLoader
operator|.
name|loadClass
argument_list|(
literal|"org.apache.camel.language.simple.SimpleLanguage"
argument_list|)
expr_stmt|;
name|instance
operator|=
name|clazz
operator|.
name|getDeclaredConstructor
argument_list|()
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// ignore
block|}
if|if
condition|(
name|clazz
operator|!=
literal|null
operator|&&
name|instance
operator|!=
literal|null
condition|)
block|{
name|Throwable
name|cause
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|predicate
condition|)
block|{
name|instance
operator|.
name|getClass
argument_list|()
operator|.
name|getMethod
argument_list|(
literal|"createPredicate"
argument_list|,
name|String
operator|.
name|class
argument_list|)
operator|.
name|invoke
argument_list|(
name|instance
argument_list|,
name|resolved
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|instance
operator|.
name|getClass
argument_list|()
operator|.
name|getMethod
argument_list|(
literal|"createExpression"
argument_list|,
name|String
operator|.
name|class
argument_list|)
operator|.
name|invoke
argument_list|(
name|instance
argument_list|,
name|resolved
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
name|cause
operator|=
name|e
operator|.
name|getTargetException
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|cause
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
comment|// reverse ~^XXX^~ back to {{XXX}}
name|String
name|errMsg
init|=
name|cause
operator|.
name|getMessage
argument_list|()
decl_stmt|;
name|errMsg
operator|=
name|errMsg
operator|.
name|replaceAll
argument_list|(
literal|"\\~\\^(.+)\\^\\~"
argument_list|,
literal|"{{$1}}"
argument_list|)
expr_stmt|;
name|answer
operator|.
name|setError
argument_list|(
name|errMsg
argument_list|)
expr_stmt|;
comment|// is it simple parser exception then we can grab the index where the problem is
if|if
condition|(
name|cause
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"org.apache.camel.language.simple.types.SimpleIllegalSyntaxException"
argument_list|)
operator|||
name|cause
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"org.apache.camel.language.simple.types.SimpleParserException"
argument_list|)
condition|)
block|{
try|try
block|{
comment|// we need to grab the index field from those simple parser exceptions
name|Method
name|method
init|=
name|cause
operator|.
name|getClass
argument_list|()
operator|.
name|getMethod
argument_list|(
literal|"getIndex"
argument_list|)
decl_stmt|;
name|Object
name|result
init|=
name|method
operator|.
name|invoke
argument_list|(
name|cause
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
name|int
name|index
init|=
operator|(
name|int
operator|)
name|result
decl_stmt|;
name|answer
operator|.
name|setIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|i
parameter_list|)
block|{
comment|// ignore
block|}
block|}
comment|// we need to grab the short message field from this simple syntax exception
if|if
condition|(
name|cause
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"org.apache.camel.language.simple.types.SimpleIllegalSyntaxException"
argument_list|)
condition|)
block|{
try|try
block|{
name|Method
name|method
init|=
name|cause
operator|.
name|getClass
argument_list|()
operator|.
name|getMethod
argument_list|(
literal|"getShortMessage"
argument_list|)
decl_stmt|;
name|Object
name|result
init|=
name|method
operator|.
name|invoke
argument_list|(
name|cause
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
name|String
name|msg
init|=
operator|(
name|String
operator|)
name|result
decl_stmt|;
name|answer
operator|.
name|setShortError
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|i
parameter_list|)
block|{
comment|// ignore
block|}
if|if
condition|(
name|answer
operator|.
name|getShortError
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// fallback and try to make existing message short instead
name|String
name|msg
init|=
name|answer
operator|.
name|getError
argument_list|()
decl_stmt|;
comment|// grab everything before " at location " which would be regarded as the short message
name|int
name|idx
init|=
name|msg
operator|.
name|indexOf
argument_list|(
literal|" at location "
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|>
literal|0
condition|)
block|{
name|msg
operator|=
name|msg
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|answer
operator|.
name|setShortError
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|answer
return|;
block|}
DECL|method|validateLanguagePredicate (ClassLoader classLoader, String language, String text)
specifier|public
name|LanguageValidationResult
name|validateLanguagePredicate
parameter_list|(
name|ClassLoader
name|classLoader
parameter_list|,
name|String
name|language
parameter_list|,
name|String
name|text
parameter_list|)
block|{
if|if
condition|(
literal|"simple"
operator|.
name|equals
argument_list|(
name|language
argument_list|)
condition|)
block|{
return|return
name|doValidateSimple
argument_list|(
name|classLoader
argument_list|,
name|text
argument_list|,
literal|true
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|doValidateLanguage
argument_list|(
name|classLoader
argument_list|,
name|language
argument_list|,
name|text
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
DECL|method|validateLanguageExpression (ClassLoader classLoader, String language, String text)
specifier|public
name|LanguageValidationResult
name|validateLanguageExpression
parameter_list|(
name|ClassLoader
name|classLoader
parameter_list|,
name|String
name|language
parameter_list|,
name|String
name|text
parameter_list|)
block|{
if|if
condition|(
literal|"simple"
operator|.
name|equals
argument_list|(
name|language
argument_list|)
condition|)
block|{
return|return
name|doValidateSimple
argument_list|(
name|classLoader
argument_list|,
name|text
argument_list|,
literal|false
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|doValidateLanguage
argument_list|(
name|classLoader
argument_list|,
name|language
argument_list|,
name|text
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
DECL|method|doValidateLanguage (ClassLoader classLoader, String language, String text, boolean predicate)
specifier|private
name|LanguageValidationResult
name|doValidateLanguage
parameter_list|(
name|ClassLoader
name|classLoader
parameter_list|,
name|String
name|language
parameter_list|,
name|String
name|text
parameter_list|,
name|boolean
name|predicate
parameter_list|)
block|{
if|if
condition|(
name|classLoader
operator|==
literal|null
condition|)
block|{
name|classLoader
operator|=
name|getClass
argument_list|()
operator|.
name|getClassLoader
argument_list|()
expr_stmt|;
block|}
name|LanguageValidationResult
name|answer
init|=
operator|new
name|LanguageValidationResult
argument_list|(
name|text
argument_list|)
decl_stmt|;
name|String
name|json
init|=
name|jsonSchemaResolver
operator|.
name|getLanguageJSonSchema
argument_list|(
name|language
argument_list|)
decl_stmt|;
if|if
condition|(
name|json
operator|==
literal|null
condition|)
block|{
name|answer
operator|.
name|setError
argument_list|(
literal|"Unknown language "
operator|+
name|language
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|rows
init|=
name|parseJsonSchema
argument_list|(
literal|"language"
argument_list|,
name|json
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|String
name|className
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|row
range|:
name|rows
control|)
block|{
if|if
condition|(
name|row
operator|.
name|containsKey
argument_list|(
literal|"javaType"
argument_list|)
condition|)
block|{
name|className
operator|=
name|row
operator|.
name|get
argument_list|(
literal|"javaType"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|className
operator|==
literal|null
condition|)
block|{
name|answer
operator|.
name|setError
argument_list|(
literal|"Cannot find javaType for language "
operator|+
name|language
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
name|Object
name|instance
init|=
literal|null
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
literal|null
decl_stmt|;
try|try
block|{
name|clazz
operator|=
name|classLoader
operator|.
name|loadClass
argument_list|(
name|className
argument_list|)
expr_stmt|;
name|instance
operator|=
name|clazz
operator|.
name|getDeclaredConstructor
argument_list|()
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// ignore
block|}
if|if
condition|(
name|clazz
operator|!=
literal|null
operator|&&
name|instance
operator|!=
literal|null
condition|)
block|{
name|Throwable
name|cause
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|predicate
condition|)
block|{
name|instance
operator|.
name|getClass
argument_list|()
operator|.
name|getMethod
argument_list|(
literal|"createPredicate"
argument_list|,
name|String
operator|.
name|class
argument_list|)
operator|.
name|invoke
argument_list|(
name|instance
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|instance
operator|.
name|getClass
argument_list|()
operator|.
name|getMethod
argument_list|(
literal|"createExpression"
argument_list|,
name|String
operator|.
name|class
argument_list|)
operator|.
name|invoke
argument_list|(
name|instance
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
name|cause
operator|=
name|e
operator|.
name|getTargetException
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|cause
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
name|answer
operator|.
name|setError
argument_list|(
name|cause
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Special logic for log endpoints to deal when showAll=true      */
DECL|method|filterProperties (String scheme, Map<String, String> options)
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|filterProperties
parameter_list|(
name|String
name|scheme
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|options
parameter_list|)
block|{
if|if
condition|(
literal|"log"
operator|.
name|equals
argument_list|(
name|scheme
argument_list|)
condition|)
block|{
name|String
name|showAll
init|=
name|options
operator|.
name|get
argument_list|(
literal|"showAll"
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"true"
operator|.
name|equals
argument_list|(
name|showAll
argument_list|)
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|filtered
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// remove all the other showXXX options when showAll=true
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|options
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|boolean
name|skip
init|=
name|key
operator|.
name|startsWith
argument_list|(
literal|"show"
argument_list|)
operator|&&
operator|!
name|key
operator|.
name|equals
argument_list|(
literal|"showAll"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|skip
condition|)
block|{
name|filtered
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|filtered
return|;
block|}
block|}
comment|// use as-is
return|return
name|options
return|;
block|}
DECL|method|validateInteger (String value)
specifier|private
specifier|static
name|boolean
name|validateInteger
parameter_list|(
name|String
name|value
parameter_list|)
block|{
name|boolean
name|valid
init|=
literal|false
decl_stmt|;
try|try
block|{
name|valid
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
operator|!=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// ignore
block|}
if|if
condition|(
operator|!
name|valid
condition|)
block|{
comment|// it may be a time pattern, such as 5s for 5 seconds = 5000
try|try
block|{
name|TimePatternConverter
operator|.
name|toMilliSeconds
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|valid
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
return|return
name|valid
return|;
block|}
comment|// CHECKSTYLE:ON
block|}
end_class

end_unit

