begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.processor.interceptor
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
operator|.
name|interceptor
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|LoggingLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|NamedNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|NoTypeConversionAvailableException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Processor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|RuntimeCamelException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|api
operator|.
name|management
operator|.
name|mbean
operator|.
name|BacklogTracerEventMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|CamelEvent
operator|.
name|ExchangeCompletedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|CamelEvent
operator|.
name|ExchangeEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|CamelLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|Debugger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|CamelContextHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|MessageHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|service
operator|.
name|ServiceHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|service
operator|.
name|ServiceSupport
import|;
end_import

begin_comment
comment|/**  * A {@link org.apache.camel.spi.Debugger} that has easy debugging functionality which  * can be used from JMX with {@link org.apache.camel.api.management.mbean.ManagedBacklogDebuggerMBean}.  *<p/>  * This implementation allows to set breakpoints (with or without a condition) and inspect the {@link Exchange}  * dumped in XML in {@link BacklogTracerEventMessage} format. There is operations to resume suspended breakpoints  * to continue routing the {@link Exchange}. There is also step functionality so you can single step a given  * {@link Exchange}.  *<p/>  * This implementation will only break the first {@link Exchange} that arrives to a breakpoint. If Camel routes using  * concurrency then sub-sequent {@link Exchange} will continue to be routed, if there breakpoint already holds a  * suspended {@link Exchange}.  */
end_comment

begin_class
DECL|class|BacklogDebugger
specifier|public
specifier|final
class|class
name|BacklogDebugger
extends|extends
name|ServiceSupport
block|{
DECL|field|fallbackTimeout
specifier|private
name|long
name|fallbackTimeout
init|=
literal|300
decl_stmt|;
DECL|field|camelContext
specifier|private
specifier|final
name|CamelContext
name|camelContext
decl_stmt|;
DECL|field|loggingLevel
specifier|private
name|LoggingLevel
name|loggingLevel
init|=
name|LoggingLevel
operator|.
name|INFO
decl_stmt|;
DECL|field|logger
specifier|private
specifier|final
name|CamelLogger
name|logger
init|=
operator|new
name|CamelLogger
argument_list|(
name|log
argument_list|,
name|loggingLevel
argument_list|)
decl_stmt|;
DECL|field|enabled
specifier|private
specifier|final
name|AtomicBoolean
name|enabled
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
DECL|field|debugCounter
specifier|private
specifier|final
name|AtomicLong
name|debugCounter
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|debugger
specifier|private
specifier|final
name|Debugger
name|debugger
decl_stmt|;
DECL|field|breakpoints
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|NodeBreakpoint
argument_list|>
name|breakpoints
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|suspendedBreakpoints
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|SuspendedExchange
argument_list|>
name|suspendedBreakpoints
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|suspendedBreakpointMessages
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|BacklogTracerEventMessage
argument_list|>
name|suspendedBreakpointMessages
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|singleStepExchangeId
specifier|private
specifier|volatile
name|String
name|singleStepExchangeId
decl_stmt|;
DECL|field|bodyMaxChars
specifier|private
name|int
name|bodyMaxChars
init|=
literal|128
operator|*
literal|1024
decl_stmt|;
DECL|field|bodyIncludeStreams
specifier|private
name|boolean
name|bodyIncludeStreams
decl_stmt|;
DECL|field|bodyIncludeFiles
specifier|private
name|boolean
name|bodyIncludeFiles
init|=
literal|true
decl_stmt|;
comment|/**      * A suspend {@link Exchange} at a breakpoint.      */
DECL|class|SuspendedExchange
specifier|private
specifier|static
specifier|final
class|class
name|SuspendedExchange
block|{
DECL|field|exchange
specifier|private
specifier|final
name|Exchange
name|exchange
decl_stmt|;
DECL|field|latch
specifier|private
specifier|final
name|CountDownLatch
name|latch
decl_stmt|;
comment|/**          * @param exchange the suspend exchange          * @param latch    the latch to use to continue routing the exchange          */
DECL|method|SuspendedExchange (Exchange exchange, CountDownLatch latch)
specifier|private
name|SuspendedExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|CountDownLatch
name|latch
parameter_list|)
block|{
name|this
operator|.
name|exchange
operator|=
name|exchange
expr_stmt|;
name|this
operator|.
name|latch
operator|=
name|latch
expr_stmt|;
block|}
DECL|method|getExchange ()
specifier|public
name|Exchange
name|getExchange
parameter_list|()
block|{
return|return
name|exchange
return|;
block|}
DECL|method|getLatch ()
specifier|public
name|CountDownLatch
name|getLatch
parameter_list|()
block|{
return|return
name|latch
return|;
block|}
block|}
DECL|method|BacklogDebugger (CamelContext camelContext)
specifier|private
name|BacklogDebugger
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|)
block|{
name|this
operator|.
name|camelContext
operator|=
name|camelContext
expr_stmt|;
name|this
operator|.
name|debugger
operator|=
operator|new
name|DefaultDebugger
argument_list|(
name|camelContext
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new backlog debugger.      *      * @param context Camel context      * @return a new backlog debugger      */
DECL|method|createDebugger (CamelContext context)
specifier|public
specifier|static
name|BacklogDebugger
name|createDebugger
parameter_list|(
name|CamelContext
name|context
parameter_list|)
block|{
return|return
operator|new
name|BacklogDebugger
argument_list|(
name|context
argument_list|)
return|;
block|}
comment|/**      * A helper method to return the BacklogDebugger instance if one is enabled      *      * @return the backlog debugger or null if none can be found      */
DECL|method|getBacklogDebugger (CamelContext context)
specifier|public
specifier|static
name|BacklogDebugger
name|getBacklogDebugger
parameter_list|(
name|CamelContext
name|context
parameter_list|)
block|{
return|return
name|context
operator|.
name|hasService
argument_list|(
name|BacklogDebugger
operator|.
name|class
argument_list|)
return|;
block|}
DECL|method|getDebugger ()
specifier|public
name|Debugger
name|getDebugger
parameter_list|()
block|{
return|return
name|debugger
return|;
block|}
DECL|method|getLoggingLevel ()
specifier|public
name|String
name|getLoggingLevel
parameter_list|()
block|{
return|return
name|loggingLevel
operator|.
name|name
argument_list|()
return|;
block|}
DECL|method|setLoggingLevel (String level)
specifier|public
name|void
name|setLoggingLevel
parameter_list|(
name|String
name|level
parameter_list|)
block|{
name|loggingLevel
operator|=
name|LoggingLevel
operator|.
name|valueOf
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|logger
operator|.
name|setLevel
argument_list|(
name|loggingLevel
argument_list|)
expr_stmt|;
block|}
DECL|method|enableDebugger ()
specifier|public
name|void
name|enableDebugger
parameter_list|()
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"Enabling debugger"
argument_list|)
expr_stmt|;
try|try
block|{
name|ServiceHelper
operator|.
name|startService
argument_list|(
name|debugger
argument_list|)
expr_stmt|;
name|enabled
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|RuntimeCamelException
operator|.
name|wrapRuntimeCamelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|disableDebugger ()
specifier|public
name|void
name|disableDebugger
parameter_list|()
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"Disabling debugger"
argument_list|)
expr_stmt|;
try|try
block|{
name|enabled
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|ServiceHelper
operator|.
name|stopService
argument_list|(
name|debugger
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// ignore
block|}
name|clearBreakpoints
argument_list|()
expr_stmt|;
block|}
DECL|method|isEnabled ()
specifier|public
name|boolean
name|isEnabled
parameter_list|()
block|{
return|return
name|enabled
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|hasBreakpoint (String nodeId)
specifier|public
name|boolean
name|hasBreakpoint
parameter_list|(
name|String
name|nodeId
parameter_list|)
block|{
return|return
name|breakpoints
operator|.
name|containsKey
argument_list|(
name|nodeId
argument_list|)
return|;
block|}
DECL|method|isSingleStepMode ()
specifier|public
name|boolean
name|isSingleStepMode
parameter_list|()
block|{
return|return
name|singleStepExchangeId
operator|!=
literal|null
return|;
block|}
DECL|method|addBreakpoint (String nodeId)
specifier|public
name|void
name|addBreakpoint
parameter_list|(
name|String
name|nodeId
parameter_list|)
block|{
name|NodeBreakpoint
name|breakpoint
init|=
name|breakpoints
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|breakpoint
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"Adding breakpoint "
operator|+
name|nodeId
argument_list|)
expr_stmt|;
name|breakpoint
operator|=
operator|new
name|NodeBreakpoint
argument_list|(
name|nodeId
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|breakpoints
operator|.
name|put
argument_list|(
name|nodeId
argument_list|,
name|breakpoint
argument_list|)
expr_stmt|;
name|debugger
operator|.
name|addBreakpoint
argument_list|(
name|breakpoint
argument_list|,
name|breakpoint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|breakpoint
operator|.
name|setCondition
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addConditionalBreakpoint (String nodeId, String language, String predicate)
specifier|public
name|void
name|addConditionalBreakpoint
parameter_list|(
name|String
name|nodeId
parameter_list|,
name|String
name|language
parameter_list|,
name|String
name|predicate
parameter_list|)
block|{
name|Predicate
name|condition
init|=
name|camelContext
operator|.
name|resolveLanguage
argument_list|(
name|language
argument_list|)
operator|.
name|createPredicate
argument_list|(
name|predicate
argument_list|)
decl_stmt|;
name|NodeBreakpoint
name|breakpoint
init|=
name|breakpoints
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|breakpoint
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"Adding conditional breakpoint "
operator|+
name|nodeId
operator|+
literal|" ["
operator|+
name|predicate
operator|+
literal|"]"
argument_list|)
expr_stmt|;
name|breakpoint
operator|=
operator|new
name|NodeBreakpoint
argument_list|(
name|nodeId
argument_list|,
name|condition
argument_list|)
expr_stmt|;
name|breakpoints
operator|.
name|put
argument_list|(
name|nodeId
argument_list|,
name|breakpoint
argument_list|)
expr_stmt|;
name|debugger
operator|.
name|addBreakpoint
argument_list|(
name|breakpoint
argument_list|,
name|breakpoint
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|breakpoint
operator|.
name|getCondition
argument_list|()
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"Updating to conditional breakpoint "
operator|+
name|nodeId
operator|+
literal|" ["
operator|+
name|predicate
operator|+
literal|"]"
argument_list|)
expr_stmt|;
name|debugger
operator|.
name|removeBreakpoint
argument_list|(
name|breakpoint
argument_list|)
expr_stmt|;
name|breakpoints
operator|.
name|put
argument_list|(
name|nodeId
argument_list|,
name|breakpoint
argument_list|)
expr_stmt|;
name|debugger
operator|.
name|addBreakpoint
argument_list|(
name|breakpoint
argument_list|,
name|breakpoint
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|breakpoint
operator|.
name|getCondition
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"Updating conditional breakpoint "
operator|+
name|nodeId
operator|+
literal|" ["
operator|+
name|predicate
operator|+
literal|"]"
argument_list|)
expr_stmt|;
name|breakpoint
operator|.
name|setCondition
argument_list|(
name|condition
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeBreakpoint (String nodeId)
specifier|public
name|void
name|removeBreakpoint
parameter_list|(
name|String
name|nodeId
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"Removing breakpoint "
operator|+
name|nodeId
argument_list|)
expr_stmt|;
comment|// when removing a break point then ensure latches is cleared and counted down so we wont have hanging threads
name|suspendedBreakpointMessages
operator|.
name|remove
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
name|SuspendedExchange
name|se
init|=
name|suspendedBreakpoints
operator|.
name|remove
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
name|NodeBreakpoint
name|breakpoint
init|=
name|breakpoints
operator|.
name|remove
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|breakpoint
operator|!=
literal|null
condition|)
block|{
name|debugger
operator|.
name|removeBreakpoint
argument_list|(
name|breakpoint
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|se
operator|!=
literal|null
condition|)
block|{
name|se
operator|.
name|getLatch
argument_list|()
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|removeAllBreakpoints ()
specifier|public
name|void
name|removeAllBreakpoints
parameter_list|()
block|{
comment|// stop single stepping
name|singleStepExchangeId
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|String
name|nodeId
range|:
name|getSuspendedBreakpointNodeIds
argument_list|()
control|)
block|{
name|removeBreakpoint
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getBreakpoints ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getBreakpoints
parameter_list|()
block|{
return|return
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|(
name|breakpoints
operator|.
name|keySet
argument_list|()
argument_list|)
return|;
block|}
DECL|method|resumeBreakpoint (String nodeId)
specifier|public
name|void
name|resumeBreakpoint
parameter_list|(
name|String
name|nodeId
parameter_list|)
block|{
name|resumeBreakpoint
argument_list|(
name|nodeId
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|resumeBreakpoint (String nodeId, boolean stepMode)
specifier|private
name|void
name|resumeBreakpoint
parameter_list|(
name|String
name|nodeId
parameter_list|,
name|boolean
name|stepMode
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"Resume breakpoint "
operator|+
name|nodeId
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stepMode
condition|)
block|{
if|if
condition|(
name|singleStepExchangeId
operator|!=
literal|null
condition|)
block|{
name|debugger
operator|.
name|stopSingleStepExchange
argument_list|(
name|singleStepExchangeId
argument_list|)
expr_stmt|;
name|singleStepExchangeId
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// remember to remove the dumped message as its no longer in need
name|suspendedBreakpointMessages
operator|.
name|remove
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
name|SuspendedExchange
name|se
init|=
name|suspendedBreakpoints
operator|.
name|remove
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|se
operator|!=
literal|null
condition|)
block|{
name|se
operator|.
name|getLatch
argument_list|()
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|setMessageBodyOnBreakpoint (String nodeId, Object body)
specifier|public
name|void
name|setMessageBodyOnBreakpoint
parameter_list|(
name|String
name|nodeId
parameter_list|,
name|Object
name|body
parameter_list|)
block|{
name|SuspendedExchange
name|se
init|=
name|suspendedBreakpoints
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|se
operator|!=
literal|null
condition|)
block|{
name|boolean
name|remove
init|=
name|body
operator|==
literal|null
decl_stmt|;
if|if
condition|(
name|remove
condition|)
block|{
name|removeMessageBodyOnBreakpoint
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|oldType
decl_stmt|;
if|if
condition|(
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|hasOut
argument_list|()
condition|)
block|{
name|oldType
operator|=
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getOut
argument_list|()
operator|.
name|getBody
argument_list|()
operator|!=
literal|null
condition|?
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getOut
argument_list|()
operator|.
name|getBody
argument_list|()
operator|.
name|getClass
argument_list|()
else|:
literal|null
expr_stmt|;
block|}
else|else
block|{
name|oldType
operator|=
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|()
operator|!=
literal|null
condition|?
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|()
operator|.
name|getClass
argument_list|()
else|:
literal|null
expr_stmt|;
block|}
name|setMessageBodyOnBreakpoint
argument_list|(
name|nodeId
argument_list|,
name|body
argument_list|,
name|oldType
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|setMessageBodyOnBreakpoint (String nodeId, Object body, Class<?> type)
specifier|public
name|void
name|setMessageBodyOnBreakpoint
parameter_list|(
name|String
name|nodeId
parameter_list|,
name|Object
name|body
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|type
parameter_list|)
block|{
name|SuspendedExchange
name|se
init|=
name|suspendedBreakpoints
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|se
operator|!=
literal|null
condition|)
block|{
name|boolean
name|remove
init|=
name|body
operator|==
literal|null
decl_stmt|;
if|if
condition|(
name|remove
condition|)
block|{
name|removeMessageBodyOnBreakpoint
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"Breakpoint at node "
operator|+
name|nodeId
operator|+
literal|" is updating message body on exchangeId: "
operator|+
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getExchangeId
argument_list|()
operator|+
literal|" with new body: "
operator|+
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|hasOut
argument_list|()
condition|)
block|{
comment|// preserve type
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getOut
argument_list|()
operator|.
name|setBody
argument_list|(
name|body
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getOut
argument_list|()
operator|.
name|setBody
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getIn
argument_list|()
operator|.
name|setBody
argument_list|(
name|body
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getIn
argument_list|()
operator|.
name|setBody
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|method|removeMessageBodyOnBreakpoint (String nodeId)
specifier|public
name|void
name|removeMessageBodyOnBreakpoint
parameter_list|(
name|String
name|nodeId
parameter_list|)
block|{
name|SuspendedExchange
name|se
init|=
name|suspendedBreakpoints
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|se
operator|!=
literal|null
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"Breakpoint at node "
operator|+
name|nodeId
operator|+
literal|" is removing message body on exchangeId: "
operator|+
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getExchangeId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|hasOut
argument_list|()
condition|)
block|{
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getOut
argument_list|()
operator|.
name|setBody
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getIn
argument_list|()
operator|.
name|setBody
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|setMessageHeaderOnBreakpoint (String nodeId, String headerName, Object value)
specifier|public
name|void
name|setMessageHeaderOnBreakpoint
parameter_list|(
name|String
name|nodeId
parameter_list|,
name|String
name|headerName
parameter_list|,
name|Object
name|value
parameter_list|)
throws|throws
name|NoTypeConversionAvailableException
block|{
name|SuspendedExchange
name|se
init|=
name|suspendedBreakpoints
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|se
operator|!=
literal|null
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|oldType
decl_stmt|;
if|if
condition|(
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|hasOut
argument_list|()
condition|)
block|{
name|oldType
operator|=
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getOut
argument_list|()
operator|.
name|getHeader
argument_list|(
name|headerName
argument_list|)
operator|!=
literal|null
condition|?
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getOut
argument_list|()
operator|.
name|getHeader
argument_list|(
name|headerName
argument_list|)
operator|.
name|getClass
argument_list|()
else|:
literal|null
expr_stmt|;
block|}
else|else
block|{
name|oldType
operator|=
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|headerName
argument_list|)
operator|!=
literal|null
condition|?
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|headerName
argument_list|)
operator|.
name|getClass
argument_list|()
else|:
literal|null
expr_stmt|;
block|}
name|setMessageHeaderOnBreakpoint
argument_list|(
name|nodeId
argument_list|,
name|headerName
argument_list|,
name|value
argument_list|,
name|oldType
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|setMessageHeaderOnBreakpoint (String nodeId, String headerName, Object value, Class<?> type)
specifier|public
name|void
name|setMessageHeaderOnBreakpoint
parameter_list|(
name|String
name|nodeId
parameter_list|,
name|String
name|headerName
parameter_list|,
name|Object
name|value
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|type
parameter_list|)
throws|throws
name|NoTypeConversionAvailableException
block|{
name|SuspendedExchange
name|se
init|=
name|suspendedBreakpoints
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|se
operator|!=
literal|null
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"Breakpoint at node "
operator|+
name|nodeId
operator|+
literal|" is updating message header on exchangeId: "
operator|+
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getExchangeId
argument_list|()
operator|+
literal|" with header: "
operator|+
name|headerName
operator|+
literal|" and value: "
operator|+
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|hasOut
argument_list|()
condition|)
block|{
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
name|Object
name|convertedValue
init|=
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|mandatoryConvertTo
argument_list|(
name|type
argument_list|,
name|se
operator|.
name|getExchange
argument_list|()
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getOut
argument_list|()
operator|.
name|setHeader
argument_list|(
name|headerName
argument_list|,
name|convertedValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getOut
argument_list|()
operator|.
name|setHeader
argument_list|(
name|headerName
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
name|Object
name|convertedValue
init|=
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|mandatoryConvertTo
argument_list|(
name|type
argument_list|,
name|se
operator|.
name|getExchange
argument_list|()
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getIn
argument_list|()
operator|.
name|setHeader
argument_list|(
name|headerName
argument_list|,
name|convertedValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getIn
argument_list|()
operator|.
name|setHeader
argument_list|(
name|headerName
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|getFallbackTimeout ()
specifier|public
name|long
name|getFallbackTimeout
parameter_list|()
block|{
return|return
name|fallbackTimeout
return|;
block|}
DECL|method|setFallbackTimeout (long fallbackTimeout)
specifier|public
name|void
name|setFallbackTimeout
parameter_list|(
name|long
name|fallbackTimeout
parameter_list|)
block|{
name|this
operator|.
name|fallbackTimeout
operator|=
name|fallbackTimeout
expr_stmt|;
block|}
DECL|method|removeMessageHeaderOnBreakpoint (String nodeId, String headerName)
specifier|public
name|void
name|removeMessageHeaderOnBreakpoint
parameter_list|(
name|String
name|nodeId
parameter_list|,
name|String
name|headerName
parameter_list|)
block|{
name|SuspendedExchange
name|se
init|=
name|suspendedBreakpoints
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|se
operator|!=
literal|null
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"Breakpoint at node "
operator|+
name|nodeId
operator|+
literal|" is removing message header on exchangeId: "
operator|+
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getExchangeId
argument_list|()
operator|+
literal|" with header: "
operator|+
name|headerName
argument_list|)
expr_stmt|;
if|if
condition|(
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|hasOut
argument_list|()
condition|)
block|{
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getOut
argument_list|()
operator|.
name|removeHeader
argument_list|(
name|headerName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|se
operator|.
name|getExchange
argument_list|()
operator|.
name|getIn
argument_list|()
operator|.
name|removeHeader
argument_list|(
name|headerName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|resumeAll ()
specifier|public
name|void
name|resumeAll
parameter_list|()
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"Resume all"
argument_list|)
expr_stmt|;
comment|// stop single stepping
name|singleStepExchangeId
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|String
name|node
range|:
name|getSuspendedBreakpointNodeIds
argument_list|()
control|)
block|{
comment|// remember to remove the dumped message as its no longer in need
name|suspendedBreakpointMessages
operator|.
name|remove
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|SuspendedExchange
name|se
init|=
name|suspendedBreakpoints
operator|.
name|remove
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|se
operator|!=
literal|null
condition|)
block|{
name|se
operator|.
name|getLatch
argument_list|()
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|stepBreakpoint (String nodeId)
specifier|public
name|void
name|stepBreakpoint
parameter_list|(
name|String
name|nodeId
parameter_list|)
block|{
comment|// if we are already in single step mode, then infer stepping
if|if
condition|(
name|isSingleStepMode
argument_list|()
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"stepBreakpoint "
operator|+
name|nodeId
operator|+
literal|" is already in single step mode, so stepping instead."
argument_list|)
expr_stmt|;
name|step
argument_list|()
expr_stmt|;
block|}
name|logger
operator|.
name|log
argument_list|(
literal|"Step breakpoint "
operator|+
name|nodeId
argument_list|)
expr_stmt|;
comment|// we want to step current exchange to next
name|BacklogTracerEventMessage
name|msg
init|=
name|suspendedBreakpointMessages
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
name|NodeBreakpoint
name|breakpoint
init|=
name|breakpoints
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
operator|!=
literal|null
operator|&&
name|breakpoint
operator|!=
literal|null
condition|)
block|{
name|singleStepExchangeId
operator|=
name|msg
operator|.
name|getExchangeId
argument_list|()
expr_stmt|;
if|if
condition|(
name|debugger
operator|.
name|startSingleStepExchange
argument_list|(
name|singleStepExchangeId
argument_list|,
operator|new
name|StepBreakpoint
argument_list|()
argument_list|)
condition|)
block|{
comment|// now resume
name|resumeBreakpoint
argument_list|(
name|nodeId
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|step ()
specifier|public
name|void
name|step
parameter_list|()
block|{
for|for
control|(
name|String
name|node
range|:
name|getSuspendedBreakpointNodeIds
argument_list|()
control|)
block|{
comment|// remember to remove the dumped message as its no longer in need
name|suspendedBreakpointMessages
operator|.
name|remove
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|SuspendedExchange
name|se
init|=
name|suspendedBreakpoints
operator|.
name|remove
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|se
operator|!=
literal|null
condition|)
block|{
name|se
operator|.
name|getLatch
argument_list|()
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|getSuspendedBreakpointNodeIds ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getSuspendedBreakpointNodeIds
parameter_list|()
block|{
return|return
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|(
name|suspendedBreakpoints
operator|.
name|keySet
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Gets the exchanged suspended at the given breakpoint id or null if there is none at that id.      *      * @param id - node id for the breakpoint      * @return The suspended exchange or null if there isn't one suspended at the given breakpoint.      */
DECL|method|getSuspendedExchange (String id)
specifier|public
name|Exchange
name|getSuspendedExchange
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|SuspendedExchange
name|suspendedExchange
init|=
name|suspendedBreakpoints
operator|.
name|get
argument_list|(
name|id
argument_list|)
decl_stmt|;
return|return
name|suspendedExchange
operator|!=
literal|null
condition|?
name|suspendedExchange
operator|.
name|getExchange
argument_list|()
else|:
literal|null
return|;
block|}
DECL|method|disableBreakpoint (String nodeId)
specifier|public
name|void
name|disableBreakpoint
parameter_list|(
name|String
name|nodeId
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"Disable breakpoint "
operator|+
name|nodeId
argument_list|)
expr_stmt|;
name|NodeBreakpoint
name|breakpoint
init|=
name|breakpoints
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|breakpoint
operator|!=
literal|null
condition|)
block|{
name|breakpoint
operator|.
name|suspend
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|enableBreakpoint (String nodeId)
specifier|public
name|void
name|enableBreakpoint
parameter_list|(
name|String
name|nodeId
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"Enable breakpoint "
operator|+
name|nodeId
argument_list|)
expr_stmt|;
name|NodeBreakpoint
name|breakpoint
init|=
name|breakpoints
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|breakpoint
operator|!=
literal|null
condition|)
block|{
name|breakpoint
operator|.
name|activate
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getBodyMaxChars ()
specifier|public
name|int
name|getBodyMaxChars
parameter_list|()
block|{
return|return
name|bodyMaxChars
return|;
block|}
DECL|method|setBodyMaxChars (int bodyMaxChars)
specifier|public
name|void
name|setBodyMaxChars
parameter_list|(
name|int
name|bodyMaxChars
parameter_list|)
block|{
name|this
operator|.
name|bodyMaxChars
operator|=
name|bodyMaxChars
expr_stmt|;
block|}
DECL|method|isBodyIncludeStreams ()
specifier|public
name|boolean
name|isBodyIncludeStreams
parameter_list|()
block|{
return|return
name|bodyIncludeStreams
return|;
block|}
DECL|method|setBodyIncludeStreams (boolean bodyIncludeStreams)
specifier|public
name|void
name|setBodyIncludeStreams
parameter_list|(
name|boolean
name|bodyIncludeStreams
parameter_list|)
block|{
name|this
operator|.
name|bodyIncludeStreams
operator|=
name|bodyIncludeStreams
expr_stmt|;
block|}
DECL|method|isBodyIncludeFiles ()
specifier|public
name|boolean
name|isBodyIncludeFiles
parameter_list|()
block|{
return|return
name|bodyIncludeFiles
return|;
block|}
DECL|method|setBodyIncludeFiles (boolean bodyIncludeFiles)
specifier|public
name|void
name|setBodyIncludeFiles
parameter_list|(
name|boolean
name|bodyIncludeFiles
parameter_list|)
block|{
name|this
operator|.
name|bodyIncludeFiles
operator|=
name|bodyIncludeFiles
expr_stmt|;
block|}
DECL|method|dumpTracedMessagesAsXml (String nodeId)
specifier|public
name|String
name|dumpTracedMessagesAsXml
parameter_list|(
name|String
name|nodeId
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"Dump trace message from breakpoint "
operator|+
name|nodeId
argument_list|)
expr_stmt|;
name|BacklogTracerEventMessage
name|msg
init|=
name|suspendedBreakpointMessages
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
operator|!=
literal|null
condition|)
block|{
return|return
name|msg
operator|.
name|toXml
argument_list|(
literal|0
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
DECL|method|getDebugCounter ()
specifier|public
name|long
name|getDebugCounter
parameter_list|()
block|{
return|return
name|debugCounter
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|resetDebugCounter ()
specifier|public
name|void
name|resetDebugCounter
parameter_list|()
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"Reset debug counter"
argument_list|)
expr_stmt|;
name|debugCounter
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|beforeProcess (Exchange exchange, Processor processor, NamedNode definition)
specifier|public
name|boolean
name|beforeProcess
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Processor
name|processor
parameter_list|,
name|NamedNode
name|definition
parameter_list|)
block|{
return|return
name|debugger
operator|.
name|beforeProcess
argument_list|(
name|exchange
argument_list|,
name|processor
argument_list|,
name|definition
argument_list|)
return|;
block|}
DECL|method|afterProcess (Exchange exchange, Processor processor, NamedNode definition, long timeTaken)
specifier|public
name|boolean
name|afterProcess
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Processor
name|processor
parameter_list|,
name|NamedNode
name|definition
parameter_list|,
name|long
name|timeTaken
parameter_list|)
block|{
comment|// noop
return|return
literal|false
return|;
block|}
DECL|method|doStart ()
specifier|protected
name|void
name|doStart
parameter_list|()
throws|throws
name|Exception
block|{
comment|// noop
block|}
DECL|method|doStop ()
specifier|protected
name|void
name|doStop
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|enabled
operator|.
name|get
argument_list|()
condition|)
block|{
name|disableDebugger
argument_list|()
expr_stmt|;
block|}
name|clearBreakpoints
argument_list|()
expr_stmt|;
block|}
DECL|method|clearBreakpoints ()
specifier|private
name|void
name|clearBreakpoints
parameter_list|()
block|{
comment|// make sure to clear state and latches is counted down so we wont have hanging threads
name|breakpoints
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|SuspendedExchange
name|se
range|:
name|suspendedBreakpoints
operator|.
name|values
argument_list|()
control|)
block|{
name|se
operator|.
name|getLatch
argument_list|()
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
name|suspendedBreakpoints
operator|.
name|clear
argument_list|()
expr_stmt|;
name|suspendedBreakpointMessages
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**      * Represents a {@link org.apache.camel.spi.Breakpoint} that has a {@link Condition} on a specific node id.      */
DECL|class|NodeBreakpoint
specifier|private
specifier|final
class|class
name|NodeBreakpoint
extends|extends
name|BreakpointSupport
implements|implements
name|Condition
block|{
DECL|field|nodeId
specifier|private
specifier|final
name|String
name|nodeId
decl_stmt|;
DECL|field|condition
specifier|private
name|Predicate
name|condition
decl_stmt|;
DECL|method|NodeBreakpoint (String nodeId, Predicate condition)
specifier|private
name|NodeBreakpoint
parameter_list|(
name|String
name|nodeId
parameter_list|,
name|Predicate
name|condition
parameter_list|)
block|{
name|this
operator|.
name|nodeId
operator|=
name|nodeId
expr_stmt|;
name|this
operator|.
name|condition
operator|=
name|condition
expr_stmt|;
block|}
DECL|method|getCondition ()
specifier|public
name|Predicate
name|getCondition
parameter_list|()
block|{
return|return
name|condition
return|;
block|}
DECL|method|setCondition (Predicate predicate)
specifier|public
name|void
name|setCondition
parameter_list|(
name|Predicate
name|predicate
parameter_list|)
block|{
name|this
operator|.
name|condition
operator|=
name|predicate
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|beforeProcess (Exchange exchange, Processor processor, NamedNode definition)
specifier|public
name|void
name|beforeProcess
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Processor
name|processor
parameter_list|,
name|NamedNode
name|definition
parameter_list|)
block|{
comment|// store a copy of the message so we can see that from the debugger
name|Date
name|timestamp
init|=
operator|new
name|Date
argument_list|()
decl_stmt|;
name|String
name|toNode
init|=
name|definition
operator|.
name|getId
argument_list|()
decl_stmt|;
name|String
name|routeId
init|=
name|CamelContextHelper
operator|.
name|getRouteId
argument_list|(
name|definition
argument_list|)
decl_stmt|;
name|String
name|exchangeId
init|=
name|exchange
operator|.
name|getExchangeId
argument_list|()
decl_stmt|;
name|String
name|messageAsXml
init|=
name|MessageHelper
operator|.
name|dumpAsXml
argument_list|(
name|exchange
operator|.
name|getIn
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|2
argument_list|,
name|isBodyIncludeStreams
argument_list|()
argument_list|,
name|isBodyIncludeFiles
argument_list|()
argument_list|,
name|getBodyMaxChars
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|uid
init|=
name|debugCounter
operator|.
name|incrementAndGet
argument_list|()
decl_stmt|;
name|BacklogTracerEventMessage
name|msg
init|=
operator|new
name|DefaultBacklogTracerEventMessage
argument_list|(
name|uid
argument_list|,
name|timestamp
argument_list|,
name|routeId
argument_list|,
name|toNode
argument_list|,
name|exchangeId
argument_list|,
name|messageAsXml
argument_list|)
decl_stmt|;
name|suspendedBreakpointMessages
operator|.
name|put
argument_list|(
name|nodeId
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// suspend at this breakpoint
specifier|final
name|SuspendedExchange
name|se
init|=
name|suspendedBreakpoints
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|se
operator|!=
literal|null
condition|)
block|{
comment|// now wait until we should continue
name|logger
operator|.
name|log
argument_list|(
literal|"NodeBreakpoint at node "
operator|+
name|toNode
operator|+
literal|" is waiting to continue for exchangeId: "
operator|+
name|exchangeId
argument_list|)
expr_stmt|;
try|try
block|{
name|boolean
name|hit
init|=
name|se
operator|.
name|getLatch
argument_list|()
operator|.
name|await
argument_list|(
name|fallbackTimeout
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|hit
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"NodeBreakpoint at node "
operator|+
name|toNode
operator|+
literal|" timed out and is continued exchangeId: "
operator|+
name|exchangeId
argument_list|,
name|LoggingLevel
operator|.
name|WARN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"NodeBreakpoint at node "
operator|+
name|toNode
operator|+
literal|" is continued exchangeId: "
operator|+
name|exchangeId
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|matchProcess (Exchange exchange, Processor processor, NamedNode definition)
specifier|public
name|boolean
name|matchProcess
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Processor
name|processor
parameter_list|,
name|NamedNode
name|definition
parameter_list|)
block|{
comment|// must match node
if|if
condition|(
operator|!
name|nodeId
operator|.
name|equals
argument_list|(
name|definition
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// if condition then must match
if|if
condition|(
name|condition
operator|!=
literal|null
operator|&&
operator|!
name|condition
operator|.
name|matches
argument_list|(
name|exchange
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// we only want to break one exchange at a time, so if there is already a suspended breakpoint then do not match
name|SuspendedExchange
name|se
init|=
operator|new
name|SuspendedExchange
argument_list|(
name|exchange
argument_list|,
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|boolean
name|existing
init|=
name|suspendedBreakpoints
operator|.
name|putIfAbsent
argument_list|(
name|nodeId
argument_list|,
name|se
argument_list|)
operator|!=
literal|null
decl_stmt|;
return|return
operator|!
name|existing
return|;
block|}
annotation|@
name|Override
DECL|method|matchEvent (Exchange exchange, ExchangeEvent event)
specifier|public
name|boolean
name|matchEvent
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|ExchangeEvent
name|event
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Represents a {@link org.apache.camel.spi.Breakpoint} that is used during single step mode.      */
DECL|class|StepBreakpoint
specifier|private
specifier|final
class|class
name|StepBreakpoint
extends|extends
name|BreakpointSupport
implements|implements
name|Condition
block|{
annotation|@
name|Override
DECL|method|beforeProcess (Exchange exchange, Processor processor, NamedNode definition)
specifier|public
name|void
name|beforeProcess
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Processor
name|processor
parameter_list|,
name|NamedNode
name|definition
parameter_list|)
block|{
comment|// store a copy of the message so we can see that from the debugger
name|Date
name|timestamp
init|=
operator|new
name|Date
argument_list|()
decl_stmt|;
name|String
name|toNode
init|=
name|definition
operator|.
name|getId
argument_list|()
decl_stmt|;
name|String
name|routeId
init|=
name|CamelContextHelper
operator|.
name|getRouteId
argument_list|(
name|definition
argument_list|)
decl_stmt|;
name|String
name|exchangeId
init|=
name|exchange
operator|.
name|getExchangeId
argument_list|()
decl_stmt|;
name|String
name|messageAsXml
init|=
name|MessageHelper
operator|.
name|dumpAsXml
argument_list|(
name|exchange
operator|.
name|getIn
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|2
argument_list|,
name|isBodyIncludeStreams
argument_list|()
argument_list|,
name|isBodyIncludeFiles
argument_list|()
argument_list|,
name|getBodyMaxChars
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|uid
init|=
name|debugCounter
operator|.
name|incrementAndGet
argument_list|()
decl_stmt|;
name|BacklogTracerEventMessage
name|msg
init|=
operator|new
name|DefaultBacklogTracerEventMessage
argument_list|(
name|uid
argument_list|,
name|timestamp
argument_list|,
name|routeId
argument_list|,
name|toNode
argument_list|,
name|exchangeId
argument_list|,
name|messageAsXml
argument_list|)
decl_stmt|;
name|suspendedBreakpointMessages
operator|.
name|put
argument_list|(
name|toNode
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// suspend at this breakpoint
name|SuspendedExchange
name|se
init|=
operator|new
name|SuspendedExchange
argument_list|(
name|exchange
argument_list|,
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|suspendedBreakpoints
operator|.
name|put
argument_list|(
name|toNode
argument_list|,
name|se
argument_list|)
expr_stmt|;
comment|// now wait until we should continue
name|logger
operator|.
name|log
argument_list|(
literal|"StepBreakpoint at node "
operator|+
name|toNode
operator|+
literal|" is waiting to continue for exchangeId: "
operator|+
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|boolean
name|hit
init|=
name|se
operator|.
name|getLatch
argument_list|()
operator|.
name|await
argument_list|(
name|fallbackTimeout
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|hit
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"StepBreakpoint at node "
operator|+
name|toNode
operator|+
literal|" timed out and is continued exchangeId: "
operator|+
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|,
name|LoggingLevel
operator|.
name|WARN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"StepBreakpoint at node "
operator|+
name|toNode
operator|+
literal|" is continued exchangeId: "
operator|+
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
annotation|@
name|Override
DECL|method|matchProcess (Exchange exchange, Processor processor, NamedNode definition)
specifier|public
name|boolean
name|matchProcess
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Processor
name|processor
parameter_list|,
name|NamedNode
name|definition
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|matchEvent (Exchange exchange, ExchangeEvent event)
specifier|public
name|boolean
name|matchEvent
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|ExchangeEvent
name|event
parameter_list|)
block|{
return|return
name|event
operator|instanceof
name|ExchangeCompletedEvent
return|;
block|}
annotation|@
name|Override
DECL|method|onEvent (Exchange exchange, ExchangeEvent event, NamedNode definition)
specifier|public
name|void
name|onEvent
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|ExchangeEvent
name|event
parameter_list|,
name|NamedNode
name|definition
parameter_list|)
block|{
comment|// when the exchange is complete, we need to turn off single step mode if we were debug stepping the exchange
if|if
condition|(
name|event
operator|instanceof
name|ExchangeCompletedEvent
condition|)
block|{
name|String
name|completedId
init|=
name|event
operator|.
name|getExchange
argument_list|()
operator|.
name|getExchangeId
argument_list|()
decl_stmt|;
if|if
condition|(
name|singleStepExchangeId
operator|!=
literal|null
operator|&&
name|singleStepExchangeId
operator|.
name|equals
argument_list|(
name|completedId
argument_list|)
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
literal|"ExchangeId: "
operator|+
name|completedId
operator|+
literal|" is completed, so exiting single step mode."
argument_list|)
expr_stmt|;
name|singleStepExchangeId
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

