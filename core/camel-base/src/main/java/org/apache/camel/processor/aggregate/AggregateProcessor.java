begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.processor.aggregate
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
operator|.
name|aggregate
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|AggregationStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|AsyncCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|AsyncProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContextAware
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelExchangeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Endpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Expression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Navigate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|NoSuchEndpointException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Processor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|ProducerTemplate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|ShutdownRunningTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|TimeoutMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Traceable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|AggregationRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|ExceptionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|IdAware
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|OptimisticLockingAggregationRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|RecoverableAggregationRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|ShutdownAware
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|ShutdownPrepared
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|Synchronization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|AsyncProcessorSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|DefaultTimeoutMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|ExchangeHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|LRUCacheFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|LoggingExceptionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|NoLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|service
operator|.
name|ServiceHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ObjectHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|StopWatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|TimeUtils
import|;
end_import

begin_comment
comment|/**  * An implementation of the<a  * href="http://camel.apache.org/aggregator2.html">Aggregator</a>  * pattern where a batch of messages are processed (up to a maximum amount or  * until some timeout is reached) and messages for the same correlation key are  * combined together using some kind of {@link AggregationStrategy}  * (by default the latest message is used) to compress many message exchanges  * into a smaller number of exchanges.  *<p/>  * A good example of this is stock market data; you may be receiving 30,000  * messages/second and you may want to throttle it right down so that multiple  * messages for the same stock are combined (or just the latest message is used  * and older prices are discarded). Another idea is to combine line item messages  * together into a single invoice message.  */
end_comment

begin_class
DECL|class|AggregateProcessor
specifier|public
class|class
name|AggregateProcessor
extends|extends
name|AsyncProcessorSupport
implements|implements
name|Navigate
argument_list|<
name|Processor
argument_list|>
implements|,
name|Traceable
implements|,
name|ShutdownPrepared
implements|,
name|ShutdownAware
implements|,
name|IdAware
block|{
DECL|field|AGGREGATE_TIMEOUT_CHECKER
specifier|public
specifier|static
specifier|final
name|String
name|AGGREGATE_TIMEOUT_CHECKER
init|=
literal|"AggregateTimeoutChecker"
decl_stmt|;
DECL|field|AGGREGATE_OPTIMISTIC_LOCKING_EXECUTOR
specifier|public
specifier|static
specifier|final
name|String
name|AGGREGATE_OPTIMISTIC_LOCKING_EXECUTOR
init|=
literal|"AggregateOptimisticLockingExecutor"
decl_stmt|;
DECL|field|COMPLETED_BY_SIZE
specifier|public
specifier|static
specifier|final
name|String
name|COMPLETED_BY_SIZE
init|=
literal|"size"
decl_stmt|;
DECL|field|COMPLETED_BY_PREDICATE
specifier|public
specifier|static
specifier|final
name|String
name|COMPLETED_BY_PREDICATE
init|=
literal|"predicate"
decl_stmt|;
DECL|field|COMPLETED_BY_CONSUMER
specifier|public
specifier|static
specifier|final
name|String
name|COMPLETED_BY_CONSUMER
init|=
literal|"consumer"
decl_stmt|;
DECL|field|COMPLETED_BY_STRATEGY
specifier|public
specifier|static
specifier|final
name|String
name|COMPLETED_BY_STRATEGY
init|=
literal|"strategy"
decl_stmt|;
DECL|field|COMPLETED_BY_INTERVAL
specifier|public
specifier|static
specifier|final
name|String
name|COMPLETED_BY_INTERVAL
init|=
literal|"interval"
decl_stmt|;
DECL|field|COMPLETED_BY_TIMEOUT
specifier|public
specifier|static
specifier|final
name|String
name|COMPLETED_BY_TIMEOUT
init|=
literal|"timeout"
decl_stmt|;
DECL|field|COMPLETED_BY_FORCE
specifier|public
specifier|static
specifier|final
name|String
name|COMPLETED_BY_FORCE
init|=
literal|"force"
decl_stmt|;
DECL|field|lock
specifier|private
specifier|volatile
name|Lock
name|lock
decl_stmt|;
DECL|field|aggregateRepositoryWarned
specifier|private
specifier|final
name|AtomicBoolean
name|aggregateRepositoryWarned
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
DECL|field|camelContext
specifier|private
specifier|final
name|CamelContext
name|camelContext
decl_stmt|;
DECL|field|processor
specifier|private
specifier|final
name|AsyncProcessor
name|processor
decl_stmt|;
DECL|field|id
specifier|private
name|String
name|id
decl_stmt|;
DECL|field|aggregationStrategy
specifier|private
name|AggregationStrategy
name|aggregationStrategy
decl_stmt|;
DECL|field|preCompletion
specifier|private
name|boolean
name|preCompletion
decl_stmt|;
DECL|field|correlationExpression
specifier|private
name|Expression
name|correlationExpression
decl_stmt|;
DECL|field|aggregateController
specifier|private
name|AggregateController
name|aggregateController
decl_stmt|;
DECL|field|executorService
specifier|private
specifier|final
name|ExecutorService
name|executorService
decl_stmt|;
DECL|field|shutdownExecutorService
specifier|private
specifier|final
name|boolean
name|shutdownExecutorService
decl_stmt|;
DECL|field|optimisticLockRetryPolicy
specifier|private
name|OptimisticLockRetryPolicy
name|optimisticLockRetryPolicy
init|=
operator|new
name|OptimisticLockRetryPolicy
argument_list|()
decl_stmt|;
DECL|field|timeoutCheckerExecutorService
specifier|private
name|ScheduledExecutorService
name|timeoutCheckerExecutorService
decl_stmt|;
DECL|field|shutdownTimeoutCheckerExecutorService
specifier|private
name|boolean
name|shutdownTimeoutCheckerExecutorService
decl_stmt|;
DECL|field|optimisticLockingExecutorService
specifier|private
name|ScheduledExecutorService
name|optimisticLockingExecutorService
decl_stmt|;
DECL|field|shutdownOptimisticLockingExecutorService
specifier|private
name|boolean
name|shutdownOptimisticLockingExecutorService
decl_stmt|;
DECL|field|recoverService
specifier|private
name|ScheduledExecutorService
name|recoverService
decl_stmt|;
comment|// store correlation key -> exchange id in timeout map
DECL|field|timeoutMap
specifier|private
name|TimeoutMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|timeoutMap
decl_stmt|;
DECL|field|exceptionHandler
specifier|private
name|ExceptionHandler
name|exceptionHandler
decl_stmt|;
DECL|field|aggregationRepository
specifier|private
name|AggregationRepository
name|aggregationRepository
decl_stmt|;
DECL|field|closedCorrelationKeys
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|closedCorrelationKeys
decl_stmt|;
DECL|field|batchConsumerCorrelationKeys
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|batchConsumerCorrelationKeys
init|=
operator|new
name|ConcurrentSkipListSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|inProgressCompleteExchanges
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|inProgressCompleteExchanges
init|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|redeliveryState
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RedeliveryData
argument_list|>
name|redeliveryState
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|statistics
specifier|private
specifier|final
name|AggregateProcessorStatistics
name|statistics
init|=
operator|new
name|Statistics
argument_list|()
decl_stmt|;
DECL|field|totalIn
specifier|private
specifier|final
name|AtomicLong
name|totalIn
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|totalCompleted
specifier|private
specifier|final
name|AtomicLong
name|totalCompleted
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|completedBySize
specifier|private
specifier|final
name|AtomicLong
name|completedBySize
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|completedByStrategy
specifier|private
specifier|final
name|AtomicLong
name|completedByStrategy
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|completedByInterval
specifier|private
specifier|final
name|AtomicLong
name|completedByInterval
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|completedByTimeout
specifier|private
specifier|final
name|AtomicLong
name|completedByTimeout
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|completedByPredicate
specifier|private
specifier|final
name|AtomicLong
name|completedByPredicate
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|completedByBatchConsumer
specifier|private
specifier|final
name|AtomicLong
name|completedByBatchConsumer
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|completedByForce
specifier|private
specifier|final
name|AtomicLong
name|completedByForce
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
comment|// keep booking about redelivery
DECL|class|RedeliveryData
specifier|private
class|class
name|RedeliveryData
block|{
DECL|field|redeliveryCounter
name|int
name|redeliveryCounter
decl_stmt|;
block|}
DECL|class|Statistics
specifier|private
class|class
name|Statistics
implements|implements
name|AggregateProcessorStatistics
block|{
DECL|field|statisticsEnabled
specifier|private
name|boolean
name|statisticsEnabled
init|=
literal|true
decl_stmt|;
annotation|@
name|Override
DECL|method|getTotalIn ()
specifier|public
name|long
name|getTotalIn
parameter_list|()
block|{
return|return
name|totalIn
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getTotalCompleted ()
specifier|public
name|long
name|getTotalCompleted
parameter_list|()
block|{
return|return
name|totalCompleted
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getCompletedBySize ()
specifier|public
name|long
name|getCompletedBySize
parameter_list|()
block|{
return|return
name|completedBySize
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getCompletedByStrategy ()
specifier|public
name|long
name|getCompletedByStrategy
parameter_list|()
block|{
return|return
name|completedByStrategy
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getCompletedByInterval ()
specifier|public
name|long
name|getCompletedByInterval
parameter_list|()
block|{
return|return
name|completedByInterval
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getCompletedByTimeout ()
specifier|public
name|long
name|getCompletedByTimeout
parameter_list|()
block|{
return|return
name|completedByTimeout
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getCompletedByPredicate ()
specifier|public
name|long
name|getCompletedByPredicate
parameter_list|()
block|{
return|return
name|completedByPredicate
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getCompletedByBatchConsumer ()
specifier|public
name|long
name|getCompletedByBatchConsumer
parameter_list|()
block|{
return|return
name|completedByBatchConsumer
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getCompletedByForce ()
specifier|public
name|long
name|getCompletedByForce
parameter_list|()
block|{
return|return
name|completedByForce
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|reset ()
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|totalIn
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|totalCompleted
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|completedBySize
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|completedByStrategy
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|completedByTimeout
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|completedByPredicate
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|completedByBatchConsumer
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|completedByForce
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isStatisticsEnabled ()
specifier|public
name|boolean
name|isStatisticsEnabled
parameter_list|()
block|{
return|return
name|statisticsEnabled
return|;
block|}
annotation|@
name|Override
DECL|method|setStatisticsEnabled (boolean statisticsEnabled)
specifier|public
name|void
name|setStatisticsEnabled
parameter_list|(
name|boolean
name|statisticsEnabled
parameter_list|)
block|{
name|this
operator|.
name|statisticsEnabled
operator|=
name|statisticsEnabled
expr_stmt|;
block|}
block|}
comment|// options
DECL|field|ignoreInvalidCorrelationKeys
specifier|private
name|boolean
name|ignoreInvalidCorrelationKeys
decl_stmt|;
DECL|field|closeCorrelationKeyOnCompletion
specifier|private
name|Integer
name|closeCorrelationKeyOnCompletion
decl_stmt|;
DECL|field|parallelProcessing
specifier|private
name|boolean
name|parallelProcessing
decl_stmt|;
DECL|field|optimisticLocking
specifier|private
name|boolean
name|optimisticLocking
decl_stmt|;
comment|// different ways to have completion triggered
DECL|field|eagerCheckCompletion
specifier|private
name|boolean
name|eagerCheckCompletion
decl_stmt|;
DECL|field|completionPredicate
specifier|private
name|Predicate
name|completionPredicate
decl_stmt|;
DECL|field|completionTimeout
specifier|private
name|long
name|completionTimeout
decl_stmt|;
DECL|field|completionTimeoutExpression
specifier|private
name|Expression
name|completionTimeoutExpression
decl_stmt|;
DECL|field|completionInterval
specifier|private
name|long
name|completionInterval
decl_stmt|;
DECL|field|completionSize
specifier|private
name|int
name|completionSize
decl_stmt|;
DECL|field|completionSizeExpression
specifier|private
name|Expression
name|completionSizeExpression
decl_stmt|;
DECL|field|completionFromBatchConsumer
specifier|private
name|boolean
name|completionFromBatchConsumer
decl_stmt|;
DECL|field|completionOnNewCorrelationGroup
specifier|private
name|boolean
name|completionOnNewCorrelationGroup
decl_stmt|;
DECL|field|batchConsumerCounter
specifier|private
name|AtomicInteger
name|batchConsumerCounter
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|field|discardOnCompletionTimeout
specifier|private
name|boolean
name|discardOnCompletionTimeout
decl_stmt|;
DECL|field|discardOnAggregationFailure
specifier|private
name|boolean
name|discardOnAggregationFailure
decl_stmt|;
DECL|field|forceCompletionOnStop
specifier|private
name|boolean
name|forceCompletionOnStop
decl_stmt|;
DECL|field|completeAllOnStop
specifier|private
name|boolean
name|completeAllOnStop
decl_stmt|;
DECL|field|completionTimeoutCheckerInterval
specifier|private
name|long
name|completionTimeoutCheckerInterval
init|=
literal|1000
decl_stmt|;
DECL|field|deadLetterProducerTemplate
specifier|private
name|ProducerTemplate
name|deadLetterProducerTemplate
decl_stmt|;
DECL|method|AggregateProcessor (CamelContext camelContext, AsyncProcessor processor, Expression correlationExpression, AggregationStrategy aggregationStrategy, ExecutorService executorService, boolean shutdownExecutorService)
specifier|public
name|AggregateProcessor
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|,
name|AsyncProcessor
name|processor
parameter_list|,
name|Expression
name|correlationExpression
parameter_list|,
name|AggregationStrategy
name|aggregationStrategy
parameter_list|,
name|ExecutorService
name|executorService
parameter_list|,
name|boolean
name|shutdownExecutorService
parameter_list|)
block|{
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|camelContext
argument_list|,
literal|"camelContext"
argument_list|)
expr_stmt|;
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|processor
argument_list|,
literal|"processor"
argument_list|)
expr_stmt|;
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|correlationExpression
argument_list|,
literal|"correlationExpression"
argument_list|)
expr_stmt|;
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|aggregationStrategy
argument_list|,
literal|"aggregationStrategy"
argument_list|)
expr_stmt|;
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|executorService
argument_list|,
literal|"executorService"
argument_list|)
expr_stmt|;
name|this
operator|.
name|camelContext
operator|=
name|camelContext
expr_stmt|;
name|this
operator|.
name|processor
operator|=
name|processor
expr_stmt|;
name|this
operator|.
name|correlationExpression
operator|=
name|correlationExpression
expr_stmt|;
name|this
operator|.
name|aggregationStrategy
operator|=
name|aggregationStrategy
expr_stmt|;
name|this
operator|.
name|executorService
operator|=
name|executorService
expr_stmt|;
name|this
operator|.
name|shutdownExecutorService
operator|=
name|shutdownExecutorService
expr_stmt|;
name|this
operator|.
name|exceptionHandler
operator|=
operator|new
name|LoggingExceptionHandler
argument_list|(
name|camelContext
argument_list|,
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"AggregateProcessor[to: "
operator|+
name|processor
operator|+
literal|"]"
return|;
block|}
annotation|@
name|Override
DECL|method|getTraceLabel ()
specifier|public
name|String
name|getTraceLabel
parameter_list|()
block|{
return|return
literal|"aggregate["
operator|+
name|correlationExpression
operator|+
literal|"]"
return|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|List
argument_list|<
name|Processor
argument_list|>
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|Processor
argument_list|>
name|answer
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|answer
operator|.
name|add
argument_list|(
name|processor
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|processor
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getId ()
specifier|public
name|String
name|getId
parameter_list|()
block|{
return|return
name|id
return|;
block|}
annotation|@
name|Override
DECL|method|setId (String id)
specifier|public
name|void
name|setId
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|process (Exchange exchange, AsyncCallback callback)
specifier|public
name|boolean
name|process
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|AsyncCallback
name|callback
parameter_list|)
block|{
try|try
block|{
name|doProcess
argument_list|(
name|exchange
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|exchange
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|callback
operator|.
name|done
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|doProcess (Exchange exchange, AsyncCallback callback)
specifier|protected
name|void
name|doProcess
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|AsyncCallback
name|callback
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|getStatistics
argument_list|()
operator|.
name|isStatisticsEnabled
argument_list|()
condition|)
block|{
name|totalIn
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|//check for the special header to force completion of all groups (and ignore the exchange otherwise)
if|if
condition|(
name|getAndRemoveBooleanHeader
argument_list|(
name|exchange
argument_list|,
name|Exchange
operator|.
name|AGGREGATION_COMPLETE_ALL_GROUPS
argument_list|)
condition|)
block|{
name|forceCompletionOfAllGroups
argument_list|()
expr_stmt|;
name|callback
operator|.
name|done
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// compute correlation expression
name|String
name|key
init|=
name|correlationExpression
operator|.
name|evaluate
argument_list|(
name|exchange
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|ObjectHelper
operator|.
name|isEmpty
argument_list|(
name|key
argument_list|)
condition|)
block|{
comment|// we have a bad correlation key
if|if
condition|(
name|isIgnoreInvalidCorrelationKeys
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Invalid correlation key. This Exchange will be ignored: {}"
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exchange
operator|.
name|setException
argument_list|(
operator|new
name|CamelExchangeException
argument_list|(
literal|"Invalid correlation key"
argument_list|,
name|exchange
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|callback
operator|.
name|done
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// is the correlation key closed?
if|if
condition|(
name|closedCorrelationKeys
operator|!=
literal|null
operator|&&
name|closedCorrelationKeys
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|exchange
operator|.
name|setException
argument_list|(
operator|new
name|ClosedCorrelationKeyException
argument_list|(
name|key
argument_list|,
name|exchange
argument_list|)
argument_list|)
expr_stmt|;
name|callback
operator|.
name|done
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|optimisticLocking
condition|)
block|{
name|doInOptimisticLock
argument_list|(
name|exchange
argument_list|,
name|key
argument_list|,
name|callback
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doProcess
argument_list|(
name|exchange
argument_list|,
name|key
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doInOptimisticLock (Exchange exchange, String key, AsyncCallback callback, int attempt)
specifier|protected
name|void
name|doInOptimisticLock
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|key
parameter_list|,
name|AsyncCallback
name|callback
parameter_list|,
name|int
name|attempt
parameter_list|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|attempt
operator|++
expr_stmt|;
try|try
block|{
name|doProcess
argument_list|(
name|exchange
argument_list|,
name|key
argument_list|,
name|callback
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|OptimisticLockingAggregationRepository
operator|.
name|OptimisticLockingException
name|e
parameter_list|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"On attempt {} OptimisticLockingAggregationRepository: {} threw OptimisticLockingException while trying to aggregate exchange: {}"
argument_list|,
name|attempt
argument_list|,
name|aggregationRepository
argument_list|,
name|exchange
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimisticLockRetryPolicy
operator|.
name|shouldRetry
argument_list|(
name|attempt
argument_list|)
condition|)
block|{
name|long
name|delay
init|=
name|optimisticLockRetryPolicy
operator|.
name|getDelay
argument_list|(
name|attempt
argument_list|)
decl_stmt|;
if|if
condition|(
name|delay
operator|>
literal|0
condition|)
block|{
name|int
name|nextAttempt
init|=
name|attempt
decl_stmt|;
name|getOptimisticLockingExecutorService
argument_list|()
operator|.
name|schedule
argument_list|(
parameter_list|()
lambda|->
name|doInOptimisticLock
argument_list|(
name|exchange
argument_list|,
name|key
argument_list|,
name|callback
argument_list|,
name|nextAttempt
argument_list|)
argument_list|,
name|delay
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|exchange
operator|.
name|setException
argument_list|(
operator|new
name|CamelExchangeException
argument_list|(
literal|"Exhausted optimistic locking retry attempts, tried "
operator|+
name|attempt
operator|+
literal|" times"
argument_list|,
name|exchange
argument_list|,
operator|new
name|OptimisticLockingAggregationRepository
operator|.
name|OptimisticLockingException
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|callback
operator|.
name|done
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
DECL|method|doProcess (Exchange exchange, String key, AsyncCallback callback)
specifier|protected
name|void
name|doProcess
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|key
parameter_list|,
name|AsyncCallback
name|callback
parameter_list|)
block|{
comment|// copy exchange, and do not share the unit of work
comment|// the aggregated output runs in another unit of work
name|Exchange
name|copy
init|=
name|ExchangeHelper
operator|.
name|createCorrelatedCopy
argument_list|(
name|exchange
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// remove the complete all groups headers as it should not be on the copy
name|copy
operator|.
name|getIn
argument_list|()
operator|.
name|removeHeader
argument_list|(
name|Exchange
operator|.
name|AGGREGATION_COMPLETE_CURRENT_GROUP
argument_list|)
expr_stmt|;
name|copy
operator|.
name|getIn
argument_list|()
operator|.
name|removeHeader
argument_list|(
name|Exchange
operator|.
name|AGGREGATION_COMPLETE_ALL_GROUPS
argument_list|)
expr_stmt|;
name|copy
operator|.
name|getIn
argument_list|()
operator|.
name|removeHeader
argument_list|(
name|Exchange
operator|.
name|AGGREGATION_COMPLETE_ALL_GROUPS_INCLUSIVE
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Exchange
argument_list|>
name|aggregated
init|=
literal|null
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|aggregated
operator|=
name|doAggregation
argument_list|(
name|key
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CamelExchangeException
name|e
parameter_list|)
block|{
name|exchange
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// we are completed so do that work outside the lock
if|if
condition|(
name|aggregated
operator|!=
literal|null
condition|)
block|{
comment|// we are completed so submit to completion
name|aggregated
operator|.
name|forEach
argument_list|(
name|agg
lambda|->
name|onSubmitCompletion
argument_list|(
name|key
argument_list|,
name|agg
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// check for the special header to force completion of all groups (inclusive of the message)
if|if
condition|(
name|getAndRemoveBooleanHeader
argument_list|(
name|exchange
argument_list|,
name|Exchange
operator|.
name|AGGREGATION_COMPLETE_ALL_GROUPS_INCLUSIVE
argument_list|)
condition|)
block|{
name|forceCompletionOfAllGroups
argument_list|()
expr_stmt|;
block|}
name|callback
operator|.
name|done
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|getBooleanProperty (Exchange exchange, String key)
specifier|protected
name|boolean
name|getBooleanProperty
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|key
parameter_list|)
block|{
return|return
name|camelContext
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|boolean
operator|.
name|class
argument_list|,
name|exchange
argument_list|,
name|exchange
operator|.
name|getProperty
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getAndRemoveBooleanProperty (Exchange exchange, String key)
specifier|protected
name|boolean
name|getAndRemoveBooleanProperty
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|key
parameter_list|)
block|{
return|return
name|camelContext
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|boolean
operator|.
name|class
argument_list|,
name|exchange
argument_list|,
name|exchange
operator|.
name|removeProperty
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getAndRemoveBooleanHeader (Exchange exchange, String key)
specifier|protected
name|boolean
name|getAndRemoveBooleanHeader
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|key
parameter_list|)
block|{
return|return
name|camelContext
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|boolean
operator|.
name|class
argument_list|,
name|exchange
argument_list|,
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|removeHeader
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Aggregates the exchange with the given correlation key      *<p/>      * This method<b>must</b> be run synchronized as we cannot aggregate the same correlation key      * in parallel.      *<p/>      * The returned {@link Exchange} should be send downstream using the {@link #onSubmitCompletion(String, org.apache.camel.Exchange)}      * method which sends out the aggregated and completed {@link Exchange}.      *      * @param key      the correlation key      * @param newExchange the exchange      * @return the aggregated exchange(s) which is complete, or<tt>null</tt> if not yet complete      * @throws org.apache.camel.CamelExchangeException is thrown if error aggregating      */
DECL|method|doAggregation (String key, Exchange newExchange)
specifier|private
name|List
argument_list|<
name|Exchange
argument_list|>
name|doAggregation
parameter_list|(
name|String
name|key
parameter_list|,
name|Exchange
name|newExchange
parameter_list|)
throws|throws
name|CamelExchangeException
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"onAggregation +++ start +++ with correlation key: {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Exchange
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|String
name|complete
init|=
literal|null
decl_stmt|;
name|Exchange
name|answer
decl_stmt|;
name|Exchange
name|originalExchange
init|=
name|aggregationRepository
operator|.
name|get
argument_list|(
name|newExchange
operator|.
name|getContext
argument_list|()
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|Exchange
name|oldExchange
init|=
name|originalExchange
decl_stmt|;
name|Integer
name|size
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|oldExchange
operator|!=
literal|null
condition|)
block|{
comment|// hack to support legacy AggregationStrategy's that modify and return the oldExchange, these will not
comment|// working when using an identify based approach for optimistic locking like the MemoryAggregationRepository.
if|if
condition|(
name|optimisticLocking
operator|&&
name|aggregationRepository
operator|instanceof
name|MemoryAggregationRepository
condition|)
block|{
name|oldExchange
operator|=
name|originalExchange
operator|.
name|copy
argument_list|()
expr_stmt|;
block|}
name|size
operator|=
name|oldExchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_SIZE
argument_list|,
literal|0
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
expr_stmt|;
name|size
operator|++
expr_stmt|;
block|}
comment|// prepare the exchanges for aggregation
name|ExchangeHelper
operator|.
name|prepareAggregation
argument_list|(
name|oldExchange
argument_list|,
name|newExchange
argument_list|)
expr_stmt|;
comment|// check if we are pre complete
if|if
condition|(
name|preCompletion
condition|)
block|{
try|try
block|{
comment|// put the current aggregated size on the exchange so its avail during completion check
name|newExchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_SIZE
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|complete
operator|=
name|isPreCompleted
argument_list|(
name|key
argument_list|,
name|oldExchange
argument_list|,
name|newExchange
argument_list|)
expr_stmt|;
comment|// make sure to track timeouts if not complete
if|if
condition|(
name|complete
operator|==
literal|null
condition|)
block|{
name|trackTimeout
argument_list|(
name|key
argument_list|,
name|newExchange
argument_list|)
expr_stmt|;
block|}
comment|// remove it afterwards
name|newExchange
operator|.
name|removeProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_SIZE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
comment|// must catch any exception from aggregation
throw|throw
operator|new
name|CamelExchangeException
argument_list|(
literal|"Error occurred during preComplete"
argument_list|,
name|newExchange
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|isEagerCheckCompletion
argument_list|()
condition|)
block|{
comment|// put the current aggregated size on the exchange so its avail during completion check
name|newExchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_SIZE
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|complete
operator|=
name|isCompleted
argument_list|(
name|key
argument_list|,
name|newExchange
argument_list|)
expr_stmt|;
comment|// make sure to track timeouts if not complete
if|if
condition|(
name|complete
operator|==
literal|null
condition|)
block|{
name|trackTimeout
argument_list|(
name|key
argument_list|,
name|newExchange
argument_list|)
expr_stmt|;
block|}
comment|// remove it afterwards
name|newExchange
operator|.
name|removeProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_SIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|preCompletion
operator|&&
name|complete
operator|!=
literal|null
condition|)
block|{
comment|// need to pre complete the current group before we aggregate
name|doAggregationComplete
argument_list|(
name|complete
argument_list|,
name|list
argument_list|,
name|key
argument_list|,
name|originalExchange
argument_list|,
name|oldExchange
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// as we complete the current group eager, we should indicate the new group is not complete
name|complete
operator|=
literal|null
expr_stmt|;
comment|// and clear old/original exchange as we start on a new group
name|oldExchange
operator|=
literal|null
expr_stmt|;
name|originalExchange
operator|=
literal|null
expr_stmt|;
comment|// and reset the size to 1
name|size
operator|=
literal|1
expr_stmt|;
comment|// make sure to track timeout as we just restart the correlation group when we are in pre completion mode
name|trackTimeout
argument_list|(
name|key
argument_list|,
name|newExchange
argument_list|)
expr_stmt|;
block|}
comment|// aggregate the exchanges
name|boolean
name|aggregateFailed
init|=
literal|false
decl_stmt|;
try|try
block|{
name|answer
operator|=
name|onAggregation
argument_list|(
name|oldExchange
argument_list|,
name|newExchange
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|aggregateFailed
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|isDiscardOnAggregationFailure
argument_list|()
condition|)
block|{
comment|// discard due failure in aggregation strategy
name|log
operator|.
name|debug
argument_list|(
literal|"Aggregation for correlation key {} discarding aggregated exchange: {} due to failure in AggregationStrategy caused by: {}"
argument_list|,
name|key
argument_list|,
name|oldExchange
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|complete
operator|=
name|COMPLETED_BY_STRATEGY
expr_stmt|;
name|answer
operator|=
name|oldExchange
expr_stmt|;
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
comment|// first message in group failed during aggregation and we should just discard this
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
comment|// must catch any exception from aggregation
throw|throw
operator|new
name|CamelExchangeException
argument_list|(
literal|"Error occurred during aggregation"
argument_list|,
name|newExchange
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CamelExchangeException
argument_list|(
literal|"AggregationStrategy "
operator|+
name|aggregationStrategy
operator|+
literal|" returned null which is not allowed"
argument_list|,
name|newExchange
argument_list|)
throw|;
block|}
comment|// check for the special exchange property to force completion of all groups
if|if
condition|(
name|getAndRemoveBooleanProperty
argument_list|(
name|answer
argument_list|,
name|Exchange
operator|.
name|AGGREGATION_COMPLETE_ALL_GROUPS
argument_list|)
condition|)
block|{
name|forceCompletionOfAllGroups
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isCompletionOnNewCorrelationGroup
argument_list|()
operator|&&
name|originalExchange
operator|==
literal|null
condition|)
block|{
comment|// its a new group so force complete of all existing groups
name|forceCompletionOfAllGroups
argument_list|()
expr_stmt|;
block|}
comment|// special for some repository implementations
if|if
condition|(
name|aggregationRepository
operator|instanceof
name|RecoverableAggregationRepository
condition|)
block|{
name|boolean
name|valid
init|=
name|oldExchange
operator|==
literal|null
operator|||
name|answer
operator|.
name|getExchangeId
argument_list|()
operator|.
name|equals
argument_list|(
name|oldExchange
operator|.
name|getExchangeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|valid
operator|&&
name|aggregateRepositoryWarned
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"AggregationStrategy should return the oldExchange instance instead of the newExchange whenever possible"
operator|+
literal|" as otherwise this can lead to unexpected behavior with some RecoverableAggregationRepository implementations"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// update the aggregated size
name|answer
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_SIZE
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|// maybe we should check completion after the aggregation
if|if
condition|(
operator|!
name|preCompletion
operator|&&
operator|!
name|isEagerCheckCompletion
argument_list|()
condition|)
block|{
name|complete
operator|=
name|isCompleted
argument_list|(
name|key
argument_list|,
name|answer
argument_list|)
expr_stmt|;
comment|// make sure to track timeouts if not complete
if|if
condition|(
name|complete
operator|==
literal|null
condition|)
block|{
name|trackTimeout
argument_list|(
name|key
argument_list|,
name|newExchange
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|aggregateFailed
operator|&&
name|complete
operator|==
literal|null
condition|)
block|{
comment|// only need to update aggregation repository if we are not complete
name|doAggregationRepositoryAdd
argument_list|(
name|newExchange
operator|.
name|getContext
argument_list|()
argument_list|,
name|key
argument_list|,
name|originalExchange
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// if we are complete then add the answer to the list
name|doAggregationComplete
argument_list|(
name|complete
argument_list|,
name|list
argument_list|,
name|key
argument_list|,
name|originalExchange
argument_list|,
name|answer
argument_list|,
name|aggregateFailed
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|trace
argument_list|(
literal|"onAggregation +++  end  +++ with correlation key: {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
DECL|method|doAggregationComplete (String complete, List<Exchange> list, String key, Exchange originalExchange, Exchange answer, boolean aggregateFailed)
specifier|protected
name|void
name|doAggregationComplete
parameter_list|(
name|String
name|complete
parameter_list|,
name|List
argument_list|<
name|Exchange
argument_list|>
name|list
parameter_list|,
name|String
name|key
parameter_list|,
name|Exchange
name|originalExchange
parameter_list|,
name|Exchange
name|answer
parameter_list|,
name|boolean
name|aggregateFailed
parameter_list|)
block|{
if|if
condition|(
name|COMPLETED_BY_CONSUMER
operator|.
name|equals
argument_list|(
name|complete
argument_list|)
condition|)
block|{
for|for
control|(
name|String
name|batchKey
range|:
name|batchConsumerCorrelationKeys
control|)
block|{
name|Exchange
name|batchAnswer
decl_stmt|;
if|if
condition|(
name|batchKey
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
comment|// skip the current aggregated key as we have already aggregated it and have the answer
name|batchAnswer
operator|=
name|answer
expr_stmt|;
block|}
else|else
block|{
name|batchAnswer
operator|=
name|aggregationRepository
operator|.
name|get
argument_list|(
name|camelContext
argument_list|,
name|batchKey
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|batchAnswer
operator|!=
literal|null
condition|)
block|{
name|batchAnswer
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_COMPLETED_BY
argument_list|,
name|complete
argument_list|)
expr_stmt|;
name|onCompletion
argument_list|(
name|batchKey
argument_list|,
name|originalExchange
argument_list|,
name|batchAnswer
argument_list|,
literal|false
argument_list|,
name|aggregateFailed
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|batchAnswer
argument_list|)
expr_stmt|;
block|}
block|}
name|batchConsumerCorrelationKeys
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// we have already submitted to completion, so answer should be null
name|answer
operator|=
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
comment|// we are complete for this exchange
name|answer
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_COMPLETED_BY
argument_list|,
name|complete
argument_list|)
expr_stmt|;
name|answer
operator|=
name|onCompletion
argument_list|(
name|key
argument_list|,
name|originalExchange
argument_list|,
name|answer
argument_list|,
literal|false
argument_list|,
name|aggregateFailed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doAggregationRepositoryAdd (CamelContext camelContext, String key, Exchange oldExchange, Exchange newExchange)
specifier|protected
name|void
name|doAggregationRepositoryAdd
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|,
name|String
name|key
parameter_list|,
name|Exchange
name|oldExchange
parameter_list|,
name|Exchange
name|newExchange
parameter_list|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"In progress aggregated oldExchange: {}, newExchange: {} with correlation key: {}"
argument_list|,
name|oldExchange
argument_list|,
name|newExchange
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimisticLocking
condition|)
block|{
try|try
block|{
operator|(
operator|(
name|OptimisticLockingAggregationRepository
operator|)
name|aggregationRepository
operator|)
operator|.
name|add
argument_list|(
name|camelContext
argument_list|,
name|key
argument_list|,
name|oldExchange
argument_list|,
name|newExchange
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OptimisticLockingAggregationRepository
operator|.
name|OptimisticLockingException
name|e
parameter_list|)
block|{
name|onOptimisticLockingFailure
argument_list|(
name|oldExchange
argument_list|,
name|newExchange
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
else|else
block|{
name|aggregationRepository
operator|.
name|add
argument_list|(
name|camelContext
argument_list|,
name|key
argument_list|,
name|newExchange
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|onOptimisticLockingFailure (Exchange oldExchange, Exchange newExchange)
specifier|protected
name|void
name|onOptimisticLockingFailure
parameter_list|(
name|Exchange
name|oldExchange
parameter_list|,
name|Exchange
name|newExchange
parameter_list|)
block|{
name|aggregationStrategy
operator|.
name|onOptimisticLockFailure
argument_list|(
name|oldExchange
argument_list|,
name|newExchange
argument_list|)
expr_stmt|;
block|}
comment|/**      * Tests whether the given exchanges is pre-complete or not      *      * @param key      the correlation key      * @param oldExchange   the existing exchange      * @param newExchange the incoming exchange      * @return<tt>null</tt> if not pre-completed, otherwise a String with the type that triggered the pre-completion      */
DECL|method|isPreCompleted (String key, Exchange oldExchange, Exchange newExchange)
specifier|protected
name|String
name|isPreCompleted
parameter_list|(
name|String
name|key
parameter_list|,
name|Exchange
name|oldExchange
parameter_list|,
name|Exchange
name|newExchange
parameter_list|)
block|{
return|return
name|aggregationStrategy
operator|.
name|preComplete
argument_list|(
name|oldExchange
argument_list|,
name|newExchange
argument_list|)
condition|?
literal|"strategy"
else|:
literal|null
return|;
block|}
comment|/**      * Tests whether the given exchange is complete or not      *      * @param key      the correlation key      * @param exchange the incoming exchange      * @return<tt>null</tt> if not completed, otherwise a String with the type that triggered the completion      */
DECL|method|isCompleted (String key, Exchange exchange)
specifier|protected
name|String
name|isCompleted
parameter_list|(
name|String
name|key
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
comment|// batch consumer completion must always run first
if|if
condition|(
name|isCompletionFromBatchConsumer
argument_list|()
condition|)
block|{
name|batchConsumerCorrelationKeys
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|batchConsumerCounter
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|int
name|size
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|BATCH_SIZE
argument_list|,
literal|0
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|batchConsumerCounter
operator|.
name|intValue
argument_list|()
operator|>=
name|size
condition|)
block|{
comment|// batch consumer is complete then reset the counter
name|batchConsumerCounter
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|COMPLETED_BY_CONSUMER
return|;
block|}
block|}
if|if
condition|(
name|getBooleanProperty
argument_list|(
name|exchange
argument_list|,
name|Exchange
operator|.
name|AGGREGATION_COMPLETE_CURRENT_GROUP
argument_list|)
condition|)
block|{
return|return
name|COMPLETED_BY_STRATEGY
return|;
block|}
if|if
condition|(
name|getCompletionPredicate
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|boolean
name|answer
init|=
name|getCompletionPredicate
argument_list|()
operator|.
name|matches
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
condition|)
block|{
return|return
name|COMPLETED_BY_PREDICATE
return|;
block|}
block|}
name|boolean
name|sizeChecked
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|getCompletionSizeExpression
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Integer
name|value
init|=
name|getCompletionSizeExpression
argument_list|()
operator|.
name|evaluate
argument_list|(
name|exchange
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|value
operator|>
literal|0
condition|)
block|{
comment|// mark as already checked size as expression takes precedence over static configured
name|sizeChecked
operator|=
literal|true
expr_stmt|;
name|int
name|size
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_SIZE
argument_list|,
literal|1
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>=
name|value
condition|)
block|{
return|return
name|COMPLETED_BY_SIZE
return|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|sizeChecked
operator|&&
name|getCompletionSize
argument_list|()
operator|>
literal|0
condition|)
block|{
name|int
name|size
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_SIZE
argument_list|,
literal|1
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>=
name|getCompletionSize
argument_list|()
condition|)
block|{
return|return
name|COMPLETED_BY_SIZE
return|;
block|}
block|}
comment|// not complete
return|return
literal|null
return|;
block|}
DECL|method|trackTimeout (String key, Exchange exchange)
specifier|protected
name|void
name|trackTimeout
parameter_list|(
name|String
name|key
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
comment|// timeout can be either evaluated based on an expression or from a fixed value
comment|// expression takes precedence
name|boolean
name|timeoutSet
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|getCompletionTimeoutExpression
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Long
name|value
init|=
name|getCompletionTimeoutExpression
argument_list|()
operator|.
name|evaluate
argument_list|(
name|exchange
argument_list|,
name|Long
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|value
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|log
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Updating correlation key {} to timeout after {} ms. as exchange received: {}"
argument_list|,
name|key
argument_list|,
name|value
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
name|addExchangeToTimeoutMap
argument_list|(
name|key
argument_list|,
name|exchange
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|timeoutSet
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|timeoutSet
operator|&&
name|getCompletionTimeout
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// timeout is used so use the timeout map to keep an eye on this
if|if
condition|(
name|log
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Updating correlation key {} to timeout after {} ms. as exchange received: {}"
argument_list|,
name|key
argument_list|,
name|getCompletionTimeout
argument_list|()
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
name|addExchangeToTimeoutMap
argument_list|(
name|key
argument_list|,
name|exchange
argument_list|,
name|getCompletionTimeout
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|onAggregation (Exchange oldExchange, Exchange newExchange)
specifier|protected
name|Exchange
name|onAggregation
parameter_list|(
name|Exchange
name|oldExchange
parameter_list|,
name|Exchange
name|newExchange
parameter_list|)
block|{
return|return
name|aggregationStrategy
operator|.
name|aggregate
argument_list|(
name|oldExchange
argument_list|,
name|newExchange
argument_list|)
return|;
block|}
DECL|method|onCompletion (final String key, final Exchange original, final Exchange aggregated, boolean fromTimeout, boolean aggregateFailed)
specifier|protected
name|Exchange
name|onCompletion
parameter_list|(
specifier|final
name|String
name|key
parameter_list|,
specifier|final
name|Exchange
name|original
parameter_list|,
specifier|final
name|Exchange
name|aggregated
parameter_list|,
name|boolean
name|fromTimeout
parameter_list|,
name|boolean
name|aggregateFailed
parameter_list|)
block|{
comment|// store the correlation key as property before we remove so the repository has that information
if|if
condition|(
name|original
operator|!=
literal|null
condition|)
block|{
name|original
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_CORRELATION_KEY
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
name|aggregated
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_CORRELATION_KEY
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|// only remove if we have previous added (as we could potentially complete with only 1 exchange)
comment|// (if we have previous added then we have that as the original exchange)
if|if
condition|(
name|original
operator|!=
literal|null
condition|)
block|{
comment|// remove from repository as its completed, we do this first as to trigger any OptimisticLockingException's
name|aggregationRepository
operator|.
name|remove
argument_list|(
name|aggregated
operator|.
name|getContext
argument_list|()
argument_list|,
name|key
argument_list|,
name|original
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fromTimeout
operator|&&
name|timeoutMap
operator|!=
literal|null
condition|)
block|{
comment|// cleanup timeout map if it was a incoming exchange which triggered the timeout (and not the timeout checker)
name|log
operator|.
name|trace
argument_list|(
literal|"Removing correlation key {} from timeout"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|timeoutMap
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
comment|// this key has been closed so add it to the closed map
if|if
condition|(
name|closedCorrelationKeys
operator|!=
literal|null
condition|)
block|{
name|closedCorrelationKeys
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fromTimeout
condition|)
block|{
comment|// invoke timeout to allow any custom processing before discarding the exchange
name|long
name|timeout
init|=
name|getCompletionTimeout
argument_list|()
operator|>
literal|0
condition|?
name|getCompletionTimeout
argument_list|()
else|:
operator|-
literal|1
decl_stmt|;
name|aggregationStrategy
operator|.
name|timeout
argument_list|(
name|aggregated
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
name|Exchange
name|answer
decl_stmt|;
if|if
condition|(
name|fromTimeout
operator|&&
name|isDiscardOnCompletionTimeout
argument_list|()
condition|)
block|{
comment|// discard due timeout
name|log
operator|.
name|debug
argument_list|(
literal|"Aggregation for correlation key {} discarding aggregated exchange: {}"
argument_list|,
name|key
argument_list|,
name|aggregated
argument_list|)
expr_stmt|;
comment|// must confirm the discarded exchange
name|aggregationRepository
operator|.
name|confirm
argument_list|(
name|aggregated
operator|.
name|getContext
argument_list|()
argument_list|,
name|aggregated
operator|.
name|getExchangeId
argument_list|()
argument_list|)
expr_stmt|;
comment|// and remove redelivery state as well
name|redeliveryState
operator|.
name|remove
argument_list|(
name|aggregated
operator|.
name|getExchangeId
argument_list|()
argument_list|)
expr_stmt|;
comment|// the completion was from timeout and we should just discard it
name|answer
operator|=
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aggregateFailed
operator|&&
name|isDiscardOnAggregationFailure
argument_list|()
condition|)
block|{
comment|// discard due aggregation failed
name|log
operator|.
name|debug
argument_list|(
literal|"Aggregation for correlation key {} discarding aggregated exchange: {}"
argument_list|,
name|key
argument_list|,
name|aggregated
argument_list|)
expr_stmt|;
comment|// must confirm the discarded exchange
name|aggregationRepository
operator|.
name|confirm
argument_list|(
name|aggregated
operator|.
name|getContext
argument_list|()
argument_list|,
name|aggregated
operator|.
name|getExchangeId
argument_list|()
argument_list|)
expr_stmt|;
comment|// and remove redelivery state as well
name|redeliveryState
operator|.
name|remove
argument_list|(
name|aggregated
operator|.
name|getExchangeId
argument_list|()
argument_list|)
expr_stmt|;
comment|// the completion was failed during aggregation and we should just discard it
name|answer
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
comment|// the aggregated exchange should be published (sent out)
name|answer
operator|=
name|aggregated
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
DECL|method|onSubmitCompletion (final String key, final Exchange exchange)
specifier|private
name|void
name|onSubmitCompletion
parameter_list|(
specifier|final
name|String
name|key
parameter_list|,
specifier|final
name|Exchange
name|exchange
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Aggregation complete for correlation key {} sending aggregated exchange: {}"
argument_list|,
name|key
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
comment|// add this as in progress before we submit the task
name|inProgressCompleteExchanges
operator|.
name|add
argument_list|(
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|)
expr_stmt|;
comment|// invoke the on completion callback
name|aggregationStrategy
operator|.
name|onCompletion
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
if|if
condition|(
name|getStatistics
argument_list|()
operator|.
name|isStatisticsEnabled
argument_list|()
condition|)
block|{
name|totalCompleted
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|String
name|completedBy
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_COMPLETED_BY
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|completedBy
condition|)
block|{
case|case
name|COMPLETED_BY_INTERVAL
case|:
name|completedByInterval
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
break|break;
case|case
name|COMPLETED_BY_TIMEOUT
case|:
name|completedByTimeout
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
break|break;
case|case
name|COMPLETED_BY_FORCE
case|:
name|completedByForce
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
break|break;
case|case
name|COMPLETED_BY_CONSUMER
case|:
name|completedByBatchConsumer
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
break|break;
case|case
name|COMPLETED_BY_PREDICATE
case|:
name|completedByPredicate
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
break|break;
case|case
name|COMPLETED_BY_SIZE
case|:
name|completedBySize
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
break|break;
case|case
name|COMPLETED_BY_STRATEGY
case|:
name|completedByStrategy
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
break|break;
default|default:
name|log
operator|.
name|error
argument_list|(
literal|"Invalid value of {} property: {}"
argument_list|,
name|Exchange
operator|.
name|AGGREGATED_COMPLETED_BY
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"Processing aggregated exchange: {}"
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
comment|// add on completion task so we remember to update the inProgressCompleteExchanges
name|exchange
operator|.
name|addOnCompletion
argument_list|(
operator|new
name|AggregateOnCompletion
argument_list|(
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// send this exchange
comment|// the call to schedule last if needed to ensure in-order processing of the aggregates
name|executorService
operator|.
name|submit
argument_list|(
parameter_list|()
lambda|->
name|camelContext
operator|.
name|getReactiveExecutor
argument_list|()
operator|.
name|scheduleSync
argument_list|(
parameter_list|()
lambda|->
name|processor
operator|.
name|process
argument_list|(
name|exchange
argument_list|,
name|done
lambda|->
block|{
comment|// log exception if there was a problem
block|if (exchange.getException(
argument_list|)
operator|!=
literal|null
block|)
block|{
comment|// if there was an exception then let the exception handler handle it
name|getExceptionHandler
argument_list|()
operator|.
name|handleException
argument_list|(
literal|"Error processing aggregated exchange"
argument_list|,
name|exchange
argument_list|,
name|exchange
operator|.
name|getException
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Processing aggregated exchange: {} complete."
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
end_class

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
literal|"sending aggregated exchange"
end_expr_stmt

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|/**      * Restores the timeout map with timeout values from the aggregation repository.      *<p/>      * This is needed in case the aggregator has been stopped and started again (for example a server restart).      * Then the existing exchanges from the {@link AggregationRepository} must have their timeout conditions restored.      */
end_comment

begin_function
DECL|method|restoreTimeoutMapFromAggregationRepository ()
unit|protected
name|void
name|restoreTimeoutMapFromAggregationRepository
parameter_list|()
throws|throws
name|Exception
block|{
comment|// grab the timeout value for each partly aggregated exchange
name|Set
argument_list|<
name|String
argument_list|>
name|keys
init|=
name|aggregationRepository
operator|.
name|getKeys
argument_list|()
decl_stmt|;
if|if
condition|(
name|keys
operator|==
literal|null
operator|||
name|keys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|StopWatch
name|watch
init|=
operator|new
name|StopWatch
argument_list|()
decl_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"Starting restoring CompletionTimeout for {} existing exchanges from the aggregation repository..."
argument_list|,
name|keys
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|key
range|:
name|keys
control|)
block|{
name|Exchange
name|exchange
init|=
name|aggregationRepository
operator|.
name|get
argument_list|(
name|camelContext
argument_list|,
name|key
argument_list|)
decl_stmt|;
comment|// grab the timeout value
name|long
name|timeout
init|=
name|exchange
operator|.
name|hasProperties
argument_list|()
condition|?
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_TIMEOUT
argument_list|,
literal|0
argument_list|,
name|long
operator|.
name|class
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Restoring CompletionTimeout for exchangeId: {} with timeout: {} millis."
argument_list|,
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|addExchangeToTimeoutMap
argument_list|(
name|key
argument_list|,
name|exchange
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
comment|// log duration of this task so end user can see how long it takes to pre-check this upon starting
name|log
operator|.
name|info
argument_list|(
literal|"Restored {} CompletionTimeout conditions in the AggregationTimeoutChecker in {}"
argument_list|,
name|timeoutMap
operator|.
name|size
argument_list|()
argument_list|,
name|TimeUtils
operator|.
name|printDuration
argument_list|(
name|watch
operator|.
name|taken
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Adds the given exchange to the timeout map, which is used by the timeout checker task to trigger timeouts.      *      * @param key      the correlation key      * @param exchange the exchange      * @param timeout  the timeout value in millis      */
end_comment

begin_function
DECL|method|addExchangeToTimeoutMap (String key, Exchange exchange, long timeout)
specifier|private
name|void
name|addExchangeToTimeoutMap
parameter_list|(
name|String
name|key
parameter_list|,
name|Exchange
name|exchange
parameter_list|,
name|long
name|timeout
parameter_list|)
block|{
comment|// store the timeout value on the exchange as well, in case we need it later
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_TIMEOUT
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|timeoutMap
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Current number of closed correlation keys in the memory cache      */
end_comment

begin_function
DECL|method|getClosedCorrelationKeysCacheSize ()
specifier|public
name|int
name|getClosedCorrelationKeysCacheSize
parameter_list|()
block|{
if|if
condition|(
name|closedCorrelationKeys
operator|!=
literal|null
condition|)
block|{
return|return
name|closedCorrelationKeys
operator|.
name|size
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/**      * Clear all the closed correlation keys stored in the cache      */
end_comment

begin_function
DECL|method|clearClosedCorrelationKeysCache ()
specifier|public
name|void
name|clearClosedCorrelationKeysCache
parameter_list|()
block|{
if|if
condition|(
name|closedCorrelationKeys
operator|!=
literal|null
condition|)
block|{
name|closedCorrelationKeys
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|getStatistics ()
specifier|public
name|AggregateProcessorStatistics
name|getStatistics
parameter_list|()
block|{
return|return
name|statistics
return|;
block|}
end_function

begin_function
DECL|method|getInProgressCompleteExchanges ()
specifier|public
name|int
name|getInProgressCompleteExchanges
parameter_list|()
block|{
return|return
name|inProgressCompleteExchanges
operator|.
name|size
argument_list|()
return|;
block|}
end_function

begin_function
DECL|method|getCompletionPredicate ()
specifier|public
name|Predicate
name|getCompletionPredicate
parameter_list|()
block|{
return|return
name|completionPredicate
return|;
block|}
end_function

begin_function
DECL|method|setCompletionPredicate (Predicate completionPredicate)
specifier|public
name|void
name|setCompletionPredicate
parameter_list|(
name|Predicate
name|completionPredicate
parameter_list|)
block|{
name|this
operator|.
name|completionPredicate
operator|=
name|completionPredicate
expr_stmt|;
block|}
end_function

begin_function
DECL|method|isEagerCheckCompletion ()
specifier|public
name|boolean
name|isEagerCheckCompletion
parameter_list|()
block|{
return|return
name|eagerCheckCompletion
return|;
block|}
end_function

begin_function
DECL|method|setEagerCheckCompletion (boolean eagerCheckCompletion)
specifier|public
name|void
name|setEagerCheckCompletion
parameter_list|(
name|boolean
name|eagerCheckCompletion
parameter_list|)
block|{
name|this
operator|.
name|eagerCheckCompletion
operator|=
name|eagerCheckCompletion
expr_stmt|;
block|}
end_function

begin_function
DECL|method|getCompletionTimeout ()
specifier|public
name|long
name|getCompletionTimeout
parameter_list|()
block|{
return|return
name|completionTimeout
return|;
block|}
end_function

begin_function
DECL|method|setCompletionTimeout (long completionTimeout)
specifier|public
name|void
name|setCompletionTimeout
parameter_list|(
name|long
name|completionTimeout
parameter_list|)
block|{
name|this
operator|.
name|completionTimeout
operator|=
name|completionTimeout
expr_stmt|;
block|}
end_function

begin_function
DECL|method|getCompletionTimeoutExpression ()
specifier|public
name|Expression
name|getCompletionTimeoutExpression
parameter_list|()
block|{
return|return
name|completionTimeoutExpression
return|;
block|}
end_function

begin_function
DECL|method|setCompletionTimeoutExpression (Expression completionTimeoutExpression)
specifier|public
name|void
name|setCompletionTimeoutExpression
parameter_list|(
name|Expression
name|completionTimeoutExpression
parameter_list|)
block|{
name|this
operator|.
name|completionTimeoutExpression
operator|=
name|completionTimeoutExpression
expr_stmt|;
block|}
end_function

begin_function
DECL|method|getCompletionInterval ()
specifier|public
name|long
name|getCompletionInterval
parameter_list|()
block|{
return|return
name|completionInterval
return|;
block|}
end_function

begin_function
DECL|method|setCompletionInterval (long completionInterval)
specifier|public
name|void
name|setCompletionInterval
parameter_list|(
name|long
name|completionInterval
parameter_list|)
block|{
name|this
operator|.
name|completionInterval
operator|=
name|completionInterval
expr_stmt|;
block|}
end_function

begin_function
DECL|method|getCompletionSize ()
specifier|public
name|int
name|getCompletionSize
parameter_list|()
block|{
return|return
name|completionSize
return|;
block|}
end_function

begin_function
DECL|method|setCompletionSize (int completionSize)
specifier|public
name|void
name|setCompletionSize
parameter_list|(
name|int
name|completionSize
parameter_list|)
block|{
name|this
operator|.
name|completionSize
operator|=
name|completionSize
expr_stmt|;
block|}
end_function

begin_function
DECL|method|getCompletionSizeExpression ()
specifier|public
name|Expression
name|getCompletionSizeExpression
parameter_list|()
block|{
return|return
name|completionSizeExpression
return|;
block|}
end_function

begin_function
DECL|method|setCompletionSizeExpression (Expression completionSizeExpression)
specifier|public
name|void
name|setCompletionSizeExpression
parameter_list|(
name|Expression
name|completionSizeExpression
parameter_list|)
block|{
name|this
operator|.
name|completionSizeExpression
operator|=
name|completionSizeExpression
expr_stmt|;
block|}
end_function

begin_function
DECL|method|isIgnoreInvalidCorrelationKeys ()
specifier|public
name|boolean
name|isIgnoreInvalidCorrelationKeys
parameter_list|()
block|{
return|return
name|ignoreInvalidCorrelationKeys
return|;
block|}
end_function

begin_function
DECL|method|setIgnoreInvalidCorrelationKeys (boolean ignoreInvalidCorrelationKeys)
specifier|public
name|void
name|setIgnoreInvalidCorrelationKeys
parameter_list|(
name|boolean
name|ignoreInvalidCorrelationKeys
parameter_list|)
block|{
name|this
operator|.
name|ignoreInvalidCorrelationKeys
operator|=
name|ignoreInvalidCorrelationKeys
expr_stmt|;
block|}
end_function

begin_function
DECL|method|getCloseCorrelationKeyOnCompletion ()
specifier|public
name|Integer
name|getCloseCorrelationKeyOnCompletion
parameter_list|()
block|{
return|return
name|closeCorrelationKeyOnCompletion
return|;
block|}
end_function

begin_function
DECL|method|setCloseCorrelationKeyOnCompletion (Integer closeCorrelationKeyOnCompletion)
specifier|public
name|void
name|setCloseCorrelationKeyOnCompletion
parameter_list|(
name|Integer
name|closeCorrelationKeyOnCompletion
parameter_list|)
block|{
name|this
operator|.
name|closeCorrelationKeyOnCompletion
operator|=
name|closeCorrelationKeyOnCompletion
expr_stmt|;
block|}
end_function

begin_function
DECL|method|isCompletionFromBatchConsumer ()
specifier|public
name|boolean
name|isCompletionFromBatchConsumer
parameter_list|()
block|{
return|return
name|completionFromBatchConsumer
return|;
block|}
end_function

begin_function
DECL|method|setCompletionFromBatchConsumer (boolean completionFromBatchConsumer)
specifier|public
name|void
name|setCompletionFromBatchConsumer
parameter_list|(
name|boolean
name|completionFromBatchConsumer
parameter_list|)
block|{
name|this
operator|.
name|completionFromBatchConsumer
operator|=
name|completionFromBatchConsumer
expr_stmt|;
block|}
end_function

begin_function
DECL|method|isCompletionOnNewCorrelationGroup ()
specifier|public
name|boolean
name|isCompletionOnNewCorrelationGroup
parameter_list|()
block|{
return|return
name|completionOnNewCorrelationGroup
return|;
block|}
end_function

begin_function
DECL|method|setCompletionOnNewCorrelationGroup (boolean completionOnNewCorrelationGroup)
specifier|public
name|void
name|setCompletionOnNewCorrelationGroup
parameter_list|(
name|boolean
name|completionOnNewCorrelationGroup
parameter_list|)
block|{
name|this
operator|.
name|completionOnNewCorrelationGroup
operator|=
name|completionOnNewCorrelationGroup
expr_stmt|;
block|}
end_function

begin_function
DECL|method|isCompleteAllOnStop ()
specifier|public
name|boolean
name|isCompleteAllOnStop
parameter_list|()
block|{
return|return
name|completeAllOnStop
return|;
block|}
end_function

begin_function
DECL|method|getCompletionTimeoutCheckerInterval ()
specifier|public
name|long
name|getCompletionTimeoutCheckerInterval
parameter_list|()
block|{
return|return
name|completionTimeoutCheckerInterval
return|;
block|}
end_function

begin_function
DECL|method|setCompletionTimeoutCheckerInterval (long completionTimeoutCheckerInterval)
specifier|public
name|void
name|setCompletionTimeoutCheckerInterval
parameter_list|(
name|long
name|completionTimeoutCheckerInterval
parameter_list|)
block|{
name|this
operator|.
name|completionTimeoutCheckerInterval
operator|=
name|completionTimeoutCheckerInterval
expr_stmt|;
block|}
end_function

begin_function
DECL|method|getExceptionHandler ()
specifier|public
name|ExceptionHandler
name|getExceptionHandler
parameter_list|()
block|{
return|return
name|exceptionHandler
return|;
block|}
end_function

begin_function
DECL|method|setExceptionHandler (ExceptionHandler exceptionHandler)
specifier|public
name|void
name|setExceptionHandler
parameter_list|(
name|ExceptionHandler
name|exceptionHandler
parameter_list|)
block|{
name|this
operator|.
name|exceptionHandler
operator|=
name|exceptionHandler
expr_stmt|;
block|}
end_function

begin_function
DECL|method|isParallelProcessing ()
specifier|public
name|boolean
name|isParallelProcessing
parameter_list|()
block|{
return|return
name|parallelProcessing
return|;
block|}
end_function

begin_function
DECL|method|setParallelProcessing (boolean parallelProcessing)
specifier|public
name|void
name|setParallelProcessing
parameter_list|(
name|boolean
name|parallelProcessing
parameter_list|)
block|{
name|this
operator|.
name|parallelProcessing
operator|=
name|parallelProcessing
expr_stmt|;
block|}
end_function

begin_function
DECL|method|isOptimisticLocking ()
specifier|public
name|boolean
name|isOptimisticLocking
parameter_list|()
block|{
return|return
name|optimisticLocking
return|;
block|}
end_function

begin_function
DECL|method|setOptimisticLocking (boolean optimisticLocking)
specifier|public
name|void
name|setOptimisticLocking
parameter_list|(
name|boolean
name|optimisticLocking
parameter_list|)
block|{
name|this
operator|.
name|optimisticLocking
operator|=
name|optimisticLocking
expr_stmt|;
block|}
end_function

begin_function
DECL|method|getAggregationRepository ()
specifier|public
name|AggregationRepository
name|getAggregationRepository
parameter_list|()
block|{
return|return
name|aggregationRepository
return|;
block|}
end_function

begin_function
DECL|method|setAggregationRepository (AggregationRepository aggregationRepository)
specifier|public
name|void
name|setAggregationRepository
parameter_list|(
name|AggregationRepository
name|aggregationRepository
parameter_list|)
block|{
name|this
operator|.
name|aggregationRepository
operator|=
name|aggregationRepository
expr_stmt|;
block|}
end_function

begin_function
DECL|method|isDiscardOnCompletionTimeout ()
specifier|public
name|boolean
name|isDiscardOnCompletionTimeout
parameter_list|()
block|{
return|return
name|discardOnCompletionTimeout
return|;
block|}
end_function

begin_function
DECL|method|setDiscardOnCompletionTimeout (boolean discardOnCompletionTimeout)
specifier|public
name|void
name|setDiscardOnCompletionTimeout
parameter_list|(
name|boolean
name|discardOnCompletionTimeout
parameter_list|)
block|{
name|this
operator|.
name|discardOnCompletionTimeout
operator|=
name|discardOnCompletionTimeout
expr_stmt|;
block|}
end_function

begin_function
DECL|method|isDiscardOnAggregationFailure ()
specifier|public
name|boolean
name|isDiscardOnAggregationFailure
parameter_list|()
block|{
return|return
name|discardOnAggregationFailure
return|;
block|}
end_function

begin_function
DECL|method|setDiscardOnAggregationFailure (boolean discardOnAggregationFailure)
specifier|public
name|void
name|setDiscardOnAggregationFailure
parameter_list|(
name|boolean
name|discardOnAggregationFailure
parameter_list|)
block|{
name|this
operator|.
name|discardOnAggregationFailure
operator|=
name|discardOnAggregationFailure
expr_stmt|;
block|}
end_function

begin_function
DECL|method|setForceCompletionOnStop (boolean forceCompletionOnStop)
specifier|public
name|void
name|setForceCompletionOnStop
parameter_list|(
name|boolean
name|forceCompletionOnStop
parameter_list|)
block|{
name|this
operator|.
name|forceCompletionOnStop
operator|=
name|forceCompletionOnStop
expr_stmt|;
block|}
end_function

begin_function
DECL|method|setCompleteAllOnStop (boolean completeAllOnStop)
specifier|public
name|void
name|setCompleteAllOnStop
parameter_list|(
name|boolean
name|completeAllOnStop
parameter_list|)
block|{
name|this
operator|.
name|completeAllOnStop
operator|=
name|completeAllOnStop
expr_stmt|;
block|}
end_function

begin_function
DECL|method|setTimeoutCheckerExecutorService (ScheduledExecutorService timeoutCheckerExecutorService)
specifier|public
name|void
name|setTimeoutCheckerExecutorService
parameter_list|(
name|ScheduledExecutorService
name|timeoutCheckerExecutorService
parameter_list|)
block|{
name|this
operator|.
name|timeoutCheckerExecutorService
operator|=
name|timeoutCheckerExecutorService
expr_stmt|;
block|}
end_function

begin_function
DECL|method|getTimeoutCheckerExecutorService ()
specifier|public
name|ScheduledExecutorService
name|getTimeoutCheckerExecutorService
parameter_list|()
block|{
return|return
name|timeoutCheckerExecutorService
return|;
block|}
end_function

begin_function
DECL|method|isShutdownTimeoutCheckerExecutorService ()
specifier|public
name|boolean
name|isShutdownTimeoutCheckerExecutorService
parameter_list|()
block|{
return|return
name|shutdownTimeoutCheckerExecutorService
return|;
block|}
end_function

begin_function
DECL|method|setShutdownTimeoutCheckerExecutorService (boolean shutdownTimeoutCheckerExecutorService)
specifier|public
name|void
name|setShutdownTimeoutCheckerExecutorService
parameter_list|(
name|boolean
name|shutdownTimeoutCheckerExecutorService
parameter_list|)
block|{
name|this
operator|.
name|shutdownTimeoutCheckerExecutorService
operator|=
name|shutdownTimeoutCheckerExecutorService
expr_stmt|;
block|}
end_function

begin_function
DECL|method|setOptimisticLockingExecutorService (ScheduledExecutorService optimisticLockingExecutorService)
specifier|public
name|void
name|setOptimisticLockingExecutorService
parameter_list|(
name|ScheduledExecutorService
name|optimisticLockingExecutorService
parameter_list|)
block|{
name|this
operator|.
name|optimisticLockingExecutorService
operator|=
name|optimisticLockingExecutorService
expr_stmt|;
block|}
end_function

begin_function
DECL|method|getOptimisticLockingExecutorService ()
specifier|public
name|ScheduledExecutorService
name|getOptimisticLockingExecutorService
parameter_list|()
block|{
return|return
name|optimisticLockingExecutorService
return|;
block|}
end_function

begin_function
DECL|method|isShutdownOptimisticLockingExecutorService ()
specifier|public
name|boolean
name|isShutdownOptimisticLockingExecutorService
parameter_list|()
block|{
return|return
name|shutdownOptimisticLockingExecutorService
return|;
block|}
end_function

begin_function
DECL|method|setShutdownOptimisticLockingExecutorService (boolean shutdownOptimisticLockingExecutorService)
specifier|public
name|void
name|setShutdownOptimisticLockingExecutorService
parameter_list|(
name|boolean
name|shutdownOptimisticLockingExecutorService
parameter_list|)
block|{
name|this
operator|.
name|shutdownOptimisticLockingExecutorService
operator|=
name|shutdownOptimisticLockingExecutorService
expr_stmt|;
block|}
end_function

begin_function
DECL|method|setOptimisticLockRetryPolicy (OptimisticLockRetryPolicy optimisticLockRetryPolicy)
specifier|public
name|void
name|setOptimisticLockRetryPolicy
parameter_list|(
name|OptimisticLockRetryPolicy
name|optimisticLockRetryPolicy
parameter_list|)
block|{
name|this
operator|.
name|optimisticLockRetryPolicy
operator|=
name|optimisticLockRetryPolicy
expr_stmt|;
block|}
end_function

begin_function
DECL|method|getOptimisticLockRetryPolicy ()
specifier|public
name|OptimisticLockRetryPolicy
name|getOptimisticLockRetryPolicy
parameter_list|()
block|{
return|return
name|optimisticLockRetryPolicy
return|;
block|}
end_function

begin_function
DECL|method|getAggregationStrategy ()
specifier|public
name|AggregationStrategy
name|getAggregationStrategy
parameter_list|()
block|{
return|return
name|aggregationStrategy
return|;
block|}
end_function

begin_function
DECL|method|setAggregationStrategy (AggregationStrategy aggregationStrategy)
specifier|public
name|void
name|setAggregationStrategy
parameter_list|(
name|AggregationStrategy
name|aggregationStrategy
parameter_list|)
block|{
name|this
operator|.
name|aggregationStrategy
operator|=
name|aggregationStrategy
expr_stmt|;
block|}
end_function

begin_function
DECL|method|getCorrelationExpression ()
specifier|public
name|Expression
name|getCorrelationExpression
parameter_list|()
block|{
return|return
name|correlationExpression
return|;
block|}
end_function

begin_function
DECL|method|setCorrelationExpression (Expression correlationExpression)
specifier|public
name|void
name|setCorrelationExpression
parameter_list|(
name|Expression
name|correlationExpression
parameter_list|)
block|{
name|this
operator|.
name|correlationExpression
operator|=
name|correlationExpression
expr_stmt|;
block|}
end_function

begin_function
DECL|method|getAggregateController ()
specifier|public
name|AggregateController
name|getAggregateController
parameter_list|()
block|{
return|return
name|aggregateController
return|;
block|}
end_function

begin_function
DECL|method|setAggregateController (AggregateController aggregateController)
specifier|public
name|void
name|setAggregateController
parameter_list|(
name|AggregateController
name|aggregateController
parameter_list|)
block|{
name|this
operator|.
name|aggregateController
operator|=
name|aggregateController
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * On completion task which keeps the booking of the in progress up to date      */
end_comment

begin_class
DECL|class|AggregateOnCompletion
specifier|private
specifier|final
class|class
name|AggregateOnCompletion
implements|implements
name|Synchronization
block|{
DECL|field|exchangeId
specifier|private
specifier|final
name|String
name|exchangeId
decl_stmt|;
DECL|method|AggregateOnCompletion (String exchangeId)
specifier|private
name|AggregateOnCompletion
parameter_list|(
name|String
name|exchangeId
parameter_list|)
block|{
comment|// must use the original exchange id as it could potentially change if send over SEDA etc.
name|this
operator|.
name|exchangeId
operator|=
name|exchangeId
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onFailure (Exchange exchange)
specifier|public
name|void
name|onFailure
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Aggregated exchange onFailure: {}"
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
comment|// must remember to remove in progress when we failed
name|inProgressCompleteExchanges
operator|.
name|remove
argument_list|(
name|exchangeId
argument_list|)
expr_stmt|;
comment|// do not remove redelivery state as we need it when we redeliver again later
block|}
annotation|@
name|Override
DECL|method|onComplete (Exchange exchange)
specifier|public
name|void
name|onComplete
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Aggregated exchange onComplete: {}"
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
comment|// only confirm if we processed without a problem
try|try
block|{
name|aggregationRepository
operator|.
name|confirm
argument_list|(
name|exchange
operator|.
name|getContext
argument_list|()
argument_list|,
name|exchangeId
argument_list|)
expr_stmt|;
comment|// and remove redelivery state as well
name|redeliveryState
operator|.
name|remove
argument_list|(
name|exchangeId
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// must remember to remove in progress when we are complete
name|inProgressCompleteExchanges
operator|.
name|remove
argument_list|(
name|exchangeId
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"AggregateOnCompletion"
return|;
block|}
block|}
end_class

begin_comment
comment|/**      * Background task that looks for aggregated exchanges which is triggered by completion timeouts.      */
end_comment

begin_class
DECL|class|AggregationTimeoutMap
specifier|private
specifier|final
class|class
name|AggregationTimeoutMap
extends|extends
name|DefaultTimeoutMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
block|{
DECL|method|AggregationTimeoutMap (ScheduledExecutorService executor, long requestMapPollTimeMillis)
specifier|private
name|AggregationTimeoutMap
parameter_list|(
name|ScheduledExecutorService
name|executor
parameter_list|,
name|long
name|requestMapPollTimeMillis
parameter_list|)
block|{
comment|// do NOT use locking on the timeout map as this aggregator has its own shared lock we will use instead
name|super
argument_list|(
name|executor
argument_list|,
name|requestMapPollTimeMillis
argument_list|,
name|optimisticLocking
argument_list|)
expr_stmt|;
name|addListener
argument_list|(
name|this
operator|::
name|onEviction
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|purge ()
specifier|protected
name|void
name|purge
parameter_list|()
block|{
comment|// wait for lock to be created
if|if
condition|(
name|lock
operator|!=
literal|null
condition|)
block|{
comment|// must acquire the shared aggregation lock to be able to purge
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|super
operator|.
name|purge
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|onEviction (Listener.Type type, String key, String exchangeId)
specifier|private
name|void
name|onEviction
parameter_list|(
name|Listener
operator|.
name|Type
name|type
parameter_list|,
name|String
name|key
parameter_list|,
name|String
name|exchangeId
parameter_list|)
block|{
if|if
condition|(
name|type
operator|!=
name|Listener
operator|.
name|Type
operator|.
name|Evict
condition|)
block|{
return|return;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"Completion timeout triggered for correlation key: {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|boolean
name|inProgress
init|=
name|inProgressCompleteExchanges
operator|.
name|contains
argument_list|(
name|exchangeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|inProgress
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Aggregated exchange with id: {} is already in progress."
argument_list|,
name|exchangeId
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// get the aggregated exchange
name|boolean
name|evictionStolen
init|=
literal|false
decl_stmt|;
name|Exchange
name|answer
init|=
name|aggregationRepository
operator|.
name|get
argument_list|(
name|camelContext
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
name|evictionStolen
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// indicate it was completed by timeout
name|answer
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_COMPLETED_BY
argument_list|,
name|COMPLETED_BY_TIMEOUT
argument_list|)
expr_stmt|;
try|try
block|{
name|answer
operator|=
name|onCompletion
argument_list|(
name|key
argument_list|,
name|answer
argument_list|,
name|answer
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|onSubmitCompletion
argument_list|(
name|key
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|OptimisticLockingAggregationRepository
operator|.
name|OptimisticLockingException
name|e
parameter_list|)
block|{
name|evictionStolen
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optimisticLocking
operator|&&
name|evictionStolen
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Another Camel instance has already successfully correlated or processed this timeout eviction "
operator|+
literal|"for exchange with id: {} and correlation id: {}"
argument_list|,
name|exchangeId
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|/**      * Background task that triggers completion based on interval.      */
end_comment

begin_class
DECL|class|AggregationIntervalTask
specifier|private
specifier|final
class|class
name|AggregationIntervalTask
implements|implements
name|Runnable
block|{
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// only run if CamelContext has been fully started
if|if
condition|(
operator|!
name|camelContext
operator|.
name|getStatus
argument_list|()
operator|.
name|isStarted
argument_list|()
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Completion interval task cannot start due CamelContext({}) has not been started yet"
argument_list|,
name|camelContext
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|log
operator|.
name|trace
argument_list|(
literal|"Starting completion interval task"
argument_list|)
expr_stmt|;
comment|// trigger completion for all in the repository
name|Set
argument_list|<
name|String
argument_list|>
name|keys
init|=
name|aggregationRepository
operator|.
name|getKeys
argument_list|()
decl_stmt|;
if|if
condition|(
name|keys
operator|!=
literal|null
operator|&&
operator|!
name|keys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// must acquire the shared aggregation lock to be able to trigger interval completion
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|String
name|key
range|:
name|keys
control|)
block|{
name|boolean
name|stolenInterval
init|=
literal|false
decl_stmt|;
name|Exchange
name|exchange
init|=
name|aggregationRepository
operator|.
name|get
argument_list|(
name|camelContext
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|exchange
operator|==
literal|null
condition|)
block|{
name|stolenInterval
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Completion interval triggered for correlation key: {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|// indicate it was completed by interval
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_COMPLETED_BY
argument_list|,
name|COMPLETED_BY_INTERVAL
argument_list|)
expr_stmt|;
try|try
block|{
name|Exchange
name|answer
init|=
name|onCompletion
argument_list|(
name|key
argument_list|,
name|exchange
argument_list|,
name|exchange
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|onSubmitCompletion
argument_list|(
name|key
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|OptimisticLockingAggregationRepository
operator|.
name|OptimisticLockingException
name|e
parameter_list|)
block|{
name|stolenInterval
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optimisticLocking
operator|&&
name|stolenInterval
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Another Camel instance has already processed this interval aggregation for exchange with correlation id: {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
name|log
operator|.
name|trace
argument_list|(
literal|"Completion interval task complete"
argument_list|)
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|/**      * Background task that looks for aggregated exchanges to recover.      */
end_comment

begin_class
DECL|class|RecoverTask
specifier|private
specifier|final
class|class
name|RecoverTask
implements|implements
name|Runnable
block|{
DECL|field|recoverable
specifier|private
specifier|final
name|RecoverableAggregationRepository
name|recoverable
decl_stmt|;
DECL|method|RecoverTask (RecoverableAggregationRepository recoverable)
specifier|private
name|RecoverTask
parameter_list|(
name|RecoverableAggregationRepository
name|recoverable
parameter_list|)
block|{
name|this
operator|.
name|recoverable
operator|=
name|recoverable
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// only run if CamelContext has been fully started
if|if
condition|(
operator|!
name|camelContext
operator|.
name|getStatus
argument_list|()
operator|.
name|isStarted
argument_list|()
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Recover check cannot start due CamelContext({}) has not been started yet"
argument_list|,
name|camelContext
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|log
operator|.
name|trace
argument_list|(
literal|"Starting recover check"
argument_list|)
expr_stmt|;
comment|// copy the current in progress before doing scan
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|copyOfInProgress
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|(
name|inProgressCompleteExchanges
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|exchangeIds
init|=
name|recoverable
operator|.
name|scan
argument_list|(
name|camelContext
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|exchangeId
range|:
name|exchangeIds
control|)
block|{
comment|// we may shutdown while doing recovery
if|if
condition|(
operator|!
name|isRunAllowed
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"We are shutting down so stop recovering"
argument_list|)
expr_stmt|;
return|return;
block|}
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// consider in progress if it was in progress before we did the scan, or currently after we did the scan
comment|// its safer to consider it in progress than risk duplicates due both in progress + recovered
name|boolean
name|inProgress
init|=
name|copyOfInProgress
operator|.
name|contains
argument_list|(
name|exchangeId
argument_list|)
operator|||
name|inProgressCompleteExchanges
operator|.
name|contains
argument_list|(
name|exchangeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|inProgress
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Aggregated exchange with id: {} is already in progress."
argument_list|,
name|exchangeId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Loading aggregated exchange with id: {} to be recovered."
argument_list|,
name|exchangeId
argument_list|)
expr_stmt|;
name|Exchange
name|exchange
init|=
name|recoverable
operator|.
name|recover
argument_list|(
name|camelContext
argument_list|,
name|exchangeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|exchange
operator|!=
literal|null
condition|)
block|{
comment|// get the correlation key
name|String
name|key
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_CORRELATION_KEY
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// and mark it as redelivered
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|setHeader
argument_list|(
name|Exchange
operator|.
name|REDELIVERED
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
comment|// get the current redelivery data
name|RedeliveryData
name|data
init|=
name|redeliveryState
operator|.
name|get
argument_list|(
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|)
decl_stmt|;
comment|// if we are exhausted, then move to dead letter channel
if|if
condition|(
name|data
operator|!=
literal|null
operator|&&
name|recoverable
operator|.
name|getMaximumRedeliveries
argument_list|()
operator|>
literal|0
operator|&&
name|data
operator|.
name|redeliveryCounter
operator|>=
name|recoverable
operator|.
name|getMaximumRedeliveries
argument_list|()
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"The recovered exchange is exhausted after "
operator|+
name|recoverable
operator|.
name|getMaximumRedeliveries
argument_list|()
operator|+
literal|" attempts, will now be moved to dead letter channel: "
operator|+
name|recoverable
operator|.
name|getDeadLetterUri
argument_list|()
argument_list|)
expr_stmt|;
comment|// send to DLC
try|try
block|{
comment|// set redelivery counter
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|setHeader
argument_list|(
name|Exchange
operator|.
name|REDELIVERY_COUNTER
argument_list|,
name|data
operator|.
name|redeliveryCounter
argument_list|)
expr_stmt|;
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|setHeader
argument_list|(
name|Exchange
operator|.
name|REDELIVERY_EXHAUSTED
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|deadLetterProducerTemplate
operator|.
name|send
argument_list|(
name|recoverable
operator|.
name|getDeadLetterUri
argument_list|()
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|exchange
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|// handle if failed
if|if
condition|(
name|exchange
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|getExceptionHandler
argument_list|()
operator|.
name|handleException
argument_list|(
literal|"Failed to move recovered Exchange to dead letter channel: "
operator|+
name|recoverable
operator|.
name|getDeadLetterUri
argument_list|()
argument_list|,
name|exchange
operator|.
name|getException
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// it was ok, so confirm after it has been moved to dead letter channel, so we wont recover it again
name|recoverable
operator|.
name|confirm
argument_list|(
name|camelContext
argument_list|,
name|exchangeId
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// update current redelivery state
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
comment|// create new data
name|data
operator|=
operator|new
name|RedeliveryData
argument_list|()
expr_stmt|;
name|redeliveryState
operator|.
name|put
argument_list|(
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|data
operator|.
name|redeliveryCounter
operator|++
expr_stmt|;
comment|// set redelivery counter
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|setHeader
argument_list|(
name|Exchange
operator|.
name|REDELIVERY_COUNTER
argument_list|,
name|data
operator|.
name|redeliveryCounter
argument_list|)
expr_stmt|;
if|if
condition|(
name|recoverable
operator|.
name|getMaximumRedeliveries
argument_list|()
operator|>
literal|0
condition|)
block|{
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|setHeader
argument_list|(
name|Exchange
operator|.
name|REDELIVERY_MAX_COUNTER
argument_list|,
name|recoverable
operator|.
name|getMaximumRedeliveries
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"Delivery attempt: {} to recover aggregated exchange with id: {}"
argument_list|,
name|data
operator|.
name|redeliveryCounter
argument_list|,
name|exchangeId
argument_list|)
expr_stmt|;
comment|// not exhaust so resubmit the recovered exchange
name|onSubmitCompletion
argument_list|(
name|key
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
name|log
operator|.
name|trace
argument_list|(
literal|"Recover check complete"
argument_list|)
expr_stmt|;
block|}
block|}
end_class

begin_function
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|doStart ()
specifier|protected
name|void
name|doStart
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|aggregationStrategy
operator|instanceof
name|CamelContextAware
condition|)
block|{
operator|(
operator|(
name|CamelContextAware
operator|)
name|aggregationStrategy
operator|)
operator|.
name|setCamelContext
argument_list|(
name|camelContext
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aggregationStrategy
operator|.
name|canPreComplete
argument_list|()
condition|)
block|{
name|preCompletion
operator|=
literal|true
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"PreCompletionAwareAggregationStrategy detected. Aggregator {} is in pre-completion mode."
argument_list|,
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|preCompletion
condition|)
block|{
comment|// if not in pre completion mode then check we configured the completion required
if|if
condition|(
name|getCompletionTimeout
argument_list|()
operator|<=
literal|0
operator|&&
name|getCompletionInterval
argument_list|()
operator|<=
literal|0
operator|&&
name|getCompletionSize
argument_list|()
operator|<=
literal|0
operator|&&
name|getCompletionPredicate
argument_list|()
operator|==
literal|null
operator|&&
operator|!
name|isCompletionFromBatchConsumer
argument_list|()
operator|&&
name|getCompletionTimeoutExpression
argument_list|()
operator|==
literal|null
operator|&&
name|getCompletionSizeExpression
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"At least one of the completions options"
operator|+
literal|" [completionTimeout, completionInterval, completionSize, completionPredicate, completionFromBatchConsumer] must be set"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|getCloseCorrelationKeyOnCompletion
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|getCloseCorrelationKeyOnCompletion
argument_list|()
operator|>
literal|0
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Using ClosedCorrelationKeys with a LRUCache with a capacity of {}"
argument_list|,
name|getCloseCorrelationKeyOnCompletion
argument_list|()
argument_list|)
expr_stmt|;
name|closedCorrelationKeys
operator|=
name|LRUCacheFactory
operator|.
name|newLRUCache
argument_list|(
name|getCloseCorrelationKeyOnCompletion
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Using ClosedCorrelationKeys with unbounded capacity"
argument_list|)
expr_stmt|;
name|closedCorrelationKeys
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|aggregationRepository
operator|==
literal|null
condition|)
block|{
name|aggregationRepository
operator|=
operator|new
name|MemoryAggregationRepository
argument_list|(
name|optimisticLocking
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Defaulting to MemoryAggregationRepository"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|optimisticLocking
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|aggregationRepository
operator|instanceof
name|OptimisticLockingAggregationRepository
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Optimistic locking cannot be enabled without using an AggregationRepository that implements OptimisticLockingAggregationRepository"
argument_list|)
throw|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Optimistic locking is enabled"
argument_list|)
expr_stmt|;
block|}
name|ServiceHelper
operator|.
name|startService
argument_list|(
name|aggregationStrategy
argument_list|,
name|processor
argument_list|,
name|aggregationRepository
argument_list|)
expr_stmt|;
comment|// should we use recover checker
if|if
condition|(
name|aggregationRepository
operator|instanceof
name|RecoverableAggregationRepository
condition|)
block|{
name|RecoverableAggregationRepository
name|recoverable
init|=
operator|(
name|RecoverableAggregationRepository
operator|)
name|aggregationRepository
decl_stmt|;
if|if
condition|(
name|recoverable
operator|.
name|isUseRecovery
argument_list|()
condition|)
block|{
name|long
name|interval
init|=
name|recoverable
operator|.
name|getRecoveryIntervalInMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|interval
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"AggregationRepository has recovery enabled and the RecoveryInterval option must be a positive number, was: "
operator|+
name|interval
argument_list|)
throw|;
block|}
comment|// create a background recover thread to check every interval
name|recoverService
operator|=
name|camelContext
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|newScheduledThreadPool
argument_list|(
name|this
argument_list|,
literal|"AggregateRecoverChecker"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Runnable
name|recoverTask
init|=
operator|new
name|RecoverTask
argument_list|(
name|recoverable
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Using RecoverableAggregationRepository by scheduling recover checker to run every {} millis."
argument_list|,
name|interval
argument_list|)
expr_stmt|;
comment|// use fixed delay so there is X interval between each run
name|recoverService
operator|.
name|scheduleWithFixedDelay
argument_list|(
name|recoverTask
argument_list|,
literal|1000L
argument_list|,
name|interval
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|recoverable
operator|.
name|getDeadLetterUri
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|int
name|max
init|=
name|recoverable
operator|.
name|getMaximumRedeliveries
argument_list|()
decl_stmt|;
if|if
condition|(
name|max
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Option maximumRedeliveries must be a positive number, was: "
operator|+
name|max
argument_list|)
throw|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"After {} failed redelivery attempts Exchanges will be moved to deadLetterUri: {}"
argument_list|,
name|max
argument_list|,
name|recoverable
operator|.
name|getDeadLetterUri
argument_list|()
argument_list|)
expr_stmt|;
comment|// dead letter uri must be a valid endpoint
name|Endpoint
name|endpoint
init|=
name|camelContext
operator|.
name|getEndpoint
argument_list|(
name|recoverable
operator|.
name|getDeadLetterUri
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|endpoint
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchEndpointException
argument_list|(
name|recoverable
operator|.
name|getDeadLetterUri
argument_list|()
argument_list|)
throw|;
block|}
name|deadLetterProducerTemplate
operator|=
name|camelContext
operator|.
name|createProducerTemplate
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|getCompletionInterval
argument_list|()
operator|>
literal|0
operator|&&
name|getCompletionTimeout
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Only one of completionInterval or completionTimeout can be used, not both."
argument_list|)
throw|;
block|}
if|if
condition|(
name|getCompletionInterval
argument_list|()
operator|>
literal|0
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Using CompletionInterval to run every {} millis."
argument_list|,
name|getCompletionInterval
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|getTimeoutCheckerExecutorService
argument_list|()
operator|==
literal|null
condition|)
block|{
name|setTimeoutCheckerExecutorService
argument_list|(
name|camelContext
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|newSingleThreadScheduledExecutor
argument_list|(
name|this
argument_list|,
name|AGGREGATE_TIMEOUT_CHECKER
argument_list|)
argument_list|)
expr_stmt|;
name|shutdownTimeoutCheckerExecutorService
operator|=
literal|true
expr_stmt|;
block|}
comment|// trigger completion based on interval
name|getTimeoutCheckerExecutorService
argument_list|()
operator|.
name|scheduleAtFixedRate
argument_list|(
operator|new
name|AggregationIntervalTask
argument_list|()
argument_list|,
name|getCompletionInterval
argument_list|()
argument_list|,
name|getCompletionInterval
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
comment|// start timeout service if its in use
if|if
condition|(
name|getCompletionTimeout
argument_list|()
operator|>
literal|0
operator|||
name|getCompletionTimeoutExpression
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Using CompletionTimeout to trigger after {} millis of inactivity."
argument_list|,
name|getCompletionTimeout
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|getTimeoutCheckerExecutorService
argument_list|()
operator|==
literal|null
condition|)
block|{
name|setTimeoutCheckerExecutorService
argument_list|(
name|camelContext
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|newSingleThreadScheduledExecutor
argument_list|(
name|this
argument_list|,
name|AGGREGATE_TIMEOUT_CHECKER
argument_list|)
argument_list|)
expr_stmt|;
name|shutdownTimeoutCheckerExecutorService
operator|=
literal|true
expr_stmt|;
block|}
comment|// check for timed out aggregated messages once every second
name|timeoutMap
operator|=
operator|new
name|AggregationTimeoutMap
argument_list|(
name|getTimeoutCheckerExecutorService
argument_list|()
argument_list|,
name|getCompletionTimeoutCheckerInterval
argument_list|()
argument_list|)
expr_stmt|;
comment|// fill in existing timeout values from the aggregation repository, for example if a restart occurred, then we
comment|// need to re-establish the timeout map so timeout can trigger
name|restoreTimeoutMapFromAggregationRepository
argument_list|()
expr_stmt|;
name|ServiceHelper
operator|.
name|startService
argument_list|(
name|timeoutMap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aggregateController
operator|==
literal|null
condition|)
block|{
name|aggregateController
operator|=
operator|new
name|DefaultAggregateController
argument_list|()
expr_stmt|;
block|}
name|aggregateController
operator|.
name|onStart
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimisticLocking
condition|)
block|{
name|lock
operator|=
name|NoLock
operator|.
name|INSTANCE
expr_stmt|;
if|if
condition|(
name|getOptimisticLockingExecutorService
argument_list|()
operator|==
literal|null
condition|)
block|{
name|setOptimisticLockingExecutorService
argument_list|(
name|camelContext
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|newScheduledThreadPool
argument_list|(
name|this
argument_list|,
name|AGGREGATE_OPTIMISTIC_LOCKING_EXECUTOR
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|shutdownOptimisticLockingExecutorService
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|lock
operator|=
operator|new
name|ReentrantLock
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|doStop ()
specifier|protected
name|void
name|doStop
parameter_list|()
throws|throws
name|Exception
block|{
comment|// note: we cannot do doForceCompletionOnStop from this doStop method
comment|// as this is handled in the prepareShutdown method which is also invoked when stopping a route
comment|// and is better suited for preparing to shutdown than this doStop method is
if|if
condition|(
name|aggregateController
operator|!=
literal|null
condition|)
block|{
name|aggregateController
operator|.
name|onStop
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recoverService
operator|!=
literal|null
condition|)
block|{
name|camelContext
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|shutdown
argument_list|(
name|recoverService
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shutdownTimeoutCheckerExecutorService
operator|&&
name|timeoutCheckerExecutorService
operator|!=
literal|null
condition|)
block|{
name|camelContext
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|shutdown
argument_list|(
name|timeoutCheckerExecutorService
argument_list|)
expr_stmt|;
name|timeoutCheckerExecutorService
operator|=
literal|null
expr_stmt|;
name|shutdownTimeoutCheckerExecutorService
operator|=
literal|false
expr_stmt|;
block|}
name|ServiceHelper
operator|.
name|stopService
argument_list|(
name|timeoutMap
argument_list|,
name|processor
argument_list|,
name|deadLetterProducerTemplate
argument_list|)
expr_stmt|;
if|if
condition|(
name|closedCorrelationKeys
operator|!=
literal|null
condition|)
block|{
comment|// it may be a service so stop it as well
name|ServiceHelper
operator|.
name|stopService
argument_list|(
name|closedCorrelationKeys
argument_list|)
expr_stmt|;
name|closedCorrelationKeys
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|batchConsumerCorrelationKeys
operator|.
name|clear
argument_list|()
expr_stmt|;
name|redeliveryState
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|prepareShutdown (boolean suspendOnly, boolean forced)
specifier|public
name|void
name|prepareShutdown
parameter_list|(
name|boolean
name|suspendOnly
parameter_list|,
name|boolean
name|forced
parameter_list|)
block|{
comment|// we are shutting down, so force completion if this option was enabled
comment|// but only do this when forced=false, as that is when we have chance to
comment|// send out new messages to be routed by Camel. When forced=true, then
comment|// we have to shutdown in a hurry
if|if
condition|(
operator|!
name|forced
operator|&&
name|forceCompletionOnStop
condition|)
block|{
name|doForceCompletionOnStop
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|deferShutdown (ShutdownRunningTask shutdownRunningTask)
specifier|public
name|boolean
name|deferShutdown
parameter_list|(
name|ShutdownRunningTask
name|shutdownRunningTask
parameter_list|)
block|{
comment|// not in use
return|return
literal|true
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|getPendingExchangesSize ()
specifier|public
name|int
name|getPendingExchangesSize
parameter_list|()
block|{
if|if
condition|(
name|completeAllOnStop
condition|)
block|{
comment|// we want to regard all pending exchanges in the repo as inflight
name|Set
argument_list|<
name|String
argument_list|>
name|keys
init|=
name|getAggregationRepository
argument_list|()
operator|.
name|getKeys
argument_list|()
decl_stmt|;
return|return
name|keys
operator|!=
literal|null
condition|?
name|keys
operator|.
name|size
argument_list|()
else|:
literal|0
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
DECL|method|doForceCompletionOnStop ()
specifier|private
name|void
name|doForceCompletionOnStop
parameter_list|()
block|{
name|int
name|expected
init|=
name|forceCompletionOfAllGroups
argument_list|()
decl_stmt|;
name|StopWatch
name|watch
init|=
operator|new
name|StopWatch
argument_list|()
decl_stmt|;
while|while
condition|(
name|inProgressCompleteExchanges
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Waiting for {} inflight exchanges to complete"
argument_list|,
name|getInProgressCompleteExchanges
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// break out as we got interrupted such as the JVM terminating
name|log
operator|.
name|warn
argument_list|(
literal|"Interrupted while waiting for {} inflight exchanges to complete."
argument_list|,
name|getInProgressCompleteExchanges
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|expected
operator|>
literal|0
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Forcing completion of all groups with {} exchanges completed in {}"
argument_list|,
name|expected
argument_list|,
name|TimeUtils
operator|.
name|printDuration
argument_list|(
name|watch
operator|.
name|taken
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|doShutdown ()
specifier|protected
name|void
name|doShutdown
parameter_list|()
throws|throws
name|Exception
block|{
comment|// shutdown aggregation repository and the strategy
name|ServiceHelper
operator|.
name|stopAndShutdownServices
argument_list|(
name|aggregationRepository
argument_list|,
name|aggregationStrategy
argument_list|)
expr_stmt|;
comment|// cleanup when shutting down
name|inProgressCompleteExchanges
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|shutdownExecutorService
condition|)
block|{
name|camelContext
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|shutdownNow
argument_list|(
name|executorService
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shutdownTimeoutCheckerExecutorService
condition|)
block|{
name|camelContext
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|shutdownNow
argument_list|(
name|timeoutCheckerExecutorService
argument_list|)
expr_stmt|;
name|timeoutCheckerExecutorService
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|shutdownOptimisticLockingExecutorService
condition|)
block|{
name|camelContext
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|shutdownNow
argument_list|(
name|optimisticLockingExecutorService
argument_list|)
expr_stmt|;
name|optimisticLockingExecutorService
operator|=
literal|null
expr_stmt|;
block|}
name|super
operator|.
name|doShutdown
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
DECL|method|forceCompletionOfGroup (String key)
specifier|public
name|int
name|forceCompletionOfGroup
parameter_list|(
name|String
name|key
parameter_list|)
block|{
comment|// must acquire the shared aggregation lock to be able to trigger force completion
name|int
name|total
init|=
literal|0
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|Exchange
name|exchange
init|=
name|aggregationRepository
operator|.
name|get
argument_list|(
name|camelContext
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|exchange
operator|!=
literal|null
condition|)
block|{
name|total
operator|=
literal|1
expr_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"Force completion triggered for correlation key: {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|// indicate it was completed by a force completion request
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_COMPLETED_BY
argument_list|,
name|COMPLETED_BY_FORCE
argument_list|)
expr_stmt|;
name|Exchange
name|answer
init|=
name|onCompletion
argument_list|(
name|key
argument_list|,
name|exchange
argument_list|,
name|exchange
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|onSubmitCompletion
argument_list|(
name|key
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|log
operator|.
name|trace
argument_list|(
literal|"Completed force completion of group {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|total
operator|>
literal|0
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Forcing completion of group {} with {} exchanges"
argument_list|,
name|key
argument_list|,
name|total
argument_list|)
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
end_function

begin_function
DECL|method|forceCompletionOfAllGroups ()
specifier|public
name|int
name|forceCompletionOfAllGroups
parameter_list|()
block|{
comment|// only run if CamelContext has been fully started or is stopping
name|boolean
name|allow
init|=
name|camelContext
operator|.
name|getStatus
argument_list|()
operator|.
name|isStarted
argument_list|()
operator|||
name|camelContext
operator|.
name|getStatus
argument_list|()
operator|.
name|isStopping
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|allow
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Cannot start force completion of all groups because CamelContext({}) has not been started"
argument_list|,
name|camelContext
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log
operator|.
name|trace
argument_list|(
literal|"Starting force completion of all groups task"
argument_list|)
expr_stmt|;
comment|// trigger completion for all in the repository
name|Set
argument_list|<
name|String
argument_list|>
name|keys
init|=
name|aggregationRepository
operator|.
name|getKeys
argument_list|()
decl_stmt|;
name|int
name|total
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|keys
operator|!=
literal|null
operator|&&
operator|!
name|keys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// must acquire the shared aggregation lock to be able to trigger force completion
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|total
operator|=
name|keys
operator|.
name|size
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|String
name|key
range|:
name|keys
control|)
block|{
name|Exchange
name|exchange
init|=
name|aggregationRepository
operator|.
name|get
argument_list|(
name|camelContext
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|exchange
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Force completion triggered for correlation key: {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|// indicate it was completed by a force completion request
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_COMPLETED_BY
argument_list|,
name|COMPLETED_BY_FORCE
argument_list|)
expr_stmt|;
name|Exchange
name|answer
init|=
name|onCompletion
argument_list|(
name|key
argument_list|,
name|exchange
argument_list|,
name|exchange
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|onSubmitCompletion
argument_list|(
name|key
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
name|log
operator|.
name|trace
argument_list|(
literal|"Completed force completion of all groups task"
argument_list|)
expr_stmt|;
if|if
condition|(
name|total
operator|>
literal|0
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Forcing completion of all groups with {} exchanges"
argument_list|,
name|total
argument_list|)
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
end_function

unit|}
end_unit

