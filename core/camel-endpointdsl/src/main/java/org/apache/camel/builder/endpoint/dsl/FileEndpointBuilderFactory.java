begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.builder.endpoint.dsl
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|endpoint
operator|.
name|dsl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Generated
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|ExchangePattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Expression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|LoggingLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|EndpointConsumerBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|EndpointProducerBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|endpoint
operator|.
name|AbstractEndpointBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|ExceptionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|IdempotentRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|PollingConsumerPollStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|ScheduledPollConsumerScheduler
import|;
end_import

begin_comment
comment|/**  * The file component is used for reading or writing files.  *   * Generated by camel-package-maven-plugin - do not edit this file!  */
end_comment

begin_interface
annotation|@
name|Generated
argument_list|(
literal|"org.apache.camel.maven.packaging.EndpointDslMojo"
argument_list|)
DECL|interface|FileEndpointBuilderFactory
specifier|public
interface|interface
name|FileEndpointBuilderFactory
block|{
comment|/**      * Builder for endpoint consumers for the File component.      */
DECL|interface|FileEndpointConsumerBuilder
specifier|public
interface|interface
name|FileEndpointConsumerBuilder
extends|extends
name|EndpointConsumerBuilder
block|{
DECL|method|advanced ()
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|advanced
parameter_list|()
block|{
return|return
operator|(
name|AdvancedFileEndpointConsumerBuilder
operator|)
name|this
return|;
block|}
comment|/**          * The starting directory.          *           * The option is a:<code>java.io.File</code> type.          *           * Group: common          */
DECL|method|directoryName (File directoryName)
specifier|default
name|FileEndpointConsumerBuilder
name|directoryName
parameter_list|(
name|File
name|directoryName
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"directoryName"
argument_list|,
name|directoryName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The starting directory.          *           * The option will be converted to a<code>java.io.File</code> type.          *           * Group: common          */
DECL|method|directoryName (String directoryName)
specifier|default
name|FileEndpointConsumerBuilder
name|directoryName
parameter_list|(
name|String
name|directoryName
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"directoryName"
argument_list|,
name|directoryName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * This option is used to specify the encoding of the file. You can use          * this on the consumer, to specify the encodings of the files, which          * allow Camel to know the charset it should load the file content in          * case the file content is being accessed. Likewise when writing a          * file, you can use this option to specify which charset to write the          * file as well. Do mind that when writing the file Camel may have to          * read the message content into memory to be able to convert the data          * into the configured charset, so do not use this if you have big          * messages.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: common          */
DECL|method|charset (String charset)
specifier|default
name|FileEndpointConsumerBuilder
name|charset
parameter_list|(
name|String
name|charset
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"charset"
argument_list|,
name|charset
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Producer: If provided, then Camel will write a 2nd done file when the          * original file has been written. The done file will be empty. This          * option configures what file name to use. Either you can specify a          * fixed name. Or you can use dynamic placeholders. The done file will          * always be written in the same folder as the original file. Consumer:          * If provided, Camel will only consume files if a done file exists.          * This option configures what file name to use. Either you can specify          * a fixed name. Or you can use dynamic placeholders.The done file is          * always expected in the same folder as the original file. Only          * ${file.name} and ${file.name.noext} is supported as dynamic          * placeholders.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: common          */
DECL|method|doneFileName (String doneFileName)
specifier|default
name|FileEndpointConsumerBuilder
name|doneFileName
parameter_list|(
name|String
name|doneFileName
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"doneFileName"
argument_list|,
name|doneFileName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Use Expression such as File Language to dynamically set the filename.          * For consumers, it's used as a filename filter. For producers, it's          * used to evaluate the filename to write. If an expression is set, it          * take precedence over the CamelFileName header. (Note: The header          * itself can also be an Expression). The expression options support          * both String and Expression types. If the expression is a String type,          * it is always evaluated using the File Language. If the expression is          * an Expression type, the specified Expression type is used - this          * allows you, for instance, to use OGNL expressions. For the consumer,          * you can use it to filter filenames, so you can for instance consume          * today's file using the File Language syntax:          * mydata-${date:now:yyyyMMdd}.txt. The producers support the          * CamelOverruleFileName header which takes precedence over any existing          * CamelFileName header; the CamelOverruleFileName is a header that is          * used only once, and makes it easier as this avoids to temporary store          * CamelFileName and have to restore it afterwards.          *           * The option is a:<code>org.apache.camel.Expression</code> type.          *           * Group: common          */
DECL|method|fileName (Expression fileName)
specifier|default
name|FileEndpointConsumerBuilder
name|fileName
parameter_list|(
name|Expression
name|fileName
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"fileName"
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Use Expression such as File Language to dynamically set the filename.          * For consumers, it's used as a filename filter. For producers, it's          * used to evaluate the filename to write. If an expression is set, it          * take precedence over the CamelFileName header. (Note: The header          * itself can also be an Expression). The expression options support          * both String and Expression types. If the expression is a String type,          * it is always evaluated using the File Language. If the expression is          * an Expression type, the specified Expression type is used - this          * allows you, for instance, to use OGNL expressions. For the consumer,          * you can use it to filter filenames, so you can for instance consume          * today's file using the File Language syntax:          * mydata-${date:now:yyyyMMdd}.txt. The producers support the          * CamelOverruleFileName header which takes precedence over any existing          * CamelFileName header; the CamelOverruleFileName is a header that is          * used only once, and makes it easier as this avoids to temporary store          * CamelFileName and have to restore it afterwards.          *           * The option will be converted to a          *<code>org.apache.camel.Expression</code> type.          *           * Group: common          */
DECL|method|fileName (String fileName)
specifier|default
name|FileEndpointConsumerBuilder
name|fileName
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"fileName"
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Allows for bridging the consumer to the Camel routing Error Handler,          * which mean any exceptions occurred while the consumer is trying to          * pickup incoming messages, or the likes, will now be processed as a          * message and handled by the routing Error Handler. By default the          * consumer will use the org.apache.camel.spi.ExceptionHandler to deal          * with exceptions, that will be logged at WARN or ERROR level and          * ignored.          *           * The option is a:<code>boolean</code> type.          *           * Group: consumer          */
DECL|method|bridgeErrorHandler ( boolean bridgeErrorHandler)
specifier|default
name|FileEndpointConsumerBuilder
name|bridgeErrorHandler
parameter_list|(
name|boolean
name|bridgeErrorHandler
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"bridgeErrorHandler"
argument_list|,
name|bridgeErrorHandler
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Allows for bridging the consumer to the Camel routing Error Handler,          * which mean any exceptions occurred while the consumer is trying to          * pickup incoming messages, or the likes, will now be processed as a          * message and handled by the routing Error Handler. By default the          * consumer will use the org.apache.camel.spi.ExceptionHandler to deal          * with exceptions, that will be logged at WARN or ERROR level and          * ignored.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: consumer          */
DECL|method|bridgeErrorHandler ( String bridgeErrorHandler)
specifier|default
name|FileEndpointConsumerBuilder
name|bridgeErrorHandler
parameter_list|(
name|String
name|bridgeErrorHandler
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"bridgeErrorHandler"
argument_list|,
name|bridgeErrorHandler
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If true, the file will be deleted after it is processed successfully.          *           * The option is a:<code>boolean</code> type.          *           * Group: consumer          */
DECL|method|delete (boolean delete)
specifier|default
name|FileEndpointConsumerBuilder
name|delete
parameter_list|(
name|boolean
name|delete
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"delete"
argument_list|,
name|delete
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If true, the file will be deleted after it is processed successfully.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: consumer          */
DECL|method|delete (String delete)
specifier|default
name|FileEndpointConsumerBuilder
name|delete
parameter_list|(
name|String
name|delete
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"delete"
argument_list|,
name|delete
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets the move failure expression based on Simple language. For          * example, to move files into a .error subdirectory use: .error. Note:          * When moving the files to the fail location Camel will handle the          * error and will not pick up the file again.          *           * The option is a:<code>org.apache.camel.Expression</code> type.          *           * Group: consumer          */
DECL|method|moveFailed (Expression moveFailed)
specifier|default
name|FileEndpointConsumerBuilder
name|moveFailed
parameter_list|(
name|Expression
name|moveFailed
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"moveFailed"
argument_list|,
name|moveFailed
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets the move failure expression based on Simple language. For          * example, to move files into a .error subdirectory use: .error. Note:          * When moving the files to the fail location Camel will handle the          * error and will not pick up the file again.          *           * The option will be converted to a          *<code>org.apache.camel.Expression</code> type.          *           * Group: consumer          */
DECL|method|moveFailed (String moveFailed)
specifier|default
name|FileEndpointConsumerBuilder
name|moveFailed
parameter_list|(
name|String
name|moveFailed
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"moveFailed"
argument_list|,
name|moveFailed
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If true, the file is not moved or deleted in any way. This option is          * good for readonly data, or for ETL type requirements. If noop=true,          * Camel will set idempotent=true as well, to avoid consuming the same          * files over and over again.          *           * The option is a:<code>boolean</code> type.          *           * Group: consumer          */
DECL|method|noop (boolean noop)
specifier|default
name|FileEndpointConsumerBuilder
name|noop
parameter_list|(
name|boolean
name|noop
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"noop"
argument_list|,
name|noop
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If true, the file is not moved or deleted in any way. This option is          * good for readonly data, or for ETL type requirements. If noop=true,          * Camel will set idempotent=true as well, to avoid consuming the same          * files over and over again.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: consumer          */
DECL|method|noop (String noop)
specifier|default
name|FileEndpointConsumerBuilder
name|noop
parameter_list|(
name|String
name|noop
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"noop"
argument_list|,
name|noop
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Expression (such as File Language) used to dynamically set the          * filename when moving it before processing. For example to move          * in-progress files into the order directory set this value to order.          *           * The option is a:<code>org.apache.camel.Expression</code> type.          *           * Group: consumer          */
DECL|method|preMove (Expression preMove)
specifier|default
name|FileEndpointConsumerBuilder
name|preMove
parameter_list|(
name|Expression
name|preMove
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"preMove"
argument_list|,
name|preMove
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Expression (such as File Language) used to dynamically set the          * filename when moving it before processing. For example to move          * in-progress files into the order directory set this value to order.          *           * The option will be converted to a          *<code>org.apache.camel.Expression</code> type.          *           * Group: consumer          */
DECL|method|preMove (String preMove)
specifier|default
name|FileEndpointConsumerBuilder
name|preMove
parameter_list|(
name|String
name|preMove
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"preMove"
argument_list|,
name|preMove
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * When pre-sort is enabled then the consumer will sort the file and          * directory names during polling, that was retrieved from the file          * system. You may want to do this in case you need to operate on the          * files in a sorted order. The pre-sort is executed before the consumer          * starts to filter, and accept files to process by Camel. This option          * is default=false meaning disabled.          *           * The option is a:<code>boolean</code> type.          *           * Group: consumer          */
DECL|method|preSort (boolean preSort)
specifier|default
name|FileEndpointConsumerBuilder
name|preSort
parameter_list|(
name|boolean
name|preSort
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"preSort"
argument_list|,
name|preSort
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * When pre-sort is enabled then the consumer will sort the file and          * directory names during polling, that was retrieved from the file          * system. You may want to do this in case you need to operate on the          * files in a sorted order. The pre-sort is executed before the consumer          * starts to filter, and accept files to process by Camel. This option          * is default=false meaning disabled.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: consumer          */
DECL|method|preSort (String preSort)
specifier|default
name|FileEndpointConsumerBuilder
name|preSort
parameter_list|(
name|String
name|preSort
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"preSort"
argument_list|,
name|preSort
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If a directory, will look for files in all the sub-directories as          * well.          *           * The option is a:<code>boolean</code> type.          *           * Group: consumer          */
DECL|method|recursive (boolean recursive)
specifier|default
name|FileEndpointConsumerBuilder
name|recursive
parameter_list|(
name|boolean
name|recursive
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"recursive"
argument_list|,
name|recursive
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If a directory, will look for files in all the sub-directories as          * well.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: consumer          */
DECL|method|recursive (String recursive)
specifier|default
name|FileEndpointConsumerBuilder
name|recursive
parameter_list|(
name|String
name|recursive
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"recursive"
argument_list|,
name|recursive
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If the polling consumer did not poll any files, you can enable this          * option to send an empty message (no body) instead.          *           * The option is a:<code>boolean</code> type.          *           * Group: consumer          */
DECL|method|sendEmptyMessageWhenIdle ( boolean sendEmptyMessageWhenIdle)
specifier|default
name|FileEndpointConsumerBuilder
name|sendEmptyMessageWhenIdle
parameter_list|(
name|boolean
name|sendEmptyMessageWhenIdle
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"sendEmptyMessageWhenIdle"
argument_list|,
name|sendEmptyMessageWhenIdle
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If the polling consumer did not poll any files, you can enable this          * option to send an empty message (no body) instead.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: consumer          */
DECL|method|sendEmptyMessageWhenIdle ( String sendEmptyMessageWhenIdle)
specifier|default
name|FileEndpointConsumerBuilder
name|sendEmptyMessageWhenIdle
parameter_list|(
name|String
name|sendEmptyMessageWhenIdle
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"sendEmptyMessageWhenIdle"
argument_list|,
name|sendEmptyMessageWhenIdle
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Ant style filter exclusion. If both antInclude and antExclude are          * used, antExclude takes precedence over antInclude. Multiple          * exclusions may be specified in comma-delimited format.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: filter          */
DECL|method|antExclude (String antExclude)
specifier|default
name|FileEndpointConsumerBuilder
name|antExclude
parameter_list|(
name|String
name|antExclude
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"antExclude"
argument_list|,
name|antExclude
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets case sensitive flag on ant filter.          *           * The option is a:<code>boolean</code> type.          *           * Group: filter          */
DECL|method|antFilterCaseSensitive ( boolean antFilterCaseSensitive)
specifier|default
name|FileEndpointConsumerBuilder
name|antFilterCaseSensitive
parameter_list|(
name|boolean
name|antFilterCaseSensitive
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"antFilterCaseSensitive"
argument_list|,
name|antFilterCaseSensitive
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets case sensitive flag on ant filter.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: filter          */
DECL|method|antFilterCaseSensitive ( String antFilterCaseSensitive)
specifier|default
name|FileEndpointConsumerBuilder
name|antFilterCaseSensitive
parameter_list|(
name|String
name|antFilterCaseSensitive
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"antFilterCaseSensitive"
argument_list|,
name|antFilterCaseSensitive
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Ant style filter inclusion. Multiple inclusions may be specified in          * comma-delimited format.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: filter          */
DECL|method|antInclude (String antInclude)
specifier|default
name|FileEndpointConsumerBuilder
name|antInclude
parameter_list|(
name|String
name|antInclude
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"antInclude"
argument_list|,
name|antInclude
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Allows for controlling whether the limit from maxMessagesPerPoll is          * eager or not. If eager then the limit is during the scanning of          * files. Where as false would scan all files, and then perform sorting.          * Setting this option to false allows for sorting all files first, and          * then limit the poll. Mind that this requires a higher memory usage as          * all file details are in memory to perform the sorting.          *           * The option is a:<code>boolean</code> type.          *           * Group: filter          */
DECL|method|eagerMaxMessagesPerPoll ( boolean eagerMaxMessagesPerPoll)
specifier|default
name|FileEndpointConsumerBuilder
name|eagerMaxMessagesPerPoll
parameter_list|(
name|boolean
name|eagerMaxMessagesPerPoll
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"eagerMaxMessagesPerPoll"
argument_list|,
name|eagerMaxMessagesPerPoll
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Allows for controlling whether the limit from maxMessagesPerPoll is          * eager or not. If eager then the limit is during the scanning of          * files. Where as false would scan all files, and then perform sorting.          * Setting this option to false allows for sorting all files first, and          * then limit the poll. Mind that this requires a higher memory usage as          * all file details are in memory to perform the sorting.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: filter          */
DECL|method|eagerMaxMessagesPerPoll ( String eagerMaxMessagesPerPoll)
specifier|default
name|FileEndpointConsumerBuilder
name|eagerMaxMessagesPerPoll
parameter_list|(
name|String
name|eagerMaxMessagesPerPoll
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"eagerMaxMessagesPerPoll"
argument_list|,
name|eagerMaxMessagesPerPoll
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Is used to exclude files, if filename matches the regex pattern          * (matching is case in-senstive). Notice if you use symbols such as          * plus sign and others you would need to configure this using the RAW()          * syntax if configuring this as an endpoint uri. See more details at          * configuring endpoint uris.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: filter          */
DECL|method|exclude (String exclude)
specifier|default
name|FileEndpointConsumerBuilder
name|exclude
parameter_list|(
name|String
name|exclude
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"exclude"
argument_list|,
name|exclude
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Pluggable filter as a          * org.apache.camel.component.file.GenericFileFilter class. Will skip          * files if filter returns false in its accept() method.          *           * The option is a:          *<code>org.apache.camel.component.file.GenericFileFilter&lt;java.io.File&gt;</code> type.          *           * Group: filter          */
DECL|method|filter (Object filter)
specifier|default
name|FileEndpointConsumerBuilder
name|filter
parameter_list|(
name|Object
name|filter
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"filter"
argument_list|,
name|filter
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Pluggable filter as a          * org.apache.camel.component.file.GenericFileFilter class. Will skip          * files if filter returns false in its accept() method.          *           * The option will be converted to a          *<code>org.apache.camel.component.file.GenericFileFilter&lt;java.io.File&gt;</code> type.          *           * Group: filter          */
DECL|method|filter (String filter)
specifier|default
name|FileEndpointConsumerBuilder
name|filter
parameter_list|(
name|String
name|filter
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"filter"
argument_list|,
name|filter
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Filters the directory based on Simple language. For example to filter          * on current date, you can use a simple date pattern such as          * ${date:now:yyyMMdd}.          *           * The option is a:<code>org.apache.camel.Predicate</code> type.          *           * Group: filter          */
DECL|method|filterDirectory ( Predicate filterDirectory)
specifier|default
name|FileEndpointConsumerBuilder
name|filterDirectory
parameter_list|(
name|Predicate
name|filterDirectory
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"filterDirectory"
argument_list|,
name|filterDirectory
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Filters the directory based on Simple language. For example to filter          * on current date, you can use a simple date pattern such as          * ${date:now:yyyMMdd}.          *           * The option will be converted to a          *<code>org.apache.camel.Predicate</code> type.          *           * Group: filter          */
DECL|method|filterDirectory ( String filterDirectory)
specifier|default
name|FileEndpointConsumerBuilder
name|filterDirectory
parameter_list|(
name|String
name|filterDirectory
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"filterDirectory"
argument_list|,
name|filterDirectory
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Filters the file based on Simple language. For example to filter on          * file size, you can use ${file:size} 5000.          *           * The option is a:<code>org.apache.camel.Predicate</code> type.          *           * Group: filter          */
DECL|method|filterFile (Predicate filterFile)
specifier|default
name|FileEndpointConsumerBuilder
name|filterFile
parameter_list|(
name|Predicate
name|filterFile
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"filterFile"
argument_list|,
name|filterFile
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Filters the file based on Simple language. For example to filter on          * file size, you can use ${file:size} 5000.          *           * The option will be converted to a          *<code>org.apache.camel.Predicate</code> type.          *           * Group: filter          */
DECL|method|filterFile (String filterFile)
specifier|default
name|FileEndpointConsumerBuilder
name|filterFile
parameter_list|(
name|String
name|filterFile
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"filterFile"
argument_list|,
name|filterFile
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Option to use the Idempotent Consumer EIP pattern to let Camel skip          * already processed files. Will by default use a memory based LRUCache          * that holds 1000 entries. If noop=true then idempotent will be enabled          * as well to avoid consuming the same files over and over again.          *           * The option is a:<code>java.lang.Boolean</code> type.          *           * Group: filter          */
DECL|method|idempotent (Boolean idempotent)
specifier|default
name|FileEndpointConsumerBuilder
name|idempotent
parameter_list|(
name|Boolean
name|idempotent
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"idempotent"
argument_list|,
name|idempotent
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Option to use the Idempotent Consumer EIP pattern to let Camel skip          * already processed files. Will by default use a memory based LRUCache          * that holds 1000 entries. If noop=true then idempotent will be enabled          * as well to avoid consuming the same files over and over again.          *           * The option will be converted to a<code>java.lang.Boolean</code>          * type.          *           * Group: filter          */
DECL|method|idempotent (String idempotent)
specifier|default
name|FileEndpointConsumerBuilder
name|idempotent
parameter_list|(
name|String
name|idempotent
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"idempotent"
argument_list|,
name|idempotent
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use a custom idempotent key. By default the absolute path of the          * file is used. You can use the File Language, for example to use the          * file name and file size, you can do:          * idempotentKey=${file:name}-${file:size}.          *           * The option is a:<code>org.apache.camel.Expression</code> type.          *           * Group: filter          */
DECL|method|idempotentKey ( Expression idempotentKey)
specifier|default
name|FileEndpointConsumerBuilder
name|idempotentKey
parameter_list|(
name|Expression
name|idempotentKey
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"idempotentKey"
argument_list|,
name|idempotentKey
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use a custom idempotent key. By default the absolute path of the          * file is used. You can use the File Language, for example to use the          * file name and file size, you can do:          * idempotentKey=${file:name}-${file:size}.          *           * The option will be converted to a          *<code>org.apache.camel.Expression</code> type.          *           * Group: filter          */
DECL|method|idempotentKey (String idempotentKey)
specifier|default
name|FileEndpointConsumerBuilder
name|idempotentKey
parameter_list|(
name|String
name|idempotentKey
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"idempotentKey"
argument_list|,
name|idempotentKey
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * A pluggable repository org.apache.camel.spi.IdempotentRepository          * which by default use MemoryMessageIdRepository if none is specified          * and idempotent is true.          *           * The option is a:          *<code>org.apache.camel.spi.IdempotentRepository</code> type.          *           * Group: filter          */
DECL|method|idempotentRepository ( IdempotentRepository idempotentRepository)
specifier|default
name|FileEndpointConsumerBuilder
name|idempotentRepository
parameter_list|(
name|IdempotentRepository
name|idempotentRepository
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"idempotentRepository"
argument_list|,
name|idempotentRepository
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * A pluggable repository org.apache.camel.spi.IdempotentRepository          * which by default use MemoryMessageIdRepository if none is specified          * and idempotent is true.          *           * The option will be converted to a          *<code>org.apache.camel.spi.IdempotentRepository</code> type.          *           * Group: filter          */
DECL|method|idempotentRepository ( String idempotentRepository)
specifier|default
name|FileEndpointConsumerBuilder
name|idempotentRepository
parameter_list|(
name|String
name|idempotentRepository
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"idempotentRepository"
argument_list|,
name|idempotentRepository
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Is used to include files, if filename matches the regex pattern          * (matching is case in-sensitive). Notice if you use symbols such as          * plus sign and others you would need to configure this using the RAW()          * syntax if configuring this as an endpoint uri. See more details at          * configuring endpoint uris.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: filter          */
DECL|method|include (String include)
specifier|default
name|FileEndpointConsumerBuilder
name|include
parameter_list|(
name|String
name|include
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"include"
argument_list|,
name|include
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The maximum depth to traverse when recursively processing a          * directory.          *           * The option is a:<code>int</code> type.          *           * Group: filter          */
DECL|method|maxDepth (int maxDepth)
specifier|default
name|FileEndpointConsumerBuilder
name|maxDepth
parameter_list|(
name|int
name|maxDepth
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"maxDepth"
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The maximum depth to traverse when recursively processing a          * directory.          *           * The option will be converted to a<code>int</code> type.          *           * Group: filter          */
DECL|method|maxDepth (String maxDepth)
specifier|default
name|FileEndpointConsumerBuilder
name|maxDepth
parameter_list|(
name|String
name|maxDepth
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"maxDepth"
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To define a maximum messages to gather per poll. By default no          * maximum is set. Can be used to set a limit of e.g. 1000 to avoid when          * starting up the server that there are thousands of files. Set a value          * of 0 or negative to disabled it. Notice: If this option is in use          * then the File and FTP components will limit before any sorting. For          * example if you have 100000 files and use maxMessagesPerPoll=500, then          * only the first 500 files will be picked up, and then sorted. You can          * use the eagerMaxMessagesPerPoll option and set this to false to allow          * to scan all files first and then sort afterwards.          *           * The option is a:<code>int</code> type.          *           * Group: filter          */
DECL|method|maxMessagesPerPoll ( int maxMessagesPerPoll)
specifier|default
name|FileEndpointConsumerBuilder
name|maxMessagesPerPoll
parameter_list|(
name|int
name|maxMessagesPerPoll
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"maxMessagesPerPoll"
argument_list|,
name|maxMessagesPerPoll
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To define a maximum messages to gather per poll. By default no          * maximum is set. Can be used to set a limit of e.g. 1000 to avoid when          * starting up the server that there are thousands of files. Set a value          * of 0 or negative to disabled it. Notice: If this option is in use          * then the File and FTP components will limit before any sorting. For          * example if you have 100000 files and use maxMessagesPerPoll=500, then          * only the first 500 files will be picked up, and then sorted. You can          * use the eagerMaxMessagesPerPoll option and set this to false to allow          * to scan all files first and then sort afterwards.          *           * The option will be converted to a<code>int</code> type.          *           * Group: filter          */
DECL|method|maxMessagesPerPoll ( String maxMessagesPerPoll)
specifier|default
name|FileEndpointConsumerBuilder
name|maxMessagesPerPoll
parameter_list|(
name|String
name|maxMessagesPerPoll
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"maxMessagesPerPoll"
argument_list|,
name|maxMessagesPerPoll
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The minimum depth to start processing when recursively processing a          * directory. Using minDepth=1 means the base directory. Using          * minDepth=2 means the first sub directory.          *           * The option is a:<code>int</code> type.          *           * Group: filter          */
DECL|method|minDepth (int minDepth)
specifier|default
name|FileEndpointConsumerBuilder
name|minDepth
parameter_list|(
name|int
name|minDepth
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"minDepth"
argument_list|,
name|minDepth
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The minimum depth to start processing when recursively processing a          * directory. Using minDepth=1 means the base directory. Using          * minDepth=2 means the first sub directory.          *           * The option will be converted to a<code>int</code> type.          *           * Group: filter          */
DECL|method|minDepth (String minDepth)
specifier|default
name|FileEndpointConsumerBuilder
name|minDepth
parameter_list|(
name|String
name|minDepth
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"minDepth"
argument_list|,
name|minDepth
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Expression (such as Simple Language) used to dynamically set the          * filename when moving it after processing. To move files into a .done          * subdirectory just enter .done.          *           * The option is a:<code>org.apache.camel.Expression</code> type.          *           * Group: filter          */
DECL|method|move (Expression move)
specifier|default
name|FileEndpointConsumerBuilder
name|move
parameter_list|(
name|Expression
name|move
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"move"
argument_list|,
name|move
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Expression (such as Simple Language) used to dynamically set the          * filename when moving it after processing. To move files into a .done          * subdirectory just enter .done.          *           * The option will be converted to a          *<code>org.apache.camel.Expression</code> type.          *           * Group: filter          */
DECL|method|move (String move)
specifier|default
name|FileEndpointConsumerBuilder
name|move
parameter_list|(
name|String
name|move
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"move"
argument_list|,
name|move
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Pluggable read-lock as a          * org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy          * implementation.          *           * The option is a:          *<code>org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy&lt;java.io.File&gt;</code> type.          *           * Group: lock          */
DECL|method|exclusiveReadLockStrategy ( Object exclusiveReadLockStrategy)
specifier|default
name|FileEndpointConsumerBuilder
name|exclusiveReadLockStrategy
parameter_list|(
name|Object
name|exclusiveReadLockStrategy
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"exclusiveReadLockStrategy"
argument_list|,
name|exclusiveReadLockStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Pluggable read-lock as a          * org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy          * implementation.          *           * The option will be converted to a          *<code>org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy&lt;java.io.File&gt;</code> type.          *           * Group: lock          */
DECL|method|exclusiveReadLockStrategy ( String exclusiveReadLockStrategy)
specifier|default
name|FileEndpointConsumerBuilder
name|exclusiveReadLockStrategy
parameter_list|(
name|String
name|exclusiveReadLockStrategy
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"exclusiveReadLockStrategy"
argument_list|,
name|exclusiveReadLockStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Used by consumer, to only poll the files if it has exclusive          * read-lock on the file (i.e. the file is not in-progress or being          * written). Camel will wait until the file lock is granted. This option          * provides the build in strategies: none - No read lock is in use          * markerFile - Camel creates a marker file (fileName.camelLock) and          * then holds a lock on it. This option is not available for the FTP          * component changed - Changed is using file length/modification          * timestamp to detect whether the file is currently being copied or          * not. Will at least use 1 sec to determine this, so this option cannot          * consume files as fast as the others, but can be more reliable as the          * JDK IO API cannot always determine whether a file is currently being          * used by another process. The option readLockCheckInterval can be used          * to set the check frequency. fileLock - is for using          * java.nio.channels.FileLock. This option is not avail for Windows OS          * and the FTP component. This approach should be avoided when accessing          * a remote file system via a mount/share unless that file system          * supports distributed file locks. rename - rename is for using a try          * to rename the file as a test if we can get exclusive read-lock.          * idempotent - (only for file component) idempotent is for using a          * idempotentRepository as the read-lock. This allows to use read locks          * that supports clustering if the idempotent repository implementation          * supports that. idempotent-changed - (only for file component)          * idempotent-changed is for using a idempotentRepository and changed as          * the combined read-lock. This allows to use read locks that supports          * clustering if the idempotent repository implementation supports that.          * idempotent-rename - (only for file component) idempotent-rename is          * for using a idempotentRepository and rename as the combined          * read-lock. This allows to use read locks that supports clustering if          * the idempotent repository implementation supports that. Notice: The          * various read locks is not all suited to work in clustered mode, where          * concurrent consumers on different nodes is competing for the same          * files on a shared file system. The markerFile using a close to atomic          * operation to create the empty marker file, but its not guaranteed to          * work in a cluster. The fileLock may work better but then the file          * system need to support distributed file locks, and so on. Using the          * idempotent read lock can support clustering if the idempotent          * repository supports clustering, such as Hazelcast Component or          * Infinispan.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: lock          */
DECL|method|readLock (String readLock)
specifier|default
name|FileEndpointConsumerBuilder
name|readLock
parameter_list|(
name|String
name|readLock
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLock"
argument_list|,
name|readLock
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Interval in millis for the read-lock, if supported by the read lock.          * This interval is used for sleeping between attempts to acquire the          * read lock. For example when using the changed read lock, you can set          * a higher interval period to cater for slow writes. The default of 1          * sec. may be too fast if the producer is very slow writing the file.          * Notice: For FTP the default readLockCheckInterval is 5000. The          * readLockTimeout value must be higher than readLockCheckInterval, but          * a rule of thumb is to have a timeout that is at least 2 or more times          * higher than the readLockCheckInterval. This is needed to ensure that          * amble time is allowed for the read lock process to try to grab the          * lock before the timeout was hit.          *           * The option is a:<code>long</code> type.          *           * Group: lock          */
DECL|method|readLockCheckInterval ( long readLockCheckInterval)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockCheckInterval
parameter_list|(
name|long
name|readLockCheckInterval
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockCheckInterval"
argument_list|,
name|readLockCheckInterval
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Interval in millis for the read-lock, if supported by the read lock.          * This interval is used for sleeping between attempts to acquire the          * read lock. For example when using the changed read lock, you can set          * a higher interval period to cater for slow writes. The default of 1          * sec. may be too fast if the producer is very slow writing the file.          * Notice: For FTP the default readLockCheckInterval is 5000. The          * readLockTimeout value must be higher than readLockCheckInterval, but          * a rule of thumb is to have a timeout that is at least 2 or more times          * higher than the readLockCheckInterval. This is needed to ensure that          * amble time is allowed for the read lock process to try to grab the          * lock before the timeout was hit.          *           * The option will be converted to a<code>long</code> type.          *           * Group: lock          */
DECL|method|readLockCheckInterval ( String readLockCheckInterval)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockCheckInterval
parameter_list|(
name|String
name|readLockCheckInterval
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockCheckInterval"
argument_list|,
name|readLockCheckInterval
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether or not read lock with marker files should upon startup delete          * any orphan read lock files, which may have been left on the file          * system, if Camel was not properly shutdown (such as a JVM crash). If          * turning this option to false then any orphaned lock file will cause          * Camel to not attempt to pickup that file, this could also be due          * another node is concurrently reading files from the same shared          * directory.          *           * The option is a:<code>boolean</code> type.          *           * Group: lock          */
DECL|method|readLockDeleteOrphanLockFiles ( boolean readLockDeleteOrphanLockFiles)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockDeleteOrphanLockFiles
parameter_list|(
name|boolean
name|readLockDeleteOrphanLockFiles
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockDeleteOrphanLockFiles"
argument_list|,
name|readLockDeleteOrphanLockFiles
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether or not read lock with marker files should upon startup delete          * any orphan read lock files, which may have been left on the file          * system, if Camel was not properly shutdown (such as a JVM crash). If          * turning this option to false then any orphaned lock file will cause          * Camel to not attempt to pickup that file, this could also be due          * another node is concurrently reading files from the same shared          * directory.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: lock          */
DECL|method|readLockDeleteOrphanLockFiles ( String readLockDeleteOrphanLockFiles)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockDeleteOrphanLockFiles
parameter_list|(
name|String
name|readLockDeleteOrphanLockFiles
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockDeleteOrphanLockFiles"
argument_list|,
name|readLockDeleteOrphanLockFiles
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the delayed release task should be synchronous or          * asynchronous. See more details at the readLockIdempotentReleaseDelay          * option.          *           * The option is a:<code>boolean</code> type.          *           * Group: lock          */
DECL|method|readLockIdempotentReleaseAsync ( boolean readLockIdempotentReleaseAsync)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockIdempotentReleaseAsync
parameter_list|(
name|boolean
name|readLockIdempotentReleaseAsync
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockIdempotentReleaseAsync"
argument_list|,
name|readLockIdempotentReleaseAsync
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the delayed release task should be synchronous or          * asynchronous. See more details at the readLockIdempotentReleaseDelay          * option.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: lock          */
DECL|method|readLockIdempotentReleaseAsync ( String readLockIdempotentReleaseAsync)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockIdempotentReleaseAsync
parameter_list|(
name|String
name|readLockIdempotentReleaseAsync
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockIdempotentReleaseAsync"
argument_list|,
name|readLockIdempotentReleaseAsync
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The number of threads in the scheduled thread pool when using          * asynchronous release tasks. Using a default of 1 core threads should          * be sufficient in almost all use-cases, only set this to a higher          * value if either updating the idempotent repository is slow, or there          * are a lot of files to process. This option is not in-use if you use a          * shared thread pool by configuring the          * readLockIdempotentReleaseExecutorService option. See more details at          * the readLockIdempotentReleaseDelay option.          *           * The option is a:<code>int</code> type.          *           * Group: lock          */
DECL|method|readLockIdempotentReleaseAsyncPoolSize ( int readLockIdempotentReleaseAsyncPoolSize)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockIdempotentReleaseAsyncPoolSize
parameter_list|(
name|int
name|readLockIdempotentReleaseAsyncPoolSize
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockIdempotentReleaseAsyncPoolSize"
argument_list|,
name|readLockIdempotentReleaseAsyncPoolSize
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The number of threads in the scheduled thread pool when using          * asynchronous release tasks. Using a default of 1 core threads should          * be sufficient in almost all use-cases, only set this to a higher          * value if either updating the idempotent repository is slow, or there          * are a lot of files to process. This option is not in-use if you use a          * shared thread pool by configuring the          * readLockIdempotentReleaseExecutorService option. See more details at          * the readLockIdempotentReleaseDelay option.          *           * The option will be converted to a<code>int</code> type.          *           * Group: lock          */
DECL|method|readLockIdempotentReleaseAsyncPoolSize ( String readLockIdempotentReleaseAsyncPoolSize)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockIdempotentReleaseAsyncPoolSize
parameter_list|(
name|String
name|readLockIdempotentReleaseAsyncPoolSize
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockIdempotentReleaseAsyncPoolSize"
argument_list|,
name|readLockIdempotentReleaseAsyncPoolSize
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to delay the release task for a period of millis. This can be          * used to delay the release tasks to expand the window when a file is          * regarded as read-locked, in an active/active cluster scenario with a          * shared idempotent repository, to ensure other nodes cannot          * potentially scan and acquire the same file, due to race-conditions.          * By expanding the time-window of the release tasks helps prevents          * these situations. Note delaying is only needed if you have configured          * readLockRemoveOnCommit to true.          *           * The option is a:<code>int</code> type.          *           * Group: lock          */
DECL|method|readLockIdempotentReleaseDelay ( int readLockIdempotentReleaseDelay)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockIdempotentReleaseDelay
parameter_list|(
name|int
name|readLockIdempotentReleaseDelay
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockIdempotentReleaseDelay"
argument_list|,
name|readLockIdempotentReleaseDelay
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to delay the release task for a period of millis. This can be          * used to delay the release tasks to expand the window when a file is          * regarded as read-locked, in an active/active cluster scenario with a          * shared idempotent repository, to ensure other nodes cannot          * potentially scan and acquire the same file, due to race-conditions.          * By expanding the time-window of the release tasks helps prevents          * these situations. Note delaying is only needed if you have configured          * readLockRemoveOnCommit to true.          *           * The option will be converted to a<code>int</code> type.          *           * Group: lock          */
DECL|method|readLockIdempotentReleaseDelay ( String readLockIdempotentReleaseDelay)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockIdempotentReleaseDelay
parameter_list|(
name|String
name|readLockIdempotentReleaseDelay
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockIdempotentReleaseDelay"
argument_list|,
name|readLockIdempotentReleaseDelay
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use a custom and shared thread pool for asynchronous release          * tasks. See more details at the readLockIdempotentReleaseDelay option.          *           * The option is a:          *<code>java.util.concurrent.ScheduledExecutorService</code> type.          *           * Group: lock          */
DECL|method|readLockIdempotentReleaseExecutorService ( ScheduledExecutorService readLockIdempotentReleaseExecutorService)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockIdempotentReleaseExecutorService
parameter_list|(
name|ScheduledExecutorService
name|readLockIdempotentReleaseExecutorService
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockIdempotentReleaseExecutorService"
argument_list|,
name|readLockIdempotentReleaseExecutorService
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use a custom and shared thread pool for asynchronous release          * tasks. See more details at the readLockIdempotentReleaseDelay option.          *           * The option will be converted to a          *<code>java.util.concurrent.ScheduledExecutorService</code> type.          *           * Group: lock          */
DECL|method|readLockIdempotentReleaseExecutorService ( String readLockIdempotentReleaseExecutorService)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockIdempotentReleaseExecutorService
parameter_list|(
name|String
name|readLockIdempotentReleaseExecutorService
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockIdempotentReleaseExecutorService"
argument_list|,
name|readLockIdempotentReleaseExecutorService
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Logging level used when a read lock could not be acquired. By default          * a DEBUG is logged. You can change this level, for example to OFF to          * not have any logging. This option is only applicable for readLock of          * types: changed, fileLock, idempotent, idempotent-changed,          * idempotent-rename, rename.          *           * The option is a:<code>org.apache.camel.LoggingLevel</code> type.          *           * Group: lock          */
DECL|method|readLockLoggingLevel ( LoggingLevel readLockLoggingLevel)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockLoggingLevel
parameter_list|(
name|LoggingLevel
name|readLockLoggingLevel
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockLoggingLevel"
argument_list|,
name|readLockLoggingLevel
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Logging level used when a read lock could not be acquired. By default          * a DEBUG is logged. You can change this level, for example to OFF to          * not have any logging. This option is only applicable for readLock of          * types: changed, fileLock, idempotent, idempotent-changed,          * idempotent-rename, rename.          *           * The option will be converted to a          *<code>org.apache.camel.LoggingLevel</code> type.          *           * Group: lock          */
DECL|method|readLockLoggingLevel ( String readLockLoggingLevel)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockLoggingLevel
parameter_list|(
name|String
name|readLockLoggingLevel
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockLoggingLevel"
argument_list|,
name|readLockLoggingLevel
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to use marker file with the changed, rename, or exclusive          * read lock types. By default a marker file is used as well to guard          * against other processes picking up the same files. This behavior can          * be turned off by setting this option to false. For example if you do          * not want to write marker files to the file systems by the Camel          * application.          *           * The option is a:<code>boolean</code> type.          *           * Group: lock          */
DECL|method|readLockMarkerFile ( boolean readLockMarkerFile)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockMarkerFile
parameter_list|(
name|boolean
name|readLockMarkerFile
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockMarkerFile"
argument_list|,
name|readLockMarkerFile
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to use marker file with the changed, rename, or exclusive          * read lock types. By default a marker file is used as well to guard          * against other processes picking up the same files. This behavior can          * be turned off by setting this option to false. For example if you do          * not want to write marker files to the file systems by the Camel          * application.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: lock          */
DECL|method|readLockMarkerFile ( String readLockMarkerFile)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockMarkerFile
parameter_list|(
name|String
name|readLockMarkerFile
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockMarkerFile"
argument_list|,
name|readLockMarkerFile
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * This option is applied only for readLock=changed. It allows to          * specify a minimum age the file must be before attempting to acquire          * the read lock. For example use readLockMinAge=300s to require the          * file is at last 5 minutes old. This can speedup the changed read lock          * as it will only attempt to acquire files which are at least that          * given age.          *           * The option is a:<code>long</code> type.          *           * Group: lock          */
DECL|method|readLockMinAge (long readLockMinAge)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockMinAge
parameter_list|(
name|long
name|readLockMinAge
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockMinAge"
argument_list|,
name|readLockMinAge
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * This option is applied only for readLock=changed. It allows to          * specify a minimum age the file must be before attempting to acquire          * the read lock. For example use readLockMinAge=300s to require the          * file is at last 5 minutes old. This can speedup the changed read lock          * as it will only attempt to acquire files which are at least that          * given age.          *           * The option will be converted to a<code>long</code> type.          *           * Group: lock          */
DECL|method|readLockMinAge (String readLockMinAge)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockMinAge
parameter_list|(
name|String
name|readLockMinAge
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockMinAge"
argument_list|,
name|readLockMinAge
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * This option is applied only for readLock=changed. It allows you to          * configure a minimum file length. By default Camel expects the file to          * contain data, and thus the default value is 1. You can set this          * option to zero, to allow consuming zero-length files.          *           * The option is a:<code>long</code> type.          *           * Group: lock          */
DECL|method|readLockMinLength ( long readLockMinLength)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockMinLength
parameter_list|(
name|long
name|readLockMinLength
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockMinLength"
argument_list|,
name|readLockMinLength
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * This option is applied only for readLock=changed. It allows you to          * configure a minimum file length. By default Camel expects the file to          * contain data, and thus the default value is 1. You can set this          * option to zero, to allow consuming zero-length files.          *           * The option will be converted to a<code>long</code> type.          *           * Group: lock          */
DECL|method|readLockMinLength ( String readLockMinLength)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockMinLength
parameter_list|(
name|String
name|readLockMinLength
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockMinLength"
argument_list|,
name|readLockMinLength
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * This option is applied only for readLock=idempotent. It allows to          * specify whether to remove the file name entry from the idempotent          * repository when processing the file is succeeded and a commit          * happens. By default the file is not removed which ensures that any          * race-condition do not occur so another active node may attempt to          * grab the file. Instead the idempotent repository may support eviction          * strategies that you can configure to evict the file name entry after          * X minutes - this ensures no problems with race conditions. See more          * details at the readLockIdempotentReleaseDelay option.          *           * The option is a:<code>boolean</code> type.          *           * Group: lock          */
DECL|method|readLockRemoveOnCommit ( boolean readLockRemoveOnCommit)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockRemoveOnCommit
parameter_list|(
name|boolean
name|readLockRemoveOnCommit
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockRemoveOnCommit"
argument_list|,
name|readLockRemoveOnCommit
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * This option is applied only for readLock=idempotent. It allows to          * specify whether to remove the file name entry from the idempotent          * repository when processing the file is succeeded and a commit          * happens. By default the file is not removed which ensures that any          * race-condition do not occur so another active node may attempt to          * grab the file. Instead the idempotent repository may support eviction          * strategies that you can configure to evict the file name entry after          * X minutes - this ensures no problems with race conditions. See more          * details at the readLockIdempotentReleaseDelay option.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: lock          */
DECL|method|readLockRemoveOnCommit ( String readLockRemoveOnCommit)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockRemoveOnCommit
parameter_list|(
name|String
name|readLockRemoveOnCommit
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockRemoveOnCommit"
argument_list|,
name|readLockRemoveOnCommit
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * This option is applied only for readLock=idempotent. It allows to          * specify whether to remove the file name entry from the idempotent          * repository when processing the file failed and a rollback happens. If          * this option is false, then the file name entry is confirmed (as if          * the file did a commit).          *           * The option is a:<code>boolean</code> type.          *           * Group: lock          */
DECL|method|readLockRemoveOnRollback ( boolean readLockRemoveOnRollback)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockRemoveOnRollback
parameter_list|(
name|boolean
name|readLockRemoveOnRollback
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockRemoveOnRollback"
argument_list|,
name|readLockRemoveOnRollback
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * This option is applied only for readLock=idempotent. It allows to          * specify whether to remove the file name entry from the idempotent          * repository when processing the file failed and a rollback happens. If          * this option is false, then the file name entry is confirmed (as if          * the file did a commit).          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: lock          */
DECL|method|readLockRemoveOnRollback ( String readLockRemoveOnRollback)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockRemoveOnRollback
parameter_list|(
name|String
name|readLockRemoveOnRollback
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockRemoveOnRollback"
argument_list|,
name|readLockRemoveOnRollback
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Optional timeout in millis for the read-lock, if supported by the          * read-lock. If the read-lock could not be granted and the timeout          * triggered, then Camel will skip the file. At next poll Camel, will          * try the file again, and this time maybe the read-lock could be          * granted. Use a value of 0 or lower to indicate forever. Currently          * fileLock, changed and rename support the timeout. Notice: For FTP the          * default readLockTimeout value is 20000 instead of 10000. The          * readLockTimeout value must be higher than readLockCheckInterval, but          * a rule of thumb is to have a timeout that is at least 2 or more times          * higher than the readLockCheckInterval. This is needed to ensure that          * amble time is allowed for the read lock process to try to grab the          * lock before the timeout was hit.          *           * The option is a:<code>long</code> type.          *           * Group: lock          */
DECL|method|readLockTimeout (long readLockTimeout)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockTimeout
parameter_list|(
name|long
name|readLockTimeout
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockTimeout"
argument_list|,
name|readLockTimeout
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Optional timeout in millis for the read-lock, if supported by the          * read-lock. If the read-lock could not be granted and the timeout          * triggered, then Camel will skip the file. At next poll Camel, will          * try the file again, and this time maybe the read-lock could be          * granted. Use a value of 0 or lower to indicate forever. Currently          * fileLock, changed and rename support the timeout. Notice: For FTP the          * default readLockTimeout value is 20000 instead of 10000. The          * readLockTimeout value must be higher than readLockCheckInterval, but          * a rule of thumb is to have a timeout that is at least 2 or more times          * higher than the readLockCheckInterval. This is needed to ensure that          * amble time is allowed for the read lock process to try to grab the          * lock before the timeout was hit.          *           * The option will be converted to a<code>long</code> type.          *           * Group: lock          */
DECL|method|readLockTimeout ( String readLockTimeout)
specifier|default
name|FileEndpointConsumerBuilder
name|readLockTimeout
parameter_list|(
name|String
name|readLockTimeout
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"readLockTimeout"
argument_list|,
name|readLockTimeout
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The number of subsequent error polls (failed due some error) that          * should happen before the backoffMultipler should kick-in.          *           * The option is a:<code>int</code> type.          *           * Group: scheduler          */
DECL|method|backoffErrorThreshold ( int backoffErrorThreshold)
specifier|default
name|FileEndpointConsumerBuilder
name|backoffErrorThreshold
parameter_list|(
name|int
name|backoffErrorThreshold
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"backoffErrorThreshold"
argument_list|,
name|backoffErrorThreshold
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The number of subsequent error polls (failed due some error) that          * should happen before the backoffMultipler should kick-in.          *           * The option will be converted to a<code>int</code> type.          *           * Group: scheduler          */
DECL|method|backoffErrorThreshold ( String backoffErrorThreshold)
specifier|default
name|FileEndpointConsumerBuilder
name|backoffErrorThreshold
parameter_list|(
name|String
name|backoffErrorThreshold
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"backoffErrorThreshold"
argument_list|,
name|backoffErrorThreshold
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The number of subsequent idle polls that should happen before the          * backoffMultipler should kick-in.          *           * The option is a:<code>int</code> type.          *           * Group: scheduler          */
DECL|method|backoffIdleThreshold ( int backoffIdleThreshold)
specifier|default
name|FileEndpointConsumerBuilder
name|backoffIdleThreshold
parameter_list|(
name|int
name|backoffIdleThreshold
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"backoffIdleThreshold"
argument_list|,
name|backoffIdleThreshold
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The number of subsequent idle polls that should happen before the          * backoffMultipler should kick-in.          *           * The option will be converted to a<code>int</code> type.          *           * Group: scheduler          */
DECL|method|backoffIdleThreshold ( String backoffIdleThreshold)
specifier|default
name|FileEndpointConsumerBuilder
name|backoffIdleThreshold
parameter_list|(
name|String
name|backoffIdleThreshold
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"backoffIdleThreshold"
argument_list|,
name|backoffIdleThreshold
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To let the scheduled polling consumer backoff if there has been a          * number of subsequent idles/errors in a row. The multiplier is then          * the number of polls that will be skipped before the next actual          * attempt is happening again. When this option is in use then          * backoffIdleThreshold and/or backoffErrorThreshold must also be          * configured.          *           * The option is a:<code>int</code> type.          *           * Group: scheduler          */
DECL|method|backoffMultiplier ( int backoffMultiplier)
specifier|default
name|FileEndpointConsumerBuilder
name|backoffMultiplier
parameter_list|(
name|int
name|backoffMultiplier
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"backoffMultiplier"
argument_list|,
name|backoffMultiplier
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To let the scheduled polling consumer backoff if there has been a          * number of subsequent idles/errors in a row. The multiplier is then          * the number of polls that will be skipped before the next actual          * attempt is happening again. When this option is in use then          * backoffIdleThreshold and/or backoffErrorThreshold must also be          * configured.          *           * The option will be converted to a<code>int</code> type.          *           * Group: scheduler          */
DECL|method|backoffMultiplier ( String backoffMultiplier)
specifier|default
name|FileEndpointConsumerBuilder
name|backoffMultiplier
parameter_list|(
name|String
name|backoffMultiplier
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"backoffMultiplier"
argument_list|,
name|backoffMultiplier
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Milliseconds before the next poll. You can also specify time values          * using units, such as 60s (60 seconds), 5m30s (5 minutes and 30          * seconds), and 1h (1 hour).          *           * The option is a:<code>long</code> type.          *           * Group: scheduler          */
DECL|method|delay (long delay)
specifier|default
name|FileEndpointConsumerBuilder
name|delay
parameter_list|(
name|long
name|delay
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"delay"
argument_list|,
name|delay
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Milliseconds before the next poll. You can also specify time values          * using units, such as 60s (60 seconds), 5m30s (5 minutes and 30          * seconds), and 1h (1 hour).          *           * The option will be converted to a<code>long</code> type.          *           * Group: scheduler          */
DECL|method|delay (String delay)
specifier|default
name|FileEndpointConsumerBuilder
name|delay
parameter_list|(
name|String
name|delay
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"delay"
argument_list|,
name|delay
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If greedy is enabled, then the ScheduledPollConsumer will run          * immediately again, if the previous run polled 1 or more messages.          *           * The option is a:<code>boolean</code> type.          *           * Group: scheduler          */
DECL|method|greedy (boolean greedy)
specifier|default
name|FileEndpointConsumerBuilder
name|greedy
parameter_list|(
name|boolean
name|greedy
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"greedy"
argument_list|,
name|greedy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If greedy is enabled, then the ScheduledPollConsumer will run          * immediately again, if the previous run polled 1 or more messages.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: scheduler          */
DECL|method|greedy (String greedy)
specifier|default
name|FileEndpointConsumerBuilder
name|greedy
parameter_list|(
name|String
name|greedy
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"greedy"
argument_list|,
name|greedy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Milliseconds before the first poll starts. You can also specify time          * values using units, such as 60s (60 seconds), 5m30s (5 minutes and 30          * seconds), and 1h (1 hour).          *           * The option is a:<code>long</code> type.          *           * Group: scheduler          */
DECL|method|initialDelay (long initialDelay)
specifier|default
name|FileEndpointConsumerBuilder
name|initialDelay
parameter_list|(
name|long
name|initialDelay
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"initialDelay"
argument_list|,
name|initialDelay
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Milliseconds before the first poll starts. You can also specify time          * values using units, such as 60s (60 seconds), 5m30s (5 minutes and 30          * seconds), and 1h (1 hour).          *           * The option will be converted to a<code>long</code> type.          *           * Group: scheduler          */
DECL|method|initialDelay (String initialDelay)
specifier|default
name|FileEndpointConsumerBuilder
name|initialDelay
parameter_list|(
name|String
name|initialDelay
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"initialDelay"
argument_list|,
name|initialDelay
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The consumer logs a start/complete log line when it polls. This          * option allows you to configure the logging level for that.          *           * The option is a:<code>org.apache.camel.LoggingLevel</code> type.          *           * Group: scheduler          */
DECL|method|runLoggingLevel ( LoggingLevel runLoggingLevel)
specifier|default
name|FileEndpointConsumerBuilder
name|runLoggingLevel
parameter_list|(
name|LoggingLevel
name|runLoggingLevel
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"runLoggingLevel"
argument_list|,
name|runLoggingLevel
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The consumer logs a start/complete log line when it polls. This          * option allows you to configure the logging level for that.          *           * The option will be converted to a          *<code>org.apache.camel.LoggingLevel</code> type.          *           * Group: scheduler          */
DECL|method|runLoggingLevel ( String runLoggingLevel)
specifier|default
name|FileEndpointConsumerBuilder
name|runLoggingLevel
parameter_list|(
name|String
name|runLoggingLevel
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"runLoggingLevel"
argument_list|,
name|runLoggingLevel
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Allows for configuring a custom/shared thread pool to use for the          * consumer. By default each consumer has its own single threaded thread          * pool.          *           * The option is a:          *<code>java.util.concurrent.ScheduledExecutorService</code> type.          *           * Group: scheduler          */
DECL|method|scheduledExecutorService ( ScheduledExecutorService scheduledExecutorService)
specifier|default
name|FileEndpointConsumerBuilder
name|scheduledExecutorService
parameter_list|(
name|ScheduledExecutorService
name|scheduledExecutorService
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"scheduledExecutorService"
argument_list|,
name|scheduledExecutorService
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Allows for configuring a custom/shared thread pool to use for the          * consumer. By default each consumer has its own single threaded thread          * pool.          *           * The option will be converted to a          *<code>java.util.concurrent.ScheduledExecutorService</code> type.          *           * Group: scheduler          */
DECL|method|scheduledExecutorService ( String scheduledExecutorService)
specifier|default
name|FileEndpointConsumerBuilder
name|scheduledExecutorService
parameter_list|(
name|String
name|scheduledExecutorService
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"scheduledExecutorService"
argument_list|,
name|scheduledExecutorService
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use a cron scheduler from either camel-spring or camel-quartz2          * component.          *           * The option is a:          *<code>org.apache.camel.spi.ScheduledPollConsumerScheduler</code>          * type.          *           * Group: scheduler          */
DECL|method|scheduler ( ScheduledPollConsumerScheduler scheduler)
specifier|default
name|FileEndpointConsumerBuilder
name|scheduler
parameter_list|(
name|ScheduledPollConsumerScheduler
name|scheduler
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"scheduler"
argument_list|,
name|scheduler
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use a cron scheduler from either camel-spring or camel-quartz2          * component.          *           * The option will be converted to a          *<code>org.apache.camel.spi.ScheduledPollConsumerScheduler</code>          * type.          *           * Group: scheduler          */
DECL|method|scheduler (String scheduler)
specifier|default
name|FileEndpointConsumerBuilder
name|scheduler
parameter_list|(
name|String
name|scheduler
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"scheduler"
argument_list|,
name|scheduler
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To configure additional properties when using a custom scheduler or          * any of the Quartz2, Spring based scheduler.          *           * The option is a:<code>java.util.Map&lt;java.lang.String,          * java.lang.Object&gt;</code> type.          *           * Group: scheduler          */
DECL|method|schedulerProperties ( Map<String, Object> schedulerProperties)
specifier|default
name|FileEndpointConsumerBuilder
name|schedulerProperties
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|schedulerProperties
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"schedulerProperties"
argument_list|,
name|schedulerProperties
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To configure additional properties when using a custom scheduler or          * any of the Quartz2, Spring based scheduler.          *           * The option will be converted to a          *<code>java.util.Map&lt;java.lang.String, java.lang.Object&gt;</code>          * type.          *           * Group: scheduler          */
DECL|method|schedulerProperties ( String schedulerProperties)
specifier|default
name|FileEndpointConsumerBuilder
name|schedulerProperties
parameter_list|(
name|String
name|schedulerProperties
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"schedulerProperties"
argument_list|,
name|schedulerProperties
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the scheduler should be auto started.          *           * The option is a:<code>boolean</code> type.          *           * Group: scheduler          */
DECL|method|startScheduler ( boolean startScheduler)
specifier|default
name|FileEndpointConsumerBuilder
name|startScheduler
parameter_list|(
name|boolean
name|startScheduler
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"startScheduler"
argument_list|,
name|startScheduler
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the scheduler should be auto started.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: scheduler          */
DECL|method|startScheduler (String startScheduler)
specifier|default
name|FileEndpointConsumerBuilder
name|startScheduler
parameter_list|(
name|String
name|startScheduler
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"startScheduler"
argument_list|,
name|startScheduler
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Time unit for initialDelay and delay options.          *           * The option is a:<code>java.util.concurrent.TimeUnit</code> type.          *           * Group: scheduler          */
DECL|method|timeUnit (TimeUnit timeUnit)
specifier|default
name|FileEndpointConsumerBuilder
name|timeUnit
parameter_list|(
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"timeUnit"
argument_list|,
name|timeUnit
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Time unit for initialDelay and delay options.          *           * The option will be converted to a          *<code>java.util.concurrent.TimeUnit</code> type.          *           * Group: scheduler          */
DECL|method|timeUnit (String timeUnit)
specifier|default
name|FileEndpointConsumerBuilder
name|timeUnit
parameter_list|(
name|String
name|timeUnit
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"timeUnit"
argument_list|,
name|timeUnit
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Controls if fixed delay or fixed rate is used. See          * ScheduledExecutorService in JDK for details.          *           * The option is a:<code>boolean</code> type.          *           * Group: scheduler          */
DECL|method|useFixedDelay (boolean useFixedDelay)
specifier|default
name|FileEndpointConsumerBuilder
name|useFixedDelay
parameter_list|(
name|boolean
name|useFixedDelay
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"useFixedDelay"
argument_list|,
name|useFixedDelay
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Controls if fixed delay or fixed rate is used. See          * ScheduledExecutorService in JDK for details.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: scheduler          */
DECL|method|useFixedDelay (String useFixedDelay)
specifier|default
name|FileEndpointConsumerBuilder
name|useFixedDelay
parameter_list|(
name|String
name|useFixedDelay
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"useFixedDelay"
argument_list|,
name|useFixedDelay
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To shuffle the list of files (sort in random order).          *           * The option is a:<code>boolean</code> type.          *           * Group: sort          */
DECL|method|shuffle (boolean shuffle)
specifier|default
name|FileEndpointConsumerBuilder
name|shuffle
parameter_list|(
name|boolean
name|shuffle
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"shuffle"
argument_list|,
name|shuffle
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To shuffle the list of files (sort in random order).          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: sort          */
DECL|method|shuffle (String shuffle)
specifier|default
name|FileEndpointConsumerBuilder
name|shuffle
parameter_list|(
name|String
name|shuffle
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"shuffle"
argument_list|,
name|shuffle
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Built-in sort by using the File Language. Supports nested sorts, so          * you can have a sort by file name and as a 2nd group sort by modified          * date.          *           * The option is a:          *<code>java.util.Comparator&lt;org.apache.camel.Exchange&gt;</code>          * type.          *           * Group: sort          */
DECL|method|sortBy (Comparator<Exchange> sortBy)
specifier|default
name|FileEndpointConsumerBuilder
name|sortBy
parameter_list|(
name|Comparator
argument_list|<
name|Exchange
argument_list|>
name|sortBy
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"sortBy"
argument_list|,
name|sortBy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Built-in sort by using the File Language. Supports nested sorts, so          * you can have a sort by file name and as a 2nd group sort by modified          * date.          *           * The option will be converted to a          *<code>java.util.Comparator&lt;org.apache.camel.Exchange&gt;</code>          * type.          *           * Group: sort          */
DECL|method|sortBy (String sortBy)
specifier|default
name|FileEndpointConsumerBuilder
name|sortBy
parameter_list|(
name|String
name|sortBy
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"sortBy"
argument_list|,
name|sortBy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Pluggable sorter as a java.util.Comparator class.          *           * The option is a:          *<code>java.util.Comparator&lt;org.apache.camel.component.file.GenericFile&lt;java.io.File&gt;&gt;</code> type.          *           * Group: sort          */
DECL|method|sorter (Comparator<Object> sorter)
specifier|default
name|FileEndpointConsumerBuilder
name|sorter
parameter_list|(
name|Comparator
argument_list|<
name|Object
argument_list|>
name|sorter
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"sorter"
argument_list|,
name|sorter
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Pluggable sorter as a java.util.Comparator class.          *           * The option will be converted to a          *<code>java.util.Comparator&lt;org.apache.camel.component.file.GenericFile&lt;java.io.File&gt;&gt;</code> type.          *           * Group: sort          */
DECL|method|sorter (String sorter)
specifier|default
name|FileEndpointConsumerBuilder
name|sorter
parameter_list|(
name|String
name|sorter
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"sorter"
argument_list|,
name|sorter
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
comment|/**      * Advanced builder for endpoint consumers for the File component.      */
DECL|interface|AdvancedFileEndpointConsumerBuilder
specifier|public
interface|interface
name|AdvancedFileEndpointConsumerBuilder
extends|extends
name|EndpointConsumerBuilder
block|{
DECL|method|basic ()
specifier|default
name|FileEndpointConsumerBuilder
name|basic
parameter_list|()
block|{
return|return
operator|(
name|FileEndpointConsumerBuilder
operator|)
name|this
return|;
block|}
comment|/**          * Similar to the startingDirectoryMustExist option but this applies          * during polling (after starting the consumer).          *           * The option is a:<code>boolean</code> type.          *           * Group: consumer (advanced)          */
DECL|method|directoryMustExist ( boolean directoryMustExist)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|directoryMustExist
parameter_list|(
name|boolean
name|directoryMustExist
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"directoryMustExist"
argument_list|,
name|directoryMustExist
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Similar to the startingDirectoryMustExist option but this applies          * during polling (after starting the consumer).          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: consumer (advanced)          */
DECL|method|directoryMustExist ( String directoryMustExist)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|directoryMustExist
parameter_list|(
name|String
name|directoryMustExist
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"directoryMustExist"
argument_list|,
name|directoryMustExist
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To let the consumer use a custom ExceptionHandler. Notice if the          * option bridgeErrorHandler is enabled then this option is not in use.          * By default the consumer will deal with exceptions, that will be          * logged at WARN or ERROR level and ignored.          *           * The option is a:<code>org.apache.camel.spi.ExceptionHandler</code>          * type.          *           * Group: consumer (advanced)          */
DECL|method|exceptionHandler ( ExceptionHandler exceptionHandler)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|exceptionHandler
parameter_list|(
name|ExceptionHandler
name|exceptionHandler
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"exceptionHandler"
argument_list|,
name|exceptionHandler
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To let the consumer use a custom ExceptionHandler. Notice if the          * option bridgeErrorHandler is enabled then this option is not in use.          * By default the consumer will deal with exceptions, that will be          * logged at WARN or ERROR level and ignored.          *           * The option will be converted to a          *<code>org.apache.camel.spi.ExceptionHandler</code> type.          *           * Group: consumer (advanced)          */
DECL|method|exceptionHandler ( String exceptionHandler)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|exceptionHandler
parameter_list|(
name|String
name|exceptionHandler
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"exceptionHandler"
argument_list|,
name|exceptionHandler
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets the exchange pattern when the consumer creates an exchange.          *           * The option is a:<code>org.apache.camel.ExchangePattern</code> type.          *           * Group: consumer (advanced)          */
DECL|method|exchangePattern ( ExchangePattern exchangePattern)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|exchangePattern
parameter_list|(
name|ExchangePattern
name|exchangePattern
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"exchangePattern"
argument_list|,
name|exchangePattern
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets the exchange pattern when the consumer creates an exchange.          *           * The option will be converted to a          *<code>org.apache.camel.ExchangePattern</code> type.          *           * Group: consumer (advanced)          */
DECL|method|exchangePattern ( String exchangePattern)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|exchangePattern
parameter_list|(
name|String
name|exchangePattern
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"exchangePattern"
argument_list|,
name|exchangePattern
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To define which file attributes of interest. Like          * posix:permissions,posix:owner,basic:lastAccessTime, it supports basic          * wildcard like posix:, basic:lastAccessTime.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: consumer (advanced)          */
DECL|method|extendedAttributes ( String extendedAttributes)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|extendedAttributes
parameter_list|(
name|String
name|extendedAttributes
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"extendedAttributes"
argument_list|,
name|extendedAttributes
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * A pluggable in-progress repository          * org.apache.camel.spi.IdempotentRepository. The in-progress repository          * is used to account the current in progress files being consumed. By          * default a memory based repository is used.          *           * The option is a:          *<code>org.apache.camel.spi.IdempotentRepository</code> type.          *           * Group: consumer (advanced)          */
DECL|method|inProgressRepository ( IdempotentRepository inProgressRepository)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|inProgressRepository
parameter_list|(
name|IdempotentRepository
name|inProgressRepository
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"inProgressRepository"
argument_list|,
name|inProgressRepository
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * A pluggable in-progress repository          * org.apache.camel.spi.IdempotentRepository. The in-progress repository          * is used to account the current in progress files being consumed. By          * default a memory based repository is used.          *           * The option will be converted to a          *<code>org.apache.camel.spi.IdempotentRepository</code> type.          *           * Group: consumer (advanced)          */
DECL|method|inProgressRepository ( String inProgressRepository)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|inProgressRepository
parameter_list|(
name|String
name|inProgressRepository
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"inProgressRepository"
argument_list|,
name|inProgressRepository
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * When consuming, a local work directory can be used to store the          * remote file content directly in local files, to avoid loading the          * content into memory. This is beneficial, if you consume a very big          * remote file and thus can conserve memory.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: consumer (advanced)          */
DECL|method|localWorkDirectory ( String localWorkDirectory)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|localWorkDirectory
parameter_list|(
name|String
name|localWorkDirectory
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"localWorkDirectory"
argument_list|,
name|localWorkDirectory
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use a custom org.apache.camel.spi.ExceptionHandler to handle any          * thrown exceptions that happens during the file on completion process          * where the consumer does either a commit or rollback. The default          * implementation will log any exception at WARN level and ignore.          *           * The option is a:<code>org.apache.camel.spi.ExceptionHandler</code>          * type.          *           * Group: consumer (advanced)          */
DECL|method|onCompletionExceptionHandler ( ExceptionHandler onCompletionExceptionHandler)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|onCompletionExceptionHandler
parameter_list|(
name|ExceptionHandler
name|onCompletionExceptionHandler
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"onCompletionExceptionHandler"
argument_list|,
name|onCompletionExceptionHandler
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use a custom org.apache.camel.spi.ExceptionHandler to handle any          * thrown exceptions that happens during the file on completion process          * where the consumer does either a commit or rollback. The default          * implementation will log any exception at WARN level and ignore.          *           * The option will be converted to a          *<code>org.apache.camel.spi.ExceptionHandler</code> type.          *           * Group: consumer (advanced)          */
DECL|method|onCompletionExceptionHandler ( String onCompletionExceptionHandler)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|onCompletionExceptionHandler
parameter_list|(
name|String
name|onCompletionExceptionHandler
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"onCompletionExceptionHandler"
argument_list|,
name|onCompletionExceptionHandler
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing          * you to provide your custom implementation to control error handling          * usually occurred during the poll operation before an Exchange have          * been created and being routed in Camel.          *           * The option is a:          *<code>org.apache.camel.spi.PollingConsumerPollStrategy</code> type.          *           * Group: consumer (advanced)          */
DECL|method|pollStrategy ( PollingConsumerPollStrategy pollStrategy)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|pollStrategy
parameter_list|(
name|PollingConsumerPollStrategy
name|pollStrategy
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"pollStrategy"
argument_list|,
name|pollStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing          * you to provide your custom implementation to control error handling          * usually occurred during the poll operation before an Exchange have          * been created and being routed in Camel.          *           * The option will be converted to a          *<code>org.apache.camel.spi.PollingConsumerPollStrategy</code> type.          *           * Group: consumer (advanced)          */
DECL|method|pollStrategy ( String pollStrategy)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|pollStrategy
parameter_list|(
name|String
name|pollStrategy
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"pollStrategy"
argument_list|,
name|pollStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to enable probing of the content type. If enable then the          * consumer uses Files#probeContentType(java.nio.file.Path) to determine          * the content-type of the file, and store that as a header with key          * Exchange#FILE_CONTENT_TYPE on the Message.          *           * The option is a:<code>boolean</code> type.          *           * Group: consumer (advanced)          */
DECL|method|probeContentType ( boolean probeContentType)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|probeContentType
parameter_list|(
name|boolean
name|probeContentType
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"probeContentType"
argument_list|,
name|probeContentType
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to enable probing of the content type. If enable then the          * consumer uses Files#probeContentType(java.nio.file.Path) to determine          * the content-type of the file, and store that as a header with key          * Exchange#FILE_CONTENT_TYPE on the Message.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: consumer (advanced)          */
DECL|method|probeContentType ( String probeContentType)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|probeContentType
parameter_list|(
name|String
name|probeContentType
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"probeContentType"
argument_list|,
name|probeContentType
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * A pluggable          * org.apache.camel.component.file.GenericFileProcessStrategy allowing          * you to implement your own readLock option or similar. Can also be          * used when special conditions must be met before a file can be          * consumed, such as a special ready file exists. If this option is set          * then the readLock option does not apply.          *           * The option is a:          *<code>org.apache.camel.component.file.GenericFileProcessStrategy&lt;java.io.File&gt;</code> type.          *           * Group: consumer (advanced)          */
DECL|method|processStrategy ( Object processStrategy)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|processStrategy
parameter_list|(
name|Object
name|processStrategy
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"processStrategy"
argument_list|,
name|processStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * A pluggable          * org.apache.camel.component.file.GenericFileProcessStrategy allowing          * you to implement your own readLock option or similar. Can also be          * used when special conditions must be met before a file can be          * consumed, such as a special ready file exists. If this option is set          * then the readLock option does not apply.          *           * The option will be converted to a          *<code>org.apache.camel.component.file.GenericFileProcessStrategy&lt;java.io.File&gt;</code> type.          *           * Group: consumer (advanced)          */
DECL|method|processStrategy ( String processStrategy)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|processStrategy
parameter_list|(
name|String
name|processStrategy
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"processStrategy"
argument_list|,
name|processStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the starting directory must exist. Mind that the autoCreate          * option is default enabled, which means the starting directory is          * normally auto created if it doesn't exist. You can disable autoCreate          * and enable this to ensure the starting directory must exist. Will          * thrown an exception if the directory doesn't exist.          *           * The option is a:<code>boolean</code> type.          *           * Group: consumer (advanced)          */
DECL|method|startingDirectoryMustExist ( boolean startingDirectoryMustExist)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|startingDirectoryMustExist
parameter_list|(
name|boolean
name|startingDirectoryMustExist
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"startingDirectoryMustExist"
argument_list|,
name|startingDirectoryMustExist
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the starting directory must exist. Mind that the autoCreate          * option is default enabled, which means the starting directory is          * normally auto created if it doesn't exist. You can disable autoCreate          * and enable this to ensure the starting directory must exist. Will          * thrown an exception if the directory doesn't exist.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: consumer (advanced)          */
DECL|method|startingDirectoryMustExist ( String startingDirectoryMustExist)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|startingDirectoryMustExist
parameter_list|(
name|String
name|startingDirectoryMustExist
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"startingDirectoryMustExist"
argument_list|,
name|startingDirectoryMustExist
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the starting directory has access permissions. Mind that the          * startingDirectoryMustExist parameter must be set to true in order to          * verify that the directory exists. Will thrown an exception if the          * directory doesn't have read and write permissions.          *           * The option is a:<code>boolean</code> type.          *           * Group: consumer (advanced)          */
DECL|method|startingDirectoryMustHaveAccess ( boolean startingDirectoryMustHaveAccess)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|startingDirectoryMustHaveAccess
parameter_list|(
name|boolean
name|startingDirectoryMustHaveAccess
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"startingDirectoryMustHaveAccess"
argument_list|,
name|startingDirectoryMustHaveAccess
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the starting directory has access permissions. Mind that the          * startingDirectoryMustExist parameter must be set to true in order to          * verify that the directory exists. Will thrown an exception if the          * directory doesn't have read and write permissions.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: consumer (advanced)          */
DECL|method|startingDirectoryMustHaveAccess ( String startingDirectoryMustHaveAccess)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|startingDirectoryMustHaveAccess
parameter_list|(
name|String
name|startingDirectoryMustHaveAccess
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"startingDirectoryMustHaveAccess"
argument_list|,
name|startingDirectoryMustHaveAccess
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Automatically create missing directories in the file's pathname. For          * the file consumer, that means creating the starting directory. For          * the file producer, it means the directory the files should be written          * to.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|autoCreate ( boolean autoCreate)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|autoCreate
parameter_list|(
name|boolean
name|autoCreate
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"autoCreate"
argument_list|,
name|autoCreate
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Automatically create missing directories in the file's pathname. For          * the file consumer, that means creating the starting directory. For          * the file producer, it means the directory the files should be written          * to.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|autoCreate (String autoCreate)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|autoCreate
parameter_list|(
name|String
name|autoCreate
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"autoCreate"
argument_list|,
name|autoCreate
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the endpoint should use basic property binding (Camel 2.x) or          * the newer property binding with additional capabilities.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|basicPropertyBinding ( boolean basicPropertyBinding)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|basicPropertyBinding
parameter_list|(
name|boolean
name|basicPropertyBinding
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"basicPropertyBinding"
argument_list|,
name|basicPropertyBinding
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the endpoint should use basic property binding (Camel 2.x) or          * the newer property binding with additional capabilities.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|basicPropertyBinding ( String basicPropertyBinding)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|basicPropertyBinding
parameter_list|(
name|String
name|basicPropertyBinding
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"basicPropertyBinding"
argument_list|,
name|basicPropertyBinding
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Write buffer sized in bytes.          *           * The option is a:<code>int</code> type.          *           * Group: advanced          */
DECL|method|bufferSize (int bufferSize)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|bufferSize
parameter_list|(
name|int
name|bufferSize
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"bufferSize"
argument_list|,
name|bufferSize
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Write buffer sized in bytes.          *           * The option will be converted to a<code>int</code> type.          *           * Group: advanced          */
DECL|method|bufferSize (String bufferSize)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|bufferSize
parameter_list|(
name|String
name|bufferSize
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"bufferSize"
argument_list|,
name|bufferSize
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to fallback and do a copy and delete file, in case the file          * could not be renamed directly. This option is not available for the          * FTP component.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|copyAndDeleteOnRenameFail ( boolean copyAndDeleteOnRenameFail)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|copyAndDeleteOnRenameFail
parameter_list|(
name|boolean
name|copyAndDeleteOnRenameFail
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"copyAndDeleteOnRenameFail"
argument_list|,
name|copyAndDeleteOnRenameFail
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to fallback and do a copy and delete file, in case the file          * could not be renamed directly. This option is not available for the          * FTP component.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|copyAndDeleteOnRenameFail ( String copyAndDeleteOnRenameFail)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|copyAndDeleteOnRenameFail
parameter_list|(
name|String
name|copyAndDeleteOnRenameFail
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"copyAndDeleteOnRenameFail"
argument_list|,
name|copyAndDeleteOnRenameFail
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Perform rename operations using a copy and delete strategy. This is          * primarily used in environments where the regular rename operation is          * unreliable (e.g. across different file systems or networks). This          * option takes precedence over the copyAndDeleteOnRenameFail parameter          * that will automatically fall back to the copy and delete strategy,          * but only after additional delays.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|renameUsingCopy ( boolean renameUsingCopy)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|renameUsingCopy
parameter_list|(
name|boolean
name|renameUsingCopy
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"renameUsingCopy"
argument_list|,
name|renameUsingCopy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Perform rename operations using a copy and delete strategy. This is          * primarily used in environments where the regular rename operation is          * unreliable (e.g. across different file systems or networks). This          * option takes precedence over the copyAndDeleteOnRenameFail parameter          * that will automatically fall back to the copy and delete strategy,          * but only after additional delays.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|renameUsingCopy ( String renameUsingCopy)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|renameUsingCopy
parameter_list|(
name|String
name|renameUsingCopy
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"renameUsingCopy"
argument_list|,
name|renameUsingCopy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets whether synchronous processing should be strictly used, or Camel          * is allowed to use asynchronous processing (if supported).          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|synchronous ( boolean synchronous)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|synchronous
parameter_list|(
name|boolean
name|synchronous
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"synchronous"
argument_list|,
name|synchronous
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets whether synchronous processing should be strictly used, or Camel          * is allowed to use asynchronous processing (if supported).          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|synchronous ( String synchronous)
specifier|default
name|AdvancedFileEndpointConsumerBuilder
name|synchronous
parameter_list|(
name|String
name|synchronous
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"synchronous"
argument_list|,
name|synchronous
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
comment|/**      * Builder for endpoint producers for the File component.      */
DECL|interface|FileEndpointProducerBuilder
specifier|public
interface|interface
name|FileEndpointProducerBuilder
extends|extends
name|EndpointProducerBuilder
block|{
DECL|method|advanced ()
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|advanced
parameter_list|()
block|{
return|return
operator|(
name|AdvancedFileEndpointProducerBuilder
operator|)
name|this
return|;
block|}
comment|/**          * The starting directory.          *           * The option is a:<code>java.io.File</code> type.          *           * Group: common          */
DECL|method|directoryName (File directoryName)
specifier|default
name|FileEndpointProducerBuilder
name|directoryName
parameter_list|(
name|File
name|directoryName
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"directoryName"
argument_list|,
name|directoryName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The starting directory.          *           * The option will be converted to a<code>java.io.File</code> type.          *           * Group: common          */
DECL|method|directoryName (String directoryName)
specifier|default
name|FileEndpointProducerBuilder
name|directoryName
parameter_list|(
name|String
name|directoryName
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"directoryName"
argument_list|,
name|directoryName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * This option is used to specify the encoding of the file. You can use          * this on the consumer, to specify the encodings of the files, which          * allow Camel to know the charset it should load the file content in          * case the file content is being accessed. Likewise when writing a          * file, you can use this option to specify which charset to write the          * file as well. Do mind that when writing the file Camel may have to          * read the message content into memory to be able to convert the data          * into the configured charset, so do not use this if you have big          * messages.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: common          */
DECL|method|charset (String charset)
specifier|default
name|FileEndpointProducerBuilder
name|charset
parameter_list|(
name|String
name|charset
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"charset"
argument_list|,
name|charset
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Producer: If provided, then Camel will write a 2nd done file when the          * original file has been written. The done file will be empty. This          * option configures what file name to use. Either you can specify a          * fixed name. Or you can use dynamic placeholders. The done file will          * always be written in the same folder as the original file. Consumer:          * If provided, Camel will only consume files if a done file exists.          * This option configures what file name to use. Either you can specify          * a fixed name. Or you can use dynamic placeholders.The done file is          * always expected in the same folder as the original file. Only          * ${file.name} and ${file.name.noext} is supported as dynamic          * placeholders.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: common          */
DECL|method|doneFileName (String doneFileName)
specifier|default
name|FileEndpointProducerBuilder
name|doneFileName
parameter_list|(
name|String
name|doneFileName
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"doneFileName"
argument_list|,
name|doneFileName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Use Expression such as File Language to dynamically set the filename.          * For consumers, it's used as a filename filter. For producers, it's          * used to evaluate the filename to write. If an expression is set, it          * take precedence over the CamelFileName header. (Note: The header          * itself can also be an Expression). The expression options support          * both String and Expression types. If the expression is a String type,          * it is always evaluated using the File Language. If the expression is          * an Expression type, the specified Expression type is used - this          * allows you, for instance, to use OGNL expressions. For the consumer,          * you can use it to filter filenames, so you can for instance consume          * today's file using the File Language syntax:          * mydata-${date:now:yyyyMMdd}.txt. The producers support the          * CamelOverruleFileName header which takes precedence over any existing          * CamelFileName header; the CamelOverruleFileName is a header that is          * used only once, and makes it easier as this avoids to temporary store          * CamelFileName and have to restore it afterwards.          *           * The option is a:<code>org.apache.camel.Expression</code> type.          *           * Group: common          */
DECL|method|fileName (Expression fileName)
specifier|default
name|FileEndpointProducerBuilder
name|fileName
parameter_list|(
name|Expression
name|fileName
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"fileName"
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Use Expression such as File Language to dynamically set the filename.          * For consumers, it's used as a filename filter. For producers, it's          * used to evaluate the filename to write. If an expression is set, it          * take precedence over the CamelFileName header. (Note: The header          * itself can also be an Expression). The expression options support          * both String and Expression types. If the expression is a String type,          * it is always evaluated using the File Language. If the expression is          * an Expression type, the specified Expression type is used - this          * allows you, for instance, to use OGNL expressions. For the consumer,          * you can use it to filter filenames, so you can for instance consume          * today's file using the File Language syntax:          * mydata-${date:now:yyyyMMdd}.txt. The producers support the          * CamelOverruleFileName header which takes precedence over any existing          * CamelFileName header; the CamelOverruleFileName is a header that is          * used only once, and makes it easier as this avoids to temporary store          * CamelFileName and have to restore it afterwards.          *           * The option will be converted to a          *<code>org.apache.camel.Expression</code> type.          *           * Group: common          */
DECL|method|fileName (String fileName)
specifier|default
name|FileEndpointProducerBuilder
name|fileName
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"fileName"
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * What to do if a file already exists with the same name. Override,          * which is the default, replaces the existing file. Append - adds          * content to the existing file. Fail - throws a          * GenericFileOperationException, indicating that there is already an          * existing file. Ignore - silently ignores the problem and does not          * override the existing file, but assumes everything is okay. Move -          * option requires to use the moveExisting option to be configured as          * well. The option eagerDeleteTargetFile can be used to control what to          * do if an moving the file, and there exists already an existing file,          * otherwise causing the move operation to fail. The Move option will          * move any existing files, before writing the target file. TryRename is          * only applicable if tempFileName option is in use. This allows to try          * renaming the file from the temporary name to the actual name, without          * doing any exists check. This check may be faster on some file systems          * and especially FTP servers.          *           * The option is a:          *<code>org.apache.camel.component.file.GenericFileExist</code> type.          *           * Group: producer          */
DECL|method|fileExist (GenericFileExist fileExist)
specifier|default
name|FileEndpointProducerBuilder
name|fileExist
parameter_list|(
name|GenericFileExist
name|fileExist
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"fileExist"
argument_list|,
name|fileExist
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * What to do if a file already exists with the same name. Override,          * which is the default, replaces the existing file. Append - adds          * content to the existing file. Fail - throws a          * GenericFileOperationException, indicating that there is already an          * existing file. Ignore - silently ignores the problem and does not          * override the existing file, but assumes everything is okay. Move -          * option requires to use the moveExisting option to be configured as          * well. The option eagerDeleteTargetFile can be used to control what to          * do if an moving the file, and there exists already an existing file,          * otherwise causing the move operation to fail. The Move option will          * move any existing files, before writing the target file. TryRename is          * only applicable if tempFileName option is in use. This allows to try          * renaming the file from the temporary name to the actual name, without          * doing any exists check. This check may be faster on some file systems          * and especially FTP servers.          *           * The option will be converted to a          *<code>org.apache.camel.component.file.GenericFileExist</code> type.          *           * Group: producer          */
DECL|method|fileExist (String fileExist)
specifier|default
name|FileEndpointProducerBuilder
name|fileExist
parameter_list|(
name|String
name|fileExist
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"fileExist"
argument_list|,
name|fileExist
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Flatten is used to flatten the file name path to strip any leading          * paths, so it's just the file name. This allows you to consume          * recursively into sub-directories, but when you eg write the files to          * another directory they will be written in a single directory. Setting          * this to true on the producer enforces that any file name in          * CamelFileName header will be stripped for any leading paths.          *           * The option is a:<code>boolean</code> type.          *           * Group: producer          */
DECL|method|flatten (boolean flatten)
specifier|default
name|FileEndpointProducerBuilder
name|flatten
parameter_list|(
name|boolean
name|flatten
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"flatten"
argument_list|,
name|flatten
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Flatten is used to flatten the file name path to strip any leading          * paths, so it's just the file name. This allows you to consume          * recursively into sub-directories, but when you eg write the files to          * another directory they will be written in a single directory. Setting          * this to true on the producer enforces that any file name in          * CamelFileName header will be stripped for any leading paths.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: producer          */
DECL|method|flatten (String flatten)
specifier|default
name|FileEndpointProducerBuilder
name|flatten
parameter_list|(
name|String
name|flatten
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"flatten"
argument_list|,
name|flatten
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Used for jailing (restricting) writing files to the starting          * directory (and sub) only. This is enabled by default to not allow          * Camel to write files to outside directories (to be more secured out          * of the box). You can turn this off to allow writing files to          * directories outside the starting directory, such as parent or root          * folders.          *           * The option is a:<code>boolean</code> type.          *           * Group: producer          */
DECL|method|jailStartingDirectory ( boolean jailStartingDirectory)
specifier|default
name|FileEndpointProducerBuilder
name|jailStartingDirectory
parameter_list|(
name|boolean
name|jailStartingDirectory
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"jailStartingDirectory"
argument_list|,
name|jailStartingDirectory
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Used for jailing (restricting) writing files to the starting          * directory (and sub) only. This is enabled by default to not allow          * Camel to write files to outside directories (to be more secured out          * of the box). You can turn this off to allow writing files to          * directories outside the starting directory, such as parent or root          * folders.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: producer          */
DECL|method|jailStartingDirectory ( String jailStartingDirectory)
specifier|default
name|FileEndpointProducerBuilder
name|jailStartingDirectory
parameter_list|(
name|String
name|jailStartingDirectory
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"jailStartingDirectory"
argument_list|,
name|jailStartingDirectory
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the producer should be started lazy (on the first message).          * By starting lazy you can use this to allow CamelContext and routes to          * startup in situations where a producer may otherwise fail during          * starting and cause the route to fail being started. By deferring this          * startup to be lazy then the startup failure can be handled during          * routing messages via Camel's routing error handlers. Beware that when          * the first message is processed then creating and starting the          * producer may take a little time and prolong the total processing time          * of the processing.          *           * The option is a:<code>boolean</code> type.          *           * Group: producer          */
DECL|method|lazyStartProducer ( boolean lazyStartProducer)
specifier|default
name|FileEndpointProducerBuilder
name|lazyStartProducer
parameter_list|(
name|boolean
name|lazyStartProducer
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"lazyStartProducer"
argument_list|,
name|lazyStartProducer
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the producer should be started lazy (on the first message).          * By starting lazy you can use this to allow CamelContext and routes to          * startup in situations where a producer may otherwise fail during          * starting and cause the route to fail being started. By deferring this          * startup to be lazy then the startup failure can be handled during          * routing messages via Camel's routing error handlers. Beware that when          * the first message is processed then creating and starting the          * producer may take a little time and prolong the total processing time          * of the processing.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: producer          */
DECL|method|lazyStartProducer ( String lazyStartProducer)
specifier|default
name|FileEndpointProducerBuilder
name|lazyStartProducer
parameter_list|(
name|String
name|lazyStartProducer
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"lazyStartProducer"
argument_list|,
name|lazyStartProducer
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Expression (such as File Language) used to compute file name to use          * when fileExist=Move is configured. To move files into a backup          * subdirectory just enter backup. This option only supports the          * following File Language tokens: file:name, file:name.ext,          * file:name.noext, file:onlyname, file:onlyname.noext, file:ext, and          * file:parent. Notice the file:parent is not supported by the FTP          * component, as the FTP component can only move any existing files to a          * relative directory based on current dir as base.          *           * The option is a:<code>org.apache.camel.Expression</code> type.          *           * Group: producer          */
DECL|method|moveExisting (Expression moveExisting)
specifier|default
name|FileEndpointProducerBuilder
name|moveExisting
parameter_list|(
name|Expression
name|moveExisting
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"moveExisting"
argument_list|,
name|moveExisting
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Expression (such as File Language) used to compute file name to use          * when fileExist=Move is configured. To move files into a backup          * subdirectory just enter backup. This option only supports the          * following File Language tokens: file:name, file:name.ext,          * file:name.noext, file:onlyname, file:onlyname.noext, file:ext, and          * file:parent. Notice the file:parent is not supported by the FTP          * component, as the FTP component can only move any existing files to a          * relative directory based on current dir as base.          *           * The option will be converted to a          *<code>org.apache.camel.Expression</code> type.          *           * Group: producer          */
DECL|method|moveExisting (String moveExisting)
specifier|default
name|FileEndpointProducerBuilder
name|moveExisting
parameter_list|(
name|String
name|moveExisting
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"moveExisting"
argument_list|,
name|moveExisting
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The same as tempPrefix option but offering a more fine grained          * control on the naming of the temporary filename as it uses the File          * Language. The location for tempFilename is relative to the final file          * location in the option 'fileName', not the target directory in the          * base uri. For example if option fileName includes a directory prefix:          * dir/finalFilename then tempFileName is relative to that subdirectory          * dir.          *           * The option is a:<code>org.apache.camel.Expression</code> type.          *           * Group: producer          */
DECL|method|tempFileName (Expression tempFileName)
specifier|default
name|FileEndpointProducerBuilder
name|tempFileName
parameter_list|(
name|Expression
name|tempFileName
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"tempFileName"
argument_list|,
name|tempFileName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The same as tempPrefix option but offering a more fine grained          * control on the naming of the temporary filename as it uses the File          * Language. The location for tempFilename is relative to the final file          * location in the option 'fileName', not the target directory in the          * base uri. For example if option fileName includes a directory prefix:          * dir/finalFilename then tempFileName is relative to that subdirectory          * dir.          *           * The option will be converted to a          *<code>org.apache.camel.Expression</code> type.          *           * Group: producer          */
DECL|method|tempFileName (String tempFileName)
specifier|default
name|FileEndpointProducerBuilder
name|tempFileName
parameter_list|(
name|String
name|tempFileName
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"tempFileName"
argument_list|,
name|tempFileName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * This option is used to write the file using a temporary name and          * then, after the write is complete, rename it to the real name. Can be          * used to identify files being written and also avoid consumers (not          * using exclusive read locks) reading in progress files. Is often used          * by FTP when uploading big files.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: producer          */
DECL|method|tempPrefix (String tempPrefix)
specifier|default
name|FileEndpointProducerBuilder
name|tempPrefix
parameter_list|(
name|String
name|tempPrefix
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"tempPrefix"
argument_list|,
name|tempPrefix
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
comment|/**      * Advanced builder for endpoint producers for the File component.      */
DECL|interface|AdvancedFileEndpointProducerBuilder
specifier|public
interface|interface
name|AdvancedFileEndpointProducerBuilder
extends|extends
name|EndpointProducerBuilder
block|{
DECL|method|basic ()
specifier|default
name|FileEndpointProducerBuilder
name|basic
parameter_list|()
block|{
return|return
operator|(
name|FileEndpointProducerBuilder
operator|)
name|this
return|;
block|}
comment|/**          * Used to specify if a null body is allowed during file writing. If set          * to true then an empty file will be created, when set to false, and          * attempting to send a null body to the file component, a          * GenericFileWriteException of 'Cannot write null body to file.' will          * be thrown. If the fileExist option is set to 'Override', then the          * file will be truncated, and if set to append the file will remain          * unchanged.          *           * The option is a:<code>boolean</code> type.          *           * Group: producer (advanced)          */
DECL|method|allowNullBody ( boolean allowNullBody)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|allowNullBody
parameter_list|(
name|boolean
name|allowNullBody
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"allowNullBody"
argument_list|,
name|allowNullBody
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Used to specify if a null body is allowed during file writing. If set          * to true then an empty file will be created, when set to false, and          * attempting to send a null body to the file component, a          * GenericFileWriteException of 'Cannot write null body to file.' will          * be thrown. If the fileExist option is set to 'Override', then the          * file will be truncated, and if set to append the file will remain          * unchanged.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: producer (advanced)          */
DECL|method|allowNullBody ( String allowNullBody)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|allowNullBody
parameter_list|(
name|String
name|allowNullBody
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"allowNullBody"
argument_list|,
name|allowNullBody
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specify the file permissions which is sent by the producer, the chmod          * value must be between 000 and 777; If there is a leading digit like          * in 0755 we will ignore it.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: producer (advanced)          */
DECL|method|chmod (String chmod)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|chmod
parameter_list|(
name|String
name|chmod
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"chmod"
argument_list|,
name|chmod
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specify the directory permissions used when the producer creates          * missing directories, the chmod value must be between 000 and 777; If          * there is a leading digit like in 0755 we will ignore it.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: producer (advanced)          */
DECL|method|chmodDirectory ( String chmodDirectory)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|chmodDirectory
parameter_list|(
name|String
name|chmodDirectory
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"chmodDirectory"
argument_list|,
name|chmodDirectory
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether or not to eagerly delete any existing target file. This          * option only applies when you use fileExists=Override and the          * tempFileName option as well. You can use this to disable (set it to          * false) deleting the target file before the temp file is written. For          * example you may write big files and want the target file to exists          * during the temp file is being written. This ensure the target file is          * only deleted until the very last moment, just before the temp file is          * being renamed to the target filename. This option is also used to          * control whether to delete any existing files when fileExist=Move is          * enabled, and an existing file exists. If this option          * copyAndDeleteOnRenameFails false, then an exception will be thrown if          * an existing file existed, if its true, then the existing file is          * deleted before the move operation.          *           * The option is a:<code>boolean</code> type.          *           * Group: producer (advanced)          */
DECL|method|eagerDeleteTargetFile ( boolean eagerDeleteTargetFile)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|eagerDeleteTargetFile
parameter_list|(
name|boolean
name|eagerDeleteTargetFile
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"eagerDeleteTargetFile"
argument_list|,
name|eagerDeleteTargetFile
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether or not to eagerly delete any existing target file. This          * option only applies when you use fileExists=Override and the          * tempFileName option as well. You can use this to disable (set it to          * false) deleting the target file before the temp file is written. For          * example you may write big files and want the target file to exists          * during the temp file is being written. This ensure the target file is          * only deleted until the very last moment, just before the temp file is          * being renamed to the target filename. This option is also used to          * control whether to delete any existing files when fileExist=Move is          * enabled, and an existing file exists. If this option          * copyAndDeleteOnRenameFails false, then an exception will be thrown if          * an existing file existed, if its true, then the existing file is          * deleted before the move operation.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: producer (advanced)          */
DECL|method|eagerDeleteTargetFile ( String eagerDeleteTargetFile)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|eagerDeleteTargetFile
parameter_list|(
name|String
name|eagerDeleteTargetFile
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"eagerDeleteTargetFile"
argument_list|,
name|eagerDeleteTargetFile
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to force syncing writes to the file system. You can turn this          * off if you do not want this level of guarantee, for example if          * writing to logs / audit logs etc; this would yield better          * performance.          *           * The option is a:<code>boolean</code> type.          *           * Group: producer (advanced)          */
DECL|method|forceWrites ( boolean forceWrites)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|forceWrites
parameter_list|(
name|boolean
name|forceWrites
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"forceWrites"
argument_list|,
name|forceWrites
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to force syncing writes to the file system. You can turn this          * off if you do not want this level of guarantee, for example if          * writing to logs / audit logs etc; this would yield better          * performance.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: producer (advanced)          */
DECL|method|forceWrites ( String forceWrites)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|forceWrites
parameter_list|(
name|String
name|forceWrites
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"forceWrites"
argument_list|,
name|forceWrites
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Will keep the last modified timestamp from the source file (if any).          * Will use the Exchange.FILE_LAST_MODIFIED header to located the          * timestamp. This header can contain either a java.util.Date or long          * with the timestamp. If the timestamp exists and the option is enabled          * it will set this timestamp on the written file. Note: This option          * only applies to the file producer. You cannot use this option with          * any of the ftp producers.          *           * The option is a:<code>boolean</code> type.          *           * Group: producer (advanced)          */
DECL|method|keepLastModified ( boolean keepLastModified)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|keepLastModified
parameter_list|(
name|boolean
name|keepLastModified
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"keepLastModified"
argument_list|,
name|keepLastModified
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Will keep the last modified timestamp from the source file (if any).          * Will use the Exchange.FILE_LAST_MODIFIED header to located the          * timestamp. This header can contain either a java.util.Date or long          * with the timestamp. If the timestamp exists and the option is enabled          * it will set this timestamp on the written file. Note: This option          * only applies to the file producer. You cannot use this option with          * any of the ftp producers.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: producer (advanced)          */
DECL|method|keepLastModified ( String keepLastModified)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|keepLastModified
parameter_list|(
name|String
name|keepLastModified
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"keepLastModified"
argument_list|,
name|keepLastModified
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Strategy (Custom Strategy) used to move file with special naming          * token to use when fileExist=Move is configured. By default, there is          * an implementation used if no custom strategy is provided.          *           * The option is a:          *<code>org.apache.camel.component.file.strategy.FileMoveExistingStrategy</code> type.          *           * Group: producer (advanced)          */
DECL|method|moveExistingFileStrategy ( Object moveExistingFileStrategy)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|moveExistingFileStrategy
parameter_list|(
name|Object
name|moveExistingFileStrategy
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"moveExistingFileStrategy"
argument_list|,
name|moveExistingFileStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Strategy (Custom Strategy) used to move file with special naming          * token to use when fileExist=Move is configured. By default, there is          * an implementation used if no custom strategy is provided.          *           * The option will be converted to a          *<code>org.apache.camel.component.file.strategy.FileMoveExistingStrategy</code> type.          *           * Group: producer (advanced)          */
DECL|method|moveExistingFileStrategy ( String moveExistingFileStrategy)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|moveExistingFileStrategy
parameter_list|(
name|String
name|moveExistingFileStrategy
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"moveExistingFileStrategy"
argument_list|,
name|moveExistingFileStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Automatically create missing directories in the file's pathname. For          * the file consumer, that means creating the starting directory. For          * the file producer, it means the directory the files should be written          * to.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|autoCreate ( boolean autoCreate)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|autoCreate
parameter_list|(
name|boolean
name|autoCreate
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"autoCreate"
argument_list|,
name|autoCreate
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Automatically create missing directories in the file's pathname. For          * the file consumer, that means creating the starting directory. For          * the file producer, it means the directory the files should be written          * to.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|autoCreate (String autoCreate)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|autoCreate
parameter_list|(
name|String
name|autoCreate
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"autoCreate"
argument_list|,
name|autoCreate
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the endpoint should use basic property binding (Camel 2.x) or          * the newer property binding with additional capabilities.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|basicPropertyBinding ( boolean basicPropertyBinding)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|basicPropertyBinding
parameter_list|(
name|boolean
name|basicPropertyBinding
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"basicPropertyBinding"
argument_list|,
name|basicPropertyBinding
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the endpoint should use basic property binding (Camel 2.x) or          * the newer property binding with additional capabilities.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|basicPropertyBinding ( String basicPropertyBinding)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|basicPropertyBinding
parameter_list|(
name|String
name|basicPropertyBinding
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"basicPropertyBinding"
argument_list|,
name|basicPropertyBinding
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Write buffer sized in bytes.          *           * The option is a:<code>int</code> type.          *           * Group: advanced          */
DECL|method|bufferSize (int bufferSize)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|bufferSize
parameter_list|(
name|int
name|bufferSize
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"bufferSize"
argument_list|,
name|bufferSize
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Write buffer sized in bytes.          *           * The option will be converted to a<code>int</code> type.          *           * Group: advanced          */
DECL|method|bufferSize (String bufferSize)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|bufferSize
parameter_list|(
name|String
name|bufferSize
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"bufferSize"
argument_list|,
name|bufferSize
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to fallback and do a copy and delete file, in case the file          * could not be renamed directly. This option is not available for the          * FTP component.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|copyAndDeleteOnRenameFail ( boolean copyAndDeleteOnRenameFail)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|copyAndDeleteOnRenameFail
parameter_list|(
name|boolean
name|copyAndDeleteOnRenameFail
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"copyAndDeleteOnRenameFail"
argument_list|,
name|copyAndDeleteOnRenameFail
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to fallback and do a copy and delete file, in case the file          * could not be renamed directly. This option is not available for the          * FTP component.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|copyAndDeleteOnRenameFail ( String copyAndDeleteOnRenameFail)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|copyAndDeleteOnRenameFail
parameter_list|(
name|String
name|copyAndDeleteOnRenameFail
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"copyAndDeleteOnRenameFail"
argument_list|,
name|copyAndDeleteOnRenameFail
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Perform rename operations using a copy and delete strategy. This is          * primarily used in environments where the regular rename operation is          * unreliable (e.g. across different file systems or networks). This          * option takes precedence over the copyAndDeleteOnRenameFail parameter          * that will automatically fall back to the copy and delete strategy,          * but only after additional delays.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|renameUsingCopy ( boolean renameUsingCopy)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|renameUsingCopy
parameter_list|(
name|boolean
name|renameUsingCopy
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"renameUsingCopy"
argument_list|,
name|renameUsingCopy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Perform rename operations using a copy and delete strategy. This is          * primarily used in environments where the regular rename operation is          * unreliable (e.g. across different file systems or networks). This          * option takes precedence over the copyAndDeleteOnRenameFail parameter          * that will automatically fall back to the copy and delete strategy,          * but only after additional delays.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|renameUsingCopy ( String renameUsingCopy)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|renameUsingCopy
parameter_list|(
name|String
name|renameUsingCopy
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"renameUsingCopy"
argument_list|,
name|renameUsingCopy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets whether synchronous processing should be strictly used, or Camel          * is allowed to use asynchronous processing (if supported).          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|synchronous ( boolean synchronous)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|synchronous
parameter_list|(
name|boolean
name|synchronous
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"synchronous"
argument_list|,
name|synchronous
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets whether synchronous processing should be strictly used, or Camel          * is allowed to use asynchronous processing (if supported).          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|synchronous ( String synchronous)
specifier|default
name|AdvancedFileEndpointProducerBuilder
name|synchronous
parameter_list|(
name|String
name|synchronous
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"synchronous"
argument_list|,
name|synchronous
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
comment|/**      * Builder for endpoint for the File component.      */
DECL|interface|FileEndpointBuilder
specifier|public
interface|interface
name|FileEndpointBuilder
extends|extends
name|FileEndpointConsumerBuilder
extends|,
name|FileEndpointProducerBuilder
block|{
DECL|method|advanced ()
specifier|default
name|AdvancedFileEndpointBuilder
name|advanced
parameter_list|()
block|{
return|return
operator|(
name|AdvancedFileEndpointBuilder
operator|)
name|this
return|;
block|}
comment|/**          * The starting directory.          *           * The option is a:<code>java.io.File</code> type.          *           * Group: common          */
DECL|method|directoryName (File directoryName)
specifier|default
name|FileEndpointBuilder
name|directoryName
parameter_list|(
name|File
name|directoryName
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"directoryName"
argument_list|,
name|directoryName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The starting directory.          *           * The option will be converted to a<code>java.io.File</code> type.          *           * Group: common          */
DECL|method|directoryName (String directoryName)
specifier|default
name|FileEndpointBuilder
name|directoryName
parameter_list|(
name|String
name|directoryName
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"directoryName"
argument_list|,
name|directoryName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * This option is used to specify the encoding of the file. You can use          * this on the consumer, to specify the encodings of the files, which          * allow Camel to know the charset it should load the file content in          * case the file content is being accessed. Likewise when writing a          * file, you can use this option to specify which charset to write the          * file as well. Do mind that when writing the file Camel may have to          * read the message content into memory to be able to convert the data          * into the configured charset, so do not use this if you have big          * messages.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: common          */
DECL|method|charset (String charset)
specifier|default
name|FileEndpointBuilder
name|charset
parameter_list|(
name|String
name|charset
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"charset"
argument_list|,
name|charset
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Producer: If provided, then Camel will write a 2nd done file when the          * original file has been written. The done file will be empty. This          * option configures what file name to use. Either you can specify a          * fixed name. Or you can use dynamic placeholders. The done file will          * always be written in the same folder as the original file. Consumer:          * If provided, Camel will only consume files if a done file exists.          * This option configures what file name to use. Either you can specify          * a fixed name. Or you can use dynamic placeholders.The done file is          * always expected in the same folder as the original file. Only          * ${file.name} and ${file.name.noext} is supported as dynamic          * placeholders.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: common          */
DECL|method|doneFileName (String doneFileName)
specifier|default
name|FileEndpointBuilder
name|doneFileName
parameter_list|(
name|String
name|doneFileName
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"doneFileName"
argument_list|,
name|doneFileName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Use Expression such as File Language to dynamically set the filename.          * For consumers, it's used as a filename filter. For producers, it's          * used to evaluate the filename to write. If an expression is set, it          * take precedence over the CamelFileName header. (Note: The header          * itself can also be an Expression). The expression options support          * both String and Expression types. If the expression is a String type,          * it is always evaluated using the File Language. If the expression is          * an Expression type, the specified Expression type is used - this          * allows you, for instance, to use OGNL expressions. For the consumer,          * you can use it to filter filenames, so you can for instance consume          * today's file using the File Language syntax:          * mydata-${date:now:yyyyMMdd}.txt. The producers support the          * CamelOverruleFileName header which takes precedence over any existing          * CamelFileName header; the CamelOverruleFileName is a header that is          * used only once, and makes it easier as this avoids to temporary store          * CamelFileName and have to restore it afterwards.          *           * The option is a:<code>org.apache.camel.Expression</code> type.          *           * Group: common          */
DECL|method|fileName (Expression fileName)
specifier|default
name|FileEndpointBuilder
name|fileName
parameter_list|(
name|Expression
name|fileName
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"fileName"
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Use Expression such as File Language to dynamically set the filename.          * For consumers, it's used as a filename filter. For producers, it's          * used to evaluate the filename to write. If an expression is set, it          * take precedence over the CamelFileName header. (Note: The header          * itself can also be an Expression). The expression options support          * both String and Expression types. If the expression is a String type,          * it is always evaluated using the File Language. If the expression is          * an Expression type, the specified Expression type is used - this          * allows you, for instance, to use OGNL expressions. For the consumer,          * you can use it to filter filenames, so you can for instance consume          * today's file using the File Language syntax:          * mydata-${date:now:yyyyMMdd}.txt. The producers support the          * CamelOverruleFileName header which takes precedence over any existing          * CamelFileName header; the CamelOverruleFileName is a header that is          * used only once, and makes it easier as this avoids to temporary store          * CamelFileName and have to restore it afterwards.          *           * The option will be converted to a          *<code>org.apache.camel.Expression</code> type.          *           * Group: common          */
DECL|method|fileName (String fileName)
specifier|default
name|FileEndpointBuilder
name|fileName
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"fileName"
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
comment|/**      * Advanced builder for endpoint for the File component.      */
DECL|interface|AdvancedFileEndpointBuilder
specifier|public
interface|interface
name|AdvancedFileEndpointBuilder
extends|extends
name|AdvancedFileEndpointConsumerBuilder
extends|,
name|AdvancedFileEndpointProducerBuilder
block|{
DECL|method|basic ()
specifier|default
name|FileEndpointBuilder
name|basic
parameter_list|()
block|{
return|return
operator|(
name|FileEndpointBuilder
operator|)
name|this
return|;
block|}
comment|/**          * Automatically create missing directories in the file's pathname. For          * the file consumer, that means creating the starting directory. For          * the file producer, it means the directory the files should be written          * to.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|autoCreate (boolean autoCreate)
specifier|default
name|AdvancedFileEndpointBuilder
name|autoCreate
parameter_list|(
name|boolean
name|autoCreate
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"autoCreate"
argument_list|,
name|autoCreate
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Automatically create missing directories in the file's pathname. For          * the file consumer, that means creating the starting directory. For          * the file producer, it means the directory the files should be written          * to.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|autoCreate (String autoCreate)
specifier|default
name|AdvancedFileEndpointBuilder
name|autoCreate
parameter_list|(
name|String
name|autoCreate
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"autoCreate"
argument_list|,
name|autoCreate
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the endpoint should use basic property binding (Camel 2.x) or          * the newer property binding with additional capabilities.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|basicPropertyBinding ( boolean basicPropertyBinding)
specifier|default
name|AdvancedFileEndpointBuilder
name|basicPropertyBinding
parameter_list|(
name|boolean
name|basicPropertyBinding
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"basicPropertyBinding"
argument_list|,
name|basicPropertyBinding
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the endpoint should use basic property binding (Camel 2.x) or          * the newer property binding with additional capabilities.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|basicPropertyBinding ( String basicPropertyBinding)
specifier|default
name|AdvancedFileEndpointBuilder
name|basicPropertyBinding
parameter_list|(
name|String
name|basicPropertyBinding
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"basicPropertyBinding"
argument_list|,
name|basicPropertyBinding
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Write buffer sized in bytes.          *           * The option is a:<code>int</code> type.          *           * Group: advanced          */
DECL|method|bufferSize (int bufferSize)
specifier|default
name|AdvancedFileEndpointBuilder
name|bufferSize
parameter_list|(
name|int
name|bufferSize
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"bufferSize"
argument_list|,
name|bufferSize
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Write buffer sized in bytes.          *           * The option will be converted to a<code>int</code> type.          *           * Group: advanced          */
DECL|method|bufferSize (String bufferSize)
specifier|default
name|AdvancedFileEndpointBuilder
name|bufferSize
parameter_list|(
name|String
name|bufferSize
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"bufferSize"
argument_list|,
name|bufferSize
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to fallback and do a copy and delete file, in case the file          * could not be renamed directly. This option is not available for the          * FTP component.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|copyAndDeleteOnRenameFail ( boolean copyAndDeleteOnRenameFail)
specifier|default
name|AdvancedFileEndpointBuilder
name|copyAndDeleteOnRenameFail
parameter_list|(
name|boolean
name|copyAndDeleteOnRenameFail
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"copyAndDeleteOnRenameFail"
argument_list|,
name|copyAndDeleteOnRenameFail
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to fallback and do a copy and delete file, in case the file          * could not be renamed directly. This option is not available for the          * FTP component.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|copyAndDeleteOnRenameFail ( String copyAndDeleteOnRenameFail)
specifier|default
name|AdvancedFileEndpointBuilder
name|copyAndDeleteOnRenameFail
parameter_list|(
name|String
name|copyAndDeleteOnRenameFail
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"copyAndDeleteOnRenameFail"
argument_list|,
name|copyAndDeleteOnRenameFail
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Perform rename operations using a copy and delete strategy. This is          * primarily used in environments where the regular rename operation is          * unreliable (e.g. across different file systems or networks). This          * option takes precedence over the copyAndDeleteOnRenameFail parameter          * that will automatically fall back to the copy and delete strategy,          * but only after additional delays.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|renameUsingCopy ( boolean renameUsingCopy)
specifier|default
name|AdvancedFileEndpointBuilder
name|renameUsingCopy
parameter_list|(
name|boolean
name|renameUsingCopy
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"renameUsingCopy"
argument_list|,
name|renameUsingCopy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Perform rename operations using a copy and delete strategy. This is          * primarily used in environments where the regular rename operation is          * unreliable (e.g. across different file systems or networks). This          * option takes precedence over the copyAndDeleteOnRenameFail parameter          * that will automatically fall back to the copy and delete strategy,          * but only after additional delays.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|renameUsingCopy ( String renameUsingCopy)
specifier|default
name|AdvancedFileEndpointBuilder
name|renameUsingCopy
parameter_list|(
name|String
name|renameUsingCopy
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"renameUsingCopy"
argument_list|,
name|renameUsingCopy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets whether synchronous processing should be strictly used, or Camel          * is allowed to use asynchronous processing (if supported).          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|synchronous (boolean synchronous)
specifier|default
name|AdvancedFileEndpointBuilder
name|synchronous
parameter_list|(
name|boolean
name|synchronous
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"synchronous"
argument_list|,
name|synchronous
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets whether synchronous processing should be strictly used, or Camel          * is allowed to use asynchronous processing (if supported).          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|synchronous (String synchronous)
specifier|default
name|AdvancedFileEndpointBuilder
name|synchronous
parameter_list|(
name|String
name|synchronous
parameter_list|)
block|{
name|setProperty
argument_list|(
literal|"synchronous"
argument_list|,
name|synchronous
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
comment|/**      * Proxy enum for      *<code>org.apache.camel.component.file.GenericFileExist</code> enum.      */
DECL|enum|GenericFileExist
enum|enum
name|GenericFileExist
block|{
DECL|enumConstant|Override
name|Override
block|,
DECL|enumConstant|Append
name|Append
block|,
DECL|enumConstant|Fail
name|Fail
block|,
DECL|enumConstant|Ignore
name|Ignore
block|,
DECL|enumConstant|Move
name|Move
block|,
DECL|enumConstant|TryRename
name|TryRename
block|;     }
comment|/**      * File (camel-file)      * The file component is used for reading or writing files.      *       * Syntax:<code>file:directoryName</code>      * Category: core,file      * Available as of version: 1.0      * Maven coordinates: org.apache.camel:camel-file      */
DECL|method|file (String path)
specifier|default
name|FileEndpointBuilder
name|file
parameter_list|(
name|String
name|path
parameter_list|)
block|{
class|class
name|FileEndpointBuilderImpl
extends|extends
name|AbstractEndpointBuilder
implements|implements
name|FileEndpointBuilder
implements|,
name|AdvancedFileEndpointBuilder
block|{
specifier|public
name|FileEndpointBuilderImpl
parameter_list|(
name|String
name|path
parameter_list|)
block|{
name|super
argument_list|(
literal|"file"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|FileEndpointBuilderImpl
argument_list|(
name|path
argument_list|)
return|;
block|}
block|}
end_interface

end_unit

