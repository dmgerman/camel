begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.builder.endpoint.dsl
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|endpoint
operator|.
name|dsl
package|;
end_package

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Generated
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|ExchangePattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|LoggingLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|EndpointConsumerBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|EndpointProducerBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|endpoint
operator|.
name|AbstractEndpointBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|ExceptionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|HeaderFilterStrategy
import|;
end_import

begin_comment
comment|/**  * The jms component allows messages to be sent to (or consumed from) a JMS  * Queue or Topic.  *   * Generated by camel-package-maven-plugin - do not edit this file!  */
end_comment

begin_interface
annotation|@
name|Generated
argument_list|(
literal|"org.apache.camel.maven.packaging.EndpointDslMojo"
argument_list|)
DECL|interface|JmsEndpointBuilderFactory
specifier|public
interface|interface
name|JmsEndpointBuilderFactory
block|{
comment|/**      * Builder for endpoint consumers for the JMS component.      */
DECL|interface|JmsEndpointConsumerBuilder
specifier|public
interface|interface
name|JmsEndpointConsumerBuilder
extends|extends
name|EndpointConsumerBuilder
block|{
DECL|method|advanced ()
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|advanced
parameter_list|()
block|{
return|return
operator|(
name|AdvancedJmsEndpointConsumerBuilder
operator|)
name|this
return|;
block|}
comment|/**          * Sets the JMS client ID to use. Note that this value, if specified,          * must be unique and can only be used by a single JMS connection          * instance. It is typically only required for durable topic          * subscriptions. If using Apache ActiveMQ you may prefer to use Virtual          * Topics instead.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: common          */
DECL|method|clientId (String clientId)
specifier|default
name|JmsEndpointConsumerBuilder
name|clientId
parameter_list|(
name|String
name|clientId
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"clientId"
argument_list|,
name|clientId
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets the default connection factory to be used if a connection          * factory is not specified for either          * setTemplateConnectionFactory(ConnectionFactory) or          * setListenerConnectionFactory(ConnectionFactory).          *           * The option is a:<code>javax.jms.ConnectionFactory</code> type.          *           * Group: common          */
DECL|method|connectionFactory ( Object connectionFactory)
specifier|default
name|JmsEndpointConsumerBuilder
name|connectionFactory
parameter_list|(
name|Object
name|connectionFactory
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"connectionFactory"
argument_list|,
name|connectionFactory
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets the default connection factory to be used if a connection          * factory is not specified for either          * setTemplateConnectionFactory(ConnectionFactory) or          * setListenerConnectionFactory(ConnectionFactory).          *           * The option will be converted to a          *<code>javax.jms.ConnectionFactory</code> type.          *           * Group: common          */
DECL|method|connectionFactory ( String connectionFactory)
specifier|default
name|JmsEndpointConsumerBuilder
name|connectionFactory
parameter_list|(
name|String
name|connectionFactory
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"connectionFactory"
argument_list|,
name|connectionFactory
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether Camel ignores the JMSReplyTo header in messages. If          * true, Camel does not send a reply back to the destination specified          * in the JMSReplyTo header. You can use this option if you want Camel          * to consume from a route and you do not want Camel to automatically          * send back a reply message because another component in your code          * handles the reply message. You can also use this option if you want          * to use Camel as a proxy between different message brokers and you          * want to route message from one system to another.          *           * The option is a:<code>boolean</code> type.          *           * Group: common          */
DECL|method|disableReplyTo (boolean disableReplyTo)
specifier|default
name|JmsEndpointConsumerBuilder
name|disableReplyTo
parameter_list|(
name|boolean
name|disableReplyTo
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"disableReplyTo"
argument_list|,
name|disableReplyTo
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether Camel ignores the JMSReplyTo header in messages. If          * true, Camel does not send a reply back to the destination specified          * in the JMSReplyTo header. You can use this option if you want Camel          * to consume from a route and you do not want Camel to automatically          * send back a reply message because another component in your code          * handles the reply message. You can also use this option if you want          * to use Camel as a proxy between different message brokers and you          * want to route message from one system to another.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: common          */
DECL|method|disableReplyTo (String disableReplyTo)
specifier|default
name|JmsEndpointConsumerBuilder
name|disableReplyTo
parameter_list|(
name|String
name|disableReplyTo
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"disableReplyTo"
argument_list|,
name|disableReplyTo
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The durable subscriber name for specifying durable topic          * subscriptions. The clientId option must be configured as well.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: common          */
DECL|method|durableSubscriptionName ( String durableSubscriptionName)
specifier|default
name|JmsEndpointConsumerBuilder
name|durableSubscriptionName
parameter_list|(
name|String
name|durableSubscriptionName
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"durableSubscriptionName"
argument_list|,
name|durableSubscriptionName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Allows you to force the use of a specific javax.jms.Message          * implementation for sending JMS messages. Possible values are: Bytes,          * Map, Object, Stream, Text. By default, Camel would determine which          * JMS message type to use from the In body type. This option allows you          * to specify it.          *           * The option is a:          *<code>org.apache.camel.component.jms.JmsMessageType</code> type.          *           * Group: common          */
DECL|method|jmsMessageType ( JmsMessageType jmsMessageType)
specifier|default
name|JmsEndpointConsumerBuilder
name|jmsMessageType
parameter_list|(
name|JmsMessageType
name|jmsMessageType
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"jmsMessageType"
argument_list|,
name|jmsMessageType
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Allows you to force the use of a specific javax.jms.Message          * implementation for sending JMS messages. Possible values are: Bytes,          * Map, Object, Stream, Text. By default, Camel would determine which          * JMS message type to use from the In body type. This option allows you          * to specify it.          *           * The option will be converted to a          *<code>org.apache.camel.component.jms.JmsMessageType</code> type.          *           * Group: common          */
DECL|method|jmsMessageType (String jmsMessageType)
specifier|default
name|JmsEndpointConsumerBuilder
name|jmsMessageType
parameter_list|(
name|String
name|jmsMessageType
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"jmsMessageType"
argument_list|,
name|jmsMessageType
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether to test the connection on startup. This ensures          * that when Camel starts that all the JMS consumers have a valid          * connection to the JMS broker. If a connection cannot be granted then          * Camel throws an exception on startup. This ensures that Camel is not          * started with failed connections. The JMS producers is tested as well.          *           * The option is a:<code>boolean</code> type.          *           * Group: common          */
DECL|method|testConnectionOnStartup ( boolean testConnectionOnStartup)
specifier|default
name|JmsEndpointConsumerBuilder
name|testConnectionOnStartup
parameter_list|(
name|boolean
name|testConnectionOnStartup
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"testConnectionOnStartup"
argument_list|,
name|testConnectionOnStartup
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether to test the connection on startup. This ensures          * that when Camel starts that all the JMS consumers have a valid          * connection to the JMS broker. If a connection cannot be granted then          * Camel throws an exception on startup. This ensures that Camel is not          * started with failed connections. The JMS producers is tested as well.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: common          */
DECL|method|testConnectionOnStartup ( String testConnectionOnStartup)
specifier|default
name|JmsEndpointConsumerBuilder
name|testConnectionOnStartup
parameter_list|(
name|String
name|testConnectionOnStartup
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"testConnectionOnStartup"
argument_list|,
name|testConnectionOnStartup
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The JMS acknowledgement name, which is one of: SESSION_TRANSACTED,          * CLIENT_ACKNOWLEDGE, AUTO_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: consumer          */
DECL|method|acknowledgementModeName ( String acknowledgementModeName)
specifier|default
name|JmsEndpointConsumerBuilder
name|acknowledgementModeName
parameter_list|(
name|String
name|acknowledgementModeName
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"acknowledgementModeName"
argument_list|,
name|acknowledgementModeName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the JmsConsumer processes the Exchange asynchronously. If          * enabled then the JmsConsumer may pickup the next message from the JMS          * queue, while the previous message is being processed asynchronously          * (by the Asynchronous Routing Engine). This means that messages may be          * processed not 100% strictly in order. If disabled (as default) then          * the Exchange is fully processed before the JmsConsumer will pickup          * the next message from the JMS queue. Note if transacted has been          * enabled, then asyncConsumer=true does not run asynchronously, as          * transaction must be executed synchronously (Camel 3.0 may support          * async transactions).          *           * The option is a:<code>boolean</code> type.          *           * Group: consumer          */
DECL|method|asyncConsumer (boolean asyncConsumer)
specifier|default
name|JmsEndpointConsumerBuilder
name|asyncConsumer
parameter_list|(
name|boolean
name|asyncConsumer
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"asyncConsumer"
argument_list|,
name|asyncConsumer
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the JmsConsumer processes the Exchange asynchronously. If          * enabled then the JmsConsumer may pickup the next message from the JMS          * queue, while the previous message is being processed asynchronously          * (by the Asynchronous Routing Engine). This means that messages may be          * processed not 100% strictly in order. If disabled (as default) then          * the Exchange is fully processed before the JmsConsumer will pickup          * the next message from the JMS queue. Note if transacted has been          * enabled, then asyncConsumer=true does not run asynchronously, as          * transaction must be executed synchronously (Camel 3.0 may support          * async transactions).          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: consumer          */
DECL|method|asyncConsumer (String asyncConsumer)
specifier|default
name|JmsEndpointConsumerBuilder
name|asyncConsumer
parameter_list|(
name|String
name|asyncConsumer
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"asyncConsumer"
argument_list|,
name|asyncConsumer
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether the consumer container should auto-startup.          *           * The option is a:<code>boolean</code> type.          *           * Group: consumer          */
DECL|method|autoStartup (boolean autoStartup)
specifier|default
name|JmsEndpointConsumerBuilder
name|autoStartup
parameter_list|(
name|boolean
name|autoStartup
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"autoStartup"
argument_list|,
name|autoStartup
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether the consumer container should auto-startup.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: consumer          */
DECL|method|autoStartup (String autoStartup)
specifier|default
name|JmsEndpointConsumerBuilder
name|autoStartup
parameter_list|(
name|String
name|autoStartup
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"autoStartup"
argument_list|,
name|autoStartup
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets the cache level by ID for the underlying JMS resources. See          * cacheLevelName option for more details.          *           * The option is a:<code>int</code> type.          *           * Group: consumer          */
DECL|method|cacheLevel (int cacheLevel)
specifier|default
name|JmsEndpointConsumerBuilder
name|cacheLevel
parameter_list|(
name|int
name|cacheLevel
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"cacheLevel"
argument_list|,
name|cacheLevel
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets the cache level by ID for the underlying JMS resources. See          * cacheLevelName option for more details.          *           * The option will be converted to a<code>int</code> type.          *           * Group: consumer          */
DECL|method|cacheLevel (String cacheLevel)
specifier|default
name|JmsEndpointConsumerBuilder
name|cacheLevel
parameter_list|(
name|String
name|cacheLevel
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"cacheLevel"
argument_list|,
name|cacheLevel
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets the cache level by name for the underlying JMS resources.          * Possible values are: CACHE_AUTO, CACHE_CONNECTION, CACHE_CONSUMER,          * CACHE_NONE, and CACHE_SESSION. The default setting is CACHE_AUTO. See          * the Spring documentation and Transactions Cache Levels for more          * information.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: consumer          */
DECL|method|cacheLevelName (String cacheLevelName)
specifier|default
name|JmsEndpointConsumerBuilder
name|cacheLevelName
parameter_list|(
name|String
name|cacheLevelName
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"cacheLevelName"
argument_list|,
name|cacheLevelName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the default number of concurrent consumers when consuming          * from JMS (not for request/reply over JMS). See also the          * maxMessagesPerTask option to control dynamic scaling up/down of          * threads. When doing request/reply over JMS then the option          * replyToConcurrentConsumers is used to control number of concurrent          * consumers on the reply message listener.          *           * The option is a:<code>int</code> type.          *           * Group: consumer          */
DECL|method|concurrentConsumers ( int concurrentConsumers)
specifier|default
name|JmsEndpointConsumerBuilder
name|concurrentConsumers
parameter_list|(
name|int
name|concurrentConsumers
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"concurrentConsumers"
argument_list|,
name|concurrentConsumers
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the default number of concurrent consumers when consuming          * from JMS (not for request/reply over JMS). See also the          * maxMessagesPerTask option to control dynamic scaling up/down of          * threads. When doing request/reply over JMS then the option          * replyToConcurrentConsumers is used to control number of concurrent          * consumers on the reply message listener.          *           * The option will be converted to a<code>int</code> type.          *           * Group: consumer          */
DECL|method|concurrentConsumers ( String concurrentConsumers)
specifier|default
name|JmsEndpointConsumerBuilder
name|concurrentConsumers
parameter_list|(
name|String
name|concurrentConsumers
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"concurrentConsumers"
argument_list|,
name|concurrentConsumers
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the maximum number of concurrent consumers when consuming          * from JMS (not for request/reply over JMS). See also the          * maxMessagesPerTask option to control dynamic scaling up/down of          * threads. When doing request/reply over JMS then the option          * replyToMaxConcurrentConsumers is used to control number of concurrent          * consumers on the reply message listener.          *           * The option is a:<code>int</code> type.          *           * Group: consumer          */
DECL|method|maxConcurrentConsumers ( int maxConcurrentConsumers)
specifier|default
name|JmsEndpointConsumerBuilder
name|maxConcurrentConsumers
parameter_list|(
name|int
name|maxConcurrentConsumers
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"maxConcurrentConsumers"
argument_list|,
name|maxConcurrentConsumers
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the maximum number of concurrent consumers when consuming          * from JMS (not for request/reply over JMS). See also the          * maxMessagesPerTask option to control dynamic scaling up/down of          * threads. When doing request/reply over JMS then the option          * replyToMaxConcurrentConsumers is used to control number of concurrent          * consumers on the reply message listener.          *           * The option will be converted to a<code>int</code> type.          *           * Group: consumer          */
DECL|method|maxConcurrentConsumers ( String maxConcurrentConsumers)
specifier|default
name|JmsEndpointConsumerBuilder
name|maxConcurrentConsumers
parameter_list|(
name|String
name|maxConcurrentConsumers
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"maxConcurrentConsumers"
argument_list|,
name|maxConcurrentConsumers
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Provides an explicit ReplyTo destination, which overrides any          * incoming value of Message.getJMSReplyTo().          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: consumer          */
DECL|method|replyTo (String replyTo)
specifier|default
name|JmsEndpointConsumerBuilder
name|replyTo
parameter_list|(
name|String
name|replyTo
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"replyTo"
argument_list|,
name|replyTo
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether to use persistent delivery by default for replies.          *           * The option is a:<code>boolean</code> type.          *           * Group: consumer          */
DECL|method|replyToDeliveryPersistent ( boolean replyToDeliveryPersistent)
specifier|default
name|JmsEndpointConsumerBuilder
name|replyToDeliveryPersistent
parameter_list|(
name|boolean
name|replyToDeliveryPersistent
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"replyToDeliveryPersistent"
argument_list|,
name|replyToDeliveryPersistent
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether to use persistent delivery by default for replies.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: consumer          */
DECL|method|replyToDeliveryPersistent ( String replyToDeliveryPersistent)
specifier|default
name|JmsEndpointConsumerBuilder
name|replyToDeliveryPersistent
parameter_list|(
name|String
name|replyToDeliveryPersistent
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"replyToDeliveryPersistent"
argument_list|,
name|replyToDeliveryPersistent
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets the JMS selector to use.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: consumer          */
DECL|method|selector (String selector)
specifier|default
name|JmsEndpointConsumerBuilder
name|selector
parameter_list|(
name|String
name|selector
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"selector"
argument_list|,
name|selector
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Set whether to make the subscription durable. The durable          * subscription name to be used can be specified through the          * subscriptionName property. Default is false. Set this to true to          * register a durable subscription, typically in combination with a          * subscriptionName value (unless your message listener class name is          * good enough as subscription name). Only makes sense when listening to          * a topic (pub-sub domain), therefore this method switches the          * pubSubDomain flag as well.          *           * The option is a:<code>boolean</code> type.          *           * Group: consumer          */
DECL|method|subscriptionDurable ( boolean subscriptionDurable)
specifier|default
name|JmsEndpointConsumerBuilder
name|subscriptionDurable
parameter_list|(
name|boolean
name|subscriptionDurable
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"subscriptionDurable"
argument_list|,
name|subscriptionDurable
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Set whether to make the subscription durable. The durable          * subscription name to be used can be specified through the          * subscriptionName property. Default is false. Set this to true to          * register a durable subscription, typically in combination with a          * subscriptionName value (unless your message listener class name is          * good enough as subscription name). Only makes sense when listening to          * a topic (pub-sub domain), therefore this method switches the          * pubSubDomain flag as well.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: consumer          */
DECL|method|subscriptionDurable ( String subscriptionDurable)
specifier|default
name|JmsEndpointConsumerBuilder
name|subscriptionDurable
parameter_list|(
name|String
name|subscriptionDurable
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"subscriptionDurable"
argument_list|,
name|subscriptionDurable
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Set the name of a subscription to create. To be applied in case of a          * topic (pub-sub domain) with a shared or durable subscription. The          * subscription name needs to be unique within this client's JMS client          * id. Default is the class name of the specified message listener.          * Note: Only 1 concurrent consumer (which is the default of this          * message listener container) is allowed for each subscription, except          * for a shared subscription (which requires JMS 2.0).          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: consumer          */
DECL|method|subscriptionName ( String subscriptionName)
specifier|default
name|JmsEndpointConsumerBuilder
name|subscriptionName
parameter_list|(
name|String
name|subscriptionName
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"subscriptionName"
argument_list|,
name|subscriptionName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Set whether to make the subscription shared. The shared subscription          * name to be used can be specified through the subscriptionName          * property. Default is false. Set this to true to register a shared          * subscription, typically in combination with a subscriptionName value          * (unless your message listener class name is good enough as          * subscription name). Note that shared subscriptions may also be          * durable, so this flag can (and often will) be combined with          * subscriptionDurable as well. Only makes sense when listening to a          * topic (pub-sub domain), therefore this method switches the          * pubSubDomain flag as well. Requires a JMS 2.0 compatible message          * broker.          *           * The option is a:<code>boolean</code> type.          *           * Group: consumer          */
DECL|method|subscriptionShared ( boolean subscriptionShared)
specifier|default
name|JmsEndpointConsumerBuilder
name|subscriptionShared
parameter_list|(
name|boolean
name|subscriptionShared
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"subscriptionShared"
argument_list|,
name|subscriptionShared
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Set whether to make the subscription shared. The shared subscription          * name to be used can be specified through the subscriptionName          * property. Default is false. Set this to true to register a shared          * subscription, typically in combination with a subscriptionName value          * (unless your message listener class name is good enough as          * subscription name). Note that shared subscriptions may also be          * durable, so this flag can (and often will) be combined with          * subscriptionDurable as well. Only makes sense when listening to a          * topic (pub-sub domain), therefore this method switches the          * pubSubDomain flag as well. Requires a JMS 2.0 compatible message          * broker.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: consumer          */
DECL|method|subscriptionShared ( String subscriptionShared)
specifier|default
name|JmsEndpointConsumerBuilder
name|subscriptionShared
parameter_list|(
name|String
name|subscriptionShared
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"subscriptionShared"
argument_list|,
name|subscriptionShared
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Allows to configure the default errorHandler logging level for          * logging uncaught exceptions.          *           * The option is a:<code>org.apache.camel.LoggingLevel</code> type.          *           * Group: logging          */
DECL|method|errorHandlerLoggingLevel ( LoggingLevel errorHandlerLoggingLevel)
specifier|default
name|JmsEndpointConsumerBuilder
name|errorHandlerLoggingLevel
parameter_list|(
name|LoggingLevel
name|errorHandlerLoggingLevel
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"errorHandlerLoggingLevel"
argument_list|,
name|errorHandlerLoggingLevel
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Allows to configure the default errorHandler logging level for          * logging uncaught exceptions.          *           * The option will be converted to a          *<code>org.apache.camel.LoggingLevel</code> type.          *           * Group: logging          */
DECL|method|errorHandlerLoggingLevel ( String errorHandlerLoggingLevel)
specifier|default
name|JmsEndpointConsumerBuilder
name|errorHandlerLoggingLevel
parameter_list|(
name|String
name|errorHandlerLoggingLevel
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"errorHandlerLoggingLevel"
argument_list|,
name|errorHandlerLoggingLevel
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Allows to control whether stacktraces should be logged or not, by the          * default errorHandler.          *           * The option is a:<code>boolean</code> type.          *           * Group: logging          */
DECL|method|errorHandlerLogStackTrace ( boolean errorHandlerLogStackTrace)
specifier|default
name|JmsEndpointConsumerBuilder
name|errorHandlerLogStackTrace
parameter_list|(
name|boolean
name|errorHandlerLogStackTrace
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"errorHandlerLogStackTrace"
argument_list|,
name|errorHandlerLogStackTrace
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Allows to control whether stacktraces should be logged or not, by the          * default errorHandler.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: logging          */
DECL|method|errorHandlerLogStackTrace ( String errorHandlerLogStackTrace)
specifier|default
name|JmsEndpointConsumerBuilder
name|errorHandlerLogStackTrace
parameter_list|(
name|String
name|errorHandlerLogStackTrace
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"errorHandlerLogStackTrace"
argument_list|,
name|errorHandlerLogStackTrace
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Password to use with the ConnectionFactory. You can also configure          * username/password directly on the ConnectionFactory.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: security          */
DECL|method|password (String password)
specifier|default
name|JmsEndpointConsumerBuilder
name|password
parameter_list|(
name|String
name|password
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"password"
argument_list|,
name|password
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Username to use with the ConnectionFactory. You can also configure          * username/password directly on the ConnectionFactory.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: security          */
DECL|method|username (String username)
specifier|default
name|JmsEndpointConsumerBuilder
name|username
parameter_list|(
name|String
name|username
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"username"
argument_list|,
name|username
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether to use transacted mode.          *           * The option is a:<code>boolean</code> type.          *           * Group: transaction          */
DECL|method|transacted (boolean transacted)
specifier|default
name|JmsEndpointConsumerBuilder
name|transacted
parameter_list|(
name|boolean
name|transacted
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transacted"
argument_list|,
name|transacted
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether to use transacted mode.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: transaction          */
DECL|method|transacted (String transacted)
specifier|default
name|JmsEndpointConsumerBuilder
name|transacted
parameter_list|(
name|String
name|transacted
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transacted"
argument_list|,
name|transacted
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
comment|/**      * Advanced builder for endpoint consumers for the JMS component.      */
DECL|interface|AdvancedJmsEndpointConsumerBuilder
specifier|public
interface|interface
name|AdvancedJmsEndpointConsumerBuilder
extends|extends
name|EndpointConsumerBuilder
block|{
DECL|method|basic ()
specifier|default
name|JmsEndpointConsumerBuilder
name|basic
parameter_list|()
block|{
return|return
operator|(
name|JmsEndpointConsumerBuilder
operator|)
name|this
return|;
block|}
comment|/**          * Specifies whether the consumer accept messages while it is stopping.          * You may consider enabling this option, if you start and stop JMS          * routes at runtime, while there are still messages enqueued on the          * queue. If this option is false, and you stop the JMS route, then          * messages may be rejected, and the JMS broker would have to attempt          * redeliveries, which yet again may be rejected, and eventually the          * message may be moved at a dead letter queue on the JMS broker. To          * avoid this its recommended to enable this option.          *           * The option is a:<code>boolean</code> type.          *           * Group: consumer (advanced)          */
DECL|method|acceptMessagesWhileStopping ( boolean acceptMessagesWhileStopping)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|acceptMessagesWhileStopping
parameter_list|(
name|boolean
name|acceptMessagesWhileStopping
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"acceptMessagesWhileStopping"
argument_list|,
name|acceptMessagesWhileStopping
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether the consumer accept messages while it is stopping.          * You may consider enabling this option, if you start and stop JMS          * routes at runtime, while there are still messages enqueued on the          * queue. If this option is false, and you stop the JMS route, then          * messages may be rejected, and the JMS broker would have to attempt          * redeliveries, which yet again may be rejected, and eventually the          * message may be moved at a dead letter queue on the JMS broker. To          * avoid this its recommended to enable this option.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: consumer (advanced)          */
DECL|method|acceptMessagesWhileStopping ( String acceptMessagesWhileStopping)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|acceptMessagesWhileStopping
parameter_list|(
name|String
name|acceptMessagesWhileStopping
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"acceptMessagesWhileStopping"
argument_list|,
name|acceptMessagesWhileStopping
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the DefaultMessageListenerContainer used in the reply          * managers for request-reply messaging allow the          * DefaultMessageListenerContainer#runningAllowed() flag to quick stop          * in case JmsConfiguration#isAcceptMessagesWhileStopping() is enabled,          * and org.apache.camel.CamelContext is currently being stopped. This          * quick stop ability is enabled by default in the regular JMS consumers          * but to enable for reply managers you must enable this flag.          *           * The option is a:<code>boolean</code> type.          *           * Group: consumer (advanced)          */
DECL|method|allowReplyManagerQuickStop ( boolean allowReplyManagerQuickStop)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|allowReplyManagerQuickStop
parameter_list|(
name|boolean
name|allowReplyManagerQuickStop
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"allowReplyManagerQuickStop"
argument_list|,
name|allowReplyManagerQuickStop
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the DefaultMessageListenerContainer used in the reply          * managers for request-reply messaging allow the          * DefaultMessageListenerContainer#runningAllowed() flag to quick stop          * in case JmsConfiguration#isAcceptMessagesWhileStopping() is enabled,          * and org.apache.camel.CamelContext is currently being stopped. This          * quick stop ability is enabled by default in the regular JMS consumers          * but to enable for reply managers you must enable this flag.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: consumer (advanced)          */
DECL|method|allowReplyManagerQuickStop ( String allowReplyManagerQuickStop)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|allowReplyManagerQuickStop
parameter_list|(
name|String
name|allowReplyManagerQuickStop
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"allowReplyManagerQuickStop"
argument_list|,
name|allowReplyManagerQuickStop
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The consumer type to use, which can be one of: Simple, Default, or          * Custom. The consumer type determines which Spring JMS listener to          * use. Default will use          * org.springframework.jms.listener.DefaultMessageListenerContainer,          * Simple will use          * org.springframework.jms.listener.SimpleMessageListenerContainer. When          * Custom is specified, the MessageListenerContainerFactory defined by          * the messageListenerContainerFactory option will determine what          * org.springframework.jms.listener.AbstractMessageListenerContainer to          * use.          *           * The option is a:          *<code>org.apache.camel.component.jms.ConsumerType</code> type.          *           * Group: consumer (advanced)          */
DECL|method|consumerType ( ConsumerType consumerType)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|consumerType
parameter_list|(
name|ConsumerType
name|consumerType
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"consumerType"
argument_list|,
name|consumerType
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The consumer type to use, which can be one of: Simple, Default, or          * Custom. The consumer type determines which Spring JMS listener to          * use. Default will use          * org.springframework.jms.listener.DefaultMessageListenerContainer,          * Simple will use          * org.springframework.jms.listener.SimpleMessageListenerContainer. When          * Custom is specified, the MessageListenerContainerFactory defined by          * the messageListenerContainerFactory option will determine what          * org.springframework.jms.listener.AbstractMessageListenerContainer to          * use.          *           * The option will be converted to a          *<code>org.apache.camel.component.jms.ConsumerType</code> type.          *           * Group: consumer (advanced)          */
DECL|method|consumerType ( String consumerType)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|consumerType
parameter_list|(
name|String
name|consumerType
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"consumerType"
argument_list|,
name|consumerType
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies what default TaskExecutor type to use in the          * DefaultMessageListenerContainer, for both consumer endpoints and the          * ReplyTo consumer of producer endpoints. Possible values: SimpleAsync          * (uses Spring's SimpleAsyncTaskExecutor) or ThreadPool (uses Spring's          * ThreadPoolTaskExecutor with optimal values - cached threadpool-like).          * If not set, it defaults to the previous behaviour, which uses a          * cached thread pool for consumer endpoints and SimpleAsync for reply          * consumers. The use of ThreadPool is recommended to reduce thread          * trash in elastic configurations with dynamically increasing and          * decreasing concurrent consumers.          *           * The option is a:          *<code>org.apache.camel.component.jms.DefaultTaskExecutorType</code>          * type.          *           * Group: consumer (advanced)          */
DECL|method|defaultTaskExecutorType ( DefaultTaskExecutorType defaultTaskExecutorType)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|defaultTaskExecutorType
parameter_list|(
name|DefaultTaskExecutorType
name|defaultTaskExecutorType
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"defaultTaskExecutorType"
argument_list|,
name|defaultTaskExecutorType
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies what default TaskExecutor type to use in the          * DefaultMessageListenerContainer, for both consumer endpoints and the          * ReplyTo consumer of producer endpoints. Possible values: SimpleAsync          * (uses Spring's SimpleAsyncTaskExecutor) or ThreadPool (uses Spring's          * ThreadPoolTaskExecutor with optimal values - cached threadpool-like).          * If not set, it defaults to the previous behaviour, which uses a          * cached thread pool for consumer endpoints and SimpleAsync for reply          * consumers. The use of ThreadPool is recommended to reduce thread          * trash in elastic configurations with dynamically increasing and          * decreasing concurrent consumers.          *           * The option will be converted to a          *<code>org.apache.camel.component.jms.DefaultTaskExecutorType</code>          * type.          *           * Group: consumer (advanced)          */
DECL|method|defaultTaskExecutorType ( String defaultTaskExecutorType)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|defaultTaskExecutorType
parameter_list|(
name|String
name|defaultTaskExecutorType
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"defaultTaskExecutorType"
argument_list|,
name|defaultTaskExecutorType
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Enables eager loading of JMS properties and payload as soon as a          * message is loaded which generally is inefficient as the JMS          * properties may not be required but sometimes can catch early any          * issues with the underlying JMS provider and the use of JMS          * properties. See also the option eagerPoisonBody.          *           * The option is a:<code>boolean</code> type.          *           * Group: consumer (advanced)          */
DECL|method|eagerLoadingOfProperties ( boolean eagerLoadingOfProperties)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|eagerLoadingOfProperties
parameter_list|(
name|boolean
name|eagerLoadingOfProperties
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"eagerLoadingOfProperties"
argument_list|,
name|eagerLoadingOfProperties
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Enables eager loading of JMS properties and payload as soon as a          * message is loaded which generally is inefficient as the JMS          * properties may not be required but sometimes can catch early any          * issues with the underlying JMS provider and the use of JMS          * properties. See also the option eagerPoisonBody.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: consumer (advanced)          */
DECL|method|eagerLoadingOfProperties ( String eagerLoadingOfProperties)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|eagerLoadingOfProperties
parameter_list|(
name|String
name|eagerLoadingOfProperties
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"eagerLoadingOfProperties"
argument_list|,
name|eagerLoadingOfProperties
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If eagerLoadingOfProperties is enabled and the JMS message payload          * (JMS body or JMS properties) (cannot be read/mapped), then set this          * text as the message body instead so the message can be processed (the          * cause of the poison are already stored as exception on the Exchange).          * This can be turned off by setting eagerPoisonBody=false. See also the          * option eagerLoadingOfProperties.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: consumer (advanced)          */
DECL|method|eagerPoisonBody ( String eagerPoisonBody)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|eagerPoisonBody
parameter_list|(
name|String
name|eagerPoisonBody
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"eagerPoisonBody"
argument_list|,
name|eagerPoisonBody
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To let the consumer use a custom ExceptionHandler. Notice if the          * option bridgeErrorHandler is enabled then this option is not in use.          * By default the consumer will deal with exceptions, that will be          * logged at WARN or ERROR level and ignored.          *           * The option is a:<code>org.apache.camel.spi.ExceptionHandler</code>          * type.          *           * Group: consumer (advanced)          */
DECL|method|exceptionHandler ( ExceptionHandler exceptionHandler)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|exceptionHandler
parameter_list|(
name|ExceptionHandler
name|exceptionHandler
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"exceptionHandler"
argument_list|,
name|exceptionHandler
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To let the consumer use a custom ExceptionHandler. Notice if the          * option bridgeErrorHandler is enabled then this option is not in use.          * By default the consumer will deal with exceptions, that will be          * logged at WARN or ERROR level and ignored.          *           * The option will be converted to a          *<code>org.apache.camel.spi.ExceptionHandler</code> type.          *           * Group: consumer (advanced)          */
DECL|method|exceptionHandler ( String exceptionHandler)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|exceptionHandler
parameter_list|(
name|String
name|exceptionHandler
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"exceptionHandler"
argument_list|,
name|exceptionHandler
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets the exchange pattern when the consumer creates an exchange.          *           * The option is a:<code>org.apache.camel.ExchangePattern</code> type.          *           * Group: consumer (advanced)          */
DECL|method|exchangePattern ( ExchangePattern exchangePattern)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|exchangePattern
parameter_list|(
name|ExchangePattern
name|exchangePattern
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"exchangePattern"
argument_list|,
name|exchangePattern
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets the exchange pattern when the consumer creates an exchange.          *           * The option will be converted to a          *<code>org.apache.camel.ExchangePattern</code> type.          *           * Group: consumer (advanced)          */
DECL|method|exchangePattern ( String exchangePattern)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|exchangePattern
parameter_list|(
name|String
name|exchangePattern
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"exchangePattern"
argument_list|,
name|exchangePattern
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether the listener session should be exposed when          * consuming messages.          *           * The option is a:<code>boolean</code> type.          *           * Group: consumer (advanced)          */
DECL|method|exposeListenerSession ( boolean exposeListenerSession)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|exposeListenerSession
parameter_list|(
name|boolean
name|exposeListenerSession
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"exposeListenerSession"
argument_list|,
name|exposeListenerSession
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether the listener session should be exposed when          * consuming messages.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: consumer (advanced)          */
DECL|method|exposeListenerSession ( String exposeListenerSession)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|exposeListenerSession
parameter_list|(
name|String
name|exposeListenerSession
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"exposeListenerSession"
argument_list|,
name|exposeListenerSession
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether a JMS consumer is allowed to send a reply message to the same          * destination that the consumer is using to consume from. This prevents          * an endless loop by consuming and sending back the same message to          * itself.          *           * The option is a:<code>boolean</code> type.          *           * Group: consumer (advanced)          */
DECL|method|replyToSameDestinationAllowed ( boolean replyToSameDestinationAllowed)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|replyToSameDestinationAllowed
parameter_list|(
name|boolean
name|replyToSameDestinationAllowed
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"replyToSameDestinationAllowed"
argument_list|,
name|replyToSameDestinationAllowed
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether a JMS consumer is allowed to send a reply message to the same          * destination that the consumer is using to consume from. This prevents          * an endless loop by consuming and sending back the same message to          * itself.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: consumer (advanced)          */
DECL|method|replyToSameDestinationAllowed ( String replyToSameDestinationAllowed)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|replyToSameDestinationAllowed
parameter_list|(
name|String
name|replyToSameDestinationAllowed
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"replyToSameDestinationAllowed"
argument_list|,
name|replyToSameDestinationAllowed
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Allows you to specify a custom task executor for consuming messages.          *           * The option is a:          *<code>org.springframework.core.task.TaskExecutor</code> type.          *           * Group: consumer (advanced)          */
DECL|method|taskExecutor ( Object taskExecutor)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|taskExecutor
parameter_list|(
name|Object
name|taskExecutor
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"taskExecutor"
argument_list|,
name|taskExecutor
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Allows you to specify a custom task executor for consuming messages.          *           * The option will be converted to a          *<code>org.springframework.core.task.TaskExecutor</code> type.          *           * Group: consumer (advanced)          */
DECL|method|taskExecutor ( String taskExecutor)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|taskExecutor
parameter_list|(
name|String
name|taskExecutor
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"taskExecutor"
argument_list|,
name|taskExecutor
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Controls whether or not to include serialized headers. Applies only          * when isTransferExchange() is true. This requires that the objects are          * serializable. Camel will exclude any non-serializable objects and log          * it at WARN level.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|allowSerializedHeaders ( boolean allowSerializedHeaders)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|allowSerializedHeaders
parameter_list|(
name|boolean
name|allowSerializedHeaders
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"allowSerializedHeaders"
argument_list|,
name|allowSerializedHeaders
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Controls whether or not to include serialized headers. Applies only          * when isTransferExchange() is true. This requires that the objects are          * serializable. Camel will exclude any non-serializable objects and log          * it at WARN level.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|allowSerializedHeaders ( String allowSerializedHeaders)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|allowSerializedHeaders
parameter_list|(
name|String
name|allowSerializedHeaders
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"allowSerializedHeaders"
argument_list|,
name|allowSerializedHeaders
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to startup the JmsConsumer message listener asynchronously,          * when starting a route. For example if a JmsConsumer cannot get a          * connection to a remote JMS broker, then it may block while retrying          * and/or failover. This will cause Camel to block while starting          * routes. By setting this option to true, you will let routes startup,          * while the JmsConsumer connects to the JMS broker using a dedicated          * thread in asynchronous mode. If this option is used, then beware that          * if the connection could not be established, then an exception is          * logged at WARN level, and the consumer will not be able to receive          * messages; You can then restart the route to retry.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|asyncStartListener ( boolean asyncStartListener)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|asyncStartListener
parameter_list|(
name|boolean
name|asyncStartListener
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"asyncStartListener"
argument_list|,
name|asyncStartListener
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to startup the JmsConsumer message listener asynchronously,          * when starting a route. For example if a JmsConsumer cannot get a          * connection to a remote JMS broker, then it may block while retrying          * and/or failover. This will cause Camel to block while starting          * routes. By setting this option to true, you will let routes startup,          * while the JmsConsumer connects to the JMS broker using a dedicated          * thread in asynchronous mode. If this option is used, then beware that          * if the connection could not be established, then an exception is          * logged at WARN level, and the consumer will not be able to receive          * messages; You can then restart the route to retry.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|asyncStartListener ( String asyncStartListener)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|asyncStartListener
parameter_list|(
name|String
name|asyncStartListener
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"asyncStartListener"
argument_list|,
name|asyncStartListener
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to stop the JmsConsumer message listener asynchronously, when          * stopping a route.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|asyncStopListener ( boolean asyncStopListener)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|asyncStopListener
parameter_list|(
name|boolean
name|asyncStopListener
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"asyncStopListener"
argument_list|,
name|asyncStopListener
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to stop the JmsConsumer message listener asynchronously, when          * stopping a route.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|asyncStopListener ( String asyncStopListener)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|asyncStopListener
parameter_list|(
name|String
name|asyncStopListener
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"asyncStopListener"
argument_list|,
name|asyncStopListener
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the endpoint should use basic property binding (Camel 2.x) or          * the newer property binding with additional capabilities.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|basicPropertyBinding ( boolean basicPropertyBinding)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|basicPropertyBinding
parameter_list|(
name|boolean
name|basicPropertyBinding
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"basicPropertyBinding"
argument_list|,
name|basicPropertyBinding
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the endpoint should use basic property binding (Camel 2.x) or          * the newer property binding with additional capabilities.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|basicPropertyBinding ( String basicPropertyBinding)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|basicPropertyBinding
parameter_list|(
name|String
name|basicPropertyBinding
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"basicPropertyBinding"
argument_list|,
name|basicPropertyBinding
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * A pluggable          * org.springframework.jms.support.destination.DestinationResolver that          * allows you to use your own resolver (for example, to lookup the real          * destination in a JNDI registry).          *           * The option is a:          *<code>org.springframework.jms.support.destination.DestinationResolver</code> type.          *           * Group: advanced          */
DECL|method|destinationResolver ( Object destinationResolver)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|destinationResolver
parameter_list|(
name|Object
name|destinationResolver
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"destinationResolver"
argument_list|,
name|destinationResolver
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * A pluggable          * org.springframework.jms.support.destination.DestinationResolver that          * allows you to use your own resolver (for example, to lookup the real          * destination in a JNDI registry).          *           * The option will be converted to a          *<code>org.springframework.jms.support.destination.DestinationResolver</code> type.          *           * Group: advanced          */
DECL|method|destinationResolver ( String destinationResolver)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|destinationResolver
parameter_list|(
name|String
name|destinationResolver
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"destinationResolver"
argument_list|,
name|destinationResolver
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies a org.springframework.util.ErrorHandler to be invoked in          * case of any uncaught exceptions thrown while processing a Message. By          * default these exceptions will be logged at the WARN level, if no          * errorHandler has been configured. You can configure logging level and          * whether stack traces should be logged using errorHandlerLoggingLevel          * and errorHandlerLogStackTrace options. This makes it much easier to          * configure, than having to code a custom errorHandler.          *           * The option is a:<code>org.springframework.util.ErrorHandler</code>          * type.          *           * Group: advanced          */
DECL|method|errorHandler ( Object errorHandler)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|errorHandler
parameter_list|(
name|Object
name|errorHandler
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"errorHandler"
argument_list|,
name|errorHandler
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies a org.springframework.util.ErrorHandler to be invoked in          * case of any uncaught exceptions thrown while processing a Message. By          * default these exceptions will be logged at the WARN level, if no          * errorHandler has been configured. You can configure logging level and          * whether stack traces should be logged using errorHandlerLoggingLevel          * and errorHandlerLogStackTrace options. This makes it much easier to          * configure, than having to code a custom errorHandler.          *           * The option will be converted to a          *<code>org.springframework.util.ErrorHandler</code> type.          *           * Group: advanced          */
DECL|method|errorHandler ( String errorHandler)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|errorHandler
parameter_list|(
name|String
name|errorHandler
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"errorHandler"
argument_list|,
name|errorHandler
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the JMS Exception Listener that is to be notified of any          * underlying JMS exceptions.          *           * The option is a:<code>javax.jms.ExceptionListener</code> type.          *           * Group: advanced          */
DECL|method|exceptionListener ( Object exceptionListener)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|exceptionListener
parameter_list|(
name|Object
name|exceptionListener
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"exceptionListener"
argument_list|,
name|exceptionListener
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the JMS Exception Listener that is to be notified of any          * underlying JMS exceptions.          *           * The option will be converted to a          *<code>javax.jms.ExceptionListener</code> type.          *           * Group: advanced          */
DECL|method|exceptionListener ( String exceptionListener)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|exceptionListener
parameter_list|(
name|String
name|exceptionListener
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"exceptionListener"
argument_list|,
name|exceptionListener
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use a custom HeaderFilterStrategy to filter header to and from          * Camel message.          *           * The option is a:          *<code>org.apache.camel.spi.HeaderFilterStrategy</code> type.          *           * Group: advanced          */
DECL|method|headerFilterStrategy ( HeaderFilterStrategy headerFilterStrategy)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|headerFilterStrategy
parameter_list|(
name|HeaderFilterStrategy
name|headerFilterStrategy
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"headerFilterStrategy"
argument_list|,
name|headerFilterStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use a custom HeaderFilterStrategy to filter header to and from          * Camel message.          *           * The option will be converted to a          *<code>org.apache.camel.spi.HeaderFilterStrategy</code> type.          *           * Group: advanced          */
DECL|method|headerFilterStrategy ( String headerFilterStrategy)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|headerFilterStrategy
parameter_list|(
name|String
name|headerFilterStrategy
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"headerFilterStrategy"
argument_list|,
name|headerFilterStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specify the limit for the number of consumers that are allowed to be          * idle at any given time.          *           * The option is a:<code>int</code> type.          *           * Group: advanced          */
DECL|method|idleConsumerLimit ( int idleConsumerLimit)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|idleConsumerLimit
parameter_list|(
name|int
name|idleConsumerLimit
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"idleConsumerLimit"
argument_list|,
name|idleConsumerLimit
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specify the limit for the number of consumers that are allowed to be          * idle at any given time.          *           * The option will be converted to a<code>int</code> type.          *           * Group: advanced          */
DECL|method|idleConsumerLimit ( String idleConsumerLimit)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|idleConsumerLimit
parameter_list|(
name|String
name|idleConsumerLimit
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"idleConsumerLimit"
argument_list|,
name|idleConsumerLimit
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the limit for idle executions of a receive task, not having          * received any message within its execution. If this limit is reached,          * the task will shut down and leave receiving to other executing tasks          * (in the case of dynamic scheduling; see the maxConcurrentConsumers          * setting). There is additional doc available from Spring.          *           * The option is a:<code>int</code> type.          *           * Group: advanced          */
DECL|method|idleTaskExecutionLimit ( int idleTaskExecutionLimit)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|idleTaskExecutionLimit
parameter_list|(
name|int
name|idleTaskExecutionLimit
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"idleTaskExecutionLimit"
argument_list|,
name|idleTaskExecutionLimit
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the limit for idle executions of a receive task, not having          * received any message within its execution. If this limit is reached,          * the task will shut down and leave receiving to other executing tasks          * (in the case of dynamic scheduling; see the maxConcurrentConsumers          * setting). There is additional doc available from Spring.          *           * The option will be converted to a<code>int</code> type.          *           * Group: advanced          */
DECL|method|idleTaskExecutionLimit ( String idleTaskExecutionLimit)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|idleTaskExecutionLimit
parameter_list|(
name|String
name|idleTaskExecutionLimit
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"idleTaskExecutionLimit"
argument_list|,
name|idleTaskExecutionLimit
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to include all JMSXxxx properties when mapping from JMS to          * Camel Message. Setting this to true will include properties such as          * JMSXAppID, and JMSXUserID etc. Note: If you are using a custom          * headerFilterStrategy then this option does not apply.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|includeAllJMSXProperties ( boolean includeAllJMSXProperties)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|includeAllJMSXProperties
parameter_list|(
name|boolean
name|includeAllJMSXProperties
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"includeAllJMSXProperties"
argument_list|,
name|includeAllJMSXProperties
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to include all JMSXxxx properties when mapping from JMS to          * Camel Message. Setting this to true will include properties such as          * JMSXAppID, and JMSXUserID etc. Note: If you are using a custom          * headerFilterStrategy then this option does not apply.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|includeAllJMSXProperties ( String includeAllJMSXProperties)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|includeAllJMSXProperties
parameter_list|(
name|String
name|includeAllJMSXProperties
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"includeAllJMSXProperties"
argument_list|,
name|includeAllJMSXProperties
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Pluggable strategy for encoding and decoding JMS keys so they can be          * compliant with the JMS specification. Camel provides two          * implementations out of the box: default and passthrough. The default          * strategy will safely marshal dots and hyphens (. and -). The          * passthrough strategy leaves the key as is. Can be used for JMS          * brokers which do not care whether JMS header keys contain illegal          * characters. You can provide your own implementation of the          * org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it          * using the # notation.          *           * The option is a:          *<code>org.apache.camel.component.jms.JmsKeyFormatStrategy</code>          * type.          *           * Group: advanced          */
DECL|method|jmsKeyFormatStrategy ( Object jmsKeyFormatStrategy)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|jmsKeyFormatStrategy
parameter_list|(
name|Object
name|jmsKeyFormatStrategy
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"jmsKeyFormatStrategy"
argument_list|,
name|jmsKeyFormatStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Pluggable strategy for encoding and decoding JMS keys so they can be          * compliant with the JMS specification. Camel provides two          * implementations out of the box: default and passthrough. The default          * strategy will safely marshal dots and hyphens (. and -). The          * passthrough strategy leaves the key as is. Can be used for JMS          * brokers which do not care whether JMS header keys contain illegal          * characters. You can provide your own implementation of the          * org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it          * using the # notation.          *           * The option will be converted to a          *<code>org.apache.camel.component.jms.JmsKeyFormatStrategy</code>          * type.          *           * Group: advanced          */
DECL|method|jmsKeyFormatStrategy ( String jmsKeyFormatStrategy)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|jmsKeyFormatStrategy
parameter_list|(
name|String
name|jmsKeyFormatStrategy
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"jmsKeyFormatStrategy"
argument_list|,
name|jmsKeyFormatStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether Camel should auto map the received JMS message to a          * suited payload type, such as javax.jms.TextMessage to a String etc.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|mapJmsMessage ( boolean mapJmsMessage)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|mapJmsMessage
parameter_list|(
name|boolean
name|mapJmsMessage
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"mapJmsMessage"
argument_list|,
name|mapJmsMessage
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether Camel should auto map the received JMS message to a          * suited payload type, such as javax.jms.TextMessage to a String etc.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|mapJmsMessage ( String mapJmsMessage)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|mapJmsMessage
parameter_list|(
name|String
name|mapJmsMessage
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"mapJmsMessage"
argument_list|,
name|mapJmsMessage
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The number of messages per task. -1 is unlimited. If you use a range          * for concurrent consumers (eg min max), then this option can be used          * to set a value to eg 100 to control how fast the consumers will          * shrink when less work is required.          *           * The option is a:<code>int</code> type.          *           * Group: advanced          */
DECL|method|maxMessagesPerTask ( int maxMessagesPerTask)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|maxMessagesPerTask
parameter_list|(
name|int
name|maxMessagesPerTask
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"maxMessagesPerTask"
argument_list|,
name|maxMessagesPerTask
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The number of messages per task. -1 is unlimited. If you use a range          * for concurrent consumers (eg min max), then this option can be used          * to set a value to eg 100 to control how fast the consumers will          * shrink when less work is required.          *           * The option will be converted to a<code>int</code> type.          *           * Group: advanced          */
DECL|method|maxMessagesPerTask ( String maxMessagesPerTask)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|maxMessagesPerTask
parameter_list|(
name|String
name|maxMessagesPerTask
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"maxMessagesPerTask"
argument_list|,
name|maxMessagesPerTask
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use a custom Spring          * org.springframework.jms.support.converter.MessageConverter so you can          * be in control how to map to/from a javax.jms.Message.          *           * The option is a:          *<code>org.springframework.jms.support.converter.MessageConverter</code> type.          *           * Group: advanced          */
DECL|method|messageConverter ( Object messageConverter)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|messageConverter
parameter_list|(
name|Object
name|messageConverter
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageConverter"
argument_list|,
name|messageConverter
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use a custom Spring          * org.springframework.jms.support.converter.MessageConverter so you can          * be in control how to map to/from a javax.jms.Message.          *           * The option will be converted to a          *<code>org.springframework.jms.support.converter.MessageConverter</code> type.          *           * Group: advanced          */
DECL|method|messageConverter ( String messageConverter)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|messageConverter
parameter_list|(
name|String
name|messageConverter
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageConverter"
argument_list|,
name|messageConverter
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use the given MessageCreatedStrategy which are invoked when Camel          * creates new instances of javax.jms.Message objects when Camel is          * sending a JMS message.          *           * The option is a:          *<code>org.apache.camel.component.jms.MessageCreatedStrategy</code>          * type.          *           * Group: advanced          */
DECL|method|messageCreatedStrategy ( Object messageCreatedStrategy)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|messageCreatedStrategy
parameter_list|(
name|Object
name|messageCreatedStrategy
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageCreatedStrategy"
argument_list|,
name|messageCreatedStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use the given MessageCreatedStrategy which are invoked when Camel          * creates new instances of javax.jms.Message objects when Camel is          * sending a JMS message.          *           * The option will be converted to a          *<code>org.apache.camel.component.jms.MessageCreatedStrategy</code>          * type.          *           * Group: advanced          */
DECL|method|messageCreatedStrategy ( String messageCreatedStrategy)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|messageCreatedStrategy
parameter_list|(
name|String
name|messageCreatedStrategy
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageCreatedStrategy"
argument_list|,
name|messageCreatedStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * When sending, specifies whether message IDs should be added. This is          * just an hint to the JMS Broker. If the JMS provider accepts this          * hint, these messages must have the message ID set to null; if the          * provider ignores the hint, the message ID must be set to its normal          * unique value.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|messageIdEnabled ( boolean messageIdEnabled)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|messageIdEnabled
parameter_list|(
name|boolean
name|messageIdEnabled
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageIdEnabled"
argument_list|,
name|messageIdEnabled
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * When sending, specifies whether message IDs should be added. This is          * just an hint to the JMS Broker. If the JMS provider accepts this          * hint, these messages must have the message ID set to null; if the          * provider ignores the hint, the message ID must be set to its normal          * unique value.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|messageIdEnabled ( String messageIdEnabled)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|messageIdEnabled
parameter_list|(
name|String
name|messageIdEnabled
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageIdEnabled"
argument_list|,
name|messageIdEnabled
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Registry ID of the MessageListenerContainerFactory used to determine          * what          * org.springframework.jms.listener.AbstractMessageListenerContainer to          * use to consume messages. Setting this will automatically set          * consumerType to Custom.          *           * The option is a:          *<code>org.apache.camel.component.jms.MessageListenerContainerFactory</code> type.          *           * Group: advanced          */
DECL|method|messageListenerContainerFactory ( Object messageListenerContainerFactory)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|messageListenerContainerFactory
parameter_list|(
name|Object
name|messageListenerContainerFactory
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageListenerContainerFactory"
argument_list|,
name|messageListenerContainerFactory
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Registry ID of the MessageListenerContainerFactory used to determine          * what          * org.springframework.jms.listener.AbstractMessageListenerContainer to          * use to consume messages. Setting this will automatically set          * consumerType to Custom.          *           * The option will be converted to a          *<code>org.apache.camel.component.jms.MessageListenerContainerFactory</code> type.          *           * Group: advanced          */
DECL|method|messageListenerContainerFactory ( String messageListenerContainerFactory)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|messageListenerContainerFactory
parameter_list|(
name|String
name|messageListenerContainerFactory
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageListenerContainerFactory"
argument_list|,
name|messageListenerContainerFactory
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether timestamps should be enabled by default on sending          * messages. This is just an hint to the JMS Broker. If the JMS provider          * accepts this hint, these messages must have the timestamp set to          * zero; if the provider ignores the hint, the timestamp must be set to          * its normal value.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|messageTimestampEnabled ( boolean messageTimestampEnabled)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|messageTimestampEnabled
parameter_list|(
name|boolean
name|messageTimestampEnabled
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageTimestampEnabled"
argument_list|,
name|messageTimestampEnabled
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether timestamps should be enabled by default on sending          * messages. This is just an hint to the JMS Broker. If the JMS provider          * accepts this hint, these messages must have the timestamp set to          * zero; if the provider ignores the hint, the timestamp must be set to          * its normal value.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|messageTimestampEnabled ( String messageTimestampEnabled)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|messageTimestampEnabled
parameter_list|(
name|String
name|messageTimestampEnabled
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageTimestampEnabled"
argument_list|,
name|messageTimestampEnabled
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether to inhibit the delivery of messages published by          * its own connection.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|pubSubNoLocal ( boolean pubSubNoLocal)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|pubSubNoLocal
parameter_list|(
name|boolean
name|pubSubNoLocal
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"pubSubNoLocal"
argument_list|,
name|pubSubNoLocal
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether to inhibit the delivery of messages published by          * its own connection.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|pubSubNoLocal ( String pubSubNoLocal)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|pubSubNoLocal
parameter_list|(
name|String
name|pubSubNoLocal
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"pubSubNoLocal"
argument_list|,
name|pubSubNoLocal
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The timeout for receiving messages (in milliseconds).          *           * The option is a:<code>long</code> type.          *           * Group: advanced          */
DECL|method|receiveTimeout ( long receiveTimeout)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|receiveTimeout
parameter_list|(
name|long
name|receiveTimeout
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"receiveTimeout"
argument_list|,
name|receiveTimeout
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The timeout for receiving messages (in milliseconds).          *           * The option will be converted to a<code>long</code> type.          *           * Group: advanced          */
DECL|method|receiveTimeout ( String receiveTimeout)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|receiveTimeout
parameter_list|(
name|String
name|receiveTimeout
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"receiveTimeout"
argument_list|,
name|receiveTimeout
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the interval between recovery attempts, i.e. when a          * connection is being refreshed, in milliseconds. The default is 5000          * ms, that is, 5 seconds.          *           * The option is a:<code>long</code> type.          *           * Group: advanced          */
DECL|method|recoveryInterval ( long recoveryInterval)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|recoveryInterval
parameter_list|(
name|long
name|recoveryInterval
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"recoveryInterval"
argument_list|,
name|recoveryInterval
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the interval between recovery attempts, i.e. when a          * connection is being refreshed, in milliseconds. The default is 5000          * ms, that is, 5 seconds.          *           * The option will be converted to a<code>long</code> type.          *           * Group: advanced          */
DECL|method|recoveryInterval ( String recoveryInterval)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|recoveryInterval
parameter_list|(
name|String
name|recoveryInterval
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"recoveryInterval"
argument_list|,
name|recoveryInterval
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Configures how often Camel should check for timed out Exchanges when          * doing request/reply over JMS. By default Camel checks once per          * second. But if you must react faster when a timeout occurs, then you          * can lower this interval, to check more frequently. The timeout is          * determined by the option requestTimeout.          *           * The option is a:<code>long</code> type.          *           * Group: advanced          */
DECL|method|requestTimeoutCheckerInterval ( long requestTimeoutCheckerInterval)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|requestTimeoutCheckerInterval
parameter_list|(
name|long
name|requestTimeoutCheckerInterval
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"requestTimeoutCheckerInterval"
argument_list|,
name|requestTimeoutCheckerInterval
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Configures how often Camel should check for timed out Exchanges when          * doing request/reply over JMS. By default Camel checks once per          * second. But if you must react faster when a timeout occurs, then you          * can lower this interval, to check more frequently. The timeout is          * determined by the option requestTimeout.          *           * The option will be converted to a<code>long</code> type.          *           * Group: advanced          */
DECL|method|requestTimeoutCheckerInterval ( String requestTimeoutCheckerInterval)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|requestTimeoutCheckerInterval
parameter_list|(
name|String
name|requestTimeoutCheckerInterval
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"requestTimeoutCheckerInterval"
argument_list|,
name|requestTimeoutCheckerInterval
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets whether synchronous processing should be strictly used, or Camel          * is allowed to use asynchronous processing (if supported).          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|synchronous ( boolean synchronous)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|synchronous
parameter_list|(
name|boolean
name|synchronous
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"synchronous"
argument_list|,
name|synchronous
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets whether synchronous processing should be strictly used, or Camel          * is allowed to use asynchronous processing (if supported).          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|synchronous ( String synchronous)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|synchronous
parameter_list|(
name|String
name|synchronous
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"synchronous"
argument_list|,
name|synchronous
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If enabled and you are using Request Reply messaging (InOut) and an          * Exchange failed on the consumer side, then the caused Exception will          * be send back in response as a javax.jms.ObjectMessage. If the client          * is Camel, the returned Exception is rethrown. This allows you to use          * Camel JMS as a bridge in your routing - for example, using persistent          * queues to enable robust routing. Notice that if you also have          * transferExchange enabled, this option takes precedence. The caught          * exception is required to be serializable. The original Exception on          * the consumer side can be wrapped in an outer exception such as          * org.apache.camel.RuntimeCamelException when returned to the producer.          * Use this with caution as the data is using Java Object serialization          * and requires the received to be able to deserialize the data at Class          * level, which forces a strong coupling between the producers and          * consumer!.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|transferException ( boolean transferException)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|transferException
parameter_list|(
name|boolean
name|transferException
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transferException"
argument_list|,
name|transferException
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If enabled and you are using Request Reply messaging (InOut) and an          * Exchange failed on the consumer side, then the caused Exception will          * be send back in response as a javax.jms.ObjectMessage. If the client          * is Camel, the returned Exception is rethrown. This allows you to use          * Camel JMS as a bridge in your routing - for example, using persistent          * queues to enable robust routing. Notice that if you also have          * transferExchange enabled, this option takes precedence. The caught          * exception is required to be serializable. The original Exception on          * the consumer side can be wrapped in an outer exception such as          * org.apache.camel.RuntimeCamelException when returned to the producer.          * Use this with caution as the data is using Java Object serialization          * and requires the received to be able to deserialize the data at Class          * level, which forces a strong coupling between the producers and          * consumer!.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|transferException ( String transferException)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|transferException
parameter_list|(
name|String
name|transferException
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transferException"
argument_list|,
name|transferException
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * You can transfer the exchange over the wire instead of just the body          * and headers. The following fields are transferred: In body, Out body,          * Fault body, In headers, Out headers, Fault headers, exchange          * properties, exchange exception. This requires that the objects are          * serializable. Camel will exclude any non-serializable objects and log          * it at WARN level. You must enable this option on both the producer          * and consumer side, so Camel knows the payloads is an Exchange and not          * a regular payload. Use this with caution as the data is using Java          * Object serialization and requires the received to be able to          * deserialize the data at Class level, which forces a strong coupling          * between the producers and consumer having to use compatible Camel          * versions!.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|transferExchange ( boolean transferExchange)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|transferExchange
parameter_list|(
name|boolean
name|transferExchange
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transferExchange"
argument_list|,
name|transferExchange
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * You can transfer the exchange over the wire instead of just the body          * and headers. The following fields are transferred: In body, Out body,          * Fault body, In headers, Out headers, Fault headers, exchange          * properties, exchange exception. This requires that the objects are          * serializable. Camel will exclude any non-serializable objects and log          * it at WARN level. You must enable this option on both the producer          * and consumer side, so Camel knows the payloads is an Exchange and not          * a regular payload. Use this with caution as the data is using Java          * Object serialization and requires the received to be able to          * deserialize the data at Class level, which forces a strong coupling          * between the producers and consumer having to use compatible Camel          * versions!.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|transferExchange ( String transferExchange)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|transferExchange
parameter_list|(
name|String
name|transferExchange
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transferExchange"
argument_list|,
name|transferExchange
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether JMSMessageID should always be used as          * JMSCorrelationID for InOut messages.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|useMessageIDAsCorrelationID ( boolean useMessageIDAsCorrelationID)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|useMessageIDAsCorrelationID
parameter_list|(
name|boolean
name|useMessageIDAsCorrelationID
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"useMessageIDAsCorrelationID"
argument_list|,
name|useMessageIDAsCorrelationID
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether JMSMessageID should always be used as          * JMSCorrelationID for InOut messages.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|useMessageIDAsCorrelationID ( String useMessageIDAsCorrelationID)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|useMessageIDAsCorrelationID
parameter_list|(
name|String
name|useMessageIDAsCorrelationID
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"useMessageIDAsCorrelationID"
argument_list|,
name|useMessageIDAsCorrelationID
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Number of times to wait for provisional correlation id to be updated          * to the actual correlation id when doing request/reply over JMS and          * when the option useMessageIDAsCorrelationID is enabled.          *           * The option is a:<code>int</code> type.          *           * Group: advanced          */
DECL|method|waitForProvisionCorrelationToBeUpdatedCounter ( int waitForProvisionCorrelationToBeUpdatedCounter)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|waitForProvisionCorrelationToBeUpdatedCounter
parameter_list|(
name|int
name|waitForProvisionCorrelationToBeUpdatedCounter
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"waitForProvisionCorrelationToBeUpdatedCounter"
argument_list|,
name|waitForProvisionCorrelationToBeUpdatedCounter
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Number of times to wait for provisional correlation id to be updated          * to the actual correlation id when doing request/reply over JMS and          * when the option useMessageIDAsCorrelationID is enabled.          *           * The option will be converted to a<code>int</code> type.          *           * Group: advanced          */
DECL|method|waitForProvisionCorrelationToBeUpdatedCounter ( String waitForProvisionCorrelationToBeUpdatedCounter)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|waitForProvisionCorrelationToBeUpdatedCounter
parameter_list|(
name|String
name|waitForProvisionCorrelationToBeUpdatedCounter
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"waitForProvisionCorrelationToBeUpdatedCounter"
argument_list|,
name|waitForProvisionCorrelationToBeUpdatedCounter
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Interval in millis to sleep each time while waiting for provisional          * correlation id to be updated.          *           * The option is a:<code>long</code> type.          *           * Group: advanced          */
DECL|method|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime ( long waitForProvisionCorrelationToBeUpdatedThreadSleepingTime)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
parameter_list|(
name|long
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"waitForProvisionCorrelationToBeUpdatedThreadSleepingTime"
argument_list|,
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Interval in millis to sleep each time while waiting for provisional          * correlation id to be updated.          *           * The option will be converted to a<code>long</code> type.          *           * Group: advanced          */
DECL|method|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime ( String waitForProvisionCorrelationToBeUpdatedThreadSleepingTime)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
parameter_list|(
name|String
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"waitForProvisionCorrelationToBeUpdatedThreadSleepingTime"
argument_list|,
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If true, Camel will create a JmsTransactionManager, if there is no          * transactionManager injected when option transacted=true.          *           * The option is a:<code>boolean</code> type.          *           * Group: transaction (advanced)          */
DECL|method|lazyCreateTransactionManager ( boolean lazyCreateTransactionManager)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|lazyCreateTransactionManager
parameter_list|(
name|boolean
name|lazyCreateTransactionManager
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"lazyCreateTransactionManager"
argument_list|,
name|lazyCreateTransactionManager
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If true, Camel will create a JmsTransactionManager, if there is no          * transactionManager injected when option transacted=true.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: transaction (advanced)          */
DECL|method|lazyCreateTransactionManager ( String lazyCreateTransactionManager)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|lazyCreateTransactionManager
parameter_list|(
name|String
name|lazyCreateTransactionManager
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"lazyCreateTransactionManager"
argument_list|,
name|lazyCreateTransactionManager
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The Spring transaction manager to use.          *           * The option is a:          *<code>org.springframework.transaction.PlatformTransactionManager</code> type.          *           * Group: transaction (advanced)          */
DECL|method|transactionManager ( Object transactionManager)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|transactionManager
parameter_list|(
name|Object
name|transactionManager
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transactionManager"
argument_list|,
name|transactionManager
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The Spring transaction manager to use.          *           * The option will be converted to a          *<code>org.springframework.transaction.PlatformTransactionManager</code> type.          *           * Group: transaction (advanced)          */
DECL|method|transactionManager ( String transactionManager)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|transactionManager
parameter_list|(
name|String
name|transactionManager
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transactionManager"
argument_list|,
name|transactionManager
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The name of the transaction to use.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: transaction (advanced)          */
DECL|method|transactionName ( String transactionName)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|transactionName
parameter_list|(
name|String
name|transactionName
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transactionName"
argument_list|,
name|transactionName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The timeout value of the transaction (in seconds), if using          * transacted mode.          *           * The option is a:<code>int</code> type.          *           * Group: transaction (advanced)          */
DECL|method|transactionTimeout ( int transactionTimeout)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|transactionTimeout
parameter_list|(
name|int
name|transactionTimeout
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transactionTimeout"
argument_list|,
name|transactionTimeout
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The timeout value of the transaction (in seconds), if using          * transacted mode.          *           * The option will be converted to a<code>int</code> type.          *           * Group: transaction (advanced)          */
DECL|method|transactionTimeout ( String transactionTimeout)
specifier|default
name|AdvancedJmsEndpointConsumerBuilder
name|transactionTimeout
parameter_list|(
name|String
name|transactionTimeout
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transactionTimeout"
argument_list|,
name|transactionTimeout
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
comment|/**      * Builder for endpoint producers for the JMS component.      */
DECL|interface|JmsEndpointProducerBuilder
specifier|public
interface|interface
name|JmsEndpointProducerBuilder
extends|extends
name|EndpointProducerBuilder
block|{
DECL|method|advanced ()
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|advanced
parameter_list|()
block|{
return|return
operator|(
name|AdvancedJmsEndpointProducerBuilder
operator|)
name|this
return|;
block|}
comment|/**          * Sets the JMS client ID to use. Note that this value, if specified,          * must be unique and can only be used by a single JMS connection          * instance. It is typically only required for durable topic          * subscriptions. If using Apache ActiveMQ you may prefer to use Virtual          * Topics instead.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: common          */
DECL|method|clientId (String clientId)
specifier|default
name|JmsEndpointProducerBuilder
name|clientId
parameter_list|(
name|String
name|clientId
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"clientId"
argument_list|,
name|clientId
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets the default connection factory to be used if a connection          * factory is not specified for either          * setTemplateConnectionFactory(ConnectionFactory) or          * setListenerConnectionFactory(ConnectionFactory).          *           * The option is a:<code>javax.jms.ConnectionFactory</code> type.          *           * Group: common          */
DECL|method|connectionFactory ( Object connectionFactory)
specifier|default
name|JmsEndpointProducerBuilder
name|connectionFactory
parameter_list|(
name|Object
name|connectionFactory
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"connectionFactory"
argument_list|,
name|connectionFactory
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets the default connection factory to be used if a connection          * factory is not specified for either          * setTemplateConnectionFactory(ConnectionFactory) or          * setListenerConnectionFactory(ConnectionFactory).          *           * The option will be converted to a          *<code>javax.jms.ConnectionFactory</code> type.          *           * Group: common          */
DECL|method|connectionFactory ( String connectionFactory)
specifier|default
name|JmsEndpointProducerBuilder
name|connectionFactory
parameter_list|(
name|String
name|connectionFactory
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"connectionFactory"
argument_list|,
name|connectionFactory
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether Camel ignores the JMSReplyTo header in messages. If          * true, Camel does not send a reply back to the destination specified          * in the JMSReplyTo header. You can use this option if you want Camel          * to consume from a route and you do not want Camel to automatically          * send back a reply message because another component in your code          * handles the reply message. You can also use this option if you want          * to use Camel as a proxy between different message brokers and you          * want to route message from one system to another.          *           * The option is a:<code>boolean</code> type.          *           * Group: common          */
DECL|method|disableReplyTo (boolean disableReplyTo)
specifier|default
name|JmsEndpointProducerBuilder
name|disableReplyTo
parameter_list|(
name|boolean
name|disableReplyTo
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"disableReplyTo"
argument_list|,
name|disableReplyTo
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether Camel ignores the JMSReplyTo header in messages. If          * true, Camel does not send a reply back to the destination specified          * in the JMSReplyTo header. You can use this option if you want Camel          * to consume from a route and you do not want Camel to automatically          * send back a reply message because another component in your code          * handles the reply message. You can also use this option if you want          * to use Camel as a proxy between different message brokers and you          * want to route message from one system to another.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: common          */
DECL|method|disableReplyTo (String disableReplyTo)
specifier|default
name|JmsEndpointProducerBuilder
name|disableReplyTo
parameter_list|(
name|String
name|disableReplyTo
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"disableReplyTo"
argument_list|,
name|disableReplyTo
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The durable subscriber name for specifying durable topic          * subscriptions. The clientId option must be configured as well.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: common          */
DECL|method|durableSubscriptionName ( String durableSubscriptionName)
specifier|default
name|JmsEndpointProducerBuilder
name|durableSubscriptionName
parameter_list|(
name|String
name|durableSubscriptionName
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"durableSubscriptionName"
argument_list|,
name|durableSubscriptionName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Allows you to force the use of a specific javax.jms.Message          * implementation for sending JMS messages. Possible values are: Bytes,          * Map, Object, Stream, Text. By default, Camel would determine which          * JMS message type to use from the In body type. This option allows you          * to specify it.          *           * The option is a:          *<code>org.apache.camel.component.jms.JmsMessageType</code> type.          *           * Group: common          */
DECL|method|jmsMessageType ( JmsMessageType jmsMessageType)
specifier|default
name|JmsEndpointProducerBuilder
name|jmsMessageType
parameter_list|(
name|JmsMessageType
name|jmsMessageType
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"jmsMessageType"
argument_list|,
name|jmsMessageType
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Allows you to force the use of a specific javax.jms.Message          * implementation for sending JMS messages. Possible values are: Bytes,          * Map, Object, Stream, Text. By default, Camel would determine which          * JMS message type to use from the In body type. This option allows you          * to specify it.          *           * The option will be converted to a          *<code>org.apache.camel.component.jms.JmsMessageType</code> type.          *           * Group: common          */
DECL|method|jmsMessageType (String jmsMessageType)
specifier|default
name|JmsEndpointProducerBuilder
name|jmsMessageType
parameter_list|(
name|String
name|jmsMessageType
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"jmsMessageType"
argument_list|,
name|jmsMessageType
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether to test the connection on startup. This ensures          * that when Camel starts that all the JMS consumers have a valid          * connection to the JMS broker. If a connection cannot be granted then          * Camel throws an exception on startup. This ensures that Camel is not          * started with failed connections. The JMS producers is tested as well.          *           * The option is a:<code>boolean</code> type.          *           * Group: common          */
DECL|method|testConnectionOnStartup ( boolean testConnectionOnStartup)
specifier|default
name|JmsEndpointProducerBuilder
name|testConnectionOnStartup
parameter_list|(
name|boolean
name|testConnectionOnStartup
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"testConnectionOnStartup"
argument_list|,
name|testConnectionOnStartup
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether to test the connection on startup. This ensures          * that when Camel starts that all the JMS consumers have a valid          * connection to the JMS broker. If a connection cannot be granted then          * Camel throws an exception on startup. This ensures that Camel is not          * started with failed connections. The JMS producers is tested as well.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: common          */
DECL|method|testConnectionOnStartup ( String testConnectionOnStartup)
specifier|default
name|JmsEndpointProducerBuilder
name|testConnectionOnStartup
parameter_list|(
name|String
name|testConnectionOnStartup
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"testConnectionOnStartup"
argument_list|,
name|testConnectionOnStartup
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets delivery delay to use for send calls for JMS. This option          * requires JMS 2.0 compliant broker.          *           * The option is a:<code>long</code> type.          *           * Group: producer          */
DECL|method|deliveryDelay (long deliveryDelay)
specifier|default
name|JmsEndpointProducerBuilder
name|deliveryDelay
parameter_list|(
name|long
name|deliveryDelay
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"deliveryDelay"
argument_list|,
name|deliveryDelay
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets delivery delay to use for send calls for JMS. This option          * requires JMS 2.0 compliant broker.          *           * The option will be converted to a<code>long</code> type.          *           * Group: producer          */
DECL|method|deliveryDelay (String deliveryDelay)
specifier|default
name|JmsEndpointProducerBuilder
name|deliveryDelay
parameter_list|(
name|String
name|deliveryDelay
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"deliveryDelay"
argument_list|,
name|deliveryDelay
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the delivery mode to be used. Possibles values are those          * defined by javax.jms.DeliveryMode. NON_PERSISTENT = 1 and PERSISTENT          * = 2.          *           * The option is a:<code>java.lang.Integer</code> type.          *           * Group: producer          */
DECL|method|deliveryMode (Integer deliveryMode)
specifier|default
name|JmsEndpointProducerBuilder
name|deliveryMode
parameter_list|(
name|Integer
name|deliveryMode
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"deliveryMode"
argument_list|,
name|deliveryMode
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the delivery mode to be used. Possibles values are those          * defined by javax.jms.DeliveryMode. NON_PERSISTENT = 1 and PERSISTENT          * = 2.          *           * The option will be converted to a<code>java.lang.Integer</code>          * type.          *           * Group: producer          */
DECL|method|deliveryMode (String deliveryMode)
specifier|default
name|JmsEndpointProducerBuilder
name|deliveryMode
parameter_list|(
name|String
name|deliveryMode
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"deliveryMode"
argument_list|,
name|deliveryMode
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether persistent delivery is used by default.          *           * The option is a:<code>boolean</code> type.          *           * Group: producer          */
DECL|method|deliveryPersistent ( boolean deliveryPersistent)
specifier|default
name|JmsEndpointProducerBuilder
name|deliveryPersistent
parameter_list|(
name|boolean
name|deliveryPersistent
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"deliveryPersistent"
argument_list|,
name|deliveryPersistent
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether persistent delivery is used by default.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: producer          */
DECL|method|deliveryPersistent ( String deliveryPersistent)
specifier|default
name|JmsEndpointProducerBuilder
name|deliveryPersistent
parameter_list|(
name|String
name|deliveryPersistent
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"deliveryPersistent"
argument_list|,
name|deliveryPersistent
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Set if the deliveryMode, priority or timeToLive qualities of service          * should be used when sending messages. This option is based on          * Spring's JmsTemplate. The deliveryMode, priority and timeToLive          * options are applied to the current endpoint. This contrasts with the          * preserveMessageQos option, which operates at message granularity,          * reading QoS properties exclusively from the Camel In message headers.          *           * The option is a:<code>java.lang.Boolean</code> type.          *           * Group: producer          */
DECL|method|explicitQosEnabled ( Boolean explicitQosEnabled)
specifier|default
name|JmsEndpointProducerBuilder
name|explicitQosEnabled
parameter_list|(
name|Boolean
name|explicitQosEnabled
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"explicitQosEnabled"
argument_list|,
name|explicitQosEnabled
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Set if the deliveryMode, priority or timeToLive qualities of service          * should be used when sending messages. This option is based on          * Spring's JmsTemplate. The deliveryMode, priority and timeToLive          * options are applied to the current endpoint. This contrasts with the          * preserveMessageQos option, which operates at message granularity,          * reading QoS properties exclusively from the Camel In message headers.          *           * The option will be converted to a<code>java.lang.Boolean</code>          * type.          *           * Group: producer          */
DECL|method|explicitQosEnabled ( String explicitQosEnabled)
specifier|default
name|JmsEndpointProducerBuilder
name|explicitQosEnabled
parameter_list|(
name|String
name|explicitQosEnabled
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"explicitQosEnabled"
argument_list|,
name|explicitQosEnabled
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets whether date headers should be formatted according to the ISO          * 8601 standard.          *           * The option is a:<code>boolean</code> type.          *           * Group: producer          */
DECL|method|formatDateHeadersToIso8601 ( boolean formatDateHeadersToIso8601)
specifier|default
name|JmsEndpointProducerBuilder
name|formatDateHeadersToIso8601
parameter_list|(
name|boolean
name|formatDateHeadersToIso8601
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"formatDateHeadersToIso8601"
argument_list|,
name|formatDateHeadersToIso8601
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets whether date headers should be formatted according to the ISO          * 8601 standard.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: producer          */
DECL|method|formatDateHeadersToIso8601 ( String formatDateHeadersToIso8601)
specifier|default
name|JmsEndpointProducerBuilder
name|formatDateHeadersToIso8601
parameter_list|(
name|String
name|formatDateHeadersToIso8601
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"formatDateHeadersToIso8601"
argument_list|,
name|formatDateHeadersToIso8601
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the producer should be started lazy (on the first message).          * By starting lazy you can use this to allow CamelContext and routes to          * startup in situations where a producer may otherwise fail during          * starting and cause the route to fail being started. By deferring this          * startup to be lazy then the startup failure can be handled during          * routing messages via Camel's routing error handlers. Beware that when          * the first message is processed then creating and starting the          * producer may take a little time and prolong the total processing time          * of the processing.          *           * The option is a:<code>boolean</code> type.          *           * Group: producer          */
DECL|method|lazyStartProducer ( boolean lazyStartProducer)
specifier|default
name|JmsEndpointProducerBuilder
name|lazyStartProducer
parameter_list|(
name|boolean
name|lazyStartProducer
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"lazyStartProducer"
argument_list|,
name|lazyStartProducer
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the producer should be started lazy (on the first message).          * By starting lazy you can use this to allow CamelContext and routes to          * startup in situations where a producer may otherwise fail during          * starting and cause the route to fail being started. By deferring this          * startup to be lazy then the startup failure can be handled during          * routing messages via Camel's routing error handlers. Beware that when          * the first message is processed then creating and starting the          * producer may take a little time and prolong the total processing time          * of the processing.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: producer          */
DECL|method|lazyStartProducer ( String lazyStartProducer)
specifier|default
name|JmsEndpointProducerBuilder
name|lazyStartProducer
parameter_list|(
name|String
name|lazyStartProducer
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"lazyStartProducer"
argument_list|,
name|lazyStartProducer
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Set to true, if you want to send message using the QoS settings          * specified on the message, instead of the QoS settings on the JMS          * endpoint. The following three headers are considered JMSPriority,          * JMSDeliveryMode, and JMSExpiration. You can provide all or only some          * of them. If not provided, Camel will fall back to use the values from          * the endpoint instead. So, when using this option, the headers          * override the values from the endpoint. The explicitQosEnabled option,          * by contrast, will only use options set on the endpoint, and not          * values from the message header.          *           * The option is a:<code>boolean</code> type.          *           * Group: producer          */
DECL|method|preserveMessageQos ( boolean preserveMessageQos)
specifier|default
name|JmsEndpointProducerBuilder
name|preserveMessageQos
parameter_list|(
name|boolean
name|preserveMessageQos
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"preserveMessageQos"
argument_list|,
name|preserveMessageQos
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Set to true, if you want to send message using the QoS settings          * specified on the message, instead of the QoS settings on the JMS          * endpoint. The following three headers are considered JMSPriority,          * JMSDeliveryMode, and JMSExpiration. You can provide all or only some          * of them. If not provided, Camel will fall back to use the values from          * the endpoint instead. So, when using this option, the headers          * override the values from the endpoint. The explicitQosEnabled option,          * by contrast, will only use options set on the endpoint, and not          * values from the message header.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: producer          */
DECL|method|preserveMessageQos ( String preserveMessageQos)
specifier|default
name|JmsEndpointProducerBuilder
name|preserveMessageQos
parameter_list|(
name|String
name|preserveMessageQos
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"preserveMessageQos"
argument_list|,
name|preserveMessageQos
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Values greater than 1 specify the message priority when sending          * (where 0 is the lowest priority and 9 is the highest). The          * explicitQosEnabled option must also be enabled in order for this          * option to have any effect.          *           * The option is a:<code>int</code> type.          *           * Group: producer          */
DECL|method|priority (int priority)
specifier|default
name|JmsEndpointProducerBuilder
name|priority
parameter_list|(
name|int
name|priority
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"priority"
argument_list|,
name|priority
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Values greater than 1 specify the message priority when sending          * (where 0 is the lowest priority and 9 is the highest). The          * explicitQosEnabled option must also be enabled in order for this          * option to have any effect.          *           * The option will be converted to a<code>int</code> type.          *           * Group: producer          */
DECL|method|priority (String priority)
specifier|default
name|JmsEndpointProducerBuilder
name|priority
parameter_list|(
name|String
name|priority
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"priority"
argument_list|,
name|priority
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the default number of concurrent consumers when doing          * request/reply over JMS. See also the maxMessagesPerTask option to          * control dynamic scaling up/down of threads.          *           * The option is a:<code>int</code> type.          *           * Group: producer          */
DECL|method|replyToConcurrentConsumers ( int replyToConcurrentConsumers)
specifier|default
name|JmsEndpointProducerBuilder
name|replyToConcurrentConsumers
parameter_list|(
name|int
name|replyToConcurrentConsumers
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"replyToConcurrentConsumers"
argument_list|,
name|replyToConcurrentConsumers
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the default number of concurrent consumers when doing          * request/reply over JMS. See also the maxMessagesPerTask option to          * control dynamic scaling up/down of threads.          *           * The option will be converted to a<code>int</code> type.          *           * Group: producer          */
DECL|method|replyToConcurrentConsumers ( String replyToConcurrentConsumers)
specifier|default
name|JmsEndpointProducerBuilder
name|replyToConcurrentConsumers
parameter_list|(
name|String
name|replyToConcurrentConsumers
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"replyToConcurrentConsumers"
argument_list|,
name|replyToConcurrentConsumers
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the maximum number of concurrent consumers when using          * request/reply over JMS. See also the maxMessagesPerTask option to          * control dynamic scaling up/down of threads.          *           * The option is a:<code>int</code> type.          *           * Group: producer          */
DECL|method|replyToMaxConcurrentConsumers ( int replyToMaxConcurrentConsumers)
specifier|default
name|JmsEndpointProducerBuilder
name|replyToMaxConcurrentConsumers
parameter_list|(
name|int
name|replyToMaxConcurrentConsumers
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"replyToMaxConcurrentConsumers"
argument_list|,
name|replyToMaxConcurrentConsumers
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the maximum number of concurrent consumers when using          * request/reply over JMS. See also the maxMessagesPerTask option to          * control dynamic scaling up/down of threads.          *           * The option will be converted to a<code>int</code> type.          *           * Group: producer          */
DECL|method|replyToMaxConcurrentConsumers ( String replyToMaxConcurrentConsumers)
specifier|default
name|JmsEndpointProducerBuilder
name|replyToMaxConcurrentConsumers
parameter_list|(
name|String
name|replyToMaxConcurrentConsumers
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"replyToMaxConcurrentConsumers"
argument_list|,
name|replyToMaxConcurrentConsumers
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the maximum number of concurrent consumers for continue          * routing when timeout occurred when using request/reply over JMS.          *           * The option is a:<code>int</code> type.          *           * Group: producer          */
DECL|method|replyToOnTimeoutMaxConcurrentConsumers ( int replyToOnTimeoutMaxConcurrentConsumers)
specifier|default
name|JmsEndpointProducerBuilder
name|replyToOnTimeoutMaxConcurrentConsumers
parameter_list|(
name|int
name|replyToOnTimeoutMaxConcurrentConsumers
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"replyToOnTimeoutMaxConcurrentConsumers"
argument_list|,
name|replyToOnTimeoutMaxConcurrentConsumers
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the maximum number of concurrent consumers for continue          * routing when timeout occurred when using request/reply over JMS.          *           * The option will be converted to a<code>int</code> type.          *           * Group: producer          */
DECL|method|replyToOnTimeoutMaxConcurrentConsumers ( String replyToOnTimeoutMaxConcurrentConsumers)
specifier|default
name|JmsEndpointProducerBuilder
name|replyToOnTimeoutMaxConcurrentConsumers
parameter_list|(
name|String
name|replyToOnTimeoutMaxConcurrentConsumers
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"replyToOnTimeoutMaxConcurrentConsumers"
argument_list|,
name|replyToOnTimeoutMaxConcurrentConsumers
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Provides an explicit ReplyTo destination in the JMS message, which          * overrides the setting of replyTo. It is useful if you want to forward          * the message to a remote Queue and receive the reply message from the          * ReplyTo destination.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: producer          */
DECL|method|replyToOverride ( String replyToOverride)
specifier|default
name|JmsEndpointProducerBuilder
name|replyToOverride
parameter_list|(
name|String
name|replyToOverride
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"replyToOverride"
argument_list|,
name|replyToOverride
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Allows for explicitly specifying which kind of strategy to use for          * replyTo queues when doing request/reply over JMS. Possible values          * are: Temporary, Shared, or Exclusive. By default Camel will use          * temporary queues. However if replyTo has been configured, then Shared          * is used by default. This option allows you to use exclusive queues          * instead of shared ones. See Camel JMS documentation for more details,          * and especially the notes about the implications if running in a          * clustered environment, and the fact that Shared reply queues has          * lower performance than its alternatives Temporary and Exclusive.          *           * The option is a:          *<code>org.apache.camel.component.jms.ReplyToType</code> type.          *           * Group: producer          */
DECL|method|replyToType (ReplyToType replyToType)
specifier|default
name|JmsEndpointProducerBuilder
name|replyToType
parameter_list|(
name|ReplyToType
name|replyToType
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"replyToType"
argument_list|,
name|replyToType
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Allows for explicitly specifying which kind of strategy to use for          * replyTo queues when doing request/reply over JMS. Possible values          * are: Temporary, Shared, or Exclusive. By default Camel will use          * temporary queues. However if replyTo has been configured, then Shared          * is used by default. This option allows you to use exclusive queues          * instead of shared ones. See Camel JMS documentation for more details,          * and especially the notes about the implications if running in a          * clustered environment, and the fact that Shared reply queues has          * lower performance than its alternatives Temporary and Exclusive.          *           * The option will be converted to a          *<code>org.apache.camel.component.jms.ReplyToType</code> type.          *           * Group: producer          */
DECL|method|replyToType (String replyToType)
specifier|default
name|JmsEndpointProducerBuilder
name|replyToType
parameter_list|(
name|String
name|replyToType
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"replyToType"
argument_list|,
name|replyToType
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The timeout for waiting for a reply when using the InOut Exchange          * Pattern (in milliseconds). The default is 20 seconds. You can include          * the header CamelJmsRequestTimeout to override this endpoint          * configured timeout value, and thus have per message individual          * timeout values. See also the requestTimeoutCheckerInterval option.          *           * The option is a:<code>long</code> type.          *           * Group: producer          */
DECL|method|requestTimeout (long requestTimeout)
specifier|default
name|JmsEndpointProducerBuilder
name|requestTimeout
parameter_list|(
name|long
name|requestTimeout
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"requestTimeout"
argument_list|,
name|requestTimeout
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The timeout for waiting for a reply when using the InOut Exchange          * Pattern (in milliseconds). The default is 20 seconds. You can include          * the header CamelJmsRequestTimeout to override this endpoint          * configured timeout value, and thus have per message individual          * timeout values. See also the requestTimeoutCheckerInterval option.          *           * The option will be converted to a<code>long</code> type.          *           * Group: producer          */
DECL|method|requestTimeout (String requestTimeout)
specifier|default
name|JmsEndpointProducerBuilder
name|requestTimeout
parameter_list|(
name|String
name|requestTimeout
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"requestTimeout"
argument_list|,
name|requestTimeout
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * When sending messages, specifies the time-to-live of the message (in          * milliseconds).          *           * The option is a:<code>long</code> type.          *           * Group: producer          */
DECL|method|timeToLive (long timeToLive)
specifier|default
name|JmsEndpointProducerBuilder
name|timeToLive
parameter_list|(
name|long
name|timeToLive
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"timeToLive"
argument_list|,
name|timeToLive
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * When sending messages, specifies the time-to-live of the message (in          * milliseconds).          *           * The option will be converted to a<code>long</code> type.          *           * Group: producer          */
DECL|method|timeToLive (String timeToLive)
specifier|default
name|JmsEndpointProducerBuilder
name|timeToLive
parameter_list|(
name|String
name|timeToLive
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"timeToLive"
argument_list|,
name|timeToLive
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Password to use with the ConnectionFactory. You can also configure          * username/password directly on the ConnectionFactory.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: security          */
DECL|method|password (String password)
specifier|default
name|JmsEndpointProducerBuilder
name|password
parameter_list|(
name|String
name|password
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"password"
argument_list|,
name|password
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Username to use with the ConnectionFactory. You can also configure          * username/password directly on the ConnectionFactory.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: security          */
DECL|method|username (String username)
specifier|default
name|JmsEndpointProducerBuilder
name|username
parameter_list|(
name|String
name|username
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"username"
argument_list|,
name|username
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether to use transacted mode.          *           * The option is a:<code>boolean</code> type.          *           * Group: transaction          */
DECL|method|transacted (boolean transacted)
specifier|default
name|JmsEndpointProducerBuilder
name|transacted
parameter_list|(
name|boolean
name|transacted
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transacted"
argument_list|,
name|transacted
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether to use transacted mode.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: transaction          */
DECL|method|transacted (String transacted)
specifier|default
name|JmsEndpointProducerBuilder
name|transacted
parameter_list|(
name|String
name|transacted
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transacted"
argument_list|,
name|transacted
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
comment|/**      * Advanced builder for endpoint producers for the JMS component.      */
DECL|interface|AdvancedJmsEndpointProducerBuilder
specifier|public
interface|interface
name|AdvancedJmsEndpointProducerBuilder
extends|extends
name|EndpointProducerBuilder
block|{
DECL|method|basic ()
specifier|default
name|JmsEndpointProducerBuilder
name|basic
parameter_list|()
block|{
return|return
operator|(
name|JmsEndpointProducerBuilder
operator|)
name|this
return|;
block|}
comment|/**          * This option is used to allow additional headers which may have values          * that are invalid according to JMS specification. For example some          * message systems such as WMQ do this with header names using prefix          * JMS_IBM_MQMD_ containing values with byte array or other invalid          * types. You can specify multiple header names separated by comma, and          * use as suffix for wildcard matching.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: producer (advanced)          */
DECL|method|allowAdditionalHeaders ( String allowAdditionalHeaders)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|allowAdditionalHeaders
parameter_list|(
name|String
name|allowAdditionalHeaders
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"allowAdditionalHeaders"
argument_list|,
name|allowAdditionalHeaders
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to allow sending messages with no body. If this option is          * false and the message body is null, then an JMSException is thrown.          *           * The option is a:<code>boolean</code> type.          *           * Group: producer (advanced)          */
DECL|method|allowNullBody ( boolean allowNullBody)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|allowNullBody
parameter_list|(
name|boolean
name|allowNullBody
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"allowNullBody"
argument_list|,
name|allowNullBody
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to allow sending messages with no body. If this option is          * false and the message body is null, then an JMSException is thrown.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: producer (advanced)          */
DECL|method|allowNullBody ( String allowNullBody)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|allowNullBody
parameter_list|(
name|String
name|allowNullBody
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"allowNullBody"
argument_list|,
name|allowNullBody
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If true, Camel will always make a JMS message copy of the message          * when it is passed to the producer for sending. Copying the message is          * needed in some situations, such as when a          * replyToDestinationSelectorName is set (incidentally, Camel will set          * the alwaysCopyMessage option to true, if a          * replyToDestinationSelectorName is set).          *           * The option is a:<code>boolean</code> type.          *           * Group: producer (advanced)          */
DECL|method|alwaysCopyMessage ( boolean alwaysCopyMessage)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|alwaysCopyMessage
parameter_list|(
name|boolean
name|alwaysCopyMessage
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"alwaysCopyMessage"
argument_list|,
name|alwaysCopyMessage
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If true, Camel will always make a JMS message copy of the message          * when it is passed to the producer for sending. Copying the message is          * needed in some situations, such as when a          * replyToDestinationSelectorName is set (incidentally, Camel will set          * the alwaysCopyMessage option to true, if a          * replyToDestinationSelectorName is set).          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: producer (advanced)          */
DECL|method|alwaysCopyMessage ( String alwaysCopyMessage)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|alwaysCopyMessage
parameter_list|(
name|String
name|alwaysCopyMessage
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"alwaysCopyMessage"
argument_list|,
name|alwaysCopyMessage
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Use this JMS property to correlate messages in InOut exchange pattern          * (request-reply) instead of JMSCorrelationID property. This allows you          * to exchange messages with systems that do not correlate messages          * using JMSCorrelationID JMS property. If used JMSCorrelationID will          * not be used or set by Camel. The value of here named property will be          * generated if not supplied in the header of the message under the same          * name.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: producer (advanced)          */
DECL|method|correlationProperty ( String correlationProperty)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|correlationProperty
parameter_list|(
name|String
name|correlationProperty
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"correlationProperty"
argument_list|,
name|correlationProperty
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Use this option to force disabling time to live. For example when you          * do request/reply over JMS, then Camel will by default use the          * requestTimeout value as time to live on the message being sent. The          * problem is that the sender and receiver systems have to have their          * clocks synchronized, so they are in sync. This is not always so easy          * to archive. So you can use disableTimeToLive=true to not set a time          * to live value on the sent message. Then the message will not expire          * on the receiver system. See below in section About time to live for          * more details.          *           * The option is a:<code>boolean</code> type.          *           * Group: producer (advanced)          */
DECL|method|disableTimeToLive ( boolean disableTimeToLive)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|disableTimeToLive
parameter_list|(
name|boolean
name|disableTimeToLive
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"disableTimeToLive"
argument_list|,
name|disableTimeToLive
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Use this option to force disabling time to live. For example when you          * do request/reply over JMS, then Camel will by default use the          * requestTimeout value as time to live on the message being sent. The          * problem is that the sender and receiver systems have to have their          * clocks synchronized, so they are in sync. This is not always so easy          * to archive. So you can use disableTimeToLive=true to not set a time          * to live value on the sent message. Then the message will not expire          * on the receiver system. See below in section About time to live for          * more details.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: producer (advanced)          */
DECL|method|disableTimeToLive ( String disableTimeToLive)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|disableTimeToLive
parameter_list|(
name|String
name|disableTimeToLive
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"disableTimeToLive"
argument_list|,
name|disableTimeToLive
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * When using mapJmsMessage=false Camel will create a new JMS message to          * send to a new JMS destination if you touch the headers (get or set)          * during the route. Set this option to true to force Camel to send the          * original JMS message that was received.          *           * The option is a:<code>boolean</code> type.          *           * Group: producer (advanced)          */
DECL|method|forceSendOriginalMessage ( boolean forceSendOriginalMessage)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|forceSendOriginalMessage
parameter_list|(
name|boolean
name|forceSendOriginalMessage
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"forceSendOriginalMessage"
argument_list|,
name|forceSendOriginalMessage
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * When using mapJmsMessage=false Camel will create a new JMS message to          * send to a new JMS destination if you touch the headers (get or set)          * during the route. Set this option to true to force Camel to send the          * original JMS message that was received.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: producer (advanced)          */
DECL|method|forceSendOriginalMessage ( String forceSendOriginalMessage)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|forceSendOriginalMessage
parameter_list|(
name|String
name|forceSendOriginalMessage
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"forceSendOriginalMessage"
argument_list|,
name|forceSendOriginalMessage
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Only applicable when sending to JMS destination using InOnly (eg fire          * and forget). Enabling this option will enrich the Camel Exchange with          * the actual JMSMessageID that was used by the JMS client when the          * message was sent to the JMS destination.          *           * The option is a:<code>boolean</code> type.          *           * Group: producer (advanced)          */
DECL|method|includeSentJMSMessageID ( boolean includeSentJMSMessageID)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|includeSentJMSMessageID
parameter_list|(
name|boolean
name|includeSentJMSMessageID
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"includeSentJMSMessageID"
argument_list|,
name|includeSentJMSMessageID
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Only applicable when sending to JMS destination using InOnly (eg fire          * and forget). Enabling this option will enrich the Camel Exchange with          * the actual JMSMessageID that was used by the JMS client when the          * message was sent to the JMS destination.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: producer (advanced)          */
DECL|method|includeSentJMSMessageID ( String includeSentJMSMessageID)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|includeSentJMSMessageID
parameter_list|(
name|String
name|includeSentJMSMessageID
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"includeSentJMSMessageID"
argument_list|,
name|includeSentJMSMessageID
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets the cache level by name for the reply consumer when doing          * request/reply over JMS. This option only applies when using fixed          * reply queues (not temporary). Camel will by default use:          * CACHE_CONSUMER for exclusive or shared w/ replyToSelectorName. And          * CACHE_SESSION for shared without replyToSelectorName. Some JMS          * brokers such as IBM WebSphere may require to set the          * replyToCacheLevelName=CACHE_NONE to work. Note: If using temporary          * queues then CACHE_NONE is not allowed, and you must use a higher          * value such as CACHE_CONSUMER or CACHE_SESSION.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: producer (advanced)          */
DECL|method|replyToCacheLevelName ( String replyToCacheLevelName)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|replyToCacheLevelName
parameter_list|(
name|String
name|replyToCacheLevelName
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"replyToCacheLevelName"
argument_list|,
name|replyToCacheLevelName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets the JMS Selector using the fixed name to be used so you can          * filter out your own replies from the others when using a shared queue          * (that is, if you are not using a temporary reply queue).          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: producer (advanced)          */
DECL|method|replyToDestinationSelectorName ( String replyToDestinationSelectorName)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|replyToDestinationSelectorName
parameter_list|(
name|String
name|replyToDestinationSelectorName
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"replyToDestinationSelectorName"
argument_list|,
name|replyToDestinationSelectorName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets whether StreamMessage type is enabled or not. Message payloads          * of streaming kind such as files, InputStream, etc will either by sent          * as BytesMessage or StreamMessage. This option controls which kind          * will be used. By default BytesMessage is used which enforces the          * entire message payload to be read into memory. By enabling this          * option the message payload is read into memory in chunks and each          * chunk is then written to the StreamMessage until no more data.          *           * The option is a:<code>boolean</code> type.          *           * Group: producer (advanced)          */
DECL|method|streamMessageTypeEnabled ( boolean streamMessageTypeEnabled)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|streamMessageTypeEnabled
parameter_list|(
name|boolean
name|streamMessageTypeEnabled
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"streamMessageTypeEnabled"
argument_list|,
name|streamMessageTypeEnabled
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets whether StreamMessage type is enabled or not. Message payloads          * of streaming kind such as files, InputStream, etc will either by sent          * as BytesMessage or StreamMessage. This option controls which kind          * will be used. By default BytesMessage is used which enforces the          * entire message payload to be read into memory. By enabling this          * option the message payload is read into memory in chunks and each          * chunk is then written to the StreamMessage until no more data.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: producer (advanced)          */
DECL|method|streamMessageTypeEnabled ( String streamMessageTypeEnabled)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|streamMessageTypeEnabled
parameter_list|(
name|String
name|streamMessageTypeEnabled
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"streamMessageTypeEnabled"
argument_list|,
name|streamMessageTypeEnabled
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Controls whether or not to include serialized headers. Applies only          * when isTransferExchange() is true. This requires that the objects are          * serializable. Camel will exclude any non-serializable objects and log          * it at WARN level.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|allowSerializedHeaders ( boolean allowSerializedHeaders)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|allowSerializedHeaders
parameter_list|(
name|boolean
name|allowSerializedHeaders
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"allowSerializedHeaders"
argument_list|,
name|allowSerializedHeaders
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Controls whether or not to include serialized headers. Applies only          * when isTransferExchange() is true. This requires that the objects are          * serializable. Camel will exclude any non-serializable objects and log          * it at WARN level.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|allowSerializedHeaders ( String allowSerializedHeaders)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|allowSerializedHeaders
parameter_list|(
name|String
name|allowSerializedHeaders
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"allowSerializedHeaders"
argument_list|,
name|allowSerializedHeaders
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to startup the JmsConsumer message listener asynchronously,          * when starting a route. For example if a JmsConsumer cannot get a          * connection to a remote JMS broker, then it may block while retrying          * and/or failover. This will cause Camel to block while starting          * routes. By setting this option to true, you will let routes startup,          * while the JmsConsumer connects to the JMS broker using a dedicated          * thread in asynchronous mode. If this option is used, then beware that          * if the connection could not be established, then an exception is          * logged at WARN level, and the consumer will not be able to receive          * messages; You can then restart the route to retry.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|asyncStartListener ( boolean asyncStartListener)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|asyncStartListener
parameter_list|(
name|boolean
name|asyncStartListener
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"asyncStartListener"
argument_list|,
name|asyncStartListener
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to startup the JmsConsumer message listener asynchronously,          * when starting a route. For example if a JmsConsumer cannot get a          * connection to a remote JMS broker, then it may block while retrying          * and/or failover. This will cause Camel to block while starting          * routes. By setting this option to true, you will let routes startup,          * while the JmsConsumer connects to the JMS broker using a dedicated          * thread in asynchronous mode. If this option is used, then beware that          * if the connection could not be established, then an exception is          * logged at WARN level, and the consumer will not be able to receive          * messages; You can then restart the route to retry.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|asyncStartListener ( String asyncStartListener)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|asyncStartListener
parameter_list|(
name|String
name|asyncStartListener
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"asyncStartListener"
argument_list|,
name|asyncStartListener
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to stop the JmsConsumer message listener asynchronously, when          * stopping a route.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|asyncStopListener ( boolean asyncStopListener)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|asyncStopListener
parameter_list|(
name|boolean
name|asyncStopListener
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"asyncStopListener"
argument_list|,
name|asyncStopListener
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to stop the JmsConsumer message listener asynchronously, when          * stopping a route.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|asyncStopListener ( String asyncStopListener)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|asyncStopListener
parameter_list|(
name|String
name|asyncStopListener
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"asyncStopListener"
argument_list|,
name|asyncStopListener
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the endpoint should use basic property binding (Camel 2.x) or          * the newer property binding with additional capabilities.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|basicPropertyBinding ( boolean basicPropertyBinding)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|basicPropertyBinding
parameter_list|(
name|boolean
name|basicPropertyBinding
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"basicPropertyBinding"
argument_list|,
name|basicPropertyBinding
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the endpoint should use basic property binding (Camel 2.x) or          * the newer property binding with additional capabilities.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|basicPropertyBinding ( String basicPropertyBinding)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|basicPropertyBinding
parameter_list|(
name|String
name|basicPropertyBinding
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"basicPropertyBinding"
argument_list|,
name|basicPropertyBinding
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * A pluggable          * org.springframework.jms.support.destination.DestinationResolver that          * allows you to use your own resolver (for example, to lookup the real          * destination in a JNDI registry).          *           * The option is a:          *<code>org.springframework.jms.support.destination.DestinationResolver</code> type.          *           * Group: advanced          */
DECL|method|destinationResolver ( Object destinationResolver)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|destinationResolver
parameter_list|(
name|Object
name|destinationResolver
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"destinationResolver"
argument_list|,
name|destinationResolver
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * A pluggable          * org.springframework.jms.support.destination.DestinationResolver that          * allows you to use your own resolver (for example, to lookup the real          * destination in a JNDI registry).          *           * The option will be converted to a          *<code>org.springframework.jms.support.destination.DestinationResolver</code> type.          *           * Group: advanced          */
DECL|method|destinationResolver ( String destinationResolver)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|destinationResolver
parameter_list|(
name|String
name|destinationResolver
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"destinationResolver"
argument_list|,
name|destinationResolver
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies a org.springframework.util.ErrorHandler to be invoked in          * case of any uncaught exceptions thrown while processing a Message. By          * default these exceptions will be logged at the WARN level, if no          * errorHandler has been configured. You can configure logging level and          * whether stack traces should be logged using errorHandlerLoggingLevel          * and errorHandlerLogStackTrace options. This makes it much easier to          * configure, than having to code a custom errorHandler.          *           * The option is a:<code>org.springframework.util.ErrorHandler</code>          * type.          *           * Group: advanced          */
DECL|method|errorHandler ( Object errorHandler)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|errorHandler
parameter_list|(
name|Object
name|errorHandler
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"errorHandler"
argument_list|,
name|errorHandler
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies a org.springframework.util.ErrorHandler to be invoked in          * case of any uncaught exceptions thrown while processing a Message. By          * default these exceptions will be logged at the WARN level, if no          * errorHandler has been configured. You can configure logging level and          * whether stack traces should be logged using errorHandlerLoggingLevel          * and errorHandlerLogStackTrace options. This makes it much easier to          * configure, than having to code a custom errorHandler.          *           * The option will be converted to a          *<code>org.springframework.util.ErrorHandler</code> type.          *           * Group: advanced          */
DECL|method|errorHandler ( String errorHandler)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|errorHandler
parameter_list|(
name|String
name|errorHandler
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"errorHandler"
argument_list|,
name|errorHandler
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the JMS Exception Listener that is to be notified of any          * underlying JMS exceptions.          *           * The option is a:<code>javax.jms.ExceptionListener</code> type.          *           * Group: advanced          */
DECL|method|exceptionListener ( Object exceptionListener)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|exceptionListener
parameter_list|(
name|Object
name|exceptionListener
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"exceptionListener"
argument_list|,
name|exceptionListener
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the JMS Exception Listener that is to be notified of any          * underlying JMS exceptions.          *           * The option will be converted to a          *<code>javax.jms.ExceptionListener</code> type.          *           * Group: advanced          */
DECL|method|exceptionListener ( String exceptionListener)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|exceptionListener
parameter_list|(
name|String
name|exceptionListener
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"exceptionListener"
argument_list|,
name|exceptionListener
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use a custom HeaderFilterStrategy to filter header to and from          * Camel message.          *           * The option is a:          *<code>org.apache.camel.spi.HeaderFilterStrategy</code> type.          *           * Group: advanced          */
DECL|method|headerFilterStrategy ( HeaderFilterStrategy headerFilterStrategy)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|headerFilterStrategy
parameter_list|(
name|HeaderFilterStrategy
name|headerFilterStrategy
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"headerFilterStrategy"
argument_list|,
name|headerFilterStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use a custom HeaderFilterStrategy to filter header to and from          * Camel message.          *           * The option will be converted to a          *<code>org.apache.camel.spi.HeaderFilterStrategy</code> type.          *           * Group: advanced          */
DECL|method|headerFilterStrategy ( String headerFilterStrategy)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|headerFilterStrategy
parameter_list|(
name|String
name|headerFilterStrategy
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"headerFilterStrategy"
argument_list|,
name|headerFilterStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specify the limit for the number of consumers that are allowed to be          * idle at any given time.          *           * The option is a:<code>int</code> type.          *           * Group: advanced          */
DECL|method|idleConsumerLimit ( int idleConsumerLimit)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|idleConsumerLimit
parameter_list|(
name|int
name|idleConsumerLimit
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"idleConsumerLimit"
argument_list|,
name|idleConsumerLimit
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specify the limit for the number of consumers that are allowed to be          * idle at any given time.          *           * The option will be converted to a<code>int</code> type.          *           * Group: advanced          */
DECL|method|idleConsumerLimit ( String idleConsumerLimit)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|idleConsumerLimit
parameter_list|(
name|String
name|idleConsumerLimit
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"idleConsumerLimit"
argument_list|,
name|idleConsumerLimit
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the limit for idle executions of a receive task, not having          * received any message within its execution. If this limit is reached,          * the task will shut down and leave receiving to other executing tasks          * (in the case of dynamic scheduling; see the maxConcurrentConsumers          * setting). There is additional doc available from Spring.          *           * The option is a:<code>int</code> type.          *           * Group: advanced          */
DECL|method|idleTaskExecutionLimit ( int idleTaskExecutionLimit)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|idleTaskExecutionLimit
parameter_list|(
name|int
name|idleTaskExecutionLimit
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"idleTaskExecutionLimit"
argument_list|,
name|idleTaskExecutionLimit
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the limit for idle executions of a receive task, not having          * received any message within its execution. If this limit is reached,          * the task will shut down and leave receiving to other executing tasks          * (in the case of dynamic scheduling; see the maxConcurrentConsumers          * setting). There is additional doc available from Spring.          *           * The option will be converted to a<code>int</code> type.          *           * Group: advanced          */
DECL|method|idleTaskExecutionLimit ( String idleTaskExecutionLimit)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|idleTaskExecutionLimit
parameter_list|(
name|String
name|idleTaskExecutionLimit
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"idleTaskExecutionLimit"
argument_list|,
name|idleTaskExecutionLimit
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to include all JMSXxxx properties when mapping from JMS to          * Camel Message. Setting this to true will include properties such as          * JMSXAppID, and JMSXUserID etc. Note: If you are using a custom          * headerFilterStrategy then this option does not apply.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|includeAllJMSXProperties ( boolean includeAllJMSXProperties)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|includeAllJMSXProperties
parameter_list|(
name|boolean
name|includeAllJMSXProperties
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"includeAllJMSXProperties"
argument_list|,
name|includeAllJMSXProperties
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to include all JMSXxxx properties when mapping from JMS to          * Camel Message. Setting this to true will include properties such as          * JMSXAppID, and JMSXUserID etc. Note: If you are using a custom          * headerFilterStrategy then this option does not apply.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|includeAllJMSXProperties ( String includeAllJMSXProperties)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|includeAllJMSXProperties
parameter_list|(
name|String
name|includeAllJMSXProperties
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"includeAllJMSXProperties"
argument_list|,
name|includeAllJMSXProperties
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Pluggable strategy for encoding and decoding JMS keys so they can be          * compliant with the JMS specification. Camel provides two          * implementations out of the box: default and passthrough. The default          * strategy will safely marshal dots and hyphens (. and -). The          * passthrough strategy leaves the key as is. Can be used for JMS          * brokers which do not care whether JMS header keys contain illegal          * characters. You can provide your own implementation of the          * org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it          * using the # notation.          *           * The option is a:          *<code>org.apache.camel.component.jms.JmsKeyFormatStrategy</code>          * type.          *           * Group: advanced          */
DECL|method|jmsKeyFormatStrategy ( Object jmsKeyFormatStrategy)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|jmsKeyFormatStrategy
parameter_list|(
name|Object
name|jmsKeyFormatStrategy
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"jmsKeyFormatStrategy"
argument_list|,
name|jmsKeyFormatStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Pluggable strategy for encoding and decoding JMS keys so they can be          * compliant with the JMS specification. Camel provides two          * implementations out of the box: default and passthrough. The default          * strategy will safely marshal dots and hyphens (. and -). The          * passthrough strategy leaves the key as is. Can be used for JMS          * brokers which do not care whether JMS header keys contain illegal          * characters. You can provide your own implementation of the          * org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it          * using the # notation.          *           * The option will be converted to a          *<code>org.apache.camel.component.jms.JmsKeyFormatStrategy</code>          * type.          *           * Group: advanced          */
DECL|method|jmsKeyFormatStrategy ( String jmsKeyFormatStrategy)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|jmsKeyFormatStrategy
parameter_list|(
name|String
name|jmsKeyFormatStrategy
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"jmsKeyFormatStrategy"
argument_list|,
name|jmsKeyFormatStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether Camel should auto map the received JMS message to a          * suited payload type, such as javax.jms.TextMessage to a String etc.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|mapJmsMessage ( boolean mapJmsMessage)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|mapJmsMessage
parameter_list|(
name|boolean
name|mapJmsMessage
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"mapJmsMessage"
argument_list|,
name|mapJmsMessage
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether Camel should auto map the received JMS message to a          * suited payload type, such as javax.jms.TextMessage to a String etc.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|mapJmsMessage ( String mapJmsMessage)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|mapJmsMessage
parameter_list|(
name|String
name|mapJmsMessage
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"mapJmsMessage"
argument_list|,
name|mapJmsMessage
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The number of messages per task. -1 is unlimited. If you use a range          * for concurrent consumers (eg min max), then this option can be used          * to set a value to eg 100 to control how fast the consumers will          * shrink when less work is required.          *           * The option is a:<code>int</code> type.          *           * Group: advanced          */
DECL|method|maxMessagesPerTask ( int maxMessagesPerTask)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|maxMessagesPerTask
parameter_list|(
name|int
name|maxMessagesPerTask
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"maxMessagesPerTask"
argument_list|,
name|maxMessagesPerTask
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The number of messages per task. -1 is unlimited. If you use a range          * for concurrent consumers (eg min max), then this option can be used          * to set a value to eg 100 to control how fast the consumers will          * shrink when less work is required.          *           * The option will be converted to a<code>int</code> type.          *           * Group: advanced          */
DECL|method|maxMessagesPerTask ( String maxMessagesPerTask)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|maxMessagesPerTask
parameter_list|(
name|String
name|maxMessagesPerTask
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"maxMessagesPerTask"
argument_list|,
name|maxMessagesPerTask
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use a custom Spring          * org.springframework.jms.support.converter.MessageConverter so you can          * be in control how to map to/from a javax.jms.Message.          *           * The option is a:          *<code>org.springframework.jms.support.converter.MessageConverter</code> type.          *           * Group: advanced          */
DECL|method|messageConverter ( Object messageConverter)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|messageConverter
parameter_list|(
name|Object
name|messageConverter
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageConverter"
argument_list|,
name|messageConverter
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use a custom Spring          * org.springframework.jms.support.converter.MessageConverter so you can          * be in control how to map to/from a javax.jms.Message.          *           * The option will be converted to a          *<code>org.springframework.jms.support.converter.MessageConverter</code> type.          *           * Group: advanced          */
DECL|method|messageConverter ( String messageConverter)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|messageConverter
parameter_list|(
name|String
name|messageConverter
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageConverter"
argument_list|,
name|messageConverter
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use the given MessageCreatedStrategy which are invoked when Camel          * creates new instances of javax.jms.Message objects when Camel is          * sending a JMS message.          *           * The option is a:          *<code>org.apache.camel.component.jms.MessageCreatedStrategy</code>          * type.          *           * Group: advanced          */
DECL|method|messageCreatedStrategy ( Object messageCreatedStrategy)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|messageCreatedStrategy
parameter_list|(
name|Object
name|messageCreatedStrategy
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageCreatedStrategy"
argument_list|,
name|messageCreatedStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use the given MessageCreatedStrategy which are invoked when Camel          * creates new instances of javax.jms.Message objects when Camel is          * sending a JMS message.          *           * The option will be converted to a          *<code>org.apache.camel.component.jms.MessageCreatedStrategy</code>          * type.          *           * Group: advanced          */
DECL|method|messageCreatedStrategy ( String messageCreatedStrategy)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|messageCreatedStrategy
parameter_list|(
name|String
name|messageCreatedStrategy
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageCreatedStrategy"
argument_list|,
name|messageCreatedStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * When sending, specifies whether message IDs should be added. This is          * just an hint to the JMS Broker. If the JMS provider accepts this          * hint, these messages must have the message ID set to null; if the          * provider ignores the hint, the message ID must be set to its normal          * unique value.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|messageIdEnabled ( boolean messageIdEnabled)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|messageIdEnabled
parameter_list|(
name|boolean
name|messageIdEnabled
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageIdEnabled"
argument_list|,
name|messageIdEnabled
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * When sending, specifies whether message IDs should be added. This is          * just an hint to the JMS Broker. If the JMS provider accepts this          * hint, these messages must have the message ID set to null; if the          * provider ignores the hint, the message ID must be set to its normal          * unique value.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|messageIdEnabled ( String messageIdEnabled)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|messageIdEnabled
parameter_list|(
name|String
name|messageIdEnabled
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageIdEnabled"
argument_list|,
name|messageIdEnabled
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Registry ID of the MessageListenerContainerFactory used to determine          * what          * org.springframework.jms.listener.AbstractMessageListenerContainer to          * use to consume messages. Setting this will automatically set          * consumerType to Custom.          *           * The option is a:          *<code>org.apache.camel.component.jms.MessageListenerContainerFactory</code> type.          *           * Group: advanced          */
DECL|method|messageListenerContainerFactory ( Object messageListenerContainerFactory)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|messageListenerContainerFactory
parameter_list|(
name|Object
name|messageListenerContainerFactory
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageListenerContainerFactory"
argument_list|,
name|messageListenerContainerFactory
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Registry ID of the MessageListenerContainerFactory used to determine          * what          * org.springframework.jms.listener.AbstractMessageListenerContainer to          * use to consume messages. Setting this will automatically set          * consumerType to Custom.          *           * The option will be converted to a          *<code>org.apache.camel.component.jms.MessageListenerContainerFactory</code> type.          *           * Group: advanced          */
DECL|method|messageListenerContainerFactory ( String messageListenerContainerFactory)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|messageListenerContainerFactory
parameter_list|(
name|String
name|messageListenerContainerFactory
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageListenerContainerFactory"
argument_list|,
name|messageListenerContainerFactory
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether timestamps should be enabled by default on sending          * messages. This is just an hint to the JMS Broker. If the JMS provider          * accepts this hint, these messages must have the timestamp set to          * zero; if the provider ignores the hint, the timestamp must be set to          * its normal value.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|messageTimestampEnabled ( boolean messageTimestampEnabled)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|messageTimestampEnabled
parameter_list|(
name|boolean
name|messageTimestampEnabled
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageTimestampEnabled"
argument_list|,
name|messageTimestampEnabled
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether timestamps should be enabled by default on sending          * messages. This is just an hint to the JMS Broker. If the JMS provider          * accepts this hint, these messages must have the timestamp set to          * zero; if the provider ignores the hint, the timestamp must be set to          * its normal value.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|messageTimestampEnabled ( String messageTimestampEnabled)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|messageTimestampEnabled
parameter_list|(
name|String
name|messageTimestampEnabled
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageTimestampEnabled"
argument_list|,
name|messageTimestampEnabled
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether to inhibit the delivery of messages published by          * its own connection.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|pubSubNoLocal ( boolean pubSubNoLocal)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|pubSubNoLocal
parameter_list|(
name|boolean
name|pubSubNoLocal
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"pubSubNoLocal"
argument_list|,
name|pubSubNoLocal
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether to inhibit the delivery of messages published by          * its own connection.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|pubSubNoLocal ( String pubSubNoLocal)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|pubSubNoLocal
parameter_list|(
name|String
name|pubSubNoLocal
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"pubSubNoLocal"
argument_list|,
name|pubSubNoLocal
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The timeout for receiving messages (in milliseconds).          *           * The option is a:<code>long</code> type.          *           * Group: advanced          */
DECL|method|receiveTimeout ( long receiveTimeout)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|receiveTimeout
parameter_list|(
name|long
name|receiveTimeout
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"receiveTimeout"
argument_list|,
name|receiveTimeout
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The timeout for receiving messages (in milliseconds).          *           * The option will be converted to a<code>long</code> type.          *           * Group: advanced          */
DECL|method|receiveTimeout ( String receiveTimeout)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|receiveTimeout
parameter_list|(
name|String
name|receiveTimeout
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"receiveTimeout"
argument_list|,
name|receiveTimeout
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the interval between recovery attempts, i.e. when a          * connection is being refreshed, in milliseconds. The default is 5000          * ms, that is, 5 seconds.          *           * The option is a:<code>long</code> type.          *           * Group: advanced          */
DECL|method|recoveryInterval ( long recoveryInterval)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|recoveryInterval
parameter_list|(
name|long
name|recoveryInterval
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"recoveryInterval"
argument_list|,
name|recoveryInterval
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the interval between recovery attempts, i.e. when a          * connection is being refreshed, in milliseconds. The default is 5000          * ms, that is, 5 seconds.          *           * The option will be converted to a<code>long</code> type.          *           * Group: advanced          */
DECL|method|recoveryInterval ( String recoveryInterval)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|recoveryInterval
parameter_list|(
name|String
name|recoveryInterval
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"recoveryInterval"
argument_list|,
name|recoveryInterval
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Configures how often Camel should check for timed out Exchanges when          * doing request/reply over JMS. By default Camel checks once per          * second. But if you must react faster when a timeout occurs, then you          * can lower this interval, to check more frequently. The timeout is          * determined by the option requestTimeout.          *           * The option is a:<code>long</code> type.          *           * Group: advanced          */
DECL|method|requestTimeoutCheckerInterval ( long requestTimeoutCheckerInterval)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|requestTimeoutCheckerInterval
parameter_list|(
name|long
name|requestTimeoutCheckerInterval
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"requestTimeoutCheckerInterval"
argument_list|,
name|requestTimeoutCheckerInterval
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Configures how often Camel should check for timed out Exchanges when          * doing request/reply over JMS. By default Camel checks once per          * second. But if you must react faster when a timeout occurs, then you          * can lower this interval, to check more frequently. The timeout is          * determined by the option requestTimeout.          *           * The option will be converted to a<code>long</code> type.          *           * Group: advanced          */
DECL|method|requestTimeoutCheckerInterval ( String requestTimeoutCheckerInterval)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|requestTimeoutCheckerInterval
parameter_list|(
name|String
name|requestTimeoutCheckerInterval
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"requestTimeoutCheckerInterval"
argument_list|,
name|requestTimeoutCheckerInterval
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets whether synchronous processing should be strictly used, or Camel          * is allowed to use asynchronous processing (if supported).          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|synchronous ( boolean synchronous)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|synchronous
parameter_list|(
name|boolean
name|synchronous
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"synchronous"
argument_list|,
name|synchronous
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets whether synchronous processing should be strictly used, or Camel          * is allowed to use asynchronous processing (if supported).          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|synchronous ( String synchronous)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|synchronous
parameter_list|(
name|String
name|synchronous
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"synchronous"
argument_list|,
name|synchronous
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If enabled and you are using Request Reply messaging (InOut) and an          * Exchange failed on the consumer side, then the caused Exception will          * be send back in response as a javax.jms.ObjectMessage. If the client          * is Camel, the returned Exception is rethrown. This allows you to use          * Camel JMS as a bridge in your routing - for example, using persistent          * queues to enable robust routing. Notice that if you also have          * transferExchange enabled, this option takes precedence. The caught          * exception is required to be serializable. The original Exception on          * the consumer side can be wrapped in an outer exception such as          * org.apache.camel.RuntimeCamelException when returned to the producer.          * Use this with caution as the data is using Java Object serialization          * and requires the received to be able to deserialize the data at Class          * level, which forces a strong coupling between the producers and          * consumer!.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|transferException ( boolean transferException)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|transferException
parameter_list|(
name|boolean
name|transferException
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transferException"
argument_list|,
name|transferException
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If enabled and you are using Request Reply messaging (InOut) and an          * Exchange failed on the consumer side, then the caused Exception will          * be send back in response as a javax.jms.ObjectMessage. If the client          * is Camel, the returned Exception is rethrown. This allows you to use          * Camel JMS as a bridge in your routing - for example, using persistent          * queues to enable robust routing. Notice that if you also have          * transferExchange enabled, this option takes precedence. The caught          * exception is required to be serializable. The original Exception on          * the consumer side can be wrapped in an outer exception such as          * org.apache.camel.RuntimeCamelException when returned to the producer.          * Use this with caution as the data is using Java Object serialization          * and requires the received to be able to deserialize the data at Class          * level, which forces a strong coupling between the producers and          * consumer!.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|transferException ( String transferException)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|transferException
parameter_list|(
name|String
name|transferException
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transferException"
argument_list|,
name|transferException
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * You can transfer the exchange over the wire instead of just the body          * and headers. The following fields are transferred: In body, Out body,          * Fault body, In headers, Out headers, Fault headers, exchange          * properties, exchange exception. This requires that the objects are          * serializable. Camel will exclude any non-serializable objects and log          * it at WARN level. You must enable this option on both the producer          * and consumer side, so Camel knows the payloads is an Exchange and not          * a regular payload. Use this with caution as the data is using Java          * Object serialization and requires the received to be able to          * deserialize the data at Class level, which forces a strong coupling          * between the producers and consumer having to use compatible Camel          * versions!.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|transferExchange ( boolean transferExchange)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|transferExchange
parameter_list|(
name|boolean
name|transferExchange
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transferExchange"
argument_list|,
name|transferExchange
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * You can transfer the exchange over the wire instead of just the body          * and headers. The following fields are transferred: In body, Out body,          * Fault body, In headers, Out headers, Fault headers, exchange          * properties, exchange exception. This requires that the objects are          * serializable. Camel will exclude any non-serializable objects and log          * it at WARN level. You must enable this option on both the producer          * and consumer side, so Camel knows the payloads is an Exchange and not          * a regular payload. Use this with caution as the data is using Java          * Object serialization and requires the received to be able to          * deserialize the data at Class level, which forces a strong coupling          * between the producers and consumer having to use compatible Camel          * versions!.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|transferExchange ( String transferExchange)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|transferExchange
parameter_list|(
name|String
name|transferExchange
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transferExchange"
argument_list|,
name|transferExchange
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether JMSMessageID should always be used as          * JMSCorrelationID for InOut messages.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|useMessageIDAsCorrelationID ( boolean useMessageIDAsCorrelationID)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|useMessageIDAsCorrelationID
parameter_list|(
name|boolean
name|useMessageIDAsCorrelationID
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"useMessageIDAsCorrelationID"
argument_list|,
name|useMessageIDAsCorrelationID
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether JMSMessageID should always be used as          * JMSCorrelationID for InOut messages.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|useMessageIDAsCorrelationID ( String useMessageIDAsCorrelationID)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|useMessageIDAsCorrelationID
parameter_list|(
name|String
name|useMessageIDAsCorrelationID
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"useMessageIDAsCorrelationID"
argument_list|,
name|useMessageIDAsCorrelationID
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Number of times to wait for provisional correlation id to be updated          * to the actual correlation id when doing request/reply over JMS and          * when the option useMessageIDAsCorrelationID is enabled.          *           * The option is a:<code>int</code> type.          *           * Group: advanced          */
DECL|method|waitForProvisionCorrelationToBeUpdatedCounter ( int waitForProvisionCorrelationToBeUpdatedCounter)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|waitForProvisionCorrelationToBeUpdatedCounter
parameter_list|(
name|int
name|waitForProvisionCorrelationToBeUpdatedCounter
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"waitForProvisionCorrelationToBeUpdatedCounter"
argument_list|,
name|waitForProvisionCorrelationToBeUpdatedCounter
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Number of times to wait for provisional correlation id to be updated          * to the actual correlation id when doing request/reply over JMS and          * when the option useMessageIDAsCorrelationID is enabled.          *           * The option will be converted to a<code>int</code> type.          *           * Group: advanced          */
DECL|method|waitForProvisionCorrelationToBeUpdatedCounter ( String waitForProvisionCorrelationToBeUpdatedCounter)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|waitForProvisionCorrelationToBeUpdatedCounter
parameter_list|(
name|String
name|waitForProvisionCorrelationToBeUpdatedCounter
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"waitForProvisionCorrelationToBeUpdatedCounter"
argument_list|,
name|waitForProvisionCorrelationToBeUpdatedCounter
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Interval in millis to sleep each time while waiting for provisional          * correlation id to be updated.          *           * The option is a:<code>long</code> type.          *           * Group: advanced          */
DECL|method|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime ( long waitForProvisionCorrelationToBeUpdatedThreadSleepingTime)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
parameter_list|(
name|long
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"waitForProvisionCorrelationToBeUpdatedThreadSleepingTime"
argument_list|,
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Interval in millis to sleep each time while waiting for provisional          * correlation id to be updated.          *           * The option will be converted to a<code>long</code> type.          *           * Group: advanced          */
DECL|method|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime ( String waitForProvisionCorrelationToBeUpdatedThreadSleepingTime)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
parameter_list|(
name|String
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"waitForProvisionCorrelationToBeUpdatedThreadSleepingTime"
argument_list|,
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If true, Camel will create a JmsTransactionManager, if there is no          * transactionManager injected when option transacted=true.          *           * The option is a:<code>boolean</code> type.          *           * Group: transaction (advanced)          */
DECL|method|lazyCreateTransactionManager ( boolean lazyCreateTransactionManager)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|lazyCreateTransactionManager
parameter_list|(
name|boolean
name|lazyCreateTransactionManager
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"lazyCreateTransactionManager"
argument_list|,
name|lazyCreateTransactionManager
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If true, Camel will create a JmsTransactionManager, if there is no          * transactionManager injected when option transacted=true.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: transaction (advanced)          */
DECL|method|lazyCreateTransactionManager ( String lazyCreateTransactionManager)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|lazyCreateTransactionManager
parameter_list|(
name|String
name|lazyCreateTransactionManager
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"lazyCreateTransactionManager"
argument_list|,
name|lazyCreateTransactionManager
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The Spring transaction manager to use.          *           * The option is a:          *<code>org.springframework.transaction.PlatformTransactionManager</code> type.          *           * Group: transaction (advanced)          */
DECL|method|transactionManager ( Object transactionManager)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|transactionManager
parameter_list|(
name|Object
name|transactionManager
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transactionManager"
argument_list|,
name|transactionManager
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The Spring transaction manager to use.          *           * The option will be converted to a          *<code>org.springframework.transaction.PlatformTransactionManager</code> type.          *           * Group: transaction (advanced)          */
DECL|method|transactionManager ( String transactionManager)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|transactionManager
parameter_list|(
name|String
name|transactionManager
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transactionManager"
argument_list|,
name|transactionManager
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The name of the transaction to use.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: transaction (advanced)          */
DECL|method|transactionName ( String transactionName)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|transactionName
parameter_list|(
name|String
name|transactionName
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transactionName"
argument_list|,
name|transactionName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The timeout value of the transaction (in seconds), if using          * transacted mode.          *           * The option is a:<code>int</code> type.          *           * Group: transaction (advanced)          */
DECL|method|transactionTimeout ( int transactionTimeout)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|transactionTimeout
parameter_list|(
name|int
name|transactionTimeout
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transactionTimeout"
argument_list|,
name|transactionTimeout
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The timeout value of the transaction (in seconds), if using          * transacted mode.          *           * The option will be converted to a<code>int</code> type.          *           * Group: transaction (advanced)          */
DECL|method|transactionTimeout ( String transactionTimeout)
specifier|default
name|AdvancedJmsEndpointProducerBuilder
name|transactionTimeout
parameter_list|(
name|String
name|transactionTimeout
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transactionTimeout"
argument_list|,
name|transactionTimeout
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
comment|/**      * Builder for endpoint for the JMS component.      */
DECL|interface|JmsEndpointBuilder
specifier|public
interface|interface
name|JmsEndpointBuilder
extends|extends
name|JmsEndpointConsumerBuilder
extends|,
name|JmsEndpointProducerBuilder
block|{
DECL|method|advanced ()
specifier|default
name|AdvancedJmsEndpointBuilder
name|advanced
parameter_list|()
block|{
return|return
operator|(
name|AdvancedJmsEndpointBuilder
operator|)
name|this
return|;
block|}
comment|/**          * Sets the JMS client ID to use. Note that this value, if specified,          * must be unique and can only be used by a single JMS connection          * instance. It is typically only required for durable topic          * subscriptions. If using Apache ActiveMQ you may prefer to use Virtual          * Topics instead.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: common          */
DECL|method|clientId (String clientId)
specifier|default
name|JmsEndpointBuilder
name|clientId
parameter_list|(
name|String
name|clientId
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"clientId"
argument_list|,
name|clientId
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets the default connection factory to be used if a connection          * factory is not specified for either          * setTemplateConnectionFactory(ConnectionFactory) or          * setListenerConnectionFactory(ConnectionFactory).          *           * The option is a:<code>javax.jms.ConnectionFactory</code> type.          *           * Group: common          */
DECL|method|connectionFactory (Object connectionFactory)
specifier|default
name|JmsEndpointBuilder
name|connectionFactory
parameter_list|(
name|Object
name|connectionFactory
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"connectionFactory"
argument_list|,
name|connectionFactory
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets the default connection factory to be used if a connection          * factory is not specified for either          * setTemplateConnectionFactory(ConnectionFactory) or          * setListenerConnectionFactory(ConnectionFactory).          *           * The option will be converted to a          *<code>javax.jms.ConnectionFactory</code> type.          *           * Group: common          */
DECL|method|connectionFactory (String connectionFactory)
specifier|default
name|JmsEndpointBuilder
name|connectionFactory
parameter_list|(
name|String
name|connectionFactory
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"connectionFactory"
argument_list|,
name|connectionFactory
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether Camel ignores the JMSReplyTo header in messages. If          * true, Camel does not send a reply back to the destination specified          * in the JMSReplyTo header. You can use this option if you want Camel          * to consume from a route and you do not want Camel to automatically          * send back a reply message because another component in your code          * handles the reply message. You can also use this option if you want          * to use Camel as a proxy between different message brokers and you          * want to route message from one system to another.          *           * The option is a:<code>boolean</code> type.          *           * Group: common          */
DECL|method|disableReplyTo (boolean disableReplyTo)
specifier|default
name|JmsEndpointBuilder
name|disableReplyTo
parameter_list|(
name|boolean
name|disableReplyTo
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"disableReplyTo"
argument_list|,
name|disableReplyTo
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether Camel ignores the JMSReplyTo header in messages. If          * true, Camel does not send a reply back to the destination specified          * in the JMSReplyTo header. You can use this option if you want Camel          * to consume from a route and you do not want Camel to automatically          * send back a reply message because another component in your code          * handles the reply message. You can also use this option if you want          * to use Camel as a proxy between different message brokers and you          * want to route message from one system to another.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: common          */
DECL|method|disableReplyTo (String disableReplyTo)
specifier|default
name|JmsEndpointBuilder
name|disableReplyTo
parameter_list|(
name|String
name|disableReplyTo
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"disableReplyTo"
argument_list|,
name|disableReplyTo
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The durable subscriber name for specifying durable topic          * subscriptions. The clientId option must be configured as well.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: common          */
DECL|method|durableSubscriptionName ( String durableSubscriptionName)
specifier|default
name|JmsEndpointBuilder
name|durableSubscriptionName
parameter_list|(
name|String
name|durableSubscriptionName
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"durableSubscriptionName"
argument_list|,
name|durableSubscriptionName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Allows you to force the use of a specific javax.jms.Message          * implementation for sending JMS messages. Possible values are: Bytes,          * Map, Object, Stream, Text. By default, Camel would determine which          * JMS message type to use from the In body type. This option allows you          * to specify it.          *           * The option is a:          *<code>org.apache.camel.component.jms.JmsMessageType</code> type.          *           * Group: common          */
DECL|method|jmsMessageType (JmsMessageType jmsMessageType)
specifier|default
name|JmsEndpointBuilder
name|jmsMessageType
parameter_list|(
name|JmsMessageType
name|jmsMessageType
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"jmsMessageType"
argument_list|,
name|jmsMessageType
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Allows you to force the use of a specific javax.jms.Message          * implementation for sending JMS messages. Possible values are: Bytes,          * Map, Object, Stream, Text. By default, Camel would determine which          * JMS message type to use from the In body type. This option allows you          * to specify it.          *           * The option will be converted to a          *<code>org.apache.camel.component.jms.JmsMessageType</code> type.          *           * Group: common          */
DECL|method|jmsMessageType (String jmsMessageType)
specifier|default
name|JmsEndpointBuilder
name|jmsMessageType
parameter_list|(
name|String
name|jmsMessageType
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"jmsMessageType"
argument_list|,
name|jmsMessageType
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether to test the connection on startup. This ensures          * that when Camel starts that all the JMS consumers have a valid          * connection to the JMS broker. If a connection cannot be granted then          * Camel throws an exception on startup. This ensures that Camel is not          * started with failed connections. The JMS producers is tested as well.          *           * The option is a:<code>boolean</code> type.          *           * Group: common          */
DECL|method|testConnectionOnStartup ( boolean testConnectionOnStartup)
specifier|default
name|JmsEndpointBuilder
name|testConnectionOnStartup
parameter_list|(
name|boolean
name|testConnectionOnStartup
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"testConnectionOnStartup"
argument_list|,
name|testConnectionOnStartup
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether to test the connection on startup. This ensures          * that when Camel starts that all the JMS consumers have a valid          * connection to the JMS broker. If a connection cannot be granted then          * Camel throws an exception on startup. This ensures that Camel is not          * started with failed connections. The JMS producers is tested as well.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: common          */
DECL|method|testConnectionOnStartup ( String testConnectionOnStartup)
specifier|default
name|JmsEndpointBuilder
name|testConnectionOnStartup
parameter_list|(
name|String
name|testConnectionOnStartup
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"testConnectionOnStartup"
argument_list|,
name|testConnectionOnStartup
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Password to use with the ConnectionFactory. You can also configure          * username/password directly on the ConnectionFactory.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: security          */
DECL|method|password (String password)
specifier|default
name|JmsEndpointBuilder
name|password
parameter_list|(
name|String
name|password
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"password"
argument_list|,
name|password
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Username to use with the ConnectionFactory. You can also configure          * username/password directly on the ConnectionFactory.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: security          */
DECL|method|username (String username)
specifier|default
name|JmsEndpointBuilder
name|username
parameter_list|(
name|String
name|username
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"username"
argument_list|,
name|username
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether to use transacted mode.          *           * The option is a:<code>boolean</code> type.          *           * Group: transaction          */
DECL|method|transacted (boolean transacted)
specifier|default
name|JmsEndpointBuilder
name|transacted
parameter_list|(
name|boolean
name|transacted
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transacted"
argument_list|,
name|transacted
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether to use transacted mode.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: transaction          */
DECL|method|transacted (String transacted)
specifier|default
name|JmsEndpointBuilder
name|transacted
parameter_list|(
name|String
name|transacted
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transacted"
argument_list|,
name|transacted
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
comment|/**      * Advanced builder for endpoint for the JMS component.      */
DECL|interface|AdvancedJmsEndpointBuilder
specifier|public
interface|interface
name|AdvancedJmsEndpointBuilder
extends|extends
name|AdvancedJmsEndpointConsumerBuilder
extends|,
name|AdvancedJmsEndpointProducerBuilder
block|{
DECL|method|basic ()
specifier|default
name|JmsEndpointBuilder
name|basic
parameter_list|()
block|{
return|return
operator|(
name|JmsEndpointBuilder
operator|)
name|this
return|;
block|}
comment|/**          * Controls whether or not to include serialized headers. Applies only          * when isTransferExchange() is true. This requires that the objects are          * serializable. Camel will exclude any non-serializable objects and log          * it at WARN level.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|allowSerializedHeaders ( boolean allowSerializedHeaders)
specifier|default
name|AdvancedJmsEndpointBuilder
name|allowSerializedHeaders
parameter_list|(
name|boolean
name|allowSerializedHeaders
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"allowSerializedHeaders"
argument_list|,
name|allowSerializedHeaders
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Controls whether or not to include serialized headers. Applies only          * when isTransferExchange() is true. This requires that the objects are          * serializable. Camel will exclude any non-serializable objects and log          * it at WARN level.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|allowSerializedHeaders ( String allowSerializedHeaders)
specifier|default
name|AdvancedJmsEndpointBuilder
name|allowSerializedHeaders
parameter_list|(
name|String
name|allowSerializedHeaders
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"allowSerializedHeaders"
argument_list|,
name|allowSerializedHeaders
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to startup the JmsConsumer message listener asynchronously,          * when starting a route. For example if a JmsConsumer cannot get a          * connection to a remote JMS broker, then it may block while retrying          * and/or failover. This will cause Camel to block while starting          * routes. By setting this option to true, you will let routes startup,          * while the JmsConsumer connects to the JMS broker using a dedicated          * thread in asynchronous mode. If this option is used, then beware that          * if the connection could not be established, then an exception is          * logged at WARN level, and the consumer will not be able to receive          * messages; You can then restart the route to retry.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|asyncStartListener ( boolean asyncStartListener)
specifier|default
name|AdvancedJmsEndpointBuilder
name|asyncStartListener
parameter_list|(
name|boolean
name|asyncStartListener
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"asyncStartListener"
argument_list|,
name|asyncStartListener
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to startup the JmsConsumer message listener asynchronously,          * when starting a route. For example if a JmsConsumer cannot get a          * connection to a remote JMS broker, then it may block while retrying          * and/or failover. This will cause Camel to block while starting          * routes. By setting this option to true, you will let routes startup,          * while the JmsConsumer connects to the JMS broker using a dedicated          * thread in asynchronous mode. If this option is used, then beware that          * if the connection could not be established, then an exception is          * logged at WARN level, and the consumer will not be able to receive          * messages; You can then restart the route to retry.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|asyncStartListener ( String asyncStartListener)
specifier|default
name|AdvancedJmsEndpointBuilder
name|asyncStartListener
parameter_list|(
name|String
name|asyncStartListener
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"asyncStartListener"
argument_list|,
name|asyncStartListener
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to stop the JmsConsumer message listener asynchronously, when          * stopping a route.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|asyncStopListener ( boolean asyncStopListener)
specifier|default
name|AdvancedJmsEndpointBuilder
name|asyncStopListener
parameter_list|(
name|boolean
name|asyncStopListener
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"asyncStopListener"
argument_list|,
name|asyncStopListener
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to stop the JmsConsumer message listener asynchronously, when          * stopping a route.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|asyncStopListener ( String asyncStopListener)
specifier|default
name|AdvancedJmsEndpointBuilder
name|asyncStopListener
parameter_list|(
name|String
name|asyncStopListener
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"asyncStopListener"
argument_list|,
name|asyncStopListener
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the endpoint should use basic property binding (Camel 2.x) or          * the newer property binding with additional capabilities.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|basicPropertyBinding ( boolean basicPropertyBinding)
specifier|default
name|AdvancedJmsEndpointBuilder
name|basicPropertyBinding
parameter_list|(
name|boolean
name|basicPropertyBinding
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"basicPropertyBinding"
argument_list|,
name|basicPropertyBinding
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether the endpoint should use basic property binding (Camel 2.x) or          * the newer property binding with additional capabilities.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|basicPropertyBinding ( String basicPropertyBinding)
specifier|default
name|AdvancedJmsEndpointBuilder
name|basicPropertyBinding
parameter_list|(
name|String
name|basicPropertyBinding
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"basicPropertyBinding"
argument_list|,
name|basicPropertyBinding
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * A pluggable          * org.springframework.jms.support.destination.DestinationResolver that          * allows you to use your own resolver (for example, to lookup the real          * destination in a JNDI registry).          *           * The option is a:          *<code>org.springframework.jms.support.destination.DestinationResolver</code> type.          *           * Group: advanced          */
DECL|method|destinationResolver ( Object destinationResolver)
specifier|default
name|AdvancedJmsEndpointBuilder
name|destinationResolver
parameter_list|(
name|Object
name|destinationResolver
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"destinationResolver"
argument_list|,
name|destinationResolver
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * A pluggable          * org.springframework.jms.support.destination.DestinationResolver that          * allows you to use your own resolver (for example, to lookup the real          * destination in a JNDI registry).          *           * The option will be converted to a          *<code>org.springframework.jms.support.destination.DestinationResolver</code> type.          *           * Group: advanced          */
DECL|method|destinationResolver ( String destinationResolver)
specifier|default
name|AdvancedJmsEndpointBuilder
name|destinationResolver
parameter_list|(
name|String
name|destinationResolver
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"destinationResolver"
argument_list|,
name|destinationResolver
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies a org.springframework.util.ErrorHandler to be invoked in          * case of any uncaught exceptions thrown while processing a Message. By          * default these exceptions will be logged at the WARN level, if no          * errorHandler has been configured. You can configure logging level and          * whether stack traces should be logged using errorHandlerLoggingLevel          * and errorHandlerLogStackTrace options. This makes it much easier to          * configure, than having to code a custom errorHandler.          *           * The option is a:<code>org.springframework.util.ErrorHandler</code>          * type.          *           * Group: advanced          */
DECL|method|errorHandler (Object errorHandler)
specifier|default
name|AdvancedJmsEndpointBuilder
name|errorHandler
parameter_list|(
name|Object
name|errorHandler
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"errorHandler"
argument_list|,
name|errorHandler
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies a org.springframework.util.ErrorHandler to be invoked in          * case of any uncaught exceptions thrown while processing a Message. By          * default these exceptions will be logged at the WARN level, if no          * errorHandler has been configured. You can configure logging level and          * whether stack traces should be logged using errorHandlerLoggingLevel          * and errorHandlerLogStackTrace options. This makes it much easier to          * configure, than having to code a custom errorHandler.          *           * The option will be converted to a          *<code>org.springframework.util.ErrorHandler</code> type.          *           * Group: advanced          */
DECL|method|errorHandler (String errorHandler)
specifier|default
name|AdvancedJmsEndpointBuilder
name|errorHandler
parameter_list|(
name|String
name|errorHandler
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"errorHandler"
argument_list|,
name|errorHandler
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the JMS Exception Listener that is to be notified of any          * underlying JMS exceptions.          *           * The option is a:<code>javax.jms.ExceptionListener</code> type.          *           * Group: advanced          */
DECL|method|exceptionListener ( Object exceptionListener)
specifier|default
name|AdvancedJmsEndpointBuilder
name|exceptionListener
parameter_list|(
name|Object
name|exceptionListener
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"exceptionListener"
argument_list|,
name|exceptionListener
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the JMS Exception Listener that is to be notified of any          * underlying JMS exceptions.          *           * The option will be converted to a          *<code>javax.jms.ExceptionListener</code> type.          *           * Group: advanced          */
DECL|method|exceptionListener ( String exceptionListener)
specifier|default
name|AdvancedJmsEndpointBuilder
name|exceptionListener
parameter_list|(
name|String
name|exceptionListener
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"exceptionListener"
argument_list|,
name|exceptionListener
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use a custom HeaderFilterStrategy to filter header to and from          * Camel message.          *           * The option is a:          *<code>org.apache.camel.spi.HeaderFilterStrategy</code> type.          *           * Group: advanced          */
DECL|method|headerFilterStrategy ( HeaderFilterStrategy headerFilterStrategy)
specifier|default
name|AdvancedJmsEndpointBuilder
name|headerFilterStrategy
parameter_list|(
name|HeaderFilterStrategy
name|headerFilterStrategy
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"headerFilterStrategy"
argument_list|,
name|headerFilterStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use a custom HeaderFilterStrategy to filter header to and from          * Camel message.          *           * The option will be converted to a          *<code>org.apache.camel.spi.HeaderFilterStrategy</code> type.          *           * Group: advanced          */
DECL|method|headerFilterStrategy ( String headerFilterStrategy)
specifier|default
name|AdvancedJmsEndpointBuilder
name|headerFilterStrategy
parameter_list|(
name|String
name|headerFilterStrategy
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"headerFilterStrategy"
argument_list|,
name|headerFilterStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specify the limit for the number of consumers that are allowed to be          * idle at any given time.          *           * The option is a:<code>int</code> type.          *           * Group: advanced          */
DECL|method|idleConsumerLimit ( int idleConsumerLimit)
specifier|default
name|AdvancedJmsEndpointBuilder
name|idleConsumerLimit
parameter_list|(
name|int
name|idleConsumerLimit
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"idleConsumerLimit"
argument_list|,
name|idleConsumerLimit
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specify the limit for the number of consumers that are allowed to be          * idle at any given time.          *           * The option will be converted to a<code>int</code> type.          *           * Group: advanced          */
DECL|method|idleConsumerLimit ( String idleConsumerLimit)
specifier|default
name|AdvancedJmsEndpointBuilder
name|idleConsumerLimit
parameter_list|(
name|String
name|idleConsumerLimit
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"idleConsumerLimit"
argument_list|,
name|idleConsumerLimit
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the limit for idle executions of a receive task, not having          * received any message within its execution. If this limit is reached,          * the task will shut down and leave receiving to other executing tasks          * (in the case of dynamic scheduling; see the maxConcurrentConsumers          * setting). There is additional doc available from Spring.          *           * The option is a:<code>int</code> type.          *           * Group: advanced          */
DECL|method|idleTaskExecutionLimit ( int idleTaskExecutionLimit)
specifier|default
name|AdvancedJmsEndpointBuilder
name|idleTaskExecutionLimit
parameter_list|(
name|int
name|idleTaskExecutionLimit
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"idleTaskExecutionLimit"
argument_list|,
name|idleTaskExecutionLimit
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the limit for idle executions of a receive task, not having          * received any message within its execution. If this limit is reached,          * the task will shut down and leave receiving to other executing tasks          * (in the case of dynamic scheduling; see the maxConcurrentConsumers          * setting). There is additional doc available from Spring.          *           * The option will be converted to a<code>int</code> type.          *           * Group: advanced          */
DECL|method|idleTaskExecutionLimit ( String idleTaskExecutionLimit)
specifier|default
name|AdvancedJmsEndpointBuilder
name|idleTaskExecutionLimit
parameter_list|(
name|String
name|idleTaskExecutionLimit
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"idleTaskExecutionLimit"
argument_list|,
name|idleTaskExecutionLimit
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to include all JMSXxxx properties when mapping from JMS to          * Camel Message. Setting this to true will include properties such as          * JMSXAppID, and JMSXUserID etc. Note: If you are using a custom          * headerFilterStrategy then this option does not apply.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|includeAllJMSXProperties ( boolean includeAllJMSXProperties)
specifier|default
name|AdvancedJmsEndpointBuilder
name|includeAllJMSXProperties
parameter_list|(
name|boolean
name|includeAllJMSXProperties
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"includeAllJMSXProperties"
argument_list|,
name|includeAllJMSXProperties
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Whether to include all JMSXxxx properties when mapping from JMS to          * Camel Message. Setting this to true will include properties such as          * JMSXAppID, and JMSXUserID etc. Note: If you are using a custom          * headerFilterStrategy then this option does not apply.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|includeAllJMSXProperties ( String includeAllJMSXProperties)
specifier|default
name|AdvancedJmsEndpointBuilder
name|includeAllJMSXProperties
parameter_list|(
name|String
name|includeAllJMSXProperties
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"includeAllJMSXProperties"
argument_list|,
name|includeAllJMSXProperties
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Pluggable strategy for encoding and decoding JMS keys so they can be          * compliant with the JMS specification. Camel provides two          * implementations out of the box: default and passthrough. The default          * strategy will safely marshal dots and hyphens (. and -). The          * passthrough strategy leaves the key as is. Can be used for JMS          * brokers which do not care whether JMS header keys contain illegal          * characters. You can provide your own implementation of the          * org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it          * using the # notation.          *           * The option is a:          *<code>org.apache.camel.component.jms.JmsKeyFormatStrategy</code>          * type.          *           * Group: advanced          */
DECL|method|jmsKeyFormatStrategy ( Object jmsKeyFormatStrategy)
specifier|default
name|AdvancedJmsEndpointBuilder
name|jmsKeyFormatStrategy
parameter_list|(
name|Object
name|jmsKeyFormatStrategy
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"jmsKeyFormatStrategy"
argument_list|,
name|jmsKeyFormatStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Pluggable strategy for encoding and decoding JMS keys so they can be          * compliant with the JMS specification. Camel provides two          * implementations out of the box: default and passthrough. The default          * strategy will safely marshal dots and hyphens (. and -). The          * passthrough strategy leaves the key as is. Can be used for JMS          * brokers which do not care whether JMS header keys contain illegal          * characters. You can provide your own implementation of the          * org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it          * using the # notation.          *           * The option will be converted to a          *<code>org.apache.camel.component.jms.JmsKeyFormatStrategy</code>          * type.          *           * Group: advanced          */
DECL|method|jmsKeyFormatStrategy ( String jmsKeyFormatStrategy)
specifier|default
name|AdvancedJmsEndpointBuilder
name|jmsKeyFormatStrategy
parameter_list|(
name|String
name|jmsKeyFormatStrategy
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"jmsKeyFormatStrategy"
argument_list|,
name|jmsKeyFormatStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether Camel should auto map the received JMS message to a          * suited payload type, such as javax.jms.TextMessage to a String etc.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|mapJmsMessage (boolean mapJmsMessage)
specifier|default
name|AdvancedJmsEndpointBuilder
name|mapJmsMessage
parameter_list|(
name|boolean
name|mapJmsMessage
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"mapJmsMessage"
argument_list|,
name|mapJmsMessage
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether Camel should auto map the received JMS message to a          * suited payload type, such as javax.jms.TextMessage to a String etc.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|mapJmsMessage (String mapJmsMessage)
specifier|default
name|AdvancedJmsEndpointBuilder
name|mapJmsMessage
parameter_list|(
name|String
name|mapJmsMessage
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"mapJmsMessage"
argument_list|,
name|mapJmsMessage
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The number of messages per task. -1 is unlimited. If you use a range          * for concurrent consumers (eg min max), then this option can be used          * to set a value to eg 100 to control how fast the consumers will          * shrink when less work is required.          *           * The option is a:<code>int</code> type.          *           * Group: advanced          */
DECL|method|maxMessagesPerTask ( int maxMessagesPerTask)
specifier|default
name|AdvancedJmsEndpointBuilder
name|maxMessagesPerTask
parameter_list|(
name|int
name|maxMessagesPerTask
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"maxMessagesPerTask"
argument_list|,
name|maxMessagesPerTask
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The number of messages per task. -1 is unlimited. If you use a range          * for concurrent consumers (eg min max), then this option can be used          * to set a value to eg 100 to control how fast the consumers will          * shrink when less work is required.          *           * The option will be converted to a<code>int</code> type.          *           * Group: advanced          */
DECL|method|maxMessagesPerTask ( String maxMessagesPerTask)
specifier|default
name|AdvancedJmsEndpointBuilder
name|maxMessagesPerTask
parameter_list|(
name|String
name|maxMessagesPerTask
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"maxMessagesPerTask"
argument_list|,
name|maxMessagesPerTask
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use a custom Spring          * org.springframework.jms.support.converter.MessageConverter so you can          * be in control how to map to/from a javax.jms.Message.          *           * The option is a:          *<code>org.springframework.jms.support.converter.MessageConverter</code> type.          *           * Group: advanced          */
DECL|method|messageConverter ( Object messageConverter)
specifier|default
name|AdvancedJmsEndpointBuilder
name|messageConverter
parameter_list|(
name|Object
name|messageConverter
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageConverter"
argument_list|,
name|messageConverter
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use a custom Spring          * org.springframework.jms.support.converter.MessageConverter so you can          * be in control how to map to/from a javax.jms.Message.          *           * The option will be converted to a          *<code>org.springframework.jms.support.converter.MessageConverter</code> type.          *           * Group: advanced          */
DECL|method|messageConverter ( String messageConverter)
specifier|default
name|AdvancedJmsEndpointBuilder
name|messageConverter
parameter_list|(
name|String
name|messageConverter
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageConverter"
argument_list|,
name|messageConverter
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use the given MessageCreatedStrategy which are invoked when Camel          * creates new instances of javax.jms.Message objects when Camel is          * sending a JMS message.          *           * The option is a:          *<code>org.apache.camel.component.jms.MessageCreatedStrategy</code>          * type.          *           * Group: advanced          */
DECL|method|messageCreatedStrategy ( Object messageCreatedStrategy)
specifier|default
name|AdvancedJmsEndpointBuilder
name|messageCreatedStrategy
parameter_list|(
name|Object
name|messageCreatedStrategy
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageCreatedStrategy"
argument_list|,
name|messageCreatedStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * To use the given MessageCreatedStrategy which are invoked when Camel          * creates new instances of javax.jms.Message objects when Camel is          * sending a JMS message.          *           * The option will be converted to a          *<code>org.apache.camel.component.jms.MessageCreatedStrategy</code>          * type.          *           * Group: advanced          */
DECL|method|messageCreatedStrategy ( String messageCreatedStrategy)
specifier|default
name|AdvancedJmsEndpointBuilder
name|messageCreatedStrategy
parameter_list|(
name|String
name|messageCreatedStrategy
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageCreatedStrategy"
argument_list|,
name|messageCreatedStrategy
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * When sending, specifies whether message IDs should be added. This is          * just an hint to the JMS Broker. If the JMS provider accepts this          * hint, these messages must have the message ID set to null; if the          * provider ignores the hint, the message ID must be set to its normal          * unique value.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|messageIdEnabled ( boolean messageIdEnabled)
specifier|default
name|AdvancedJmsEndpointBuilder
name|messageIdEnabled
parameter_list|(
name|boolean
name|messageIdEnabled
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageIdEnabled"
argument_list|,
name|messageIdEnabled
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * When sending, specifies whether message IDs should be added. This is          * just an hint to the JMS Broker. If the JMS provider accepts this          * hint, these messages must have the message ID set to null; if the          * provider ignores the hint, the message ID must be set to its normal          * unique value.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|messageIdEnabled ( String messageIdEnabled)
specifier|default
name|AdvancedJmsEndpointBuilder
name|messageIdEnabled
parameter_list|(
name|String
name|messageIdEnabled
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageIdEnabled"
argument_list|,
name|messageIdEnabled
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Registry ID of the MessageListenerContainerFactory used to determine          * what          * org.springframework.jms.listener.AbstractMessageListenerContainer to          * use to consume messages. Setting this will automatically set          * consumerType to Custom.          *           * The option is a:          *<code>org.apache.camel.component.jms.MessageListenerContainerFactory</code> type.          *           * Group: advanced          */
DECL|method|messageListenerContainerFactory ( Object messageListenerContainerFactory)
specifier|default
name|AdvancedJmsEndpointBuilder
name|messageListenerContainerFactory
parameter_list|(
name|Object
name|messageListenerContainerFactory
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageListenerContainerFactory"
argument_list|,
name|messageListenerContainerFactory
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Registry ID of the MessageListenerContainerFactory used to determine          * what          * org.springframework.jms.listener.AbstractMessageListenerContainer to          * use to consume messages. Setting this will automatically set          * consumerType to Custom.          *           * The option will be converted to a          *<code>org.apache.camel.component.jms.MessageListenerContainerFactory</code> type.          *           * Group: advanced          */
DECL|method|messageListenerContainerFactory ( String messageListenerContainerFactory)
specifier|default
name|AdvancedJmsEndpointBuilder
name|messageListenerContainerFactory
parameter_list|(
name|String
name|messageListenerContainerFactory
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageListenerContainerFactory"
argument_list|,
name|messageListenerContainerFactory
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether timestamps should be enabled by default on sending          * messages. This is just an hint to the JMS Broker. If the JMS provider          * accepts this hint, these messages must have the timestamp set to          * zero; if the provider ignores the hint, the timestamp must be set to          * its normal value.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|messageTimestampEnabled ( boolean messageTimestampEnabled)
specifier|default
name|AdvancedJmsEndpointBuilder
name|messageTimestampEnabled
parameter_list|(
name|boolean
name|messageTimestampEnabled
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageTimestampEnabled"
argument_list|,
name|messageTimestampEnabled
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether timestamps should be enabled by default on sending          * messages. This is just an hint to the JMS Broker. If the JMS provider          * accepts this hint, these messages must have the timestamp set to          * zero; if the provider ignores the hint, the timestamp must be set to          * its normal value.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|messageTimestampEnabled ( String messageTimestampEnabled)
specifier|default
name|AdvancedJmsEndpointBuilder
name|messageTimestampEnabled
parameter_list|(
name|String
name|messageTimestampEnabled
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"messageTimestampEnabled"
argument_list|,
name|messageTimestampEnabled
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether to inhibit the delivery of messages published by          * its own connection.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|pubSubNoLocal (boolean pubSubNoLocal)
specifier|default
name|AdvancedJmsEndpointBuilder
name|pubSubNoLocal
parameter_list|(
name|boolean
name|pubSubNoLocal
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"pubSubNoLocal"
argument_list|,
name|pubSubNoLocal
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether to inhibit the delivery of messages published by          * its own connection.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|pubSubNoLocal (String pubSubNoLocal)
specifier|default
name|AdvancedJmsEndpointBuilder
name|pubSubNoLocal
parameter_list|(
name|String
name|pubSubNoLocal
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"pubSubNoLocal"
argument_list|,
name|pubSubNoLocal
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The timeout for receiving messages (in milliseconds).          *           * The option is a:<code>long</code> type.          *           * Group: advanced          */
DECL|method|receiveTimeout (long receiveTimeout)
specifier|default
name|AdvancedJmsEndpointBuilder
name|receiveTimeout
parameter_list|(
name|long
name|receiveTimeout
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"receiveTimeout"
argument_list|,
name|receiveTimeout
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The timeout for receiving messages (in milliseconds).          *           * The option will be converted to a<code>long</code> type.          *           * Group: advanced          */
DECL|method|receiveTimeout (String receiveTimeout)
specifier|default
name|AdvancedJmsEndpointBuilder
name|receiveTimeout
parameter_list|(
name|String
name|receiveTimeout
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"receiveTimeout"
argument_list|,
name|receiveTimeout
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the interval between recovery attempts, i.e. when a          * connection is being refreshed, in milliseconds. The default is 5000          * ms, that is, 5 seconds.          *           * The option is a:<code>long</code> type.          *           * Group: advanced          */
DECL|method|recoveryInterval ( long recoveryInterval)
specifier|default
name|AdvancedJmsEndpointBuilder
name|recoveryInterval
parameter_list|(
name|long
name|recoveryInterval
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"recoveryInterval"
argument_list|,
name|recoveryInterval
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the interval between recovery attempts, i.e. when a          * connection is being refreshed, in milliseconds. The default is 5000          * ms, that is, 5 seconds.          *           * The option will be converted to a<code>long</code> type.          *           * Group: advanced          */
DECL|method|recoveryInterval ( String recoveryInterval)
specifier|default
name|AdvancedJmsEndpointBuilder
name|recoveryInterval
parameter_list|(
name|String
name|recoveryInterval
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"recoveryInterval"
argument_list|,
name|recoveryInterval
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Configures how often Camel should check for timed out Exchanges when          * doing request/reply over JMS. By default Camel checks once per          * second. But if you must react faster when a timeout occurs, then you          * can lower this interval, to check more frequently. The timeout is          * determined by the option requestTimeout.          *           * The option is a:<code>long</code> type.          *           * Group: advanced          */
DECL|method|requestTimeoutCheckerInterval ( long requestTimeoutCheckerInterval)
specifier|default
name|AdvancedJmsEndpointBuilder
name|requestTimeoutCheckerInterval
parameter_list|(
name|long
name|requestTimeoutCheckerInterval
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"requestTimeoutCheckerInterval"
argument_list|,
name|requestTimeoutCheckerInterval
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Configures how often Camel should check for timed out Exchanges when          * doing request/reply over JMS. By default Camel checks once per          * second. But if you must react faster when a timeout occurs, then you          * can lower this interval, to check more frequently. The timeout is          * determined by the option requestTimeout.          *           * The option will be converted to a<code>long</code> type.          *           * Group: advanced          */
DECL|method|requestTimeoutCheckerInterval ( String requestTimeoutCheckerInterval)
specifier|default
name|AdvancedJmsEndpointBuilder
name|requestTimeoutCheckerInterval
parameter_list|(
name|String
name|requestTimeoutCheckerInterval
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"requestTimeoutCheckerInterval"
argument_list|,
name|requestTimeoutCheckerInterval
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets whether synchronous processing should be strictly used, or Camel          * is allowed to use asynchronous processing (if supported).          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|synchronous (boolean synchronous)
specifier|default
name|AdvancedJmsEndpointBuilder
name|synchronous
parameter_list|(
name|boolean
name|synchronous
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"synchronous"
argument_list|,
name|synchronous
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Sets whether synchronous processing should be strictly used, or Camel          * is allowed to use asynchronous processing (if supported).          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|synchronous (String synchronous)
specifier|default
name|AdvancedJmsEndpointBuilder
name|synchronous
parameter_list|(
name|String
name|synchronous
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"synchronous"
argument_list|,
name|synchronous
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If enabled and you are using Request Reply messaging (InOut) and an          * Exchange failed on the consumer side, then the caused Exception will          * be send back in response as a javax.jms.ObjectMessage. If the client          * is Camel, the returned Exception is rethrown. This allows you to use          * Camel JMS as a bridge in your routing - for example, using persistent          * queues to enable robust routing. Notice that if you also have          * transferExchange enabled, this option takes precedence. The caught          * exception is required to be serializable. The original Exception on          * the consumer side can be wrapped in an outer exception such as          * org.apache.camel.RuntimeCamelException when returned to the producer.          * Use this with caution as the data is using Java Object serialization          * and requires the received to be able to deserialize the data at Class          * level, which forces a strong coupling between the producers and          * consumer!.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|transferException ( boolean transferException)
specifier|default
name|AdvancedJmsEndpointBuilder
name|transferException
parameter_list|(
name|boolean
name|transferException
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transferException"
argument_list|,
name|transferException
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If enabled and you are using Request Reply messaging (InOut) and an          * Exchange failed on the consumer side, then the caused Exception will          * be send back in response as a javax.jms.ObjectMessage. If the client          * is Camel, the returned Exception is rethrown. This allows you to use          * Camel JMS as a bridge in your routing - for example, using persistent          * queues to enable robust routing. Notice that if you also have          * transferExchange enabled, this option takes precedence. The caught          * exception is required to be serializable. The original Exception on          * the consumer side can be wrapped in an outer exception such as          * org.apache.camel.RuntimeCamelException when returned to the producer.          * Use this with caution as the data is using Java Object serialization          * and requires the received to be able to deserialize the data at Class          * level, which forces a strong coupling between the producers and          * consumer!.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|transferException ( String transferException)
specifier|default
name|AdvancedJmsEndpointBuilder
name|transferException
parameter_list|(
name|String
name|transferException
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transferException"
argument_list|,
name|transferException
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * You can transfer the exchange over the wire instead of just the body          * and headers. The following fields are transferred: In body, Out body,          * Fault body, In headers, Out headers, Fault headers, exchange          * properties, exchange exception. This requires that the objects are          * serializable. Camel will exclude any non-serializable objects and log          * it at WARN level. You must enable this option on both the producer          * and consumer side, so Camel knows the payloads is an Exchange and not          * a regular payload. Use this with caution as the data is using Java          * Object serialization and requires the received to be able to          * deserialize the data at Class level, which forces a strong coupling          * between the producers and consumer having to use compatible Camel          * versions!.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|transferExchange ( boolean transferExchange)
specifier|default
name|AdvancedJmsEndpointBuilder
name|transferExchange
parameter_list|(
name|boolean
name|transferExchange
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transferExchange"
argument_list|,
name|transferExchange
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * You can transfer the exchange over the wire instead of just the body          * and headers. The following fields are transferred: In body, Out body,          * Fault body, In headers, Out headers, Fault headers, exchange          * properties, exchange exception. This requires that the objects are          * serializable. Camel will exclude any non-serializable objects and log          * it at WARN level. You must enable this option on both the producer          * and consumer side, so Camel knows the payloads is an Exchange and not          * a regular payload. Use this with caution as the data is using Java          * Object serialization and requires the received to be able to          * deserialize the data at Class level, which forces a strong coupling          * between the producers and consumer having to use compatible Camel          * versions!.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|transferExchange ( String transferExchange)
specifier|default
name|AdvancedJmsEndpointBuilder
name|transferExchange
parameter_list|(
name|String
name|transferExchange
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transferExchange"
argument_list|,
name|transferExchange
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether JMSMessageID should always be used as          * JMSCorrelationID for InOut messages.          *           * The option is a:<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|useMessageIDAsCorrelationID ( boolean useMessageIDAsCorrelationID)
specifier|default
name|AdvancedJmsEndpointBuilder
name|useMessageIDAsCorrelationID
parameter_list|(
name|boolean
name|useMessageIDAsCorrelationID
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"useMessageIDAsCorrelationID"
argument_list|,
name|useMessageIDAsCorrelationID
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies whether JMSMessageID should always be used as          * JMSCorrelationID for InOut messages.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: advanced          */
DECL|method|useMessageIDAsCorrelationID ( String useMessageIDAsCorrelationID)
specifier|default
name|AdvancedJmsEndpointBuilder
name|useMessageIDAsCorrelationID
parameter_list|(
name|String
name|useMessageIDAsCorrelationID
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"useMessageIDAsCorrelationID"
argument_list|,
name|useMessageIDAsCorrelationID
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Number of times to wait for provisional correlation id to be updated          * to the actual correlation id when doing request/reply over JMS and          * when the option useMessageIDAsCorrelationID is enabled.          *           * The option is a:<code>int</code> type.          *           * Group: advanced          */
DECL|method|waitForProvisionCorrelationToBeUpdatedCounter ( int waitForProvisionCorrelationToBeUpdatedCounter)
specifier|default
name|AdvancedJmsEndpointBuilder
name|waitForProvisionCorrelationToBeUpdatedCounter
parameter_list|(
name|int
name|waitForProvisionCorrelationToBeUpdatedCounter
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"waitForProvisionCorrelationToBeUpdatedCounter"
argument_list|,
name|waitForProvisionCorrelationToBeUpdatedCounter
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Number of times to wait for provisional correlation id to be updated          * to the actual correlation id when doing request/reply over JMS and          * when the option useMessageIDAsCorrelationID is enabled.          *           * The option will be converted to a<code>int</code> type.          *           * Group: advanced          */
DECL|method|waitForProvisionCorrelationToBeUpdatedCounter ( String waitForProvisionCorrelationToBeUpdatedCounter)
specifier|default
name|AdvancedJmsEndpointBuilder
name|waitForProvisionCorrelationToBeUpdatedCounter
parameter_list|(
name|String
name|waitForProvisionCorrelationToBeUpdatedCounter
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"waitForProvisionCorrelationToBeUpdatedCounter"
argument_list|,
name|waitForProvisionCorrelationToBeUpdatedCounter
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Interval in millis to sleep each time while waiting for provisional          * correlation id to be updated.          *           * The option is a:<code>long</code> type.          *           * Group: advanced          */
DECL|method|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime ( long waitForProvisionCorrelationToBeUpdatedThreadSleepingTime)
specifier|default
name|AdvancedJmsEndpointBuilder
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
parameter_list|(
name|long
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"waitForProvisionCorrelationToBeUpdatedThreadSleepingTime"
argument_list|,
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Interval in millis to sleep each time while waiting for provisional          * correlation id to be updated.          *           * The option will be converted to a<code>long</code> type.          *           * Group: advanced          */
DECL|method|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime ( String waitForProvisionCorrelationToBeUpdatedThreadSleepingTime)
specifier|default
name|AdvancedJmsEndpointBuilder
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
parameter_list|(
name|String
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"waitForProvisionCorrelationToBeUpdatedThreadSleepingTime"
argument_list|,
name|waitForProvisionCorrelationToBeUpdatedThreadSleepingTime
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If true, Camel will create a JmsTransactionManager, if there is no          * transactionManager injected when option transacted=true.          *           * The option is a:<code>boolean</code> type.          *           * Group: transaction (advanced)          */
DECL|method|lazyCreateTransactionManager ( boolean lazyCreateTransactionManager)
specifier|default
name|AdvancedJmsEndpointBuilder
name|lazyCreateTransactionManager
parameter_list|(
name|boolean
name|lazyCreateTransactionManager
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"lazyCreateTransactionManager"
argument_list|,
name|lazyCreateTransactionManager
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * If true, Camel will create a JmsTransactionManager, if there is no          * transactionManager injected when option transacted=true.          *           * The option will be converted to a<code>boolean</code> type.          *           * Group: transaction (advanced)          */
DECL|method|lazyCreateTransactionManager ( String lazyCreateTransactionManager)
specifier|default
name|AdvancedJmsEndpointBuilder
name|lazyCreateTransactionManager
parameter_list|(
name|String
name|lazyCreateTransactionManager
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"lazyCreateTransactionManager"
argument_list|,
name|lazyCreateTransactionManager
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The Spring transaction manager to use.          *           * The option is a:          *<code>org.springframework.transaction.PlatformTransactionManager</code> type.          *           * Group: transaction (advanced)          */
DECL|method|transactionManager ( Object transactionManager)
specifier|default
name|AdvancedJmsEndpointBuilder
name|transactionManager
parameter_list|(
name|Object
name|transactionManager
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transactionManager"
argument_list|,
name|transactionManager
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The Spring transaction manager to use.          *           * The option will be converted to a          *<code>org.springframework.transaction.PlatformTransactionManager</code> type.          *           * Group: transaction (advanced)          */
DECL|method|transactionManager ( String transactionManager)
specifier|default
name|AdvancedJmsEndpointBuilder
name|transactionManager
parameter_list|(
name|String
name|transactionManager
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transactionManager"
argument_list|,
name|transactionManager
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The name of the transaction to use.          *           * The option is a:<code>java.lang.String</code> type.          *           * Group: transaction (advanced)          */
DECL|method|transactionName ( String transactionName)
specifier|default
name|AdvancedJmsEndpointBuilder
name|transactionName
parameter_list|(
name|String
name|transactionName
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transactionName"
argument_list|,
name|transactionName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The timeout value of the transaction (in seconds), if using          * transacted mode.          *           * The option is a:<code>int</code> type.          *           * Group: transaction (advanced)          */
DECL|method|transactionTimeout ( int transactionTimeout)
specifier|default
name|AdvancedJmsEndpointBuilder
name|transactionTimeout
parameter_list|(
name|int
name|transactionTimeout
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transactionTimeout"
argument_list|,
name|transactionTimeout
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * The timeout value of the transaction (in seconds), if using          * transacted mode.          *           * The option will be converted to a<code>int</code> type.          *           * Group: transaction (advanced)          */
DECL|method|transactionTimeout ( String transactionTimeout)
specifier|default
name|AdvancedJmsEndpointBuilder
name|transactionTimeout
parameter_list|(
name|String
name|transactionTimeout
parameter_list|)
block|{
name|doSetProperty
argument_list|(
literal|"transactionTimeout"
argument_list|,
name|transactionTimeout
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
comment|/**      * Proxy enum for<code>org.apache.camel.component.jms.JmsMessageType</code>      * enum.      */
DECL|enum|JmsMessageType
enum|enum
name|JmsMessageType
block|{
DECL|enumConstant|Bytes
name|Bytes
block|,
DECL|enumConstant|Map
name|Map
block|,
DECL|enumConstant|Object
name|Object
block|,
DECL|enumConstant|Stream
name|Stream
block|,
DECL|enumConstant|Text
name|Text
block|,
DECL|enumConstant|Blob
name|Blob
block|;     }
comment|/**      * Proxy enum for<code>org.apache.camel.component.jms.ConsumerType</code>      * enum.      */
DECL|enum|ConsumerType
enum|enum
name|ConsumerType
block|{
DECL|enumConstant|Simple
name|Simple
block|,
DECL|enumConstant|Default
name|Default
block|,
DECL|enumConstant|Custom
name|Custom
block|;     }
comment|/**      * Proxy enum for      *<code>org.apache.camel.component.jms.DefaultTaskExecutorType</code> enum.      */
DECL|enum|DefaultTaskExecutorType
enum|enum
name|DefaultTaskExecutorType
block|{
DECL|enumConstant|ThreadPool
name|ThreadPool
block|,
DECL|enumConstant|SimpleAsync
name|SimpleAsync
block|;     }
comment|/**      * Proxy enum for<code>org.apache.camel.component.jms.ReplyToType</code>      * enum.      */
DECL|enum|ReplyToType
enum|enum
name|ReplyToType
block|{
DECL|enumConstant|Temporary
name|Temporary
block|,
DECL|enumConstant|Shared
name|Shared
block|,
DECL|enumConstant|Exclusive
name|Exclusive
block|;     }
comment|/**      * JMS (camel-jms)      * The jms component allows messages to be sent to (or consumed from) a JMS      * Queue or Topic.      *       * Category: messaging      * Since: 1.0      * Maven coordinates: org.apache.camel:camel-jms      *       * Syntax:<code>jms:destinationType:destinationName</code>      *       * Path parameter: destinationType      * The kind of destination to use      * Default value: queue      * The value can be one of: queue, topic, temp-queue, temp-topic      *       * Path parameter: destinationName (required)      * Name of the queue or topic to use as destination      */
DECL|method|jms (String path)
specifier|default
name|JmsEndpointBuilder
name|jms
parameter_list|(
name|String
name|path
parameter_list|)
block|{
class|class
name|JmsEndpointBuilderImpl
extends|extends
name|AbstractEndpointBuilder
implements|implements
name|JmsEndpointBuilder
implements|,
name|AdvancedJmsEndpointBuilder
block|{
specifier|public
name|JmsEndpointBuilderImpl
parameter_list|(
name|String
name|path
parameter_list|)
block|{
name|super
argument_list|(
literal|"jms"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|JmsEndpointBuilderImpl
argument_list|(
name|path
argument_list|)
return|;
block|}
block|}
end_interface

end_unit

