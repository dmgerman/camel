begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.util
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_comment
comment|/**  * Helper for working with reflection on classes.  *<p/>  * This code is based on org.apache.camel.spring.util.ReflectionUtils class.  */
end_comment

begin_class
DECL|class|ReflectionHelper
specifier|public
specifier|final
class|class
name|ReflectionHelper
block|{
DECL|method|ReflectionHelper ()
specifier|private
name|ReflectionHelper
parameter_list|()
block|{
comment|// utility class
block|}
comment|/**      * Callback interface invoked on each field in the hierarchy.      */
DECL|interface|FieldCallback
specifier|public
interface|interface
name|FieldCallback
block|{
comment|/**          * Perform an operation using the given field.          *          * @param field the field to operate on          */
DECL|method|doWith (Field field)
name|void
name|doWith
parameter_list|(
name|Field
name|field
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|IllegalAccessException
function_decl|;
block|}
comment|/**      * Action to take on each method.      */
DECL|interface|MethodCallback
specifier|public
interface|interface
name|MethodCallback
block|{
comment|/**          * Perform an operation using the given method.          *          * @param method the method to operate on          */
DECL|method|doWith (Method method)
name|void
name|doWith
parameter_list|(
name|Method
name|method
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|IllegalAccessException
function_decl|;
block|}
comment|/**      * Invoke the given callback on all fields in the target class, going up the      * class hierarchy to get all declared fields.      * @param clazz the target class to analyze      * @param fc the callback to invoke for each field      */
DECL|method|doWithFields (Class<?> clazz, FieldCallback fc)
specifier|public
specifier|static
name|void
name|doWithFields
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|,
name|FieldCallback
name|fc
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
comment|// Keep backing up the inheritance hierarchy.
name|Class
argument_list|<
name|?
argument_list|>
name|targetClass
init|=
name|clazz
decl_stmt|;
do|do
block|{
name|Field
index|[]
name|fields
init|=
name|targetClass
operator|.
name|getDeclaredFields
argument_list|()
decl_stmt|;
for|for
control|(
name|Field
name|field
range|:
name|fields
control|)
block|{
try|try
block|{
name|fc
operator|.
name|doWith
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Shouldn't be illegal to access field '"
operator|+
name|field
operator|.
name|getName
argument_list|()
operator|+
literal|"': "
operator|+
name|ex
argument_list|)
throw|;
block|}
block|}
name|targetClass
operator|=
name|targetClass
operator|.
name|getSuperclass
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|targetClass
operator|!=
literal|null
operator|&&
name|targetClass
operator|!=
name|Object
operator|.
name|class
condition|)
do|;
block|}
comment|/**      * Perform the given callback operation on all matching methods of the given      * class and superclasses (or given interface and super-interfaces).      *<p/>      *<b>Important:</b> This method does not take the      * {@link java.lang.reflect.Method#isBridge() bridge methods} into account.      *      * @param clazz class to start looking at      * @param mc the callback to invoke for each method      */
DECL|method|doWithMethods (Class<?> clazz, MethodCallback mc)
specifier|public
specifier|static
name|void
name|doWithMethods
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|,
name|MethodCallback
name|mc
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
comment|// Keep backing up the inheritance hierarchy.
name|Method
index|[]
name|methods
init|=
name|clazz
operator|.
name|getDeclaredMethods
argument_list|()
decl_stmt|;
for|for
control|(
name|Method
name|method
range|:
name|methods
control|)
block|{
if|if
condition|(
name|method
operator|.
name|isBridge
argument_list|()
condition|)
block|{
comment|// skip the bridge methods which in Java 8 leads to problems with inheritance
comment|// see https://bugs.openjdk.java.net/browse/JDK-6695379
continue|continue;
block|}
try|try
block|{
name|mc
operator|.
name|doWith
argument_list|(
name|method
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Shouldn't be illegal to access method '"
operator|+
name|method
operator|.
name|getName
argument_list|()
operator|+
literal|"': "
operator|+
name|ex
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|clazz
operator|.
name|getSuperclass
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|doWithMethods
argument_list|(
name|clazz
operator|.
name|getSuperclass
argument_list|()
argument_list|,
name|mc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|clazz
operator|.
name|isInterface
argument_list|()
condition|)
block|{
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|superIfc
range|:
name|clazz
operator|.
name|getInterfaces
argument_list|()
control|)
block|{
name|doWithMethods
argument_list|(
name|superIfc
argument_list|,
name|mc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Attempt to find a {@link Method} on the supplied class with the supplied name      * and parameter types. Searches all superclasses up to {@code Object}.      *<p>Returns {@code null} if no {@link Method} can be found.      * @param clazz the class to introspect      * @param name the name of the method      * @param paramTypes the parameter types of the method      * (may be {@code null} to indicate any signature)      * @return the Method object, or {@code null} if none found      */
DECL|method|findMethod (Class<?> clazz, String name, Class<?>... paramTypes)
specifier|public
specifier|static
name|Method
name|findMethod
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|,
name|String
name|name
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
modifier|...
name|paramTypes
parameter_list|)
block|{
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|clazz
argument_list|,
literal|"Class must not be null"
argument_list|)
expr_stmt|;
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|name
argument_list|,
literal|"Method name must not be null"
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|searchType
init|=
name|clazz
decl_stmt|;
while|while
condition|(
name|searchType
operator|!=
literal|null
condition|)
block|{
name|Method
index|[]
name|methods
init|=
name|searchType
operator|.
name|isInterface
argument_list|()
condition|?
name|searchType
operator|.
name|getMethods
argument_list|()
else|:
name|searchType
operator|.
name|getDeclaredMethods
argument_list|()
decl_stmt|;
for|for
control|(
name|Method
name|method
range|:
name|methods
control|)
block|{
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
name|method
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
operator|(
name|paramTypes
operator|==
literal|null
operator|||
name|Arrays
operator|.
name|equals
argument_list|(
name|paramTypes
argument_list|,
name|method
operator|.
name|getParameterTypes
argument_list|()
argument_list|)
operator|)
condition|)
block|{
return|return
name|method
return|;
block|}
block|}
name|searchType
operator|=
name|searchType
operator|.
name|getSuperclass
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|setField (Field f, Object instance, Object value)
specifier|public
specifier|static
name|void
name|setField
parameter_list|(
name|Field
name|f
parameter_list|,
name|Object
name|instance
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
try|try
block|{
name|boolean
name|oldAccessible
init|=
name|f
operator|.
name|isAccessible
argument_list|()
decl_stmt|;
name|boolean
name|shouldSetAccessible
init|=
operator|!
name|Modifier
operator|.
name|isPublic
argument_list|(
name|f
operator|.
name|getModifiers
argument_list|()
argument_list|)
operator|&&
operator|!
name|oldAccessible
decl_stmt|;
if|if
condition|(
name|shouldSetAccessible
condition|)
block|{
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|f
operator|.
name|set
argument_list|(
name|instance
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldSetAccessible
condition|)
block|{
name|f
operator|.
name|setAccessible
argument_list|(
name|oldAccessible
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot inject value of class: "
operator|+
name|value
operator|.
name|getClass
argument_list|()
operator|+
literal|" into: "
operator|+
name|f
argument_list|)
throw|;
block|}
block|}
DECL|method|getField (Field f, Object instance)
specifier|public
specifier|static
name|Object
name|getField
parameter_list|(
name|Field
name|f
parameter_list|,
name|Object
name|instance
parameter_list|)
block|{
try|try
block|{
name|boolean
name|oldAccessible
init|=
name|f
operator|.
name|isAccessible
argument_list|()
decl_stmt|;
name|boolean
name|shouldSetAccessible
init|=
operator|!
name|Modifier
operator|.
name|isPublic
argument_list|(
name|f
operator|.
name|getModifiers
argument_list|()
argument_list|)
operator|&&
operator|!
name|oldAccessible
decl_stmt|;
if|if
condition|(
name|shouldSetAccessible
condition|)
block|{
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|Object
name|answer
init|=
name|f
operator|.
name|get
argument_list|(
name|instance
argument_list|)
decl_stmt|;
if|if
condition|(
name|shouldSetAccessible
condition|)
block|{
name|f
operator|.
name|setAccessible
argument_list|(
name|oldAccessible
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
comment|// ignore
block|}
return|return
literal|null
return|;
block|}
block|}
end_class

end_unit

