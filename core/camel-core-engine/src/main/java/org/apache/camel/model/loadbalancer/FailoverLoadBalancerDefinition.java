begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.model.loadbalancer
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|model
operator|.
name|loadbalancer
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|bind
operator|.
name|annotation
operator|.
name|XmlAccessType
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|bind
operator|.
name|annotation
operator|.
name|XmlAccessorType
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|bind
operator|.
name|annotation
operator|.
name|XmlAttribute
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|bind
operator|.
name|annotation
operator|.
name|XmlElement
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|bind
operator|.
name|annotation
operator|.
name|XmlRootElement
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|bind
operator|.
name|annotation
operator|.
name|XmlTransient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|model
operator|.
name|LoadBalancerDefinition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|Metadata
import|;
end_import

begin_comment
comment|/**  * Failover load balancer The failover load balancer is capable of trying the  * next processor in case an Exchange failed with an exception during  * processing. You can constrain the failover to activate only when one  * exception of a list you specify occurs. If you do not specify a list any  * exception will cause fail over to occur. This balancer uses the same strategy  * for matching exceptions as the Exception Clause does for the onException.  */
end_comment

begin_class
annotation|@
name|Metadata
argument_list|(
name|label
operator|=
literal|"eip,routing,loadbalance"
argument_list|)
annotation|@
name|XmlRootElement
argument_list|(
name|name
operator|=
literal|"failover"
argument_list|)
annotation|@
name|XmlAccessorType
argument_list|(
name|XmlAccessType
operator|.
name|FIELD
argument_list|)
DECL|class|FailoverLoadBalancerDefinition
specifier|public
class|class
name|FailoverLoadBalancerDefinition
extends|extends
name|LoadBalancerDefinition
block|{
annotation|@
name|XmlTransient
DECL|field|exceptionTypes
specifier|private
name|List
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|exceptionTypes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|XmlElement
argument_list|(
name|name
operator|=
literal|"exception"
argument_list|)
DECL|field|exceptions
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|exceptions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|XmlAttribute
DECL|field|roundRobin
specifier|private
name|Boolean
name|roundRobin
decl_stmt|;
annotation|@
name|XmlAttribute
DECL|field|sticky
specifier|private
name|Boolean
name|sticky
decl_stmt|;
annotation|@
name|XmlAttribute
annotation|@
name|Metadata
argument_list|(
name|defaultValue
operator|=
literal|"-1"
argument_list|)
DECL|field|maximumFailoverAttempts
specifier|private
name|Integer
name|maximumFailoverAttempts
decl_stmt|;
DECL|method|FailoverLoadBalancerDefinition ()
specifier|public
name|FailoverLoadBalancerDefinition
parameter_list|()
block|{     }
DECL|method|getExceptions ()
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getExceptions
parameter_list|()
block|{
return|return
name|exceptions
return|;
block|}
comment|/**      * A list of class names for specific exceptions to monitor. If no      * exceptions is configured then all exceptions is monitored      */
DECL|method|setExceptions (List<String> exceptions)
specifier|public
name|void
name|setExceptions
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|exceptions
parameter_list|)
block|{
name|this
operator|.
name|exceptions
operator|=
name|exceptions
expr_stmt|;
block|}
DECL|method|getExceptionTypes ()
specifier|public
name|List
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|getExceptionTypes
parameter_list|()
block|{
return|return
name|exceptionTypes
return|;
block|}
comment|/**      * A list of specific exceptions to monitor. If no exceptions is configured      * then all exceptions is monitored      */
DECL|method|setExceptionTypes (List<Class<?>> exceptionTypes)
specifier|public
name|void
name|setExceptionTypes
parameter_list|(
name|List
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|exceptionTypes
parameter_list|)
block|{
name|this
operator|.
name|exceptionTypes
operator|=
name|exceptionTypes
expr_stmt|;
block|}
DECL|method|getRoundRobin ()
specifier|public
name|Boolean
name|getRoundRobin
parameter_list|()
block|{
return|return
name|roundRobin
return|;
block|}
comment|/**      * Whether or not the failover load balancer should operate in round robin      * mode or not. If not, then it will always start from the first endpoint      * when a new message is to be processed. In other words it restart from the      * top for every message. If round robin is enabled, then it keeps state and      * will continue with the next endpoint in a round robin fashion.      *<p/>      * You can also enable sticky mode together with round robin, if so then it      * will pick the last known good endpoint to use when starting the load      * balancing (instead of using the next when starting).      */
DECL|method|setRoundRobin (Boolean roundRobin)
specifier|public
name|void
name|setRoundRobin
parameter_list|(
name|Boolean
name|roundRobin
parameter_list|)
block|{
name|this
operator|.
name|roundRobin
operator|=
name|roundRobin
expr_stmt|;
block|}
DECL|method|getSticky ()
specifier|public
name|Boolean
name|getSticky
parameter_list|()
block|{
return|return
name|sticky
return|;
block|}
comment|/**      * Whether or not the failover load balancer should operate in sticky mode      * or not. If not, then it will always start from the first endpoint when a      * new message is to be processed. In other words it restart from the top      * for every message. If sticky is enabled, then it keeps state and will      * continue with the last known good endpoint.      *<p/>      * You can also enable sticky mode together with round robin, if so then it      * will pick the last known good endpoint to use when starting the load      * balancing (instead of using the next when starting).      */
DECL|method|setSticky (Boolean sticky)
specifier|public
name|void
name|setSticky
parameter_list|(
name|Boolean
name|sticky
parameter_list|)
block|{
name|this
operator|.
name|sticky
operator|=
name|sticky
expr_stmt|;
block|}
DECL|method|getMaximumFailoverAttempts ()
specifier|public
name|Integer
name|getMaximumFailoverAttempts
parameter_list|()
block|{
return|return
name|maximumFailoverAttempts
return|;
block|}
comment|/**      * A value to indicate after X failover attempts we should exhaust (give      * up). Use -1 to indicate never give up and continuously try to failover.      * Use 0 to never failover. And use e.g. 3 to failover at most 3 times      * before giving up. his option can be used whether or not roundRobin is      * enabled or not.      */
DECL|method|setMaximumFailoverAttempts (Integer maximumFailoverAttempts)
specifier|public
name|void
name|setMaximumFailoverAttempts
parameter_list|(
name|Integer
name|maximumFailoverAttempts
parameter_list|)
block|{
name|this
operator|.
name|maximumFailoverAttempts
operator|=
name|maximumFailoverAttempts
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"FailoverLoadBalancer"
return|;
block|}
block|}
end_class

end_unit

