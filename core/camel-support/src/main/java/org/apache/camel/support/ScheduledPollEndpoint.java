begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.support
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|LoggingLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|PollingConsumer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|ResolveEndpointFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|PollingConsumerPollStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|ScheduledPollConsumerScheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|UriParam
import|;
end_import

begin_comment
comment|/**  * A base class for {@link org.apache.camel.Endpoint} which creates a {@link ScheduledPollConsumer}  */
end_comment

begin_class
DECL|class|ScheduledPollEndpoint
specifier|public
specifier|abstract
class|class
name|ScheduledPollEndpoint
extends|extends
name|DefaultEndpoint
block|{
DECL|field|SPRING_SCHEDULER
specifier|private
specifier|static
specifier|final
name|String
name|SPRING_SCHEDULER
init|=
literal|"org.apache.camel.spring.pollingconsumer.SpringScheduledPollConsumerScheduler"
decl_stmt|;
DECL|field|QUARTZ_2_SCHEDULER
specifier|private
specifier|static
specifier|final
name|String
name|QUARTZ_2_SCHEDULER
init|=
literal|"org.apache.camel.pollconsumer.quartz2.QuartzScheduledPollConsumerScheduler"
decl_stmt|;
comment|// if adding more options then align with org.apache.camel.support.ScheduledPollConsumer
annotation|@
name|UriParam
argument_list|(
name|optionalPrefix
operator|=
literal|"consumer."
argument_list|,
name|defaultValue
operator|=
literal|"true"
argument_list|,
name|label
operator|=
literal|"consumer,scheduler"
argument_list|,
name|description
operator|=
literal|"Whether the scheduler should be auto started."
argument_list|)
DECL|field|startScheduler
specifier|private
name|boolean
name|startScheduler
init|=
literal|true
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|optionalPrefix
operator|=
literal|"consumer."
argument_list|,
name|defaultValue
operator|=
literal|"1000"
argument_list|,
name|label
operator|=
literal|"consumer,scheduler"
argument_list|,
name|description
operator|=
literal|"Milliseconds before the first poll starts."
operator|+
literal|" You can also specify time values using units, such as 60s (60 seconds), 5m30s (5 minutes and 30 seconds), and 1h (1 hour)."
argument_list|)
DECL|field|initialDelay
specifier|private
name|long
name|initialDelay
init|=
literal|1000
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|optionalPrefix
operator|=
literal|"consumer."
argument_list|,
name|defaultValue
operator|=
literal|"500"
argument_list|,
name|label
operator|=
literal|"consumer,scheduler"
argument_list|,
name|description
operator|=
literal|"Milliseconds before the next poll."
operator|+
literal|" You can also specify time values using units, such as 60s (60 seconds), 5m30s (5 minutes and 30 seconds), and 1h (1 hour)."
argument_list|)
DECL|field|delay
specifier|private
name|long
name|delay
init|=
literal|500
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|optionalPrefix
operator|=
literal|"consumer."
argument_list|,
name|defaultValue
operator|=
literal|"MILLISECONDS"
argument_list|,
name|label
operator|=
literal|"consumer,scheduler"
argument_list|,
name|description
operator|=
literal|"Time unit for initialDelay and delay options."
argument_list|)
DECL|field|timeUnit
specifier|private
name|TimeUnit
name|timeUnit
init|=
name|TimeUnit
operator|.
name|MILLISECONDS
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|optionalPrefix
operator|=
literal|"consumer."
argument_list|,
name|defaultValue
operator|=
literal|"true"
argument_list|,
name|label
operator|=
literal|"consumer,scheduler"
argument_list|,
name|description
operator|=
literal|"Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details."
argument_list|)
DECL|field|useFixedDelay
specifier|private
name|boolean
name|useFixedDelay
init|=
literal|true
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|optionalPrefix
operator|=
literal|"consumer."
argument_list|,
name|label
operator|=
literal|"consumer,advanced"
argument_list|,
name|description
operator|=
literal|"A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation"
operator|+
literal|" to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel."
argument_list|)
DECL|field|pollStrategy
specifier|private
name|PollingConsumerPollStrategy
name|pollStrategy
init|=
operator|new
name|DefaultPollingConsumerPollStrategy
argument_list|()
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|optionalPrefix
operator|=
literal|"consumer."
argument_list|,
name|defaultValue
operator|=
literal|"TRACE"
argument_list|,
name|label
operator|=
literal|"consumer,scheduler"
argument_list|,
name|description
operator|=
literal|"The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that."
argument_list|)
DECL|field|runLoggingLevel
specifier|private
name|LoggingLevel
name|runLoggingLevel
init|=
name|LoggingLevel
operator|.
name|TRACE
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|optionalPrefix
operator|=
literal|"consumer."
argument_list|,
name|label
operator|=
literal|"consumer"
argument_list|,
name|description
operator|=
literal|"If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead."
argument_list|)
DECL|field|sendEmptyMessageWhenIdle
specifier|private
name|boolean
name|sendEmptyMessageWhenIdle
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|optionalPrefix
operator|=
literal|"consumer."
argument_list|,
name|label
operator|=
literal|"consumer,scheduler"
argument_list|,
name|description
operator|=
literal|"If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages."
argument_list|)
DECL|field|greedy
specifier|private
name|boolean
name|greedy
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|optionalPrefix
operator|=
literal|"consumer."
argument_list|,
name|enums
operator|=
literal|"none,spring,quartz2"
argument_list|,
name|defaultValue
operator|=
literal|"none"
argument_list|,
name|label
operator|=
literal|"consumer,scheduler"
argument_list|,
name|description
operator|=
literal|"To use a cron scheduler from either camel-spring or camel-quartz2 component"
argument_list|)
DECL|field|scheduler
specifier|private
name|ScheduledPollConsumerScheduler
name|scheduler
decl_stmt|;
DECL|field|schedulerName
specifier|private
name|String
name|schedulerName
init|=
literal|"none"
decl_stmt|;
comment|// used when configuring scheduler using a string value
annotation|@
name|UriParam
argument_list|(
name|prefix
operator|=
literal|"scheduler."
argument_list|,
name|multiValue
operator|=
literal|true
argument_list|,
name|label
operator|=
literal|"consumer,scheduler"
argument_list|,
name|description
operator|=
literal|"To configure additional properties when using a custom scheduler or any of the Quartz2, Spring based scheduler."
argument_list|)
DECL|field|schedulerProperties
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|schedulerProperties
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|optionalPrefix
operator|=
literal|"consumer."
argument_list|,
name|label
operator|=
literal|"consumer,scheduler"
argument_list|,
name|description
operator|=
literal|"Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool."
argument_list|)
DECL|field|scheduledExecutorService
specifier|private
name|ScheduledExecutorService
name|scheduledExecutorService
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|optionalPrefix
operator|=
literal|"consumer."
argument_list|,
name|label
operator|=
literal|"consumer,scheduler"
argument_list|,
name|description
operator|=
literal|"To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row."
operator|+
literal|" The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again."
operator|+
literal|" When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured."
argument_list|)
DECL|field|backoffMultiplier
specifier|private
name|int
name|backoffMultiplier
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|optionalPrefix
operator|=
literal|"consumer."
argument_list|,
name|label
operator|=
literal|"consumer,scheduler"
argument_list|,
name|description
operator|=
literal|"The number of subsequent idle polls that should happen before the backoffMultipler should kick-in."
argument_list|)
DECL|field|backoffIdleThreshold
specifier|private
name|int
name|backoffIdleThreshold
decl_stmt|;
annotation|@
name|UriParam
argument_list|(
name|optionalPrefix
operator|=
literal|"consumer."
argument_list|,
name|label
operator|=
literal|"consumer,scheduler"
argument_list|,
name|description
operator|=
literal|"The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in."
argument_list|)
DECL|field|backoffErrorThreshold
specifier|private
name|int
name|backoffErrorThreshold
decl_stmt|;
DECL|method|ScheduledPollEndpoint (String endpointUri, Component component)
specifier|protected
name|ScheduledPollEndpoint
parameter_list|(
name|String
name|endpointUri
parameter_list|,
name|Component
name|component
parameter_list|)
block|{
name|super
argument_list|(
name|endpointUri
argument_list|,
name|component
argument_list|)
expr_stmt|;
block|}
DECL|method|ScheduledPollEndpoint ()
specifier|protected
name|ScheduledPollEndpoint
parameter_list|()
block|{     }
DECL|method|configureProperties (Map<String, Object> options)
specifier|public
name|void
name|configureProperties
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|options
parameter_list|)
block|{
name|super
operator|.
name|configureProperties
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|configureScheduledPollConsumerProperties
argument_list|(
name|options
argument_list|,
name|getConsumerProperties
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|configureScheduledPollConsumerProperties (Map<String, Object> options, Map<String, Object> consumerProperties)
specifier|protected
name|void
name|configureScheduledPollConsumerProperties
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|options
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|consumerProperties
parameter_list|)
block|{
comment|// special for scheduled poll consumers as we want to allow end users to configure its options
comment|// from the URI parameters without the consumer. prefix
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|schedulerProperties
init|=
name|IntrospectionSupport
operator|.
name|extractProperties
argument_list|(
name|options
argument_list|,
literal|"scheduler."
argument_list|)
decl_stmt|;
if|if
condition|(
name|schedulerProperties
operator|!=
literal|null
operator|&&
operator|!
name|schedulerProperties
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|setSchedulerProperties
argument_list|(
name|schedulerProperties
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scheduler
operator|==
literal|null
operator|&&
name|schedulerName
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
literal|"none"
operator|.
name|equals
argument_list|(
name|schedulerName
argument_list|)
condition|)
block|{
comment|// no cron scheduler in use
name|scheduler
operator|=
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"spring"
operator|.
name|equals
argument_list|(
name|schedulerName
argument_list|)
condition|)
block|{
comment|// special for scheduler if its "spring" or "quartz2"
try|try
block|{
name|Class
argument_list|<
name|?
extends|extends
name|ScheduledPollConsumerScheduler
argument_list|>
name|clazz
init|=
name|getCamelContext
argument_list|()
operator|.
name|getClassResolver
argument_list|()
operator|.
name|resolveMandatoryClass
argument_list|(
name|SPRING_SCHEDULER
argument_list|,
name|ScheduledPollConsumerScheduler
operator|.
name|class
argument_list|)
decl_stmt|;
name|setScheduler
argument_list|(
name|getCamelContext
argument_list|()
operator|.
name|getInjector
argument_list|()
operator|.
name|newInstance
argument_list|(
name|clazz
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot load "
operator|+
name|SPRING_SCHEDULER
operator|+
literal|" from classpath. Make sure camel-spring.jar is on the classpath."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"quartz2"
operator|.
name|equals
argument_list|(
name|schedulerName
argument_list|)
condition|)
block|{
comment|// special for scheduler if its "spring" or "quartz2"
try|try
block|{
name|Class
argument_list|<
name|?
extends|extends
name|ScheduledPollConsumerScheduler
argument_list|>
name|clazz
init|=
name|getCamelContext
argument_list|()
operator|.
name|getClassResolver
argument_list|()
operator|.
name|resolveMandatoryClass
argument_list|(
name|QUARTZ_2_SCHEDULER
argument_list|,
name|ScheduledPollConsumerScheduler
operator|.
name|class
argument_list|)
decl_stmt|;
name|setScheduler
argument_list|(
name|getCamelContext
argument_list|()
operator|.
name|getInjector
argument_list|()
operator|.
name|newInstance
argument_list|(
name|clazz
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot load "
operator|+
name|QUARTZ_2_SCHEDULER
operator|+
literal|" from classpath. Make sure camel-quartz2.jar is on the classpath."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// must refer to a custom scheduler by the given name
name|setScheduler
argument_list|(
name|CamelContextHelper
operator|.
name|mandatoryLookup
argument_list|(
name|getCamelContext
argument_list|()
argument_list|,
name|schedulerName
argument_list|,
name|ScheduledPollConsumerScheduler
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|configurePollingConsumer (PollingConsumer consumer)
specifier|protected
name|void
name|configurePollingConsumer
parameter_list|(
name|PollingConsumer
name|consumer
parameter_list|)
throws|throws
name|Exception
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|copy
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|getConsumerProperties
argument_list|()
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|throwaway
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// filter out unwanted options which is intended for the scheduled poll consumer
comment|// as these options are not supported on the polling consumer
name|configureScheduledPollConsumerProperties
argument_list|(
name|copy
argument_list|,
name|throwaway
argument_list|)
expr_stmt|;
comment|// configure consumer
name|setProperties
argument_list|(
name|consumer
argument_list|,
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isLenientProperties
argument_list|()
operator|&&
name|copy
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|ResolveEndpointFailedException
argument_list|(
name|this
operator|.
name|getEndpointUri
argument_list|()
argument_list|,
literal|"There are "
operator|+
name|copy
operator|.
name|size
argument_list|()
operator|+
literal|" parameters that couldn't be set on the endpoint polling consumer."
operator|+
literal|" Check the uri if the parameters are spelt correctly and that they are properties of the endpoint."
operator|+
literal|" Unknown consumer parameters=["
operator|+
name|copy
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
DECL|method|initConsumerProperties ()
specifier|protected
name|void
name|initConsumerProperties
parameter_list|()
block|{
comment|// must setup consumer properties before we are ready to start
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|options
init|=
name|getConsumerProperties
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|options
operator|.
name|containsKey
argument_list|(
literal|"startScheduler"
argument_list|)
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
literal|"startScheduler"
argument_list|,
name|isStartScheduler
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|options
operator|.
name|containsKey
argument_list|(
literal|"initialDelay"
argument_list|)
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
literal|"initialDelay"
argument_list|,
name|getInitialDelay
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|options
operator|.
name|containsKey
argument_list|(
literal|"delay"
argument_list|)
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
literal|"delay"
argument_list|,
name|getDelay
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|options
operator|.
name|containsKey
argument_list|(
literal|"timeUnit"
argument_list|)
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
literal|"timeUnit"
argument_list|,
name|getTimeUnit
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|options
operator|.
name|containsKey
argument_list|(
literal|"useFixedDelay"
argument_list|)
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
literal|"useFixedDelay"
argument_list|,
name|isUseFixedDelay
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|options
operator|.
name|containsKey
argument_list|(
literal|"pollStrategy"
argument_list|)
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
literal|"pollStrategy"
argument_list|,
name|getPollStrategy
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|options
operator|.
name|containsKey
argument_list|(
literal|"runLoggingLevel"
argument_list|)
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
literal|"runLoggingLevel"
argument_list|,
name|getRunLoggingLevel
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|options
operator|.
name|containsKey
argument_list|(
literal|"sendEmptyMessageWhenIdle"
argument_list|)
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
literal|"sendEmptyMessageWhenIdle"
argument_list|,
name|isSendEmptyMessageWhenIdle
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|options
operator|.
name|containsKey
argument_list|(
literal|"greedy"
argument_list|)
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
literal|"greedy"
argument_list|,
name|isGreedy
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|options
operator|.
name|containsKey
argument_list|(
literal|"scheduler"
argument_list|)
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
literal|"scheduler"
argument_list|,
name|getScheduler
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|options
operator|.
name|containsKey
argument_list|(
literal|"schedulerProperties"
argument_list|)
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
literal|"schedulerProperties"
argument_list|,
name|getSchedulerProperties
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|options
operator|.
name|containsKey
argument_list|(
literal|"scheduledExecutorService"
argument_list|)
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
literal|"scheduledExecutorService"
argument_list|,
name|getScheduledExecutorService
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|options
operator|.
name|containsKey
argument_list|(
literal|"backoffMultiplier"
argument_list|)
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
literal|"backoffMultiplier"
argument_list|,
name|getBackoffMultiplier
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|options
operator|.
name|containsKey
argument_list|(
literal|"backoffIdleThreshold"
argument_list|)
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
literal|"backoffIdleThreshold"
argument_list|,
name|getBackoffIdleThreshold
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|options
operator|.
name|containsKey
argument_list|(
literal|"backoffErrorThreshold"
argument_list|)
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
literal|"backoffErrorThreshold"
argument_list|,
name|getBackoffErrorThreshold
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|doStart ()
specifier|protected
name|void
name|doStart
parameter_list|()
throws|throws
name|Exception
block|{
name|initConsumerProperties
argument_list|()
expr_stmt|;
name|super
operator|.
name|doStart
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStop ()
specifier|protected
name|void
name|doStop
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|doStop
argument_list|()
expr_stmt|;
comment|// noop
block|}
DECL|method|isStartScheduler ()
specifier|public
name|boolean
name|isStartScheduler
parameter_list|()
block|{
return|return
name|startScheduler
return|;
block|}
comment|/**      * Whether the scheduler should be auto started.      */
DECL|method|setStartScheduler (boolean startScheduler)
specifier|public
name|void
name|setStartScheduler
parameter_list|(
name|boolean
name|startScheduler
parameter_list|)
block|{
name|this
operator|.
name|startScheduler
operator|=
name|startScheduler
expr_stmt|;
block|}
DECL|method|getInitialDelay ()
specifier|public
name|long
name|getInitialDelay
parameter_list|()
block|{
return|return
name|initialDelay
return|;
block|}
comment|/**      * Milliseconds before the first poll starts.      *<p/>      * The default value is 1000.      * You can also specify time values using units, such as 60s (60 seconds), 5m30s (5 minutes and 30 seconds), and 1h (1 hour).      * @see<a href="http://camel.apache.org/how-do-i-specify-time-period-in-a-human-friendly-syntax.html">human friendly syntax</a>      */
DECL|method|setInitialDelay (long initialDelay)
specifier|public
name|void
name|setInitialDelay
parameter_list|(
name|long
name|initialDelay
parameter_list|)
block|{
name|this
operator|.
name|initialDelay
operator|=
name|initialDelay
expr_stmt|;
block|}
DECL|method|getDelay ()
specifier|public
name|long
name|getDelay
parameter_list|()
block|{
return|return
name|delay
return|;
block|}
comment|/**      * Milliseconds before the next poll.      *<p/>      * The default value is 500.      * You can also specify time values using units, such as 60s (60 seconds), 5m30s (5 minutes and 30 seconds), and 1h (1 hour).      * @see<a href="http://camel.apache.org/how-do-i-specify-time-period-in-a-human-friendly-syntax.html">human friendly syntax</a>      */
DECL|method|setDelay (long delay)
specifier|public
name|void
name|setDelay
parameter_list|(
name|long
name|delay
parameter_list|)
block|{
name|this
operator|.
name|delay
operator|=
name|delay
expr_stmt|;
block|}
DECL|method|getTimeUnit ()
specifier|public
name|TimeUnit
name|getTimeUnit
parameter_list|()
block|{
return|return
name|timeUnit
return|;
block|}
comment|/**      * Time unit for initialDelay and delay options.      */
DECL|method|setTimeUnit (TimeUnit timeUnit)
specifier|public
name|void
name|setTimeUnit
parameter_list|(
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
name|this
operator|.
name|timeUnit
operator|=
name|timeUnit
expr_stmt|;
block|}
DECL|method|isUseFixedDelay ()
specifier|public
name|boolean
name|isUseFixedDelay
parameter_list|()
block|{
return|return
name|useFixedDelay
return|;
block|}
comment|/**      * Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.      */
DECL|method|setUseFixedDelay (boolean useFixedDelay)
specifier|public
name|void
name|setUseFixedDelay
parameter_list|(
name|boolean
name|useFixedDelay
parameter_list|)
block|{
name|this
operator|.
name|useFixedDelay
operator|=
name|useFixedDelay
expr_stmt|;
block|}
DECL|method|getPollStrategy ()
specifier|public
name|PollingConsumerPollStrategy
name|getPollStrategy
parameter_list|()
block|{
return|return
name|pollStrategy
return|;
block|}
comment|/**      * A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation      * to control error handling usually occurred during the poll operation before an Exchange have been created      * and being routed in Camel. In other words the error occurred while the polling was gathering information,      * for instance access to a file network failed so Camel cannot access it to scan for files.      * The default implementation will log the caused exception at WARN level and ignore it.      */
DECL|method|setPollStrategy (PollingConsumerPollStrategy pollStrategy)
specifier|public
name|void
name|setPollStrategy
parameter_list|(
name|PollingConsumerPollStrategy
name|pollStrategy
parameter_list|)
block|{
name|this
operator|.
name|pollStrategy
operator|=
name|pollStrategy
expr_stmt|;
comment|// we are allowed to change poll strategy
block|}
DECL|method|getRunLoggingLevel ()
specifier|public
name|LoggingLevel
name|getRunLoggingLevel
parameter_list|()
block|{
return|return
name|runLoggingLevel
return|;
block|}
comment|/**      * The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.      */
DECL|method|setRunLoggingLevel (LoggingLevel runLoggingLevel)
specifier|public
name|void
name|setRunLoggingLevel
parameter_list|(
name|LoggingLevel
name|runLoggingLevel
parameter_list|)
block|{
name|this
operator|.
name|runLoggingLevel
operator|=
name|runLoggingLevel
expr_stmt|;
block|}
DECL|method|isSendEmptyMessageWhenIdle ()
specifier|public
name|boolean
name|isSendEmptyMessageWhenIdle
parameter_list|()
block|{
return|return
name|sendEmptyMessageWhenIdle
return|;
block|}
comment|/**      * If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.      */
DECL|method|setSendEmptyMessageWhenIdle (boolean sendEmptyMessageWhenIdle)
specifier|public
name|void
name|setSendEmptyMessageWhenIdle
parameter_list|(
name|boolean
name|sendEmptyMessageWhenIdle
parameter_list|)
block|{
name|this
operator|.
name|sendEmptyMessageWhenIdle
operator|=
name|sendEmptyMessageWhenIdle
expr_stmt|;
block|}
DECL|method|isGreedy ()
specifier|public
name|boolean
name|isGreedy
parameter_list|()
block|{
return|return
name|greedy
return|;
block|}
comment|/**      * If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.      */
DECL|method|setGreedy (boolean greedy)
specifier|public
name|void
name|setGreedy
parameter_list|(
name|boolean
name|greedy
parameter_list|)
block|{
name|this
operator|.
name|greedy
operator|=
name|greedy
expr_stmt|;
block|}
DECL|method|getScheduler ()
specifier|public
name|ScheduledPollConsumerScheduler
name|getScheduler
parameter_list|()
block|{
return|return
name|scheduler
return|;
block|}
comment|/**      * Allow to plugin a custom org.apache.camel.spi.ScheduledPollConsumerScheduler to use as the scheduler for      * firing when the polling consumer runs. The default implementation uses the ScheduledExecutorService and      * there is a Quartz2, and Spring based which supports CRON expressions.      *      * Notice: If using a custom scheduler then the options for initialDelay, useFixedDelay, timeUnit,      * and scheduledExecutorService may not be in use. Use the text quartz2 to refer to use the Quartz2 scheduler;      * and use the text spring to use the Spring based; and use the text #myScheduler to refer to a custom scheduler      * by its id in the Registry. See Quartz2 page for an example.      */
DECL|method|setScheduler (ScheduledPollConsumerScheduler scheduler)
specifier|public
name|void
name|setScheduler
parameter_list|(
name|ScheduledPollConsumerScheduler
name|scheduler
parameter_list|)
block|{
name|this
operator|.
name|scheduler
operator|=
name|scheduler
expr_stmt|;
block|}
comment|/**      * Allow to plugin a custom org.apache.camel.spi.ScheduledPollConsumerScheduler to use as the scheduler for      * firing when the polling consumer runs. This option is used for referring to one of the built-in schedulers      * either<tt>spring</tt>, or<tt>quartz2</tt>. Using<tt>none</tt> refers to no scheduler to be used.      */
DECL|method|setScheduler (String schedulerName)
specifier|public
name|void
name|setScheduler
parameter_list|(
name|String
name|schedulerName
parameter_list|)
block|{
name|this
operator|.
name|schedulerName
operator|=
name|schedulerName
expr_stmt|;
block|}
DECL|method|getSchedulerProperties ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getSchedulerProperties
parameter_list|()
block|{
return|return
name|schedulerProperties
return|;
block|}
comment|/**      * To configure additional properties when using a custom scheduler or any of the Quartz2, Spring based scheduler.      */
DECL|method|setSchedulerProperties (Map<String, Object> schedulerProperties)
specifier|public
name|void
name|setSchedulerProperties
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|schedulerProperties
parameter_list|)
block|{
name|this
operator|.
name|schedulerProperties
operator|=
name|schedulerProperties
expr_stmt|;
block|}
DECL|method|getScheduledExecutorService ()
specifier|public
name|ScheduledExecutorService
name|getScheduledExecutorService
parameter_list|()
block|{
return|return
name|scheduledExecutorService
return|;
block|}
comment|/**      * Allows for configuring a custom/shared thread pool to use for the consumer.      * By default each consumer has its own single threaded thread pool.      * This option allows you to share a thread pool among multiple consumers.      */
DECL|method|setScheduledExecutorService (ScheduledExecutorService scheduledExecutorService)
specifier|public
name|void
name|setScheduledExecutorService
parameter_list|(
name|ScheduledExecutorService
name|scheduledExecutorService
parameter_list|)
block|{
name|this
operator|.
name|scheduledExecutorService
operator|=
name|scheduledExecutorService
expr_stmt|;
block|}
DECL|method|getBackoffMultiplier ()
specifier|public
name|int
name|getBackoffMultiplier
parameter_list|()
block|{
return|return
name|backoffMultiplier
return|;
block|}
comment|/**      * To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row.      * The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again.      * When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.      */
DECL|method|setBackoffMultiplier (int backoffMultiplier)
specifier|public
name|void
name|setBackoffMultiplier
parameter_list|(
name|int
name|backoffMultiplier
parameter_list|)
block|{
name|this
operator|.
name|backoffMultiplier
operator|=
name|backoffMultiplier
expr_stmt|;
block|}
DECL|method|getBackoffIdleThreshold ()
specifier|public
name|int
name|getBackoffIdleThreshold
parameter_list|()
block|{
return|return
name|backoffIdleThreshold
return|;
block|}
comment|/**      * The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.      */
DECL|method|setBackoffIdleThreshold (int backoffIdleThreshold)
specifier|public
name|void
name|setBackoffIdleThreshold
parameter_list|(
name|int
name|backoffIdleThreshold
parameter_list|)
block|{
name|this
operator|.
name|backoffIdleThreshold
operator|=
name|backoffIdleThreshold
expr_stmt|;
block|}
DECL|method|getBackoffErrorThreshold ()
specifier|public
name|int
name|getBackoffErrorThreshold
parameter_list|()
block|{
return|return
name|backoffErrorThreshold
return|;
block|}
comment|/**      * The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.      */
DECL|method|setBackoffErrorThreshold (int backoffErrorThreshold)
specifier|public
name|void
name|setBackoffErrorThreshold
parameter_list|(
name|int
name|backoffErrorThreshold
parameter_list|)
block|{
name|this
operator|.
name|backoffErrorThreshold
operator|=
name|backoffErrorThreshold
expr_stmt|;
block|}
block|}
end_class

end_unit

