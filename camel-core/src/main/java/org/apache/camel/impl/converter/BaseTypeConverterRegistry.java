begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.impl.converter
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|impl
operator|.
name|converter
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|LongAdder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|StampedLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContextAware
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelExecutionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|LoggingLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|NoFactoryAvailableException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|NoTypeConversionAvailableException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|RuntimeCamelException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|TypeConversionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|TypeConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|TypeConverterExists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|TypeConverterExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|TypeConverterLoaderException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|TypeConverters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|CamelLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|FactoryFinder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|Injector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|PackageScanClassResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|TypeConverterAware
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|TypeConverterLoader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|TypeConverterRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|MessageHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|ServiceSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|TypeConverterSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ObjectHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|function
operator|.
name|TriConsumer
import|;
end_import

begin_comment
comment|/**  * Base implementation of a type converter registry used for  *<a href="http://camel.apache.org/type-converter.html">type converters</a> in Camel.  */
end_comment

begin_class
DECL|class|BaseTypeConverterRegistry
specifier|public
specifier|abstract
class|class
name|BaseTypeConverterRegistry
extends|extends
name|ServiceSupport
implements|implements
name|TypeConverter
implements|,
name|TypeConverterRegistry
implements|,
name|CamelContextAware
block|{
DECL|field|MISS_CONVERTER
specifier|protected
specifier|static
specifier|final
name|TypeConverter
name|MISS_CONVERTER
init|=
operator|new
name|TypeConverterSupport
argument_list|()
block|{
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|convertTo
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|Exchange
name|exchange
parameter_list|,
name|Object
name|value
parameter_list|)
throws|throws
name|TypeConversionException
block|{
return|return
operator|(
name|T
operator|)
name|MISS_VALUE
return|;
block|}
block|}
decl_stmt|;
DECL|field|typeMappings
specifier|protected
specifier|final
name|DoubleMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|TypeConverter
argument_list|>
name|typeMappings
init|=
operator|new
name|DoubleMap
argument_list|<>
argument_list|(
literal|200
argument_list|)
decl_stmt|;
DECL|field|typeConverterLoaders
specifier|protected
specifier|final
name|List
argument_list|<
name|TypeConverterLoader
argument_list|>
name|typeConverterLoaders
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|fallbackConverters
specifier|protected
specifier|final
name|List
argument_list|<
name|FallbackTypeConverter
argument_list|>
name|fallbackConverters
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|resolver
specifier|protected
specifier|final
name|PackageScanClassResolver
name|resolver
decl_stmt|;
DECL|field|camelContext
specifier|protected
name|CamelContext
name|camelContext
decl_stmt|;
DECL|field|injector
specifier|protected
name|Injector
name|injector
decl_stmt|;
DECL|field|factoryFinder
specifier|protected
specifier|final
name|FactoryFinder
name|factoryFinder
decl_stmt|;
DECL|field|typeConverterExists
specifier|protected
name|TypeConverterExists
name|typeConverterExists
init|=
name|TypeConverterExists
operator|.
name|Override
decl_stmt|;
DECL|field|typeConverterExistsLoggingLevel
specifier|protected
name|LoggingLevel
name|typeConverterExistsLoggingLevel
init|=
name|LoggingLevel
operator|.
name|WARN
decl_stmt|;
DECL|field|statistics
specifier|protected
specifier|final
name|Statistics
name|statistics
init|=
operator|new
name|UtilizationStatistics
argument_list|()
decl_stmt|;
DECL|field|noopCounter
specifier|protected
specifier|final
name|LongAdder
name|noopCounter
init|=
operator|new
name|LongAdder
argument_list|()
decl_stmt|;
DECL|field|attemptCounter
specifier|protected
specifier|final
name|LongAdder
name|attemptCounter
init|=
operator|new
name|LongAdder
argument_list|()
decl_stmt|;
DECL|field|missCounter
specifier|protected
specifier|final
name|LongAdder
name|missCounter
init|=
operator|new
name|LongAdder
argument_list|()
decl_stmt|;
DECL|field|baseHitCounter
specifier|protected
specifier|final
name|LongAdder
name|baseHitCounter
init|=
operator|new
name|LongAdder
argument_list|()
decl_stmt|;
DECL|field|hitCounter
specifier|protected
specifier|final
name|LongAdder
name|hitCounter
init|=
operator|new
name|LongAdder
argument_list|()
decl_stmt|;
DECL|field|failedCounter
specifier|protected
specifier|final
name|LongAdder
name|failedCounter
init|=
operator|new
name|LongAdder
argument_list|()
decl_stmt|;
DECL|method|BaseTypeConverterRegistry (PackageScanClassResolver resolver, Injector injector, FactoryFinder factoryFinder)
specifier|public
name|BaseTypeConverterRegistry
parameter_list|(
name|PackageScanClassResolver
name|resolver
parameter_list|,
name|Injector
name|injector
parameter_list|,
name|FactoryFinder
name|factoryFinder
parameter_list|)
block|{
name|this
operator|.
name|resolver
operator|=
name|resolver
expr_stmt|;
name|this
operator|.
name|injector
operator|=
name|injector
expr_stmt|;
name|this
operator|.
name|factoryFinder
operator|=
name|factoryFinder
expr_stmt|;
name|this
operator|.
name|typeConverterLoaders
operator|.
name|add
argument_list|(
operator|new
name|AnnotationTypeConverterLoader
argument_list|(
name|resolver
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|FallbackTypeConverter
argument_list|>
name|fallbacks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// add to string first as it will then be last in the last as to string can nearly
comment|// always convert something to a string so we want it only as the last resort
comment|// ToStringTypeConverter should NOT allow to be promoted
name|addCoreFallbackTypeConverterToList
argument_list|(
operator|new
name|ToStringTypeConverter
argument_list|()
argument_list|,
literal|false
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
comment|// enum is okay to be promoted
name|addCoreFallbackTypeConverterToList
argument_list|(
operator|new
name|EnumTypeConverter
argument_list|()
argument_list|,
literal|true
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
comment|// arrays is okay to be promoted
name|addCoreFallbackTypeConverterToList
argument_list|(
operator|new
name|ArrayTypeConverter
argument_list|()
argument_list|,
literal|true
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
comment|// and future should also not allowed to be promoted
name|addCoreFallbackTypeConverterToList
argument_list|(
operator|new
name|FutureTypeConverter
argument_list|(
name|this
argument_list|)
argument_list|,
literal|false
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
comment|// add sync processor to async processor converter is to be promoted
name|addCoreFallbackTypeConverterToList
argument_list|(
operator|new
name|AsyncProcessorTypeConverter
argument_list|()
argument_list|,
literal|true
argument_list|,
name|fallbacks
argument_list|)
expr_stmt|;
comment|// add all core fallback converters at once which is faster (profiler)
name|fallbackConverters
operator|.
name|addAll
argument_list|(
name|fallbacks
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getCamelContext ()
specifier|public
name|CamelContext
name|getCamelContext
parameter_list|()
block|{
return|return
name|camelContext
return|;
block|}
annotation|@
name|Override
DECL|method|setCamelContext (CamelContext camelContext)
specifier|public
name|void
name|setCamelContext
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|)
block|{
name|this
operator|.
name|camelContext
operator|=
name|camelContext
expr_stmt|;
block|}
DECL|method|getTypeConverterLoaders ()
specifier|public
name|List
argument_list|<
name|TypeConverterLoader
argument_list|>
name|getTypeConverterLoaders
parameter_list|()
block|{
return|return
name|typeConverterLoaders
return|;
block|}
annotation|@
name|Override
DECL|method|convertTo (Class<T> type, Object value)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|convertTo
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
name|convertTo
argument_list|(
name|type
argument_list|,
literal|null
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|convertTo (Class<T> type, Exchange exchange, Object value)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|convertTo
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|Exchange
name|exchange
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
operator|(
name|T
operator|)
name|doConvertTo
argument_list|(
name|type
argument_list|,
name|exchange
argument_list|,
name|value
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|mandatoryConvertTo (Class<T> type, Object value)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|mandatoryConvertTo
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|Object
name|value
parameter_list|)
throws|throws
name|NoTypeConversionAvailableException
block|{
return|return
name|mandatoryConvertTo
argument_list|(
name|type
argument_list|,
literal|null
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|mandatoryConvertTo (Class<T> type, Exchange exchange, Object value)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|mandatoryConvertTo
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|Exchange
name|exchange
parameter_list|,
name|Object
name|value
parameter_list|)
throws|throws
name|NoTypeConversionAvailableException
block|{
name|Object
name|answer
init|=
name|doConvertTo
argument_list|(
name|type
argument_list|,
name|exchange
argument_list|,
name|value
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
comment|// Could not find suitable conversion
throw|throw
operator|new
name|NoTypeConversionAvailableException
argument_list|(
name|value
argument_list|,
name|type
argument_list|)
throw|;
block|}
return|return
operator|(
name|T
operator|)
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|tryConvertTo (Class<T> type, Object value)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|tryConvertTo
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
name|tryConvertTo
argument_list|(
name|type
argument_list|,
literal|null
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|tryConvertTo (Class<T> type, Exchange exchange, Object value)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|tryConvertTo
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|Exchange
name|exchange
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
operator|(
name|T
operator|)
name|doConvertTo
argument_list|(
name|type
argument_list|,
name|exchange
argument_list|,
name|value
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|doConvertTo (final Class<?> type, final Exchange exchange, final Object value, final boolean mandatory, final boolean tryConvert)
specifier|protected
name|Object
name|doConvertTo
parameter_list|(
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|type
parameter_list|,
specifier|final
name|Exchange
name|exchange
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|,
specifier|final
name|boolean
name|mandatory
parameter_list|,
specifier|final
name|boolean
name|tryConvert
parameter_list|)
block|{
name|Object
name|answer
decl_stmt|;
try|try
block|{
name|answer
operator|=
name|doConvertTo
argument_list|(
name|type
argument_list|,
name|exchange
argument_list|,
name|value
argument_list|,
name|tryConvert
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|statistics
operator|.
name|isStatisticsEnabled
argument_list|()
condition|)
block|{
name|failedCounter
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tryConvert
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// if its a ExecutionException then we have rethrow it as its not due to failed conversion
comment|// this is special for FutureTypeConverter
name|boolean
name|execution
init|=
name|ObjectHelper
operator|.
name|getException
argument_list|(
name|ExecutionException
operator|.
name|class
argument_list|,
name|e
argument_list|)
operator|!=
literal|null
operator|||
name|ObjectHelper
operator|.
name|getException
argument_list|(
name|CamelExecutionException
operator|.
name|class
argument_list|,
name|e
argument_list|)
operator|!=
literal|null
decl_stmt|;
if|if
condition|(
name|execution
condition|)
block|{
throw|throw
name|CamelExecutionException
operator|.
name|wrapCamelExecutionException
argument_list|(
name|exchange
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// error occurred during type conversion
throw|throw
name|createTypeConversionException
argument_list|(
name|exchange
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|answer
operator|==
name|MISS_VALUE
condition|)
block|{
comment|// Could not find suitable conversion
if|if
condition|(
name|statistics
operator|.
name|isStatisticsEnabled
argument_list|()
condition|)
block|{
name|missCounter
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
else|else
block|{
if|if
condition|(
name|statistics
operator|.
name|isStatisticsEnabled
argument_list|()
condition|)
block|{
name|hitCounter
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
block|}
DECL|method|doConvertTo (final Class<?> type, final Exchange exchange, final Object value, final boolean tryConvert)
specifier|protected
name|Object
name|doConvertTo
parameter_list|(
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|type
parameter_list|,
specifier|final
name|Exchange
name|exchange
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|,
specifier|final
name|boolean
name|tryConvert
parameter_list|)
throws|throws
name|Exception
block|{
name|boolean
name|trace
init|=
name|log
operator|.
name|isTraceEnabled
argument_list|()
decl_stmt|;
name|boolean
name|statisticsEnabled
init|=
name|statistics
operator|.
name|isStatisticsEnabled
argument_list|()
decl_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Finding type converter to convert {} -> {} with value: {}"
argument_list|,
name|value
operator|==
literal|null
condition|?
literal|"null"
else|:
name|value
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
argument_list|,
name|type
operator|.
name|getCanonicalName
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
comment|// no type conversion was needed
if|if
condition|(
name|statisticsEnabled
condition|)
block|{
name|noopCounter
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
comment|// lets avoid NullPointerException when converting to primitives for null values
if|if
condition|(
name|type
operator|.
name|isPrimitive
argument_list|()
condition|)
block|{
if|if
condition|(
name|boolean
operator|.
name|class
operator|==
name|type
condition|)
block|{
return|return
name|Boolean
operator|.
name|FALSE
return|;
block|}
if|if
condition|(
name|int
operator|.
name|class
operator|==
name|type
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|long
operator|.
name|class
operator|==
name|type
condition|)
block|{
return|return
literal|0L
return|;
block|}
if|if
condition|(
name|byte
operator|.
name|class
operator|==
name|type
condition|)
block|{
return|return
operator|(
name|byte
operator|)
literal|0
return|;
block|}
if|if
condition|(
name|short
operator|.
name|class
operator|==
name|type
condition|)
block|{
return|return
operator|(
name|short
operator|)
literal|0
return|;
block|}
if|if
condition|(
name|double
operator|.
name|class
operator|==
name|type
condition|)
block|{
return|return
literal|0.0
return|;
block|}
if|if
condition|(
name|float
operator|.
name|class
operator|==
name|type
condition|)
block|{
return|return
literal|0.0f
return|;
block|}
if|if
condition|(
name|char
operator|.
name|class
operator|==
name|type
condition|)
block|{
return|return
literal|'\0'
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|// same instance type
if|if
condition|(
name|type
operator|.
name|isInstance
argument_list|(
name|value
argument_list|)
condition|)
block|{
comment|// no type conversion was needed
if|if
condition|(
name|statisticsEnabled
condition|)
block|{
name|noopCounter
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
comment|// okay we need to attempt to convert
if|if
condition|(
name|statisticsEnabled
condition|)
block|{
name|attemptCounter
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
comment|// try to find a suitable type converter
name|TypeConverter
name|converter
init|=
name|getOrFindTypeConverter
argument_list|(
name|type
argument_list|,
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|converter
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|trace
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Using converter: {} to convert [{}=>{}]"
argument_list|,
name|converter
argument_list|,
name|value
operator|.
name|getClass
argument_list|()
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|Object
name|rc
decl_stmt|;
if|if
condition|(
name|tryConvert
condition|)
block|{
name|rc
operator|=
name|converter
operator|.
name|tryConvertTo
argument_list|(
name|type
argument_list|,
name|exchange
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|converter
operator|.
name|convertTo
argument_list|(
name|type
argument_list|,
name|exchange
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|null
condition|)
block|{
return|return
name|rc
return|;
block|}
elseif|else
if|if
condition|(
name|converter
operator|.
name|allowNull
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|// not found with that type then if it was a primitive type then try again with the wrapper type
if|if
condition|(
name|type
operator|.
name|isPrimitive
argument_list|()
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|primitiveType
init|=
name|ObjectHelper
operator|.
name|convertPrimitiveTypeToWrapperType
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|primitiveType
operator|!=
name|type
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|fromType
init|=
name|value
operator|.
name|getClass
argument_list|()
decl_stmt|;
name|TypeConverter
name|tc
init|=
name|getOrFindTypeConverter
argument_list|(
name|primitiveType
argument_list|,
name|fromType
argument_list|)
decl_stmt|;
if|if
condition|(
name|tc
operator|!=
literal|null
condition|)
block|{
comment|// add the type as a known type converter as we can convert from primitive to object converter
name|addTypeConverter
argument_list|(
name|type
argument_list|,
name|fromType
argument_list|,
name|tc
argument_list|)
expr_stmt|;
name|Object
name|rc
decl_stmt|;
if|if
condition|(
name|tryConvert
condition|)
block|{
name|rc
operator|=
name|tc
operator|.
name|tryConvertTo
argument_list|(
name|primitiveType
argument_list|,
name|exchange
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|tc
operator|.
name|convertTo
argument_list|(
name|primitiveType
argument_list|,
name|exchange
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|==
literal|null
operator|&&
name|tc
operator|.
name|allowNull
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|!=
literal|null
condition|)
block|{
return|return
name|rc
return|;
block|}
block|}
block|}
block|}
comment|// fallback converters
for|for
control|(
name|FallbackTypeConverter
name|fallback
range|:
name|fallbackConverters
control|)
block|{
name|TypeConverter
name|tc
init|=
name|fallback
operator|.
name|getFallbackTypeConverter
argument_list|()
decl_stmt|;
name|Object
name|rc
decl_stmt|;
if|if
condition|(
name|tryConvert
condition|)
block|{
name|rc
operator|=
name|tc
operator|.
name|tryConvertTo
argument_list|(
name|type
argument_list|,
name|exchange
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|tc
operator|.
name|convertTo
argument_list|(
name|type
argument_list|,
name|exchange
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|==
literal|null
operator|&&
name|tc
operator|.
name|allowNull
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|rc
operator|==
name|MISS_VALUE
condition|)
block|{
comment|// it cannot be converted so give up
return|return
name|MISS_VALUE
return|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|null
condition|)
block|{
comment|// if fallback can promote then let it be promoted to a first class type converter
if|if
condition|(
name|fallback
operator|.
name|isCanPromote
argument_list|()
condition|)
block|{
comment|// add it as a known type converter since we found a fallback that could do it
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Promoting fallback type converter as a known type converter to convert from: {} to: {} for the fallback converter: {}"
argument_list|,
name|type
operator|.
name|getCanonicalName
argument_list|()
argument_list|,
name|value
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
argument_list|,
name|fallback
operator|.
name|getFallbackTypeConverter
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|addTypeConverter
argument_list|(
name|type
argument_list|,
name|value
operator|.
name|getClass
argument_list|()
argument_list|,
name|fallback
operator|.
name|getFallbackTypeConverter
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Fallback type converter {} converted type from: {} to: {}"
argument_list|,
name|fallback
operator|.
name|getFallbackTypeConverter
argument_list|()
argument_list|,
name|type
operator|.
name|getCanonicalName
argument_list|()
argument_list|,
name|value
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// return converted value
return|return
name|rc
return|;
block|}
block|}
if|if
condition|(
operator|!
name|tryConvert
condition|)
block|{
comment|// Could not find suitable conversion, so remember it
comment|// do not register misses for try conversions
name|typeMappings
operator|.
name|put
argument_list|(
name|type
argument_list|,
name|value
operator|.
name|getClass
argument_list|()
argument_list|,
name|MISS_CONVERTER
argument_list|)
expr_stmt|;
block|}
comment|// Could not find suitable conversion, so return Void to indicate not found
return|return
name|MISS_VALUE
return|;
block|}
annotation|@
name|Override
DECL|method|addTypeConverter (Class<?> toType, Class<?> fromType, TypeConverter typeConverter)
specifier|public
name|void
name|addTypeConverter
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|toType
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|fromType
parameter_list|,
name|TypeConverter
name|typeConverter
parameter_list|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Adding type converter: {}"
argument_list|,
name|typeConverter
argument_list|)
expr_stmt|;
name|TypeConverter
name|converter
init|=
name|typeMappings
operator|.
name|get
argument_list|(
name|toType
argument_list|,
name|fromType
argument_list|)
decl_stmt|;
comment|// only override it if its different
comment|// as race conditions can lead to many threads trying to promote the same fallback converter
if|if
condition|(
name|typeConverter
operator|!=
name|converter
condition|)
block|{
comment|// add the converter unless we should ignore
name|boolean
name|add
init|=
literal|true
decl_stmt|;
comment|// if converter is not null then a duplicate exists
if|if
condition|(
name|converter
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|typeConverterExists
operator|==
name|TypeConverterExists
operator|.
name|Override
condition|)
block|{
name|CamelLogger
name|logger
init|=
operator|new
name|CamelLogger
argument_list|(
name|log
argument_list|,
name|typeConverterExistsLoggingLevel
argument_list|)
decl_stmt|;
name|logger
operator|.
name|log
argument_list|(
literal|"Overriding type converter from: "
operator|+
name|converter
operator|+
literal|" to: "
operator|+
name|typeConverter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typeConverterExists
operator|==
name|TypeConverterExists
operator|.
name|Ignore
condition|)
block|{
name|CamelLogger
name|logger
init|=
operator|new
name|CamelLogger
argument_list|(
name|log
argument_list|,
name|typeConverterExistsLoggingLevel
argument_list|)
decl_stmt|;
name|logger
operator|.
name|log
argument_list|(
literal|"Ignoring duplicate type converter from: "
operator|+
name|converter
operator|+
literal|" to: "
operator|+
name|typeConverter
argument_list|)
expr_stmt|;
name|add
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|// we should fail
throw|throw
operator|new
name|TypeConverterExistsException
argument_list|(
name|toType
argument_list|,
name|fromType
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|add
condition|)
block|{
name|typeMappings
operator|.
name|put
argument_list|(
name|toType
argument_list|,
name|fromType
argument_list|,
name|typeConverter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|addTypeConverters (TypeConverters typeConverters)
specifier|public
name|void
name|addTypeConverters
parameter_list|(
name|TypeConverters
name|typeConverters
parameter_list|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Adding type converters: {}"
argument_list|,
name|typeConverters
argument_list|)
expr_stmt|;
try|try
block|{
comment|// scan the class for @Converter and load them into this registry
name|TypeConvertersLoader
name|loader
init|=
operator|new
name|TypeConvertersLoader
argument_list|(
name|typeConverters
argument_list|)
decl_stmt|;
name|loader
operator|.
name|load
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TypeConverterLoaderException
name|e
parameter_list|)
block|{
throw|throw
name|RuntimeCamelException
operator|.
name|wrapRuntimeCamelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|removeTypeConverter (Class<?> toType, Class<?> fromType)
specifier|public
name|boolean
name|removeTypeConverter
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|toType
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|fromType
parameter_list|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Removing type converter from: {} to: {}"
argument_list|,
name|fromType
argument_list|,
name|toType
argument_list|)
expr_stmt|;
return|return
name|typeMappings
operator|.
name|remove
argument_list|(
name|toType
argument_list|,
name|fromType
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|addFallbackTypeConverter (TypeConverter typeConverter, boolean canPromote)
specifier|public
name|void
name|addFallbackTypeConverter
parameter_list|(
name|TypeConverter
name|typeConverter
parameter_list|,
name|boolean
name|canPromote
parameter_list|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Adding fallback type converter: {} which can promote: {}"
argument_list|,
name|typeConverter
argument_list|,
name|canPromote
argument_list|)
expr_stmt|;
comment|// add in top of fallback as the toString() fallback will nearly always be able to convert
comment|// the last one which is add to the FallbackTypeConverter will be called at the first place
name|fallbackConverters
operator|.
name|add
argument_list|(
literal|0
argument_list|,
operator|new
name|FallbackTypeConverter
argument_list|(
name|typeConverter
argument_list|,
name|canPromote
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|typeConverter
operator|instanceof
name|TypeConverterAware
condition|)
block|{
name|TypeConverterAware
name|typeConverterAware
init|=
operator|(
name|TypeConverterAware
operator|)
name|typeConverter
decl_stmt|;
name|typeConverterAware
operator|.
name|setTypeConverter
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typeConverter
operator|instanceof
name|CamelContextAware
condition|)
block|{
name|CamelContextAware
name|camelContextAware
init|=
operator|(
name|CamelContextAware
operator|)
name|typeConverter
decl_stmt|;
if|if
condition|(
name|camelContext
operator|!=
literal|null
condition|)
block|{
name|camelContextAware
operator|.
name|setCamelContext
argument_list|(
name|camelContext
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|addCoreFallbackTypeConverterToList (TypeConverter typeConverter, boolean canPromote, List<FallbackTypeConverter> converters)
specifier|private
name|void
name|addCoreFallbackTypeConverterToList
parameter_list|(
name|TypeConverter
name|typeConverter
parameter_list|,
name|boolean
name|canPromote
parameter_list|,
name|List
argument_list|<
name|FallbackTypeConverter
argument_list|>
name|converters
parameter_list|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Adding core fallback type converter: {} which can promote: {}"
argument_list|,
name|typeConverter
argument_list|,
name|canPromote
argument_list|)
expr_stmt|;
comment|// add in top of fallback as the toString() fallback will nearly always be able to convert
comment|// the last one which is add to the FallbackTypeConverter will be called at the first place
name|converters
operator|.
name|add
argument_list|(
literal|0
argument_list|,
operator|new
name|FallbackTypeConverter
argument_list|(
name|typeConverter
argument_list|,
name|canPromote
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|typeConverter
operator|instanceof
name|TypeConverterAware
condition|)
block|{
name|TypeConverterAware
name|typeConverterAware
init|=
operator|(
name|TypeConverterAware
operator|)
name|typeConverter
decl_stmt|;
name|typeConverterAware
operator|.
name|setTypeConverter
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typeConverter
operator|instanceof
name|CamelContextAware
condition|)
block|{
name|CamelContextAware
name|camelContextAware
init|=
operator|(
name|CamelContextAware
operator|)
name|typeConverter
decl_stmt|;
if|if
condition|(
name|camelContext
operator|!=
literal|null
condition|)
block|{
name|camelContextAware
operator|.
name|setCamelContext
argument_list|(
name|camelContext
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getTypeConverter (Class<?> toType, Class<?> fromType)
specifier|public
name|TypeConverter
name|getTypeConverter
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|toType
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|fromType
parameter_list|)
block|{
return|return
name|typeMappings
operator|.
name|get
argument_list|(
name|toType
argument_list|,
name|fromType
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getInjector ()
specifier|public
name|Injector
name|getInjector
parameter_list|()
block|{
return|return
name|injector
return|;
block|}
annotation|@
name|Override
DECL|method|setInjector (Injector injector)
specifier|public
name|void
name|setInjector
parameter_list|(
name|Injector
name|injector
parameter_list|)
block|{
name|this
operator|.
name|injector
operator|=
name|injector
expr_stmt|;
block|}
DECL|method|getOrFindTypeConverter (Class<?> toType, Class<?> fromType)
specifier|protected
parameter_list|<
name|T
parameter_list|>
name|TypeConverter
name|getOrFindTypeConverter
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|toType
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|fromType
parameter_list|)
block|{
name|TypeConverter
name|converter
init|=
name|typeMappings
operator|.
name|get
argument_list|(
name|toType
argument_list|,
name|fromType
argument_list|)
decl_stmt|;
if|if
condition|(
name|converter
operator|==
literal|null
condition|)
block|{
comment|// converter not found, try to lookup then
name|converter
operator|=
name|lookup
argument_list|(
name|toType
argument_list|,
name|fromType
argument_list|)
expr_stmt|;
if|if
condition|(
name|converter
operator|!=
literal|null
condition|)
block|{
name|typeMappings
operator|.
name|put
argument_list|(
name|toType
argument_list|,
name|fromType
argument_list|,
name|converter
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|converter
return|;
block|}
annotation|@
name|Override
DECL|method|lookup (Class<?> toType, Class<?> fromType)
specifier|public
name|TypeConverter
name|lookup
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|toType
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|fromType
parameter_list|)
block|{
return|return
name|doLookup
argument_list|(
name|toType
argument_list|,
name|fromType
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|doLookup (Class<?> toType, Class<?> fromType, boolean isSuper)
specifier|protected
name|TypeConverter
name|doLookup
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|toType
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|fromType
parameter_list|,
name|boolean
name|isSuper
parameter_list|)
block|{
if|if
condition|(
name|fromType
operator|!=
literal|null
condition|)
block|{
comment|// lets try if there is a direct match
name|TypeConverter
name|converter
init|=
name|getTypeConverter
argument_list|(
name|toType
argument_list|,
name|fromType
argument_list|)
decl_stmt|;
if|if
condition|(
name|converter
operator|!=
literal|null
condition|)
block|{
return|return
name|converter
return|;
block|}
comment|// try the interfaces
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|type
range|:
name|fromType
operator|.
name|getInterfaces
argument_list|()
control|)
block|{
name|converter
operator|=
name|getTypeConverter
argument_list|(
name|toType
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|converter
operator|!=
literal|null
condition|)
block|{
return|return
name|converter
return|;
block|}
block|}
comment|// try super then
name|Class
argument_list|<
name|?
argument_list|>
name|fromSuperClass
init|=
name|fromType
operator|.
name|getSuperclass
argument_list|()
decl_stmt|;
if|if
condition|(
name|fromSuperClass
operator|!=
literal|null
operator|&&
operator|!
name|fromSuperClass
operator|.
name|equals
argument_list|(
name|Object
operator|.
name|class
argument_list|)
condition|)
block|{
name|converter
operator|=
name|doLookup
argument_list|(
name|toType
argument_list|,
name|fromSuperClass
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|converter
operator|!=
literal|null
condition|)
block|{
return|return
name|converter
return|;
block|}
block|}
block|}
comment|// only do these tests as fallback and only on the target type (eg not on its super)
if|if
condition|(
operator|!
name|isSuper
condition|)
block|{
if|if
condition|(
name|fromType
operator|!=
literal|null
operator|&&
operator|!
name|fromType
operator|.
name|equals
argument_list|(
name|Object
operator|.
name|class
argument_list|)
condition|)
block|{
comment|// lets try classes derived from this toType
name|TypeConverter
name|converter
init|=
name|typeMappings
operator|.
name|getFirst
argument_list|(
name|to
lambda|->
name|toType
operator|.
name|isAssignableFrom
argument_list|(
name|to
argument_list|)
argument_list|,
comment|// skip Object based we do them last
name|from
lambda|->
operator|!
name|from
operator|.
name|equals
argument_list|(
name|Object
operator|.
name|class
argument_list|)
operator|&&
name|from
operator|.
name|isAssignableFrom
argument_list|(
name|fromType
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|converter
operator|!=
literal|null
condition|)
block|{
return|return
name|converter
return|;
block|}
comment|// lets test for Object based converters as last resort
name|converter
operator|=
name|getTypeConverter
argument_list|(
name|toType
argument_list|,
name|Object
operator|.
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|converter
operator|!=
literal|null
condition|)
block|{
return|return
name|converter
return|;
block|}
block|}
block|}
comment|// none found
return|return
literal|null
return|;
block|}
DECL|method|listAllTypeConvertersFromTo ()
specifier|public
name|List
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
index|[]
argument_list|>
name|listAllTypeConvertersFromTo
parameter_list|()
block|{
name|List
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
index|[]
argument_list|>
name|answer
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|typeMappings
operator|.
name|forEach
argument_list|(
parameter_list|(
name|k1
parameter_list|,
name|k2
parameter_list|,
name|v
parameter_list|)
lambda|->
name|answer
operator|.
name|add
argument_list|(
operator|new
name|Class
argument_list|<
name|?
argument_list|>
index|[]
block|{
name|k2
block|,
name|k1
block|}
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
comment|/**      * Loads the core type converters which is mandatory to use Camel      */
DECL|method|loadCoreTypeConverters ()
specifier|public
name|void
name|loadCoreTypeConverters
parameter_list|()
throws|throws
name|Exception
block|{
comment|// load all the type converters from camel-core
name|CoreStaticTypeConverterLoader
name|core
init|=
operator|new
name|CoreStaticTypeConverterLoader
argument_list|()
decl_stmt|;
name|core
operator|.
name|load
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**      * Checks if the registry is loaded and if not lazily load it      */
DECL|method|loadTypeConverters ()
specifier|protected
name|void
name|loadTypeConverters
parameter_list|()
throws|throws
name|Exception
block|{
for|for
control|(
name|TypeConverterLoader
name|typeConverterLoader
range|:
name|getTypeConverterLoaders
argument_list|()
control|)
block|{
name|typeConverterLoader
operator|.
name|load
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|// lets try load any other fallback converters
try|try
block|{
name|loadFallbackTypeConverters
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoFactoryAvailableException
name|e
parameter_list|)
block|{
comment|// ignore its fine to have none
block|}
block|}
DECL|method|loadFallbackTypeConverters ()
specifier|protected
name|void
name|loadFallbackTypeConverters
parameter_list|()
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|List
argument_list|<
name|TypeConverter
argument_list|>
name|converters
init|=
name|factoryFinder
operator|.
name|newInstances
argument_list|(
literal|"FallbackTypeConverter"
argument_list|,
name|getInjector
argument_list|()
argument_list|,
name|TypeConverter
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|TypeConverter
name|converter
range|:
name|converters
control|)
block|{
name|addFallbackTypeConverter
argument_list|(
name|converter
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|createTypeConversionException (Exchange exchange, Class<?> type, Object value, Throwable cause)
specifier|protected
name|TypeConversionException
name|createTypeConversionException
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|type
parameter_list|,
name|Object
name|value
parameter_list|,
name|Throwable
name|cause
parameter_list|)
block|{
if|if
condition|(
name|cause
operator|instanceof
name|TypeConversionException
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|TypeConversionException
operator|)
name|cause
operator|)
operator|.
name|getToType
argument_list|()
operator|==
name|type
condition|)
block|{
return|return
operator|(
name|TypeConversionException
operator|)
name|cause
return|;
block|}
block|}
name|Object
name|body
decl_stmt|;
comment|// extract the body for logging which allows to limit the message body in the exception/stacktrace
comment|// and also can be used to turn off logging sensitive message data
if|if
condition|(
name|exchange
operator|!=
literal|null
condition|)
block|{
name|body
operator|=
name|MessageHelper
operator|.
name|extractValueForLogging
argument_list|(
name|value
argument_list|,
name|exchange
operator|.
name|getIn
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|body
operator|=
name|value
expr_stmt|;
block|}
return|return
operator|new
name|TypeConversionException
argument_list|(
name|body
argument_list|,
name|type
argument_list|,
name|cause
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getStatistics ()
specifier|public
name|Statistics
name|getStatistics
parameter_list|()
block|{
return|return
name|statistics
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|typeMappings
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|getTypeConverterExistsLoggingLevel ()
specifier|public
name|LoggingLevel
name|getTypeConverterExistsLoggingLevel
parameter_list|()
block|{
return|return
name|typeConverterExistsLoggingLevel
return|;
block|}
DECL|method|setTypeConverterExistsLoggingLevel (LoggingLevel typeConverterExistsLoggingLevel)
specifier|public
name|void
name|setTypeConverterExistsLoggingLevel
parameter_list|(
name|LoggingLevel
name|typeConverterExistsLoggingLevel
parameter_list|)
block|{
name|this
operator|.
name|typeConverterExistsLoggingLevel
operator|=
name|typeConverterExistsLoggingLevel
expr_stmt|;
block|}
DECL|method|getTypeConverterExists ()
specifier|public
name|TypeConverterExists
name|getTypeConverterExists
parameter_list|()
block|{
return|return
name|typeConverterExists
return|;
block|}
DECL|method|setTypeConverterExists (TypeConverterExists typeConverterExists)
specifier|public
name|void
name|setTypeConverterExists
parameter_list|(
name|TypeConverterExists
name|typeConverterExists
parameter_list|)
block|{
name|this
operator|.
name|typeConverterExists
operator|=
name|typeConverterExists
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStart ()
specifier|protected
name|void
name|doStart
parameter_list|()
throws|throws
name|Exception
block|{
comment|// noop
block|}
annotation|@
name|Override
DECL|method|doStop ()
specifier|protected
name|void
name|doStop
parameter_list|()
throws|throws
name|Exception
block|{
comment|// log utilization statistics when stopping, including mappings
if|if
condition|(
name|statistics
operator|.
name|isStatisticsEnabled
argument_list|()
condition|)
block|{
name|String
name|info
init|=
name|statistics
operator|.
name|toString
argument_list|()
decl_stmt|;
name|AtomicInteger
name|misses
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
name|typeMappings
operator|.
name|forEach
argument_list|(
parameter_list|(
name|k1
parameter_list|,
name|k2
parameter_list|,
name|v
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|v
operator|==
name|MISS_CONVERTER
condition|)
block|{
name|misses
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|info
operator|+=
name|String
operator|.
name|format
argument_list|(
literal|" mappings[total=%s, misses=%s]"
argument_list|,
name|typeMappings
operator|.
name|size
argument_list|()
argument_list|,
name|misses
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|typeMappings
operator|.
name|clear
argument_list|()
expr_stmt|;
name|statistics
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
comment|/**      * Represents utilization statistics      */
DECL|class|UtilizationStatistics
specifier|private
specifier|final
class|class
name|UtilizationStatistics
implements|implements
name|Statistics
block|{
DECL|field|statisticsEnabled
specifier|private
name|boolean
name|statisticsEnabled
decl_stmt|;
annotation|@
name|Override
DECL|method|getNoopCounter ()
specifier|public
name|long
name|getNoopCounter
parameter_list|()
block|{
return|return
name|noopCounter
operator|.
name|longValue
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getAttemptCounter ()
specifier|public
name|long
name|getAttemptCounter
parameter_list|()
block|{
return|return
name|attemptCounter
operator|.
name|longValue
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getHitCounter ()
specifier|public
name|long
name|getHitCounter
parameter_list|()
block|{
return|return
name|hitCounter
operator|.
name|longValue
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getBaseHitCounter ()
specifier|public
name|long
name|getBaseHitCounter
parameter_list|()
block|{
return|return
name|baseHitCounter
operator|.
name|longValue
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getMissCounter ()
specifier|public
name|long
name|getMissCounter
parameter_list|()
block|{
return|return
name|missCounter
operator|.
name|longValue
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getFailedCounter ()
specifier|public
name|long
name|getFailedCounter
parameter_list|()
block|{
return|return
name|failedCounter
operator|.
name|longValue
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|reset ()
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|noopCounter
operator|.
name|reset
argument_list|()
expr_stmt|;
name|attemptCounter
operator|.
name|reset
argument_list|()
expr_stmt|;
name|hitCounter
operator|.
name|reset
argument_list|()
expr_stmt|;
name|baseHitCounter
operator|.
name|reset
argument_list|()
expr_stmt|;
name|missCounter
operator|.
name|reset
argument_list|()
expr_stmt|;
name|failedCounter
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isStatisticsEnabled ()
specifier|public
name|boolean
name|isStatisticsEnabled
parameter_list|()
block|{
return|return
name|statisticsEnabled
return|;
block|}
annotation|@
name|Override
DECL|method|setStatisticsEnabled (boolean statisticsEnabled)
specifier|public
name|void
name|setStatisticsEnabled
parameter_list|(
name|boolean
name|statisticsEnabled
parameter_list|)
block|{
name|this
operator|.
name|statisticsEnabled
operator|=
name|statisticsEnabled
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"TypeConverterRegistry utilization[noop=%s, attempts=%s, hits=%s, baseHits=%s, misses=%s, failures=%s]"
argument_list|,
name|getNoopCounter
argument_list|()
argument_list|,
name|getAttemptCounter
argument_list|()
argument_list|,
name|getHitCounter
argument_list|()
argument_list|,
name|getBaseHitCounter
argument_list|()
argument_list|,
name|getMissCounter
argument_list|()
argument_list|,
name|getFailedCounter
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**      * Represents a fallback type converter      */
DECL|class|FallbackTypeConverter
specifier|protected
specifier|static
class|class
name|FallbackTypeConverter
block|{
DECL|field|canPromote
specifier|private
specifier|final
name|boolean
name|canPromote
decl_stmt|;
DECL|field|fallbackTypeConverter
specifier|private
specifier|final
name|TypeConverter
name|fallbackTypeConverter
decl_stmt|;
DECL|method|FallbackTypeConverter (TypeConverter fallbackTypeConverter, boolean canPromote)
name|FallbackTypeConverter
parameter_list|(
name|TypeConverter
name|fallbackTypeConverter
parameter_list|,
name|boolean
name|canPromote
parameter_list|)
block|{
name|this
operator|.
name|canPromote
operator|=
name|canPromote
expr_stmt|;
name|this
operator|.
name|fallbackTypeConverter
operator|=
name|fallbackTypeConverter
expr_stmt|;
block|}
DECL|method|isCanPromote ()
specifier|public
name|boolean
name|isCanPromote
parameter_list|()
block|{
return|return
name|canPromote
return|;
block|}
DECL|method|getFallbackTypeConverter ()
specifier|public
name|TypeConverter
name|getFallbackTypeConverter
parameter_list|()
block|{
return|return
name|fallbackTypeConverter
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|class|DoubleMap
specifier|protected
specifier|static
class|class
name|DoubleMap
parameter_list|<
name|K1
parameter_list|,
name|K2
parameter_list|,
name|V
parameter_list|>
block|{
DECL|class|Entry
specifier|static
class|class
name|Entry
block|{
DECL|field|k1
name|Object
name|k1
decl_stmt|;
DECL|field|k2
name|Object
name|k2
decl_stmt|;
DECL|field|v
name|Object
name|v
decl_stmt|;
DECL|field|next
name|Entry
name|next
decl_stmt|;
block|}
DECL|field|table
specifier|private
name|Entry
index|[]
name|table
decl_stmt|;
DECL|field|mask
specifier|private
name|int
name|mask
decl_stmt|;
DECL|method|DoubleMap (int size)
specifier|public
name|DoubleMap
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|table
operator|=
operator|new
name|Entry
index|[
name|closedTableSize
argument_list|(
name|size
argument_list|)
index|]
expr_stmt|;
name|mask
operator|=
name|table
operator|.
name|length
operator|-
literal|1
expr_stmt|;
block|}
DECL|method|get (K1 k1, K2 k2)
specifier|public
name|V
name|get
parameter_list|(
name|K1
name|k1
parameter_list|,
name|K2
name|k2
parameter_list|)
block|{
name|Entry
index|[]
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|mask
init|=
name|this
operator|.
name|mask
decl_stmt|;
name|int
name|index
init|=
name|smear
argument_list|(
name|k1
operator|.
name|hashCode
argument_list|()
operator|*
literal|31
operator|+
name|k2
operator|.
name|hashCode
argument_list|()
argument_list|)
operator|&
name|mask
decl_stmt|;
for|for
control|(
name|Entry
name|entry
init|=
name|table
index|[
name|index
index|]
init|;
name|entry
operator|!=
literal|null
condition|;
name|entry
operator|=
name|entry
operator|.
name|next
control|)
block|{
if|if
condition|(
name|k1
operator|==
name|entry
operator|.
name|k1
operator|&&
name|k2
operator|==
name|entry
operator|.
name|k2
condition|)
block|{
return|return
operator|(
name|V
operator|)
name|entry
operator|.
name|v
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|forEach (TriConsumer<K1, K2, V> consumer)
specifier|public
name|void
name|forEach
parameter_list|(
name|TriConsumer
argument_list|<
name|K1
argument_list|,
name|K2
argument_list|,
name|V
argument_list|>
name|consumer
parameter_list|)
block|{
name|Entry
index|[]
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
for|for
control|(
name|Entry
name|entry
range|:
name|table
control|)
block|{
while|while
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|consumer
operator|.
name|accept
argument_list|(
operator|(
name|K1
operator|)
name|entry
operator|.
name|k1
argument_list|,
operator|(
name|K2
operator|)
name|entry
operator|.
name|k2
argument_list|,
operator|(
name|V
operator|)
name|entry
operator|.
name|v
argument_list|)
expr_stmt|;
name|entry
operator|=
name|entry
operator|.
name|next
expr_stmt|;
block|}
block|}
block|}
DECL|method|containsKey (K1 k1, K2 k2)
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|K1
name|k1
parameter_list|,
name|K2
name|k2
parameter_list|)
block|{
name|Entry
index|[]
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|mask
init|=
name|this
operator|.
name|mask
decl_stmt|;
name|int
name|index
init|=
name|smear
argument_list|(
name|k1
operator|.
name|hashCode
argument_list|()
operator|*
literal|31
operator|+
name|k2
operator|.
name|hashCode
argument_list|()
argument_list|)
operator|&
name|mask
decl_stmt|;
for|for
control|(
name|Entry
name|entry
init|=
name|table
index|[
name|index
index|]
init|;
name|entry
operator|!=
literal|null
condition|;
name|entry
operator|=
name|entry
operator|.
name|next
control|)
block|{
if|if
condition|(
name|k1
operator|==
name|entry
operator|.
name|k1
operator|&&
name|k2
operator|==
name|entry
operator|.
name|k2
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|put (K1 k1, K2 k2, V v)
specifier|public
specifier|synchronized
name|void
name|put
parameter_list|(
name|K1
name|k1
parameter_list|,
name|K2
name|k2
parameter_list|,
name|V
name|v
parameter_list|)
block|{
name|Entry
index|[]
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|size
init|=
name|size
argument_list|()
operator|+
literal|1
decl_stmt|;
name|int
name|realSize
init|=
name|closedTableSize
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|realSize
operator|<=
name|table
operator|.
name|length
condition|)
block|{
name|realSize
operator|=
name|table
operator|.
name|length
expr_stmt|;
name|int
name|index
init|=
name|smear
argument_list|(
name|k1
operator|.
name|hashCode
argument_list|()
operator|*
literal|31
operator|+
name|k2
operator|.
name|hashCode
argument_list|()
argument_list|)
operator|&
operator|(
name|realSize
operator|-
literal|1
operator|)
decl_stmt|;
for|for
control|(
name|Entry
name|oldEntry
init|=
name|table
index|[
name|index
index|]
init|;
name|oldEntry
operator|!=
literal|null
condition|;
name|oldEntry
operator|=
name|oldEntry
operator|.
name|next
control|)
block|{
if|if
condition|(
name|oldEntry
operator|.
name|k1
operator|==
name|k1
operator|&&
name|oldEntry
operator|.
name|k2
operator|==
name|k2
condition|)
block|{
name|oldEntry
operator|.
name|v
operator|=
name|v
expr_stmt|;
return|return;
block|}
block|}
name|Entry
name|entry
init|=
operator|new
name|Entry
argument_list|()
decl_stmt|;
name|entry
operator|.
name|k1
operator|=
name|k1
expr_stmt|;
name|entry
operator|.
name|k2
operator|=
name|k2
expr_stmt|;
name|entry
operator|.
name|v
operator|=
name|v
expr_stmt|;
name|entry
operator|.
name|next
operator|=
name|table
index|[
name|index
index|]
expr_stmt|;
name|table
index|[
name|index
index|]
operator|=
name|entry
expr_stmt|;
block|}
else|else
block|{
name|Entry
index|[]
name|newT
init|=
operator|new
name|Entry
index|[
name|realSize
index|]
decl_stmt|;
name|int
name|index
init|=
name|smear
argument_list|(
name|k1
operator|.
name|hashCode
argument_list|()
operator|*
literal|31
operator|+
name|k2
operator|.
name|hashCode
argument_list|()
argument_list|)
operator|&
operator|(
name|realSize
operator|-
literal|1
operator|)
decl_stmt|;
name|Entry
name|entry
init|=
operator|new
name|Entry
argument_list|()
decl_stmt|;
name|newT
index|[
name|index
index|]
operator|=
name|entry
expr_stmt|;
name|entry
operator|.
name|k1
operator|=
name|k1
expr_stmt|;
name|entry
operator|.
name|k2
operator|=
name|k2
expr_stmt|;
name|entry
operator|.
name|v
operator|=
name|v
expr_stmt|;
for|for
control|(
name|Entry
name|oldEntry
range|:
name|table
control|)
block|{
while|while
condition|(
name|oldEntry
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|k1
operator|!=
name|oldEntry
operator|.
name|k1
operator|||
name|k2
operator|!=
name|oldEntry
operator|.
name|k2
condition|)
block|{
name|index
operator|=
name|smear
argument_list|(
name|oldEntry
operator|.
name|k1
operator|.
name|hashCode
argument_list|()
operator|*
literal|31
operator|+
name|oldEntry
operator|.
name|k2
operator|.
name|hashCode
argument_list|()
argument_list|)
operator|&
operator|(
name|realSize
operator|-
literal|1
operator|)
expr_stmt|;
name|Entry
name|newEntry
init|=
operator|new
name|Entry
argument_list|()
decl_stmt|;
name|newEntry
operator|.
name|k1
operator|=
name|oldEntry
operator|.
name|k1
expr_stmt|;
name|newEntry
operator|.
name|k2
operator|=
name|oldEntry
operator|.
name|k2
expr_stmt|;
name|newEntry
operator|.
name|v
operator|=
name|oldEntry
operator|.
name|v
expr_stmt|;
name|newEntry
operator|.
name|next
operator|=
name|newT
index|[
name|index
index|]
expr_stmt|;
name|newT
index|[
name|index
index|]
operator|=
name|newEntry
expr_stmt|;
block|}
name|oldEntry
operator|=
name|oldEntry
operator|.
name|next
expr_stmt|;
block|}
block|}
name|this
operator|.
name|table
operator|=
name|newT
expr_stmt|;
name|this
operator|.
name|mask
operator|=
name|realSize
operator|-
literal|1
expr_stmt|;
block|}
block|}
DECL|method|remove (K1 k1, K2 k2)
specifier|public
specifier|synchronized
name|boolean
name|remove
parameter_list|(
name|K1
name|k1
parameter_list|,
name|K2
name|k2
parameter_list|)
block|{
name|Entry
index|[]
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|mask
init|=
name|this
operator|.
name|mask
decl_stmt|;
name|int
name|index
init|=
name|smear
argument_list|(
name|k1
operator|.
name|hashCode
argument_list|()
operator|*
literal|31
operator|+
name|k2
operator|.
name|hashCode
argument_list|()
argument_list|)
operator|&
name|mask
decl_stmt|;
name|Entry
name|prevEntry
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Entry
name|oldEntry
init|=
name|table
index|[
name|index
index|]
init|;
name|oldEntry
operator|!=
literal|null
condition|;
name|prevEntry
operator|=
name|oldEntry
operator|,
name|oldEntry
operator|=
name|oldEntry
operator|.
name|next
control|)
block|{
if|if
condition|(
name|oldEntry
operator|.
name|k1
operator|==
name|k1
operator|&&
name|oldEntry
operator|.
name|k2
operator|==
name|k2
condition|)
block|{
if|if
condition|(
name|prevEntry
operator|==
literal|null
condition|)
block|{
name|table
index|[
name|index
index|]
operator|=
name|oldEntry
operator|.
name|next
expr_stmt|;
block|}
else|else
block|{
name|prevEntry
operator|.
name|next
operator|=
name|oldEntry
operator|.
name|next
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|getFirst (Predicate<K1> p1, Predicate<K2> p2)
specifier|public
name|V
name|getFirst
parameter_list|(
name|Predicate
argument_list|<
name|K1
argument_list|>
name|p1
parameter_list|,
name|Predicate
argument_list|<
name|K2
argument_list|>
name|p2
parameter_list|)
block|{
for|for
control|(
name|Entry
name|entry
range|:
name|table
control|)
block|{
while|while
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|p1
operator|.
name|test
argument_list|(
operator|(
name|K1
operator|)
name|entry
operator|.
name|k1
argument_list|)
operator|&&
name|p2
operator|.
name|test
argument_list|(
operator|(
name|K2
operator|)
name|entry
operator|.
name|k2
argument_list|)
condition|)
block|{
return|return
operator|(
name|V
operator|)
name|entry
operator|.
name|v
return|;
block|}
name|entry
operator|=
name|entry
operator|.
name|next
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
name|Entry
index|[]
name|table
init|=
name|this
operator|.
name|table
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|table
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Entry
name|e
range|:
name|table
control|)
block|{
for|for
control|(
name|Entry
name|c
init|=
name|e
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|next
control|)
block|{
name|n
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|n
return|;
block|}
DECL|method|clear ()
specifier|public
specifier|synchronized
name|void
name|clear
parameter_list|()
block|{
name|this
operator|.
name|table
operator|=
operator|new
name|Entry
index|[
name|table
operator|.
name|length
index|]
expr_stmt|;
block|}
DECL|field|MAX_LOAD_FACTOR
specifier|private
specifier|static
specifier|final
name|double
name|MAX_LOAD_FACTOR
init|=
literal|1.2
decl_stmt|;
DECL|field|MAX_TABLE_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|MAX_TABLE_SIZE
init|=
literal|32768
decl_stmt|;
DECL|field|C1
specifier|private
specifier|static
specifier|final
name|int
name|C1
init|=
literal|0xcc9e2d51
decl_stmt|;
DECL|field|C2
specifier|private
specifier|static
specifier|final
name|int
name|C2
init|=
literal|0x1b873593
decl_stmt|;
DECL|method|smear (int hashCode)
specifier|static
name|int
name|smear
parameter_list|(
name|int
name|hashCode
parameter_list|)
block|{
return|return
name|C2
operator|*
name|Integer
operator|.
name|rotateLeft
argument_list|(
name|hashCode
operator|*
name|C1
argument_list|,
literal|15
argument_list|)
return|;
block|}
DECL|method|closedTableSize (int expectedEntries)
specifier|static
name|int
name|closedTableSize
parameter_list|(
name|int
name|expectedEntries
parameter_list|)
block|{
comment|// Get the recommended table size.
comment|// Round down to the nearest power of 2.
name|expectedEntries
operator|=
name|Math
operator|.
name|max
argument_list|(
name|expectedEntries
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|int
name|tableSize
init|=
name|Integer
operator|.
name|highestOneBit
argument_list|(
name|expectedEntries
argument_list|)
decl_stmt|;
comment|// Check to make sure that we will not exceed the maximum load factor.
if|if
condition|(
name|expectedEntries
operator|>
call|(
name|int
call|)
argument_list|(
name|MAX_LOAD_FACTOR
operator|*
name|tableSize
argument_list|)
condition|)
block|{
name|tableSize
operator|<<=
literal|1
expr_stmt|;
return|return
operator|(
name|tableSize
operator|>
literal|0
operator|)
condition|?
name|tableSize
else|:
name|MAX_TABLE_SIZE
return|;
block|}
return|return
name|tableSize
return|;
block|}
block|}
block|}
end_class

end_unit

