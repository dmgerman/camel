begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.impl
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContextAware
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Consumer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Route
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|ShutdownRoute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|ShutdownRunningTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Suspendable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|InflightRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|RouteStartupOrder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|ShutdownAware
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|ShutdownPrepared
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|ShutdownStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|ServiceSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|CollectionStringBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|EventHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ObjectHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ServiceHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|StopWatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Default {@link org.apache.camel.spi.ShutdownStrategy} which uses graceful shutdown.  *<p/>  * Graceful shutdown ensures that any inflight and pending messages will be taken into account  * and it will wait until these exchanges has been completed.  *<p/>  * This strategy will perform graceful shutdown in two steps:  *<ul>  *<li>Graceful - By suspending/stopping consumers, and let any in-flight exchanges complete</li>  *<li>Forced - After a given period of time, a timeout occurred and if there are still pending  *     exchanges to complete, then a more aggressive forced strategy is performed.</li>  *</ul>  * The idea by the<tt>graceful</tt> shutdown strategy, is to stop taking in more new messages,  * and allow any existing inflight messages to complete. Then when there is no more inflight messages  * then the routes can be fully shutdown. This mean that if there is inflight messages then we will have  * to wait for these messages to complete. If they do not complete after a period of time, then a  * timeout triggers. And then a more aggressive strategy takes over.  *<p/>  * The idea by the<tt>forced</tt> shutdown strategy, is to stop continue processing messages.  * And force routes and its services to shutdown now. There is a risk when shutting down now,  * that some resources is not properly shutdown, which can cause side effects. The timeout value  * is by default 300 seconds, but can be customized.  *<p/>  * As this strategy will politely wait until all exchanges has been completed it can potential wait  * for a long time, and hence why a timeout value can be set. When the timeout triggers you can also  * specify whether the remainder consumers should be shutdown now or ignore.  *<p/>  * Will by default use a timeout of 300 seconds (5 minutes) by which it will shutdown now the remaining consumers.  * This ensures that when shutting down Camel it at some point eventually will shutdown.  * This behavior can of course be configured using the {@link #setTimeout(long)} and  * {@link #setShutdownNowOnTimeout(boolean)} methods.  *<p/>  * Routes will by default be shutdown in the reverse order of which they where started.  * You can customize this using the {@link #setShutdownRoutesInReverseOrder(boolean)} method.  *<p/>  * After route consumers have been shutdown, then any {@link ShutdownPrepared} services on the routes  * is being prepared for shutdown, by invoking {@link ShutdownPrepared#prepareShutdown(boolean,boolean)} which  *<tt>force=false</tt>.  *<p/>  * Then if a timeout occurred and the strategy has been configured with shutdown-now on timeout, then  * the strategy performs a more aggressive forced shutdown, by forcing all consumers to shutdown  * and then invokes {@link ShutdownPrepared#prepareShutdown(boolean,boolean)} with<tt>force=true</tt>  * on the services. This allows the services to know they should force shutdown now.  *<p/>  * When timeout occurred and a forced shutdown is happening, then there may be threads/tasks which are  * still inflight which may be rejected continued being routed. By default this can cause WARN and ERRORs  * to be logged. The option {@link #setSuppressLoggingOnTimeout(boolean)} can be used to suppress these  * logs, so they are logged at TRACE level instead.  *<p/>  * Also when a timeout occurred then information about the inflight exchanges is logged, if {@link #isLogInflightExchangesOnTimeout()}  * is enabled (is by default). This allows end users to known where these inflight exchanges currently are in the route(s),  * and how long time they have been inflight.  *<p/>  * This information can also be obtained from the {@link org.apache.camel.spi.InflightRepository}  * at all time during runtime.  *  * @version  */
end_comment

begin_class
DECL|class|DefaultShutdownStrategy
specifier|public
class|class
name|DefaultShutdownStrategy
extends|extends
name|ServiceSupport
implements|implements
name|ShutdownStrategy
implements|,
name|CamelContextAware
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|DefaultShutdownStrategy
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|camelContext
specifier|private
name|CamelContext
name|camelContext
decl_stmt|;
DECL|field|executor
specifier|private
name|ExecutorService
name|executor
decl_stmt|;
DECL|field|timeout
specifier|private
name|long
name|timeout
init|=
literal|5
operator|*
literal|60
decl_stmt|;
DECL|field|timeUnit
specifier|private
name|TimeUnit
name|timeUnit
init|=
name|TimeUnit
operator|.
name|SECONDS
decl_stmt|;
DECL|field|shutdownNowOnTimeout
specifier|private
name|boolean
name|shutdownNowOnTimeout
init|=
literal|true
decl_stmt|;
DECL|field|shutdownRoutesInReverseOrder
specifier|private
name|boolean
name|shutdownRoutesInReverseOrder
init|=
literal|true
decl_stmt|;
DECL|field|suppressLoggingOnTimeout
specifier|private
name|boolean
name|suppressLoggingOnTimeout
decl_stmt|;
DECL|field|logInflightExchangesOnTimeout
specifier|private
name|boolean
name|logInflightExchangesOnTimeout
init|=
literal|true
decl_stmt|;
DECL|field|forceShutdown
specifier|private
specifier|volatile
name|boolean
name|forceShutdown
decl_stmt|;
DECL|field|timeoutOccurred
specifier|private
specifier|final
name|AtomicBoolean
name|timeoutOccurred
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
DECL|field|currentShutdownTaskFuture
specifier|private
specifier|volatile
name|Future
argument_list|<
name|?
argument_list|>
name|currentShutdownTaskFuture
decl_stmt|;
DECL|method|DefaultShutdownStrategy ()
specifier|public
name|DefaultShutdownStrategy
parameter_list|()
block|{     }
DECL|method|DefaultShutdownStrategy (CamelContext camelContext)
specifier|public
name|DefaultShutdownStrategy
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|)
block|{
name|this
operator|.
name|camelContext
operator|=
name|camelContext
expr_stmt|;
block|}
DECL|method|shutdown (CamelContext context, List<RouteStartupOrder> routes)
specifier|public
name|void
name|shutdown
parameter_list|(
name|CamelContext
name|context
parameter_list|,
name|List
argument_list|<
name|RouteStartupOrder
argument_list|>
name|routes
parameter_list|)
throws|throws
name|Exception
block|{
name|shutdown
argument_list|(
name|context
argument_list|,
name|routes
argument_list|,
name|getTimeout
argument_list|()
argument_list|,
name|getTimeUnit
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|shutdownForced (CamelContext context, List<RouteStartupOrder> routes)
specifier|public
name|void
name|shutdownForced
parameter_list|(
name|CamelContext
name|context
parameter_list|,
name|List
argument_list|<
name|RouteStartupOrder
argument_list|>
name|routes
parameter_list|)
throws|throws
name|Exception
block|{
name|doShutdown
argument_list|(
name|context
argument_list|,
name|routes
argument_list|,
name|getTimeout
argument_list|()
argument_list|,
name|getTimeUnit
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|suspend (CamelContext context, List<RouteStartupOrder> routes)
specifier|public
name|void
name|suspend
parameter_list|(
name|CamelContext
name|context
parameter_list|,
name|List
argument_list|<
name|RouteStartupOrder
argument_list|>
name|routes
parameter_list|)
throws|throws
name|Exception
block|{
name|doShutdown
argument_list|(
name|context
argument_list|,
name|routes
argument_list|,
name|getTimeout
argument_list|()
argument_list|,
name|getTimeUnit
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|shutdown (CamelContext context, List<RouteStartupOrder> routes, long timeout, TimeUnit timeUnit)
specifier|public
name|void
name|shutdown
parameter_list|(
name|CamelContext
name|context
parameter_list|,
name|List
argument_list|<
name|RouteStartupOrder
argument_list|>
name|routes
parameter_list|,
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
throws|throws
name|Exception
block|{
name|doShutdown
argument_list|(
name|context
argument_list|,
name|routes
argument_list|,
name|timeout
argument_list|,
name|timeUnit
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|shutdown (CamelContext context, RouteStartupOrder route, long timeout, TimeUnit timeUnit, boolean abortAfterTimeout)
specifier|public
name|boolean
name|shutdown
parameter_list|(
name|CamelContext
name|context
parameter_list|,
name|RouteStartupOrder
name|route
parameter_list|,
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|,
name|boolean
name|abortAfterTimeout
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|RouteStartupOrder
argument_list|>
name|routes
init|=
operator|new
name|ArrayList
argument_list|<
name|RouteStartupOrder
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|routes
operator|.
name|add
argument_list|(
name|route
argument_list|)
expr_stmt|;
return|return
name|doShutdown
argument_list|(
name|context
argument_list|,
name|routes
argument_list|,
name|timeout
argument_list|,
name|timeUnit
argument_list|,
literal|false
argument_list|,
name|abortAfterTimeout
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|suspend (CamelContext context, List<RouteStartupOrder> routes, long timeout, TimeUnit timeUnit)
specifier|public
name|void
name|suspend
parameter_list|(
name|CamelContext
name|context
parameter_list|,
name|List
argument_list|<
name|RouteStartupOrder
argument_list|>
name|routes
parameter_list|,
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
throws|throws
name|Exception
block|{
name|doShutdown
argument_list|(
name|context
argument_list|,
name|routes
argument_list|,
name|timeout
argument_list|,
name|timeUnit
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|doShutdown (CamelContext context, List<RouteStartupOrder> routes, long timeout, TimeUnit timeUnit, boolean suspendOnly, boolean abortAfterTimeout, boolean forceShutdown)
specifier|protected
name|boolean
name|doShutdown
parameter_list|(
name|CamelContext
name|context
parameter_list|,
name|List
argument_list|<
name|RouteStartupOrder
argument_list|>
name|routes
parameter_list|,
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|,
name|boolean
name|suspendOnly
parameter_list|,
name|boolean
name|abortAfterTimeout
parameter_list|,
name|boolean
name|forceShutdown
parameter_list|)
throws|throws
name|Exception
block|{
comment|// timeout must be a positive value
if|if
condition|(
name|timeout
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Timeout must be a positive value"
argument_list|)
throw|;
block|}
comment|// just return if no routes to shutdown
if|if
condition|(
name|routes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|StopWatch
name|watch
init|=
operator|new
name|StopWatch
argument_list|()
decl_stmt|;
comment|// at first sort according to route startup order
name|List
argument_list|<
name|RouteStartupOrder
argument_list|>
name|routesOrdered
init|=
operator|new
name|ArrayList
argument_list|<
name|RouteStartupOrder
argument_list|>
argument_list|(
name|routes
argument_list|)
decl_stmt|;
name|routesOrdered
operator|.
name|sort
argument_list|(
operator|new
name|Comparator
argument_list|<
name|RouteStartupOrder
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|RouteStartupOrder
name|o1
parameter_list|,
name|RouteStartupOrder
name|o2
parameter_list|)
block|{
return|return
name|o1
operator|.
name|getStartupOrder
argument_list|()
operator|-
name|o2
operator|.
name|getStartupOrder
argument_list|()
return|;
block|}
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|shutdownRoutesInReverseOrder
condition|)
block|{
name|Collections
operator|.
name|reverse
argument_list|(
name|routesOrdered
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|suspendOnly
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting to graceful suspend "
operator|+
name|routesOrdered
operator|.
name|size
argument_list|()
operator|+
literal|" routes (timeout "
operator|+
name|timeout
operator|+
literal|" "
operator|+
name|timeUnit
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting to graceful shutdown "
operator|+
name|routesOrdered
operator|.
name|size
argument_list|()
operator|+
literal|" routes (timeout "
operator|+
name|timeout
operator|+
literal|" "
operator|+
name|timeUnit
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
comment|// use another thread to perform the shutdowns so we can support timeout
name|timeoutOccurred
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|currentShutdownTaskFuture
operator|=
name|getExecutorService
argument_list|()
operator|.
name|submit
argument_list|(
operator|new
name|ShutdownTask
argument_list|(
name|context
argument_list|,
name|routesOrdered
argument_list|,
name|timeout
argument_list|,
name|timeUnit
argument_list|,
name|suspendOnly
argument_list|,
name|abortAfterTimeout
argument_list|,
name|timeoutOccurred
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|currentShutdownTaskFuture
operator|.
name|get
argument_list|(
name|timeout
argument_list|,
name|timeUnit
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
comment|// unwrap execution exception
throw|throw
name|ObjectHelper
operator|.
name|wrapRuntimeCamelException
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// either timeout or interrupted exception was thrown so this is okay
comment|// as interrupted would mean cancel was called on the currentShutdownTaskFuture to signal a forced timeout
comment|// we hit a timeout, so set the flag
name|timeoutOccurred
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// timeout then cancel the task
name|currentShutdownTaskFuture
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// signal we are forcing shutdown now, since timeout occurred
name|this
operator|.
name|forceShutdown
operator|=
name|forceShutdown
expr_stmt|;
comment|// if set, stop processing and return false to indicate that the shutdown is aborting
if|if
condition|(
operator|!
name|forceShutdown
operator|&&
name|abortAfterTimeout
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Timeout occurred during graceful shutdown. Aborting the shutdown now."
operator|+
literal|" Notice: some resources may still be running as graceful shutdown did not complete successfully."
argument_list|)
expr_stmt|;
comment|// we attempt to force shutdown so lets log the current inflight exchanges which are affected
name|logInflightExchanges
argument_list|(
name|context
argument_list|,
name|routes
argument_list|,
name|isLogInflightExchangesOnTimeout
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
if|if
condition|(
name|forceShutdown
operator|||
name|shutdownNowOnTimeout
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Timeout occurred during graceful shutdown. Forcing the routes to be shutdown now."
operator|+
literal|" Notice: some resources may still be running as graceful shutdown did not complete successfully."
argument_list|)
expr_stmt|;
comment|// we attempt to force shutdown so lets log the current inflight exchanges which are affected
name|logInflightExchanges
argument_list|(
name|context
argument_list|,
name|routes
argument_list|,
name|isLogInflightExchangesOnTimeout
argument_list|()
argument_list|)
expr_stmt|;
comment|// force the routes to shutdown now
name|shutdownRoutesNow
argument_list|(
name|routesOrdered
argument_list|)
expr_stmt|;
comment|// now the route consumers has been shutdown, then prepare route services for shutdown now (forced)
for|for
control|(
name|RouteStartupOrder
name|order
range|:
name|routes
control|)
block|{
for|for
control|(
name|Service
name|service
range|:
name|order
operator|.
name|getServices
argument_list|()
control|)
block|{
name|prepareShutdown
argument_list|(
name|service
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|isSuppressLoggingOnTimeout
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Timeout occurred during graceful shutdown. Will ignore shutting down the remainder routes."
operator|+
literal|" Notice: some resources may still be running as graceful shutdown did not complete successfully."
argument_list|)
expr_stmt|;
name|logInflightExchanges
argument_list|(
name|context
argument_list|,
name|routes
argument_list|,
name|isLogInflightExchangesOnTimeout
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|currentShutdownTaskFuture
operator|=
literal|null
expr_stmt|;
block|}
comment|// convert to seconds as its easier to read than a big milli seconds number
name|long
name|seconds
init|=
name|TimeUnit
operator|.
name|SECONDS
operator|.
name|convert
argument_list|(
name|watch
operator|.
name|stop
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Graceful shutdown of "
operator|+
name|routesOrdered
operator|.
name|size
argument_list|()
operator|+
literal|" routes completed in "
operator|+
name|seconds
operator|+
literal|" seconds"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|forceShutdown (Service service)
specifier|public
name|boolean
name|forceShutdown
parameter_list|(
name|Service
name|service
parameter_list|)
block|{
return|return
name|forceShutdown
return|;
block|}
annotation|@
name|Override
DECL|method|hasTimeoutOccurred ()
specifier|public
name|boolean
name|hasTimeoutOccurred
parameter_list|()
block|{
return|return
name|timeoutOccurred
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|setTimeout (long timeout)
specifier|public
name|void
name|setTimeout
parameter_list|(
name|long
name|timeout
parameter_list|)
block|{
if|if
condition|(
name|timeout
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Timeout must be a positive value"
argument_list|)
throw|;
block|}
name|this
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
block|}
DECL|method|getTimeout ()
specifier|public
name|long
name|getTimeout
parameter_list|()
block|{
return|return
name|timeout
return|;
block|}
DECL|method|setTimeUnit (TimeUnit timeUnit)
specifier|public
name|void
name|setTimeUnit
parameter_list|(
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
name|this
operator|.
name|timeUnit
operator|=
name|timeUnit
expr_stmt|;
block|}
DECL|method|getTimeUnit ()
specifier|public
name|TimeUnit
name|getTimeUnit
parameter_list|()
block|{
return|return
name|timeUnit
return|;
block|}
DECL|method|setShutdownNowOnTimeout (boolean shutdownNowOnTimeout)
specifier|public
name|void
name|setShutdownNowOnTimeout
parameter_list|(
name|boolean
name|shutdownNowOnTimeout
parameter_list|)
block|{
name|this
operator|.
name|shutdownNowOnTimeout
operator|=
name|shutdownNowOnTimeout
expr_stmt|;
block|}
DECL|method|isShutdownNowOnTimeout ()
specifier|public
name|boolean
name|isShutdownNowOnTimeout
parameter_list|()
block|{
return|return
name|shutdownNowOnTimeout
return|;
block|}
DECL|method|isShutdownRoutesInReverseOrder ()
specifier|public
name|boolean
name|isShutdownRoutesInReverseOrder
parameter_list|()
block|{
return|return
name|shutdownRoutesInReverseOrder
return|;
block|}
DECL|method|setShutdownRoutesInReverseOrder (boolean shutdownRoutesInReverseOrder)
specifier|public
name|void
name|setShutdownRoutesInReverseOrder
parameter_list|(
name|boolean
name|shutdownRoutesInReverseOrder
parameter_list|)
block|{
name|this
operator|.
name|shutdownRoutesInReverseOrder
operator|=
name|shutdownRoutesInReverseOrder
expr_stmt|;
block|}
DECL|method|isSuppressLoggingOnTimeout ()
specifier|public
name|boolean
name|isSuppressLoggingOnTimeout
parameter_list|()
block|{
return|return
name|suppressLoggingOnTimeout
return|;
block|}
DECL|method|setSuppressLoggingOnTimeout (boolean suppressLoggingOnTimeout)
specifier|public
name|void
name|setSuppressLoggingOnTimeout
parameter_list|(
name|boolean
name|suppressLoggingOnTimeout
parameter_list|)
block|{
name|this
operator|.
name|suppressLoggingOnTimeout
operator|=
name|suppressLoggingOnTimeout
expr_stmt|;
block|}
DECL|method|isLogInflightExchangesOnTimeout ()
specifier|public
name|boolean
name|isLogInflightExchangesOnTimeout
parameter_list|()
block|{
return|return
name|logInflightExchangesOnTimeout
return|;
block|}
DECL|method|setLogInflightExchangesOnTimeout (boolean logInflightExchangesOnTimeout)
specifier|public
name|void
name|setLogInflightExchangesOnTimeout
parameter_list|(
name|boolean
name|logInflightExchangesOnTimeout
parameter_list|)
block|{
name|this
operator|.
name|logInflightExchangesOnTimeout
operator|=
name|logInflightExchangesOnTimeout
expr_stmt|;
block|}
DECL|method|getCamelContext ()
specifier|public
name|CamelContext
name|getCamelContext
parameter_list|()
block|{
return|return
name|camelContext
return|;
block|}
DECL|method|setCamelContext (CamelContext camelContext)
specifier|public
name|void
name|setCamelContext
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|)
block|{
name|this
operator|.
name|camelContext
operator|=
name|camelContext
expr_stmt|;
block|}
DECL|method|getCurrentShutdownTaskFuture ()
specifier|public
name|Future
argument_list|<
name|?
argument_list|>
name|getCurrentShutdownTaskFuture
parameter_list|()
block|{
return|return
name|currentShutdownTaskFuture
return|;
block|}
comment|/**      * Shutdown all the consumers immediately.      *      * @param routes the routes to shutdown      */
DECL|method|shutdownRoutesNow (List<RouteStartupOrder> routes)
specifier|protected
name|void
name|shutdownRoutesNow
parameter_list|(
name|List
argument_list|<
name|RouteStartupOrder
argument_list|>
name|routes
parameter_list|)
block|{
for|for
control|(
name|RouteStartupOrder
name|order
range|:
name|routes
control|)
block|{
comment|// set the route to shutdown as fast as possible by stopping after
comment|// it has completed its current task
name|ShutdownRunningTask
name|current
init|=
name|order
operator|.
name|getRoute
argument_list|()
operator|.
name|getRouteContext
argument_list|()
operator|.
name|getShutdownRunningTask
argument_list|()
decl_stmt|;
if|if
condition|(
name|current
operator|!=
name|ShutdownRunningTask
operator|.
name|CompleteCurrentTaskOnly
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Changing shutdownRunningTask from {} to "
operator|+
name|ShutdownRunningTask
operator|.
name|CompleteCurrentTaskOnly
operator|+
literal|" on route {} to shutdown faster"
argument_list|,
name|current
argument_list|,
name|order
operator|.
name|getRoute
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|order
operator|.
name|getRoute
argument_list|()
operator|.
name|getRouteContext
argument_list|()
operator|.
name|setShutdownRunningTask
argument_list|(
name|ShutdownRunningTask
operator|.
name|CompleteCurrentTaskOnly
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Consumer
name|consumer
range|:
name|order
operator|.
name|getInputs
argument_list|()
control|)
block|{
name|shutdownNow
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Shutdown all the consumers immediately.      *      * @param consumers the consumers to shutdown      */
DECL|method|shutdownNow (List<Consumer> consumers)
specifier|protected
name|void
name|shutdownNow
parameter_list|(
name|List
argument_list|<
name|Consumer
argument_list|>
name|consumers
parameter_list|)
block|{
for|for
control|(
name|Consumer
name|consumer
range|:
name|consumers
control|)
block|{
name|shutdownNow
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Shutdown the consumer immediately.      *      * @param consumer the consumer to shutdown      */
DECL|method|shutdownNow (Consumer consumer)
specifier|protected
specifier|static
name|void
name|shutdownNow
parameter_list|(
name|Consumer
name|consumer
parameter_list|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Shutting down: {}"
argument_list|,
name|consumer
argument_list|)
expr_stmt|;
comment|// allow us to do custom work before delegating to service helper
try|try
block|{
name|ServiceHelper
operator|.
name|stopService
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error occurred while shutting down route: "
operator|+
name|consumer
operator|+
literal|". This exception will be ignored."
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// fire event
name|EventHelper
operator|.
name|notifyServiceStopFailure
argument_list|(
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|getCamelContext
argument_list|()
argument_list|,
name|consumer
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"Shutdown complete for: {}"
argument_list|,
name|consumer
argument_list|)
expr_stmt|;
block|}
comment|/**      * Suspends/stops the consumer immediately.      *      * @param consumer the consumer to suspend      */
DECL|method|suspendNow (Consumer consumer)
specifier|protected
specifier|static
name|void
name|suspendNow
parameter_list|(
name|Consumer
name|consumer
parameter_list|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Suspending: {}"
argument_list|,
name|consumer
argument_list|)
expr_stmt|;
comment|// allow us to do custom work before delegating to service helper
try|try
block|{
name|ServiceHelper
operator|.
name|suspendService
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error occurred while suspending route: "
operator|+
name|consumer
operator|+
literal|". This exception will be ignored."
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// fire event
name|EventHelper
operator|.
name|notifyServiceStopFailure
argument_list|(
name|consumer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|getCamelContext
argument_list|()
argument_list|,
name|consumer
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"Suspend complete for: {}"
argument_list|,
name|consumer
argument_list|)
expr_stmt|;
block|}
DECL|method|getExecutorService ()
specifier|private
name|ExecutorService
name|getExecutorService
parameter_list|()
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
block|{
comment|// use a thread pool that allow to terminate idle threads so they do not hang around forever
name|executor
operator|=
name|camelContext
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|newThreadPool
argument_list|(
name|this
argument_list|,
literal|"ShutdownTask"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|executor
return|;
block|}
annotation|@
name|Override
DECL|method|doStart ()
specifier|protected
name|void
name|doStart
parameter_list|()
throws|throws
name|Exception
block|{
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|camelContext
argument_list|,
literal|"CamelContext"
argument_list|)
expr_stmt|;
comment|// reset option
name|forceShutdown
operator|=
literal|false
expr_stmt|;
name|timeoutOccurred
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStop ()
specifier|protected
name|void
name|doStop
parameter_list|()
throws|throws
name|Exception
block|{
comment|// noop
block|}
annotation|@
name|Override
DECL|method|doShutdown ()
specifier|protected
name|void
name|doShutdown
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|executor
operator|!=
literal|null
condition|)
block|{
comment|// force shutting down as we are shutting down Camel
name|camelContext
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|shutdownNow
argument_list|(
name|executor
argument_list|)
expr_stmt|;
comment|// should clear executor so we can restart by creating a new thread pool
name|executor
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**      * Prepares the services for shutdown, by invoking the {@link ShutdownPrepared#prepareShutdown(boolean, boolean)} method      * on the service if it implement this interface.      *      * @param service the service      * @param forced  whether to force shutdown      * @param includeChildren whether to prepare the child of the service as well      */
DECL|method|prepareShutdown (Service service, boolean suspendOnly, boolean forced, boolean includeChildren, boolean suppressLogging)
specifier|private
specifier|static
name|void
name|prepareShutdown
parameter_list|(
name|Service
name|service
parameter_list|,
name|boolean
name|suspendOnly
parameter_list|,
name|boolean
name|forced
parameter_list|,
name|boolean
name|includeChildren
parameter_list|,
name|boolean
name|suppressLogging
parameter_list|)
block|{
name|Set
argument_list|<
name|Service
argument_list|>
name|list
decl_stmt|;
if|if
condition|(
name|includeChildren
condition|)
block|{
comment|// include error handlers as we want to prepare them for shutdown as well
name|list
operator|=
name|ServiceHelper
operator|.
name|getChildServices
argument_list|(
name|service
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|=
operator|new
name|LinkedHashSet
argument_list|<
name|Service
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Service
name|child
range|:
name|list
control|)
block|{
if|if
condition|(
name|child
operator|instanceof
name|ShutdownPrepared
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Preparing {} shutdown on {}"
argument_list|,
name|forced
condition|?
literal|"forced"
else|:
literal|""
argument_list|,
name|child
argument_list|)
expr_stmt|;
operator|(
operator|(
name|ShutdownPrepared
operator|)
name|child
operator|)
operator|.
name|prepareShutdown
argument_list|(
name|suspendOnly
argument_list|,
name|forced
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|suppressLogging
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Error during prepare shutdown on "
operator|+
name|child
operator|+
literal|". This exception will be ignored."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error during prepare shutdown on "
operator|+
name|child
operator|+
literal|". This exception will be ignored."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * Holder for deferred consumers      */
DECL|class|ShutdownDeferredConsumer
specifier|static
class|class
name|ShutdownDeferredConsumer
block|{
DECL|field|route
specifier|private
specifier|final
name|Route
name|route
decl_stmt|;
DECL|field|consumer
specifier|private
specifier|final
name|Consumer
name|consumer
decl_stmt|;
DECL|method|ShutdownDeferredConsumer (Route route, Consumer consumer)
name|ShutdownDeferredConsumer
parameter_list|(
name|Route
name|route
parameter_list|,
name|Consumer
name|consumer
parameter_list|)
block|{
name|this
operator|.
name|route
operator|=
name|route
expr_stmt|;
name|this
operator|.
name|consumer
operator|=
name|consumer
expr_stmt|;
block|}
DECL|method|getRoute ()
name|Route
name|getRoute
parameter_list|()
block|{
return|return
name|route
return|;
block|}
DECL|method|getConsumer ()
name|Consumer
name|getConsumer
parameter_list|()
block|{
return|return
name|consumer
return|;
block|}
block|}
comment|/**      * Shutdown task which shutdown all the routes in a graceful manner.      */
DECL|class|ShutdownTask
specifier|static
class|class
name|ShutdownTask
implements|implements
name|Runnable
block|{
DECL|field|context
specifier|private
specifier|final
name|CamelContext
name|context
decl_stmt|;
DECL|field|routes
specifier|private
specifier|final
name|List
argument_list|<
name|RouteStartupOrder
argument_list|>
name|routes
decl_stmt|;
DECL|field|suspendOnly
specifier|private
specifier|final
name|boolean
name|suspendOnly
decl_stmt|;
DECL|field|abortAfterTimeout
specifier|private
specifier|final
name|boolean
name|abortAfterTimeout
decl_stmt|;
DECL|field|timeout
specifier|private
specifier|final
name|long
name|timeout
decl_stmt|;
DECL|field|timeUnit
specifier|private
specifier|final
name|TimeUnit
name|timeUnit
decl_stmt|;
DECL|field|timeoutOccurred
specifier|private
specifier|final
name|AtomicBoolean
name|timeoutOccurred
decl_stmt|;
DECL|method|ShutdownTask (CamelContext context, List<RouteStartupOrder> routes, long timeout, TimeUnit timeUnit, boolean suspendOnly, boolean abortAfterTimeout, AtomicBoolean timeoutOccurred)
name|ShutdownTask
parameter_list|(
name|CamelContext
name|context
parameter_list|,
name|List
argument_list|<
name|RouteStartupOrder
argument_list|>
name|routes
parameter_list|,
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|,
name|boolean
name|suspendOnly
parameter_list|,
name|boolean
name|abortAfterTimeout
parameter_list|,
name|AtomicBoolean
name|timeoutOccurred
parameter_list|)
block|{
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|this
operator|.
name|routes
operator|=
name|routes
expr_stmt|;
name|this
operator|.
name|suspendOnly
operator|=
name|suspendOnly
expr_stmt|;
name|this
operator|.
name|abortAfterTimeout
operator|=
name|abortAfterTimeout
expr_stmt|;
name|this
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
name|this
operator|.
name|timeUnit
operator|=
name|timeUnit
expr_stmt|;
name|this
operator|.
name|timeoutOccurred
operator|=
name|timeoutOccurred
expr_stmt|;
block|}
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// the strategy in this run method is to
comment|// 1) go over the routes and shutdown those routes which can be shutdown asap
comment|//    some routes will be deferred to shutdown at the end, as they are needed
comment|//    by other routes so they can complete their tasks
comment|// 2) wait until all inflight and pending exchanges has been completed
comment|// 3) shutdown the deferred routes
name|LOG
operator|.
name|debug
argument_list|(
literal|"There are {} routes to {}"
argument_list|,
name|routes
operator|.
name|size
argument_list|()
argument_list|,
name|suspendOnly
condition|?
literal|"suspend"
else|:
literal|"shutdown"
argument_list|)
expr_stmt|;
comment|// list of deferred consumers to shutdown when all exchanges has been completed routed
comment|// and thus there are no more inflight exchanges so they can be safely shutdown at that time
name|List
argument_list|<
name|ShutdownDeferredConsumer
argument_list|>
name|deferredConsumers
init|=
operator|new
name|ArrayList
argument_list|<
name|ShutdownDeferredConsumer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RouteStartupOrder
name|order
range|:
name|routes
control|)
block|{
name|ShutdownRoute
name|shutdownRoute
init|=
name|order
operator|.
name|getRoute
argument_list|()
operator|.
name|getRouteContext
argument_list|()
operator|.
name|getShutdownRoute
argument_list|()
decl_stmt|;
name|ShutdownRunningTask
name|shutdownRunningTask
init|=
name|order
operator|.
name|getRoute
argument_list|()
operator|.
name|getRouteContext
argument_list|()
operator|.
name|getShutdownRunningTask
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}{} with options [{},{}]"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|suspendOnly
condition|?
literal|"Suspending route: "
else|:
literal|"Shutting down route: "
block|,
name|order
operator|.
name|getRoute
argument_list|()
operator|.
name|getId
argument_list|()
block|,
name|shutdownRoute
block|,
name|shutdownRunningTask
block|}
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Consumer
name|consumer
range|:
name|order
operator|.
name|getInputs
argument_list|()
control|)
block|{
name|boolean
name|suspend
init|=
literal|false
decl_stmt|;
comment|// assume we should shutdown if we are not deferred
name|boolean
name|shutdown
init|=
name|shutdownRoute
operator|!=
name|ShutdownRoute
operator|.
name|Defer
decl_stmt|;
if|if
condition|(
name|shutdown
condition|)
block|{
comment|// if we are to shutdown then check whether we can suspend instead as its a more
comment|// gentle way to graceful shutdown
comment|// some consumers do not support shutting down so let them decide
comment|// if a consumer is suspendable then prefer to use that and then shutdown later
if|if
condition|(
name|consumer
operator|instanceof
name|ShutdownAware
condition|)
block|{
name|shutdown
operator|=
operator|!
operator|(
operator|(
name|ShutdownAware
operator|)
name|consumer
operator|)
operator|.
name|deferShutdown
argument_list|(
name|shutdownRunningTask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shutdown
operator|&&
name|consumer
operator|instanceof
name|Suspendable
condition|)
block|{
comment|// we prefer to suspend over shutdown
name|suspend
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// log at info level when a route has been shutdown (otherwise log at debug level to not be too noisy)
if|if
condition|(
name|suspend
condition|)
block|{
comment|// only suspend it and then later shutdown it
name|suspendNow
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
comment|// add it to the deferred list so the route will be shutdown later
name|deferredConsumers
operator|.
name|add
argument_list|(
operator|new
name|ShutdownDeferredConsumer
argument_list|(
name|order
operator|.
name|getRoute
argument_list|()
argument_list|,
name|consumer
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Route: {} suspended and shutdown deferred, was consuming from: {}"
argument_list|,
name|order
operator|.
name|getRoute
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|order
operator|.
name|getRoute
argument_list|()
operator|.
name|getEndpoint
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shutdown
condition|)
block|{
name|shutdownNow
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Route: {} shutdown complete, was consuming from: {}"
argument_list|,
name|order
operator|.
name|getRoute
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|order
operator|.
name|getRoute
argument_list|()
operator|.
name|getEndpoint
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we will stop it later, but for now it must run to be able to help all inflight messages
comment|// be safely completed
name|deferredConsumers
operator|.
name|add
argument_list|(
operator|new
name|ShutdownDeferredConsumer
argument_list|(
name|order
operator|.
name|getRoute
argument_list|()
argument_list|,
name|consumer
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Route: "
operator|+
name|order
operator|.
name|getRoute
argument_list|()
operator|.
name|getId
argument_list|()
operator|+
operator|(
name|suspendOnly
condition|?
literal|" shutdown deferred."
else|:
literal|" suspension deferred."
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// notify the services we intend to shutdown
for|for
control|(
name|RouteStartupOrder
name|order
range|:
name|routes
control|)
block|{
for|for
control|(
name|Service
name|service
range|:
name|order
operator|.
name|getServices
argument_list|()
control|)
block|{
comment|// skip the consumer as we handle that specially
if|if
condition|(
name|service
operator|instanceof
name|Consumer
condition|)
block|{
continue|continue;
block|}
name|prepareShutdown
argument_list|(
name|service
argument_list|,
name|suspendOnly
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|// wait till there are no more pending and inflight messages
name|boolean
name|done
init|=
literal|false
decl_stmt|;
name|long
name|loopDelaySeconds
init|=
literal|1
decl_stmt|;
name|long
name|loopCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
operator|!
name|timeoutOccurred
operator|.
name|get
argument_list|()
condition|)
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
comment|// number of inflights per route
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|routeInflight
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RouteStartupOrder
name|order
range|:
name|routes
control|)
block|{
name|int
name|inflight
init|=
name|context
operator|.
name|getInflightRepository
argument_list|()
operator|.
name|size
argument_list|(
name|order
operator|.
name|getRoute
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|inflight
operator|+=
name|getPendingInflightExchanges
argument_list|(
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
name|inflight
operator|>
literal|0
condition|)
block|{
name|String
name|routeId
init|=
name|order
operator|.
name|getRoute
argument_list|()
operator|.
name|getId
argument_list|()
decl_stmt|;
name|routeInflight
operator|.
name|put
argument_list|(
name|routeId
argument_list|,
name|inflight
argument_list|)
expr_stmt|;
name|size
operator|+=
name|inflight
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"{} inflight and pending exchanges for route: {}"
argument_list|,
name|inflight
argument_list|,
name|routeId
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
try|try
block|{
comment|// build a message with inflight per route
name|CollectionStringBuffer
name|csb
init|=
operator|new
name|CollectionStringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|entry
range|:
name|routeInflight
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|row
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%s = %s"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|csb
operator|.
name|append
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
name|String
name|msg
init|=
literal|"Waiting as there are still "
operator|+
name|size
operator|+
literal|" inflight and pending exchanges to complete, timeout in "
operator|+
operator|(
name|TimeUnit
operator|.
name|SECONDS
operator|.
name|convert
argument_list|(
name|timeout
argument_list|,
name|timeUnit
argument_list|)
operator|-
operator|(
name|loopCount
operator|++
operator|*
name|loopDelaySeconds
operator|)
operator|)
operator|+
literal|" seconds."
decl_stmt|;
name|msg
operator|+=
literal|" Inflights per route: ["
operator|+
name|csb
operator|.
name|toString
argument_list|()
operator|+
literal|"]"
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|msg
argument_list|)
expr_stmt|;
comment|// log verbose if DEBUG logging is enabled
name|logInflightExchanges
argument_list|(
name|context
argument_list|,
name|routes
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|loopDelaySeconds
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
if|if
condition|(
name|abortAfterTimeout
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted while waiting during graceful shutdown, will abort."
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted while waiting during graceful shutdown, will force shutdown now."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|done
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// prepare for shutdown
for|for
control|(
name|ShutdownDeferredConsumer
name|deferred
range|:
name|deferredConsumers
control|)
block|{
name|Consumer
name|consumer
init|=
name|deferred
operator|.
name|getConsumer
argument_list|()
decl_stmt|;
if|if
condition|(
name|consumer
operator|instanceof
name|ShutdownAware
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Route: {} preparing to shutdown."
argument_list|,
name|deferred
operator|.
name|getRoute
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|forced
init|=
name|context
operator|.
name|getShutdownStrategy
argument_list|()
operator|.
name|forceShutdown
argument_list|(
name|consumer
argument_list|)
decl_stmt|;
name|boolean
name|suppress
init|=
name|context
operator|.
name|getShutdownStrategy
argument_list|()
operator|.
name|isSuppressLoggingOnTimeout
argument_list|()
decl_stmt|;
name|prepareShutdown
argument_list|(
name|consumer
argument_list|,
name|suspendOnly
argument_list|,
name|forced
argument_list|,
literal|false
argument_list|,
name|suppress
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Route: {} preparing to shutdown complete."
argument_list|,
name|deferred
operator|.
name|getRoute
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// now all messages has been completed then stop the deferred consumers
for|for
control|(
name|ShutdownDeferredConsumer
name|deferred
range|:
name|deferredConsumers
control|)
block|{
name|Consumer
name|consumer
init|=
name|deferred
operator|.
name|getConsumer
argument_list|()
decl_stmt|;
if|if
condition|(
name|suspendOnly
condition|)
block|{
name|suspendNow
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Route: {} suspend complete, was consuming from: {}"
argument_list|,
name|deferred
operator|.
name|getRoute
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|deferred
operator|.
name|getConsumer
argument_list|()
operator|.
name|getEndpoint
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shutdownNow
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Route: {} shutdown complete, was consuming from: {}"
argument_list|,
name|deferred
operator|.
name|getRoute
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|deferred
operator|.
name|getConsumer
argument_list|()
operator|.
name|getEndpoint
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// now the route consumers has been shutdown, then prepare route services for shutdown
for|for
control|(
name|RouteStartupOrder
name|order
range|:
name|routes
control|)
block|{
for|for
control|(
name|Service
name|service
range|:
name|order
operator|.
name|getServices
argument_list|()
control|)
block|{
name|boolean
name|forced
init|=
name|context
operator|.
name|getShutdownStrategy
argument_list|()
operator|.
name|forceShutdown
argument_list|(
name|service
argument_list|)
decl_stmt|;
name|boolean
name|suppress
init|=
name|context
operator|.
name|getShutdownStrategy
argument_list|()
operator|.
name|isSuppressLoggingOnTimeout
argument_list|()
decl_stmt|;
name|prepareShutdown
argument_list|(
name|service
argument_list|,
name|suspendOnly
argument_list|,
name|forced
argument_list|,
literal|true
argument_list|,
name|suppress
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Calculates the total number of inflight exchanges for the given route      *      * @param order the route      * @return number of inflight exchanges      */
DECL|method|getPendingInflightExchanges (RouteStartupOrder order)
specifier|protected
specifier|static
name|int
name|getPendingInflightExchanges
parameter_list|(
name|RouteStartupOrder
name|order
parameter_list|)
block|{
name|int
name|inflight
init|=
literal|0
decl_stmt|;
comment|// the consumer is the 1st service so we always get the consumer
comment|// the child services are EIPs in the routes which may also have pending
comment|// inflight exchanges (such as the aggregator)
for|for
control|(
name|Service
name|service
range|:
name|order
operator|.
name|getServices
argument_list|()
control|)
block|{
name|Set
argument_list|<
name|Service
argument_list|>
name|children
init|=
name|ServiceHelper
operator|.
name|getChildServices
argument_list|(
name|service
argument_list|)
decl_stmt|;
for|for
control|(
name|Service
name|child
range|:
name|children
control|)
block|{
if|if
condition|(
name|child
operator|instanceof
name|ShutdownAware
condition|)
block|{
name|inflight
operator|+=
operator|(
operator|(
name|ShutdownAware
operator|)
name|child
operator|)
operator|.
name|getPendingExchangesSize
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
name|inflight
return|;
block|}
comment|/**      * Logs information about the inflight exchanges      *      * @param infoLevel<tt>true</tt> to log at INFO level,<tt>false</tt> to log at DEBUG level      */
DECL|method|logInflightExchanges (CamelContext camelContext, List<RouteStartupOrder> routes, boolean infoLevel)
specifier|protected
specifier|static
name|void
name|logInflightExchanges
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|,
name|List
argument_list|<
name|RouteStartupOrder
argument_list|>
name|routes
parameter_list|,
name|boolean
name|infoLevel
parameter_list|)
block|{
comment|// check if we need to log
if|if
condition|(
operator|!
name|infoLevel
operator|&&
operator|!
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
return|return;
block|}
name|Collection
argument_list|<
name|InflightRepository
operator|.
name|InflightExchange
argument_list|>
name|inflights
init|=
name|camelContext
operator|.
name|getInflightRepository
argument_list|()
operator|.
name|browse
argument_list|()
decl_stmt|;
name|int
name|size
init|=
name|inflights
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return;
block|}
comment|// filter so inflight must start from any of the routes
name|Set
argument_list|<
name|String
argument_list|>
name|routeIds
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RouteStartupOrder
name|route
range|:
name|routes
control|)
block|{
name|routeIds
operator|.
name|add
argument_list|(
name|route
operator|.
name|getRoute
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Collection
argument_list|<
name|InflightRepository
operator|.
name|InflightExchange
argument_list|>
name|filtered
init|=
operator|new
name|ArrayList
argument_list|<
name|InflightRepository
operator|.
name|InflightExchange
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|InflightRepository
operator|.
name|InflightExchange
name|inflight
range|:
name|inflights
control|)
block|{
name|String
name|routeId
init|=
name|inflight
operator|.
name|getExchange
argument_list|()
operator|.
name|getFromRouteId
argument_list|()
decl_stmt|;
if|if
condition|(
name|routeIds
operator|.
name|contains
argument_list|(
name|routeId
argument_list|)
condition|)
block|{
name|filtered
operator|.
name|add
argument_list|(
name|inflight
argument_list|)
expr_stmt|;
block|}
block|}
name|size
operator|=
name|filtered
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"There are "
operator|+
name|size
operator|+
literal|" inflight exchanges:"
argument_list|)
decl_stmt|;
for|for
control|(
name|InflightRepository
operator|.
name|InflightExchange
name|inflight
range|:
name|filtered
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n\tInflightExchange: [exchangeId="
argument_list|)
operator|.
name|append
argument_list|(
name|inflight
operator|.
name|getExchange
argument_list|()
operator|.
name|getExchangeId
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|", fromRouteId="
argument_list|)
operator|.
name|append
argument_list|(
name|inflight
operator|.
name|getExchange
argument_list|()
operator|.
name|getFromRouteId
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|", routeId="
argument_list|)
operator|.
name|append
argument_list|(
name|inflight
operator|.
name|getRouteId
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|", nodeId="
argument_list|)
operator|.
name|append
argument_list|(
name|inflight
operator|.
name|getNodeId
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|", elapsed="
argument_list|)
operator|.
name|append
argument_list|(
name|inflight
operator|.
name|getElapsed
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|", duration="
argument_list|)
operator|.
name|append
argument_list|(
name|inflight
operator|.
name|getDuration
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|infoLevel
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

