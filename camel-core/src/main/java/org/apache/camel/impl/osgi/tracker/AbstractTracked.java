begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_comment
comment|/*  * Copyright (c) OSGi Alliance (2007, 2008). All Rights Reserved.  *   * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.impl.osgi.tracker
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|impl
operator|.
name|osgi
operator|.
name|tracker
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * Abstract class to track items. If a Tracker is reused (closed then reopened),  * then a new AbstractTracked object is used. This class acts a map of tracked  * item -> customized object. Subclasses of this class will act as the listener  * object for the tracker. This class is used to synchronize access to the  * tracked items. This is not a public class. It is only for use by the  * implementation of the Tracker class.  *   * @ThreadSafe  * @version   * @since 1.4  */
end_comment

begin_class
DECL|class|AbstractTracked
specifier|abstract
class|class
name|AbstractTracked
block|{
comment|/* set this to true to compile in debug messages */
DECL|field|DEBUG
specifier|static
specifier|final
name|boolean
name|DEBUG
init|=
literal|false
decl_stmt|;
comment|/**      * true if the tracked object is closed. This field is volatile because it      * is set by one thread and read by another.      */
DECL|field|closed
specifier|volatile
name|boolean
name|closed
decl_stmt|;
comment|/**      * Map of tracked items to customized objects.      *       * @GuardedBy this      */
DECL|field|tracked
specifier|private
specifier|final
name|Map
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|tracked
decl_stmt|;
comment|/**      * Modification count. This field is initialized to zero and incremented by      * modified.      *       * @GuardedBy this      */
DECL|field|trackingCount
specifier|private
name|int
name|trackingCount
decl_stmt|;
comment|/**      * List of items in the process of being added. This is used to deal with      * nesting of events. Since events may be synchronously delivered, events      * can be nested. For example, when processing the adding of a service and      * the customizer causes the service to be unregistered, notification to the      * nested call to untrack that the service was unregistered can be made to      * the track method. Since the ArrayList implementation is not synchronized,      * all access to this list must be protected by the same synchronized object      * for thread-safety.      *       * @GuardedBy this      */
DECL|field|adding
specifier|private
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|adding
decl_stmt|;
comment|/**      * Initial list of items for the tracker. This is used to correctly process      * the initial items which could be modified before they are tracked. This      * is necessary since the initial set of tracked items are not "announced"      * by events and therefore the event which makes the item untracked could be      * delivered before we track the item. An item must not be in both the      * initial and adding lists at the same time. An item must be moved from the      * initial list to the adding list "atomically" before we begin tracking it.      * Since the LinkedList implementation is not synchronized, all access to      * this list must be protected by the same synchronized object for      * thread-safety.      *       * @GuardedBy this      */
DECL|field|initial
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|Object
argument_list|>
name|initial
decl_stmt|;
comment|/**      * AbstractTracked constructor.      */
DECL|method|AbstractTracked ()
name|AbstractTracked
parameter_list|()
block|{
name|tracked
operator|=
operator|new
name|HashMap
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
argument_list|()
expr_stmt|;
name|trackingCount
operator|=
literal|0
expr_stmt|;
name|adding
operator|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|initial
operator|=
operator|new
name|LinkedList
argument_list|<
name|Object
argument_list|>
argument_list|()
expr_stmt|;
name|closed
operator|=
literal|false
expr_stmt|;
block|}
comment|/**      * Set initial list of items into tracker before events begin to be      * received. This method must be called from Tracker's open method while      * synchronized on this object in the same synchronized block as the add      * listener call.      *       * @param list The initial list of items to be tracked.<code>null</code>      *            entries in the list are ignored.      * @GuardedBy this      */
DECL|method|setInitial (Object[] list)
name|void
name|setInitial
parameter_list|(
name|Object
index|[]
name|list
parameter_list|)
block|{
if|if
condition|(
name|list
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|int
name|size
init|=
name|list
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|item
init|=
name|list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|item
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"AbstractTracked.setInitial: "
operator|+
name|item
argument_list|)
expr_stmt|;
block|}
name|initial
operator|.
name|add
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Track the initial list of items. This is called after events can begin to      * be received. This method must be called from Tracker's open method while      * not synchronized on this object after the add listener call.      */
DECL|method|trackInitial ()
name|void
name|trackInitial
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|Object
name|item
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|closed
operator|||
operator|(
name|initial
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
comment|/*                      * if there are no more initial items                      */
return|return;
comment|/* we are done */
block|}
comment|/*                  * move the first item from the initial list to the adding list                  * within this synchronized block.                  */
name|item
operator|=
name|initial
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
if|if
condition|(
name|tracked
operator|.
name|get
argument_list|(
name|item
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|/* if we are already tracking this item */
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"AbstractTracked.trackInitial[already tracked]: "
operator|+
name|item
argument_list|)
expr_stmt|;
block|}
continue|continue;
comment|/* skip this item */
block|}
if|if
condition|(
name|adding
operator|.
name|contains
argument_list|(
name|item
argument_list|)
condition|)
block|{
comment|/*                      * if this item is already in the process of being added.                      */
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"AbstractTracked.trackInitial[already adding]: "
operator|+
name|item
argument_list|)
expr_stmt|;
block|}
continue|continue;
comment|/* skip this item */
block|}
name|adding
operator|.
name|add
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"AbstractTracked.trackInitial: "
operator|+
name|item
argument_list|)
expr_stmt|;
block|}
name|trackAdding
argument_list|(
name|item
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|/*                                       * Begin tracking it. We call trackAdding                                       * since we have already put the item in                                       * the adding list.                                       */
block|}
block|}
comment|/**      * Called by the owning Tracker object when it is closed.      */
DECL|method|close ()
name|void
name|close
parameter_list|()
block|{
name|closed
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * Begin to track an item.      *       * @param item Item to be tracked.      * @param related Action related object.      */
DECL|method|track (final Object item, final Object related)
name|void
name|track
parameter_list|(
specifier|final
name|Object
name|item
parameter_list|,
specifier|final
name|Object
name|related
parameter_list|)
block|{
specifier|final
name|Object
name|object
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|closed
condition|)
block|{
return|return;
block|}
name|object
operator|=
name|tracked
operator|.
name|get
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|==
literal|null
condition|)
block|{
comment|/* we are not tracking the item */
if|if
condition|(
name|adding
operator|.
name|contains
argument_list|(
name|item
argument_list|)
condition|)
block|{
comment|/* if this item is already in the process of being added. */
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"AbstractTracked.track[already adding]: "
operator|+
name|item
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|adding
operator|.
name|add
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/* mark this item is being added */
block|}
else|else
block|{
comment|/* we are currently tracking this item */
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"AbstractTracked.track[modified]: "
operator|+
name|item
argument_list|)
expr_stmt|;
block|}
name|modified
argument_list|()
expr_stmt|;
comment|/* increment modification count */
block|}
block|}
if|if
condition|(
name|object
operator|==
literal|null
condition|)
block|{
comment|/* we are not tracking the item */
name|trackAdding
argument_list|(
name|item
argument_list|,
name|related
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Call customizer outside of synchronized region */
name|customizerModified
argument_list|(
name|item
argument_list|,
name|related
argument_list|,
name|object
argument_list|)
expr_stmt|;
comment|/*              * If the customizer throws an unchecked exception, it is safe to              * let it propagate              */
block|}
block|}
comment|/**      * Common logic to add an item to the tracker used by track and      * trackInitial. The specified item must have been placed in the adding list      * before calling this method.      *       * @param item Item to be tracked.      * @param related Action related object.      */
DECL|method|trackAdding (final Object item, final Object related)
specifier|private
name|void
name|trackAdding
parameter_list|(
specifier|final
name|Object
name|item
parameter_list|,
specifier|final
name|Object
name|related
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"AbstractTracked.trackAdding: "
operator|+
name|item
argument_list|)
expr_stmt|;
block|}
name|Object
name|object
init|=
literal|null
decl_stmt|;
name|boolean
name|becameUntracked
init|=
literal|false
decl_stmt|;
comment|/* Call customizer outside of synchronized region */
try|try
block|{
name|object
operator|=
name|customizerAdding
argument_list|(
name|item
argument_list|,
name|related
argument_list|)
expr_stmt|;
comment|/*              * If the customizer throws an unchecked exception, it will              * propagate after the finally              */
block|}
finally|finally
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|adding
operator|.
name|remove
argument_list|(
name|item
argument_list|)
operator|&&
operator|!
name|closed
condition|)
block|{
comment|/*                      * if the item was not untracked during the customizer                      * callback                      */
if|if
condition|(
name|object
operator|!=
literal|null
condition|)
block|{
name|tracked
operator|.
name|put
argument_list|(
name|item
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|modified
argument_list|()
expr_stmt|;
comment|/* increment modification count */
name|notifyAll
argument_list|()
expr_stmt|;
comment|/* notify any waiters */
block|}
block|}
else|else
block|{
name|becameUntracked
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|/*          * The item became untracked during the customizer callback.          */
if|if
condition|(
name|becameUntracked
operator|&&
operator|(
name|object
operator|!=
literal|null
operator|)
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"AbstractTracked.trackAdding[removed]: "
operator|+
name|item
argument_list|)
expr_stmt|;
block|}
comment|/* Call customizer outside of synchronized region */
name|customizerRemoved
argument_list|(
name|item
argument_list|,
name|related
argument_list|,
name|object
argument_list|)
expr_stmt|;
comment|/*              * If the customizer throws an unchecked exception, it is safe to              * let it propagate              */
block|}
block|}
comment|/**      * Discontinue tracking the item.      *       * @param item Item to be untracked.      * @param related Action related object.      */
DECL|method|untrack (final Object item, final Object related)
name|void
name|untrack
parameter_list|(
specifier|final
name|Object
name|item
parameter_list|,
specifier|final
name|Object
name|related
parameter_list|)
block|{
specifier|final
name|Object
name|object
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|initial
operator|.
name|remove
argument_list|(
name|item
argument_list|)
condition|)
block|{
comment|/*                                          * if this item is already in the list                                          * of initial references to process                                          */
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"AbstractTracked.untrack[removed from initial]: "
operator|+
name|item
argument_list|)
expr_stmt|;
block|}
return|return;
comment|/*                          * we have removed it from the list and it will not be                          * processed                          */
block|}
if|if
condition|(
name|adding
operator|.
name|remove
argument_list|(
name|item
argument_list|)
condition|)
block|{
comment|/*                                         * if the item is in the process of being                                         * added                                         */
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"AbstractTracked.untrack[being added]: "
operator|+
name|item
argument_list|)
expr_stmt|;
block|}
return|return;
comment|/*                          * in case the item is untracked while in the process of                          * adding                          */
block|}
name|object
operator|=
name|tracked
operator|.
name|remove
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/*                                             * must remove from tracker before                                             * calling customizer callback                                             */
if|if
condition|(
name|object
operator|==
literal|null
condition|)
block|{
comment|/* are we actually tracking the item */
return|return;
block|}
name|modified
argument_list|()
expr_stmt|;
comment|/* increment modification count */
block|}
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"AbstractTracked.untrack[removed]: "
operator|+
name|item
argument_list|)
expr_stmt|;
block|}
comment|/* Call customizer outside of synchronized region */
name|customizerRemoved
argument_list|(
name|item
argument_list|,
name|related
argument_list|,
name|object
argument_list|)
expr_stmt|;
comment|/*          * If the customizer throws an unchecked exception, it is safe to let it          * propagate          */
block|}
comment|/**      * Returns the number of tracked items.      *       * @return The number of tracked items.      * @GuardedBy this      */
DECL|method|size ()
name|int
name|size
parameter_list|()
block|{
return|return
name|tracked
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Return the customized object for the specified item      *       * @param item The item to lookup in the map      * @return The customized object for the specified item.      * @GuardedBy this      */
DECL|method|getCustomizedObject (final Object item)
name|Object
name|getCustomizedObject
parameter_list|(
specifier|final
name|Object
name|item
parameter_list|)
block|{
return|return
name|tracked
operator|.
name|get
argument_list|(
name|item
argument_list|)
return|;
block|}
comment|/**      * Return the list of tracked items.      *       * @param list An array to contain the tracked items.      * @return The specified list if it is large enough to hold the tracked      *         items or a new array large enough to hold the tracked items.      * @GuardedBy this      */
DECL|method|getTracked (final Object[] list)
name|Object
index|[]
name|getTracked
parameter_list|(
specifier|final
name|Object
index|[]
name|list
parameter_list|)
block|{
return|return
name|tracked
operator|.
name|keySet
argument_list|()
operator|.
name|toArray
argument_list|(
name|list
argument_list|)
return|;
block|}
comment|/**      * Increment the modification count. If this method is overridden, the      * overriding method MUST call this method to increment the tracking count.      *       * @GuardedBy this      */
DECL|method|modified ()
name|void
name|modified
parameter_list|()
block|{
name|trackingCount
operator|++
expr_stmt|;
block|}
comment|/**      * Returns the tracking count for this<code>ServiceTracker</code> object.      * The tracking count is initialized to 0 when this object is opened. Every      * time an item is added, modified or removed from this object the tracking      * count is incremented.      *       * @GuardedBy this      * @return The tracking count for this object.      */
DECL|method|getTrackingCount ()
name|int
name|getTrackingCount
parameter_list|()
block|{
return|return
name|trackingCount
return|;
block|}
comment|/**      * Call the specific customizer adding method. This method must not be      * called while synchronized on this object.      *       * @param item Item to be tracked.      * @param related Action related object.      * @return Customized object for the tracked item or<code>null</code> if      *         the item is not to be tracked.      */
DECL|method|customizerAdding (Object item, Object related)
specifier|abstract
name|Object
name|customizerAdding
parameter_list|(
name|Object
name|item
parameter_list|,
name|Object
name|related
parameter_list|)
function_decl|;
comment|/**      * Call the specific customizer modified method. This method must not be      * called while synchronized on this object.      *       * @param item Tracked item.      * @param related Action related object.      * @param object Customized object for the tracked item.      */
DECL|method|customizerModified (Object item, Object related, Object object)
specifier|abstract
name|void
name|customizerModified
parameter_list|(
name|Object
name|item
parameter_list|,
name|Object
name|related
parameter_list|,
name|Object
name|object
parameter_list|)
function_decl|;
comment|/**      * Call the specific customizer removed method. This method must not be      * called while synchronized on this object.      *       * @param item Tracked item.      * @param related Action related object.      * @param object Customized object for the tracked item.      */
DECL|method|customizerRemoved (Object item, Object related, Object object)
specifier|abstract
name|void
name|customizerRemoved
parameter_list|(
name|Object
name|item
parameter_list|,
name|Object
name|related
parameter_list|,
name|Object
name|object
parameter_list|)
function_decl|;
block|}
end_class

end_unit

