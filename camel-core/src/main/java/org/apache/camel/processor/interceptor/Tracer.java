begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.processor.interceptor
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
operator|.
name|interceptor
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Endpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|LoggingLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Processor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|model
operator|.
name|ProcessorDefinition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|model
operator|.
name|RouteDefinitionHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
operator|.
name|CamelLogProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|ExchangeFormatter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|InterceptStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|CamelLogger
import|;
end_import

begin_comment
comment|/**  * An interceptor strategy for tracing routes  *  * @version   */
end_comment

begin_class
DECL|class|Tracer
specifier|public
class|class
name|Tracer
implements|implements
name|InterceptStrategy
implements|,
name|Service
block|{
DECL|field|JPA_TRACE_EVENT_MESSAGE
specifier|private
specifier|static
specifier|final
name|String
name|JPA_TRACE_EVENT_MESSAGE
init|=
literal|"org.apache.camel.processor.interceptor.jpa.JpaTraceEventMessage"
decl_stmt|;
DECL|field|formatter
specifier|private
name|TraceFormatter
name|formatter
init|=
operator|new
name|DefaultTraceFormatter
argument_list|()
decl_stmt|;
DECL|field|enabled
specifier|private
name|boolean
name|enabled
init|=
literal|true
decl_stmt|;
DECL|field|logName
specifier|private
name|String
name|logName
init|=
name|Tracer
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
DECL|field|logLevel
specifier|private
name|LoggingLevel
name|logLevel
init|=
name|LoggingLevel
operator|.
name|INFO
decl_stmt|;
DECL|field|traceFilter
specifier|private
name|Predicate
name|traceFilter
decl_stmt|;
DECL|field|traceInterceptors
specifier|private
name|boolean
name|traceInterceptors
decl_stmt|;
DECL|field|traceExceptions
specifier|private
name|boolean
name|traceExceptions
init|=
literal|true
decl_stmt|;
DECL|field|logStackTrace
specifier|private
name|boolean
name|logStackTrace
decl_stmt|;
DECL|field|traceOutExchanges
specifier|private
name|boolean
name|traceOutExchanges
decl_stmt|;
DECL|field|destinationUri
specifier|private
name|String
name|destinationUri
decl_stmt|;
DECL|field|destination
specifier|private
name|Endpoint
name|destination
decl_stmt|;
DECL|field|useJpa
specifier|private
name|boolean
name|useJpa
decl_stmt|;
DECL|field|logger
specifier|private
name|CamelLogProcessor
name|logger
decl_stmt|;
DECL|field|traceInterceptorFactory
specifier|private
name|TraceInterceptorFactory
name|traceInterceptorFactory
init|=
operator|new
name|DefaultTraceInterceptorFactory
argument_list|()
decl_stmt|;
DECL|field|traceHandler
specifier|private
name|TraceEventHandler
name|traceHandler
decl_stmt|;
DECL|field|jpaTraceEventMessageClassName
specifier|private
name|String
name|jpaTraceEventMessageClassName
init|=
name|JPA_TRACE_EVENT_MESSAGE
decl_stmt|;
comment|/**      * Creates a new tracer.      *      * @param context Camel context      * @return a new tracer      */
DECL|method|createTracer (CamelContext context)
specifier|public
specifier|static
name|Tracer
name|createTracer
parameter_list|(
name|CamelContext
name|context
parameter_list|)
block|{
name|Tracer
name|tracer
init|=
operator|new
name|Tracer
argument_list|()
decl_stmt|;
comment|// lets see if we have a formatter if so use it
name|TraceFormatter
name|formatter
init|=
name|context
operator|.
name|getRegistry
argument_list|()
operator|.
name|lookup
argument_list|(
literal|"traceFormatter"
argument_list|,
name|TraceFormatter
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|formatter
operator|!=
literal|null
condition|)
block|{
name|tracer
operator|.
name|setFormatter
argument_list|(
name|formatter
argument_list|)
expr_stmt|;
block|}
return|return
name|tracer
return|;
block|}
comment|/**      * A helper method to return the Tracer instance if one is enabled      *      * @return the tracer or null if none can be found      */
DECL|method|getTracer (CamelContext context)
specifier|public
specifier|static
name|Tracer
name|getTracer
parameter_list|(
name|CamelContext
name|context
parameter_list|)
block|{
name|List
argument_list|<
name|InterceptStrategy
argument_list|>
name|list
init|=
name|context
operator|.
name|getInterceptStrategies
argument_list|()
decl_stmt|;
for|for
control|(
name|InterceptStrategy
name|interceptStrategy
range|:
name|list
control|)
block|{
if|if
condition|(
name|interceptStrategy
operator|instanceof
name|Tracer
condition|)
block|{
return|return
operator|(
name|Tracer
operator|)
name|interceptStrategy
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Gets the logger to be used for tracers that can format and log a given exchange.      *      * @param formatter the exchange formatter      * @return the logger to use      */
DECL|method|getLogger (ExchangeFormatter formatter)
specifier|public
specifier|synchronized
name|CamelLogProcessor
name|getLogger
parameter_list|(
name|ExchangeFormatter
name|formatter
parameter_list|)
block|{
if|if
condition|(
name|logger
operator|==
literal|null
condition|)
block|{
name|logger
operator|=
operator|new
name|CamelLogProcessor
argument_list|(
operator|new
name|CamelLogger
argument_list|(
name|getLogName
argument_list|()
argument_list|,
name|getLogLevel
argument_list|()
argument_list|)
argument_list|,
name|formatter
argument_list|)
expr_stmt|;
block|}
return|return
name|logger
return|;
block|}
DECL|method|wrapProcessorInInterceptors (CamelContext context, ProcessorDefinition<?> definition, Processor target, Processor nextTarget)
specifier|public
name|Processor
name|wrapProcessorInInterceptors
parameter_list|(
name|CamelContext
name|context
parameter_list|,
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|definition
parameter_list|,
name|Processor
name|target
parameter_list|,
name|Processor
name|nextTarget
parameter_list|)
throws|throws
name|Exception
block|{
comment|// Force the creation of an id, otherwise the id is not available when the trace formatter is
comment|// outputting trace information
name|RouteDefinitionHelper
operator|.
name|forceAssignIds
argument_list|(
name|context
argument_list|,
name|definition
argument_list|)
expr_stmt|;
return|return
name|getTraceInterceptorFactory
argument_list|()
operator|.
name|createTraceInterceptor
argument_list|(
name|definition
argument_list|,
name|target
argument_list|,
name|formatter
argument_list|,
name|this
argument_list|)
return|;
block|}
DECL|method|getFormatter ()
specifier|public
name|TraceFormatter
name|getFormatter
parameter_list|()
block|{
return|return
name|formatter
return|;
block|}
DECL|method|getDefaultTraceFormatter ()
specifier|public
name|DefaultTraceFormatter
name|getDefaultTraceFormatter
parameter_list|()
block|{
if|if
condition|(
name|formatter
operator|instanceof
name|DefaultTraceFormatter
condition|)
block|{
return|return
operator|(
name|DefaultTraceFormatter
operator|)
name|formatter
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|setFormatter (TraceFormatter formatter)
specifier|public
name|void
name|setFormatter
parameter_list|(
name|TraceFormatter
name|formatter
parameter_list|)
block|{
name|this
operator|.
name|formatter
operator|=
name|formatter
expr_stmt|;
block|}
DECL|method|setEnabled (boolean flag)
specifier|public
name|void
name|setEnabled
parameter_list|(
name|boolean
name|flag
parameter_list|)
block|{
name|enabled
operator|=
name|flag
expr_stmt|;
block|}
DECL|method|isEnabled ()
specifier|public
name|boolean
name|isEnabled
parameter_list|()
block|{
return|return
name|enabled
return|;
block|}
DECL|method|isTraceInterceptors ()
specifier|public
name|boolean
name|isTraceInterceptors
parameter_list|()
block|{
return|return
name|traceInterceptors
return|;
block|}
comment|/**      * Sets whether interceptors should be traced or not      */
DECL|method|setTraceInterceptors (boolean traceInterceptors)
specifier|public
name|void
name|setTraceInterceptors
parameter_list|(
name|boolean
name|traceInterceptors
parameter_list|)
block|{
name|this
operator|.
name|traceInterceptors
operator|=
name|traceInterceptors
expr_stmt|;
block|}
DECL|method|getTraceFilter ()
specifier|public
name|Predicate
name|getTraceFilter
parameter_list|()
block|{
return|return
name|traceFilter
return|;
block|}
comment|/**      * Sets a predicate to be used as filter when tracing      */
DECL|method|setTraceFilter (Predicate traceFilter)
specifier|public
name|void
name|setTraceFilter
parameter_list|(
name|Predicate
name|traceFilter
parameter_list|)
block|{
name|this
operator|.
name|traceFilter
operator|=
name|traceFilter
expr_stmt|;
block|}
DECL|method|getLogLevel ()
specifier|public
name|LoggingLevel
name|getLogLevel
parameter_list|()
block|{
return|return
name|logLevel
return|;
block|}
comment|/**      * Sets the logging level to output tracing. Will use<tt>INFO</tt> level by default.      */
DECL|method|setLogLevel (LoggingLevel logLevel)
specifier|public
name|void
name|setLogLevel
parameter_list|(
name|LoggingLevel
name|logLevel
parameter_list|)
block|{
name|this
operator|.
name|logLevel
operator|=
name|logLevel
expr_stmt|;
comment|// update logger if its in use
if|if
condition|(
name|logger
operator|!=
literal|null
condition|)
block|{
name|logger
operator|.
name|getLogger
argument_list|()
operator|.
name|setLevel
argument_list|(
name|logLevel
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|isTraceExceptions ()
specifier|public
name|boolean
name|isTraceExceptions
parameter_list|()
block|{
return|return
name|traceExceptions
return|;
block|}
comment|/**      * Sets whether thrown exceptions should be traced      */
DECL|method|setTraceExceptions (boolean traceExceptions)
specifier|public
name|void
name|setTraceExceptions
parameter_list|(
name|boolean
name|traceExceptions
parameter_list|)
block|{
name|this
operator|.
name|traceExceptions
operator|=
name|traceExceptions
expr_stmt|;
block|}
DECL|method|isLogStackTrace ()
specifier|public
name|boolean
name|isLogStackTrace
parameter_list|()
block|{
return|return
name|logStackTrace
return|;
block|}
comment|/**      * Sets whether thrown exception stacktrace should be traced, if disabled then only the exception message is logged      */
DECL|method|setLogStackTrace (boolean logStackTrace)
specifier|public
name|void
name|setLogStackTrace
parameter_list|(
name|boolean
name|logStackTrace
parameter_list|)
block|{
name|this
operator|.
name|logStackTrace
operator|=
name|logStackTrace
expr_stmt|;
block|}
DECL|method|getLogName ()
specifier|public
name|String
name|getLogName
parameter_list|()
block|{
return|return
name|logName
return|;
block|}
comment|/**      * Sets the logging name to use.      * Will default use<tt>org.apache.camel.processor.interceptor.TraceInterceptor<tt>.      */
DECL|method|setLogName (String logName)
specifier|public
name|void
name|setLogName
parameter_list|(
name|String
name|logName
parameter_list|)
block|{
name|this
operator|.
name|logName
operator|=
name|logName
expr_stmt|;
comment|// update logger if its in use
if|if
condition|(
name|logger
operator|!=
literal|null
condition|)
block|{
name|logger
operator|.
name|getLogger
argument_list|()
operator|.
name|setLogName
argument_list|(
name|logName
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Sets whether exchanges coming out of processors should be traced      */
DECL|method|setTraceOutExchanges (boolean traceOutExchanges)
specifier|public
name|void
name|setTraceOutExchanges
parameter_list|(
name|boolean
name|traceOutExchanges
parameter_list|)
block|{
name|this
operator|.
name|traceOutExchanges
operator|=
name|traceOutExchanges
expr_stmt|;
block|}
DECL|method|isTraceOutExchanges ()
specifier|public
name|boolean
name|isTraceOutExchanges
parameter_list|()
block|{
return|return
name|traceOutExchanges
return|;
block|}
DECL|method|getDestinationUri ()
specifier|public
name|String
name|getDestinationUri
parameter_list|()
block|{
return|return
name|destinationUri
return|;
block|}
comment|/**      * Sets an optional destination to send the traced Exchange.      *<p/>      * Can be used to store tracing as files, in a database or whatever. The routing of the Exchange      * will happen synchronously and the original route will first continue when this destination routing      * has been completed.      */
DECL|method|setDestinationUri (String destinationUri)
specifier|public
name|void
name|setDestinationUri
parameter_list|(
name|String
name|destinationUri
parameter_list|)
block|{
name|this
operator|.
name|destinationUri
operator|=
name|destinationUri
expr_stmt|;
block|}
DECL|method|getDestination ()
specifier|public
name|Endpoint
name|getDestination
parameter_list|()
block|{
return|return
name|destination
return|;
block|}
comment|/**      * See {@link #setDestinationUri(String)}      */
DECL|method|setDestination (Endpoint destination)
specifier|public
name|void
name|setDestination
parameter_list|(
name|Endpoint
name|destination
parameter_list|)
block|{
name|this
operator|.
name|destination
operator|=
name|destination
expr_stmt|;
block|}
DECL|method|isUseJpa ()
specifier|public
name|boolean
name|isUseJpa
parameter_list|()
block|{
return|return
name|useJpa
return|;
block|}
comment|/**      * Sets whether we should use a JpaTraceEventMessage instead of      * an ordinary {@link org.apache.camel.processor.interceptor.DefaultTraceEventMessage}      *<p/>      * Use this to allow persistence of trace events into a database using JPA.      * This requires camel-jpa in the classpath.      */
DECL|method|setUseJpa (boolean useJpa)
specifier|public
name|void
name|setUseJpa
parameter_list|(
name|boolean
name|useJpa
parameter_list|)
block|{
name|this
operator|.
name|useJpa
operator|=
name|useJpa
expr_stmt|;
block|}
DECL|method|getTraceInterceptorFactory ()
specifier|public
name|TraceInterceptorFactory
name|getTraceInterceptorFactory
parameter_list|()
block|{
return|return
name|this
operator|.
name|traceInterceptorFactory
return|;
block|}
comment|/**      * Set the factory to be used to create the trace interceptor.      * It is expected that the factory will create a subclass of TraceInterceptor.      *<p/>      * Use this to take complete control of how trace events are handled.      * The TraceInterceptorFactory should only be set before any routes are created, hence this      * method is not thread safe.      */
DECL|method|setTraceInterceptorFactory (TraceInterceptorFactory traceInterceptorFactory)
specifier|public
name|void
name|setTraceInterceptorFactory
parameter_list|(
name|TraceInterceptorFactory
name|traceInterceptorFactory
parameter_list|)
block|{
name|this
operator|.
name|traceInterceptorFactory
operator|=
name|traceInterceptorFactory
expr_stmt|;
block|}
DECL|method|getTraceHandler ()
specifier|public
name|TraceEventHandler
name|getTraceHandler
parameter_list|()
block|{
return|return
name|traceHandler
return|;
block|}
comment|/**      * Set the object to be used to perform tracing.      *<p/>      * Use this to take more control of how trace events are persisted.      * Setting the traceHandler provides a simpler mechanism for controlling tracing      * than the TraceInterceptorFactory.      * The TraceHandler should only be set before any routes are created, hence this      * method is not thread safe.      */
DECL|method|setTraceHandler (TraceEventHandler traceHandler)
specifier|public
name|void
name|setTraceHandler
parameter_list|(
name|TraceEventHandler
name|traceHandler
parameter_list|)
block|{
name|this
operator|.
name|traceHandler
operator|=
name|traceHandler
expr_stmt|;
block|}
DECL|method|getJpaTraceEventMessageClassName ()
specifier|public
name|String
name|getJpaTraceEventMessageClassName
parameter_list|()
block|{
return|return
name|jpaTraceEventMessageClassName
return|;
block|}
comment|/**      * Set the fully qualified name of the class to be used by the JPA event tracing.      *<p/>      * The class must exist in the classpath and be available for dynamic loading.      * The class name should only be set before any routes are created, hence this      * method is not thread safe.      */
DECL|method|setJpaTraceEventMessageClassName (String jpaTraceEventMessageClassName)
specifier|public
name|void
name|setJpaTraceEventMessageClassName
parameter_list|(
name|String
name|jpaTraceEventMessageClassName
parameter_list|)
block|{
name|this
operator|.
name|jpaTraceEventMessageClassName
operator|=
name|jpaTraceEventMessageClassName
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Tracer"
return|;
block|}
DECL|method|start ()
specifier|public
name|void
name|start
parameter_list|()
throws|throws
name|Exception
block|{     }
DECL|method|stop ()
specifier|public
name|void
name|stop
parameter_list|()
throws|throws
name|Exception
block|{     }
block|}
end_class

end_unit

