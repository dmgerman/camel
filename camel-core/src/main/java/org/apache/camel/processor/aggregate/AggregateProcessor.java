begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.processor.aggregate
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
operator|.
name|aggregate
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelExchangeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Endpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Expression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Navigate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|NoSuchEndpointException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Processor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|ProducerTemplate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|TimeoutMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Traceable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|impl
operator|.
name|LoggingExceptionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|AggregationRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|ExceptionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|RecoverableAggregationRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|ShutdownPrepared
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|Synchronization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|DefaultTimeoutMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|ServiceSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ExchangeHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|LRUCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ObjectHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ServiceHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|StopWatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|TimeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * An implementation of the<a  * href="http://camel.apache.org/aggregator2.html">Aggregator</a>  * pattern where a batch of messages are processed (up to a maximum amount or  * until some timeout is reached) and messages for the same correlation key are  * combined together using some kind of {@link AggregationStrategy}  * (by default the latest message is used) to compress many message exchanges  * into a smaller number of exchanges.  *<p/>  * A good example of this is stock market data; you may be receiving 30,000  * messages/second and you may want to throttle it right down so that multiple  * messages for the same stock are combined (or just the latest message is used  * and older prices are discarded). Another idea is to combine line item messages  * together into a single invoice message.  */
end_comment

begin_class
DECL|class|AggregateProcessor
specifier|public
class|class
name|AggregateProcessor
extends|extends
name|ServiceSupport
implements|implements
name|Processor
implements|,
name|Navigate
argument_list|<
name|Processor
argument_list|>
implements|,
name|Traceable
implements|,
name|ShutdownPrepared
block|{
DECL|field|AGGREGATE_TIMEOUT_CHECKER
specifier|public
specifier|static
specifier|final
name|String
name|AGGREGATE_TIMEOUT_CHECKER
init|=
literal|"AggregateTimeoutChecker"
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|AggregateProcessor
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|lock
specifier|private
specifier|final
name|Lock
name|lock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
DECL|field|camelContext
specifier|private
specifier|final
name|CamelContext
name|camelContext
decl_stmt|;
DECL|field|processor
specifier|private
specifier|final
name|Processor
name|processor
decl_stmt|;
DECL|field|aggregationStrategy
specifier|private
specifier|final
name|AggregationStrategy
name|aggregationStrategy
decl_stmt|;
DECL|field|correlationExpression
specifier|private
specifier|final
name|Expression
name|correlationExpression
decl_stmt|;
DECL|field|executorService
specifier|private
specifier|final
name|ExecutorService
name|executorService
decl_stmt|;
DECL|field|shutdownExecutorService
specifier|private
specifier|final
name|boolean
name|shutdownExecutorService
decl_stmt|;
DECL|field|timeoutCheckerExecutorService
specifier|private
name|ScheduledExecutorService
name|timeoutCheckerExecutorService
decl_stmt|;
DECL|field|shutdownTimeoutCheckerExecutorService
specifier|private
name|boolean
name|shutdownTimeoutCheckerExecutorService
decl_stmt|;
DECL|field|recoverService
specifier|private
name|ScheduledExecutorService
name|recoverService
decl_stmt|;
comment|// store correlation key -> exchange id in timeout map
DECL|field|timeoutMap
specifier|private
name|TimeoutMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|timeoutMap
decl_stmt|;
DECL|field|exceptionHandler
specifier|private
name|ExceptionHandler
name|exceptionHandler
init|=
operator|new
name|LoggingExceptionHandler
argument_list|(
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|aggregationRepository
specifier|private
name|AggregationRepository
name|aggregationRepository
init|=
operator|new
name|MemoryAggregationRepository
argument_list|()
decl_stmt|;
DECL|field|closedCorrelationKeys
specifier|private
name|Map
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|closedCorrelationKeys
decl_stmt|;
DECL|field|batchConsumerCorrelationKeys
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|batchConsumerCorrelationKeys
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|inProgressCompleteExchanges
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|inProgressCompleteExchanges
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|redeliveryState
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RedeliveryData
argument_list|>
name|redeliveryState
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|RedeliveryData
argument_list|>
argument_list|()
decl_stmt|;
comment|// keep booking about redelivery
DECL|class|RedeliveryData
specifier|private
class|class
name|RedeliveryData
block|{
DECL|field|redeliveryCounter
name|int
name|redeliveryCounter
decl_stmt|;
block|}
comment|// options
DECL|field|ignoreInvalidCorrelationKeys
specifier|private
name|boolean
name|ignoreInvalidCorrelationKeys
decl_stmt|;
DECL|field|closeCorrelationKeyOnCompletion
specifier|private
name|Integer
name|closeCorrelationKeyOnCompletion
decl_stmt|;
DECL|field|parallelProcessing
specifier|private
name|boolean
name|parallelProcessing
decl_stmt|;
comment|// different ways to have completion triggered
DECL|field|eagerCheckCompletion
specifier|private
name|boolean
name|eagerCheckCompletion
decl_stmt|;
DECL|field|completionPredicate
specifier|private
name|Predicate
name|completionPredicate
decl_stmt|;
DECL|field|completionTimeout
specifier|private
name|long
name|completionTimeout
decl_stmt|;
DECL|field|completionTimeoutExpression
specifier|private
name|Expression
name|completionTimeoutExpression
decl_stmt|;
DECL|field|completionInterval
specifier|private
name|long
name|completionInterval
decl_stmt|;
DECL|field|completionSize
specifier|private
name|int
name|completionSize
decl_stmt|;
DECL|field|completionSizeExpression
specifier|private
name|Expression
name|completionSizeExpression
decl_stmt|;
DECL|field|completionFromBatchConsumer
specifier|private
name|boolean
name|completionFromBatchConsumer
decl_stmt|;
DECL|field|batchConsumerCounter
specifier|private
name|AtomicInteger
name|batchConsumerCounter
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|field|discardOnCompletionTimeout
specifier|private
name|boolean
name|discardOnCompletionTimeout
decl_stmt|;
DECL|field|forceCompletionOnStop
specifier|private
name|boolean
name|forceCompletionOnStop
decl_stmt|;
DECL|field|deadLetterProducerTemplate
specifier|private
name|ProducerTemplate
name|deadLetterProducerTemplate
decl_stmt|;
DECL|method|AggregateProcessor (CamelContext camelContext, Processor processor, Expression correlationExpression, AggregationStrategy aggregationStrategy, ExecutorService executorService, boolean shutdownExecutorService)
specifier|public
name|AggregateProcessor
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|,
name|Processor
name|processor
parameter_list|,
name|Expression
name|correlationExpression
parameter_list|,
name|AggregationStrategy
name|aggregationStrategy
parameter_list|,
name|ExecutorService
name|executorService
parameter_list|,
name|boolean
name|shutdownExecutorService
parameter_list|)
block|{
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|camelContext
argument_list|,
literal|"camelContext"
argument_list|)
expr_stmt|;
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|processor
argument_list|,
literal|"processor"
argument_list|)
expr_stmt|;
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|correlationExpression
argument_list|,
literal|"correlationExpression"
argument_list|)
expr_stmt|;
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|aggregationStrategy
argument_list|,
literal|"aggregationStrategy"
argument_list|)
expr_stmt|;
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|executorService
argument_list|,
literal|"executorService"
argument_list|)
expr_stmt|;
name|this
operator|.
name|camelContext
operator|=
name|camelContext
expr_stmt|;
name|this
operator|.
name|processor
operator|=
name|processor
expr_stmt|;
name|this
operator|.
name|correlationExpression
operator|=
name|correlationExpression
expr_stmt|;
name|this
operator|.
name|aggregationStrategy
operator|=
name|aggregationStrategy
expr_stmt|;
name|this
operator|.
name|executorService
operator|=
name|executorService
expr_stmt|;
name|this
operator|.
name|shutdownExecutorService
operator|=
name|shutdownExecutorService
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"AggregateProcessor[to: "
operator|+
name|processor
operator|+
literal|"]"
return|;
block|}
DECL|method|getTraceLabel ()
specifier|public
name|String
name|getTraceLabel
parameter_list|()
block|{
return|return
literal|"aggregate["
operator|+
name|correlationExpression
operator|+
literal|"]"
return|;
block|}
DECL|method|next ()
specifier|public
name|List
argument_list|<
name|Processor
argument_list|>
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|Processor
argument_list|>
name|answer
init|=
operator|new
name|ArrayList
argument_list|<
name|Processor
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|answer
operator|.
name|add
argument_list|(
name|processor
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|processor
operator|!=
literal|null
return|;
block|}
DECL|method|process (Exchange exchange)
specifier|public
name|void
name|process
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
comment|//check for the special header to force completion of all groups (and ignore the exchange otherwise)
name|boolean
name|completeAllGroups
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|Exchange
operator|.
name|AGGREGATION_COMPLETE_ALL_GROUPS
argument_list|,
literal|false
argument_list|,
name|boolean
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|completeAllGroups
condition|)
block|{
name|forceCompletionOfAllGroups
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// compute correlation expression
name|String
name|key
init|=
name|correlationExpression
operator|.
name|evaluate
argument_list|(
name|exchange
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|ObjectHelper
operator|.
name|isEmpty
argument_list|(
name|key
argument_list|)
condition|)
block|{
comment|// we have a bad correlation key
if|if
condition|(
name|isIgnoreInvalidCorrelationKeys
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Invalid correlation key. This Exchange will be ignored: {}"
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
throw|throw
operator|new
name|CamelExchangeException
argument_list|(
literal|"Invalid correlation key"
argument_list|,
name|exchange
argument_list|)
throw|;
block|}
block|}
comment|// is the correlation key closed?
if|if
condition|(
name|closedCorrelationKeys
operator|!=
literal|null
operator|&&
name|closedCorrelationKeys
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClosedCorrelationKeyException
argument_list|(
name|key
argument_list|,
name|exchange
argument_list|)
throw|;
block|}
comment|// copy exchange, and do not share the unit of work
comment|// the aggregated output runs in another unit of work
name|Exchange
name|copy
init|=
name|ExchangeHelper
operator|.
name|createCorrelatedCopy
argument_list|(
name|exchange
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// when memory based then its fast using synchronized, but if the aggregation repository is IO
comment|// bound such as JPA etc then concurrent aggregation per correlation key could
comment|// improve performance as we can run aggregation repository get/add in parallel
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|doAggregation
argument_list|(
name|key
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Aggregates the exchange with the given correlation key      *<p/>      * This method<b>must</b> be run synchronized as we cannot aggregate the same correlation key      * in parallel.      *      * @param key      the correlation key      * @param exchange the exchange      * @return the aggregated exchange      * @throws org.apache.camel.CamelExchangeException is thrown if error aggregating      */
DECL|method|doAggregation (String key, Exchange exchange)
specifier|private
name|Exchange
name|doAggregation
parameter_list|(
name|String
name|key
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|CamelExchangeException
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"onAggregation +++ start +++ with correlation key: {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|Exchange
name|answer
decl_stmt|;
name|Exchange
name|oldExchange
init|=
name|aggregationRepository
operator|.
name|get
argument_list|(
name|exchange
operator|.
name|getContext
argument_list|()
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|Exchange
name|newExchange
init|=
name|exchange
decl_stmt|;
name|Integer
name|size
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|oldExchange
operator|!=
literal|null
condition|)
block|{
name|size
operator|=
name|oldExchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_SIZE
argument_list|,
literal|0
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
expr_stmt|;
name|size
operator|++
expr_stmt|;
block|}
comment|// check if we are complete
name|String
name|complete
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isEagerCheckCompletion
argument_list|()
condition|)
block|{
comment|// put the current aggregated size on the exchange so its avail during completion check
name|newExchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_SIZE
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|complete
operator|=
name|isCompleted
argument_list|(
name|key
argument_list|,
name|newExchange
argument_list|)
expr_stmt|;
comment|// remove it afterwards
name|newExchange
operator|.
name|removeProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_SIZE
argument_list|)
expr_stmt|;
block|}
comment|// prepare the exchanges for aggregation and aggregate it
name|ExchangeHelper
operator|.
name|prepareAggregation
argument_list|(
name|oldExchange
argument_list|,
name|newExchange
argument_list|)
expr_stmt|;
comment|// must catch any exception from aggregation
try|try
block|{
name|answer
operator|=
name|onAggregation
argument_list|(
name|oldExchange
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CamelExchangeException
argument_list|(
literal|"Error occurred during aggregation"
argument_list|,
name|exchange
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CamelExchangeException
argument_list|(
literal|"AggregationStrategy "
operator|+
name|aggregationStrategy
operator|+
literal|" returned null which is not allowed"
argument_list|,
name|exchange
argument_list|)
throw|;
block|}
comment|// update the aggregated size
name|answer
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_SIZE
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|// maybe we should check completion after the aggregation
if|if
condition|(
operator|!
name|isEagerCheckCompletion
argument_list|()
condition|)
block|{
name|complete
operator|=
name|isCompleted
argument_list|(
name|key
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
comment|// only need to update aggregation repository if we are not complete
if|if
condition|(
name|complete
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"In progress aggregated exchange: {} with correlation key: {}"
argument_list|,
name|answer
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|aggregationRepository
operator|.
name|add
argument_list|(
name|exchange
operator|.
name|getContext
argument_list|()
argument_list|,
name|key
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// if batch consumer completion is enabled then we need to complete the group
if|if
condition|(
literal|"consumer"
operator|.
name|equals
argument_list|(
name|complete
argument_list|)
condition|)
block|{
for|for
control|(
name|String
name|batchKey
range|:
name|batchConsumerCorrelationKeys
control|)
block|{
name|Exchange
name|batchAnswer
decl_stmt|;
if|if
condition|(
name|batchKey
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
comment|// skip the current aggregated key as we have already aggregated it and have the answer
name|batchAnswer
operator|=
name|answer
expr_stmt|;
block|}
else|else
block|{
name|batchAnswer
operator|=
name|aggregationRepository
operator|.
name|get
argument_list|(
name|camelContext
argument_list|,
name|batchKey
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|batchAnswer
operator|!=
literal|null
condition|)
block|{
name|batchAnswer
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_COMPLETED_BY
argument_list|,
name|complete
argument_list|)
expr_stmt|;
name|onCompletion
argument_list|(
name|batchKey
argument_list|,
name|batchAnswer
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
name|batchConsumerCorrelationKeys
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// we are complete for this exchange
name|answer
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_COMPLETED_BY
argument_list|,
name|complete
argument_list|)
expr_stmt|;
name|onCompletion
argument_list|(
name|key
argument_list|,
name|answer
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"onAggregation +++  end  +++ with correlation key: {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
comment|/**      * Tests whether the given exchange is complete or not      *      * @param key      the correlation key      * @param exchange the incoming exchange      * @return<tt>null</tt> if not completed, otherwise a String with the type that triggered the completion      */
DECL|method|isCompleted (String key, Exchange exchange)
specifier|protected
name|String
name|isCompleted
parameter_list|(
name|String
name|key
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
name|getCompletionPredicate
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|boolean
name|answer
init|=
name|getCompletionPredicate
argument_list|()
operator|.
name|matches
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
condition|)
block|{
return|return
literal|"predicate"
return|;
block|}
block|}
if|if
condition|(
name|getCompletionSizeExpression
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Integer
name|value
init|=
name|getCompletionSizeExpression
argument_list|()
operator|.
name|evaluate
argument_list|(
name|exchange
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|value
operator|>
literal|0
condition|)
block|{
name|int
name|size
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_SIZE
argument_list|,
literal|1
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>=
name|value
condition|)
block|{
return|return
literal|"size"
return|;
block|}
else|else
block|{
comment|// not completed yet
return|return
literal|null
return|;
block|}
block|}
block|}
if|if
condition|(
name|getCompletionSize
argument_list|()
operator|>
literal|0
condition|)
block|{
name|int
name|size
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_SIZE
argument_list|,
literal|1
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>=
name|getCompletionSize
argument_list|()
condition|)
block|{
return|return
literal|"size"
return|;
block|}
block|}
comment|// timeout can be either evaluated based on an expression or from a fixed value
comment|// expression takes precedence
name|boolean
name|timeoutSet
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|getCompletionTimeoutExpression
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Long
name|value
init|=
name|getCompletionTimeoutExpression
argument_list|()
operator|.
name|evaluate
argument_list|(
name|exchange
argument_list|,
name|Long
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|value
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Updating correlation key {} to timeout after {} ms. as exchange received: {}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|key
block|,
name|value
block|,
name|exchange
block|}
argument_list|)
expr_stmt|;
block|}
name|addExchangeToTimeoutMap
argument_list|(
name|key
argument_list|,
name|exchange
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|timeoutSet
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|timeoutSet
operator|&&
name|getCompletionTimeout
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// timeout is used so use the timeout map to keep an eye on this
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Updating correlation key {} to timeout after {} ms. as exchange received: {}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|key
block|,
name|getCompletionTimeout
argument_list|()
block|,
name|exchange
block|}
argument_list|)
expr_stmt|;
block|}
name|addExchangeToTimeoutMap
argument_list|(
name|key
argument_list|,
name|exchange
argument_list|,
name|getCompletionTimeout
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isCompletionFromBatchConsumer
argument_list|()
condition|)
block|{
name|batchConsumerCorrelationKeys
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|batchConsumerCounter
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|int
name|size
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|BATCH_SIZE
argument_list|,
literal|0
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|batchConsumerCounter
operator|.
name|intValue
argument_list|()
operator|>=
name|size
condition|)
block|{
comment|// batch consumer is complete then reset the counter
name|batchConsumerCounter
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|"consumer"
return|;
block|}
block|}
comment|// not complete
return|return
literal|null
return|;
block|}
DECL|method|onAggregation (Exchange oldExchange, Exchange newExchange)
specifier|protected
name|Exchange
name|onAggregation
parameter_list|(
name|Exchange
name|oldExchange
parameter_list|,
name|Exchange
name|newExchange
parameter_list|)
block|{
return|return
name|aggregationStrategy
operator|.
name|aggregate
argument_list|(
name|oldExchange
argument_list|,
name|newExchange
argument_list|)
return|;
block|}
DECL|method|onCompletion (final String key, final Exchange exchange, boolean fromTimeout)
specifier|protected
name|void
name|onCompletion
parameter_list|(
specifier|final
name|String
name|key
parameter_list|,
specifier|final
name|Exchange
name|exchange
parameter_list|,
name|boolean
name|fromTimeout
parameter_list|)
block|{
comment|// store the correlation key as property
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_CORRELATION_KEY
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|// remove from repository as its completed
name|aggregationRepository
operator|.
name|remove
argument_list|(
name|exchange
operator|.
name|getContext
argument_list|()
argument_list|,
name|key
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fromTimeout
operator|&&
name|timeoutMap
operator|!=
literal|null
condition|)
block|{
comment|// cleanup timeout map if it was a incoming exchange which triggered the timeout (and not the timeout checker)
name|timeoutMap
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
comment|// this key has been closed so add it to the closed map
if|if
condition|(
name|closedCorrelationKeys
operator|!=
literal|null
condition|)
block|{
name|closedCorrelationKeys
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fromTimeout
condition|)
block|{
comment|// invoke timeout if its timeout aware aggregation strategy,
comment|// to allow any custom processing before discarding the exchange
if|if
condition|(
name|aggregationStrategy
operator|instanceof
name|TimeoutAwareAggregationStrategy
condition|)
block|{
name|long
name|timeout
init|=
name|getCompletionTimeout
argument_list|()
operator|>
literal|0
condition|?
name|getCompletionTimeout
argument_list|()
else|:
operator|-
literal|1
decl_stmt|;
operator|(
operator|(
name|TimeoutAwareAggregationStrategy
operator|)
name|aggregationStrategy
operator|)
operator|.
name|timeout
argument_list|(
name|exchange
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fromTimeout
operator|&&
name|isDiscardOnCompletionTimeout
argument_list|()
condition|)
block|{
comment|// discard due timeout
name|LOG
operator|.
name|debug
argument_list|(
literal|"Aggregation for correlation key {} discarding aggregated exchange: ()"
argument_list|,
name|key
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
comment|// must confirm the discarded exchange
name|aggregationRepository
operator|.
name|confirm
argument_list|(
name|exchange
operator|.
name|getContext
argument_list|()
argument_list|,
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|)
expr_stmt|;
comment|// and remove redelivery state as well
name|redeliveryState
operator|.
name|remove
argument_list|(
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// the aggregated exchange should be published (sent out)
name|onSubmitCompletion
argument_list|(
name|key
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|onSubmitCompletion (final Object key, final Exchange exchange)
specifier|private
name|void
name|onSubmitCompletion
parameter_list|(
specifier|final
name|Object
name|key
parameter_list|,
specifier|final
name|Exchange
name|exchange
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Aggregation complete for correlation key {} sending aggregated exchange: {}"
argument_list|,
name|key
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
comment|// add this as in progress before we submit the task
name|inProgressCompleteExchanges
operator|.
name|add
argument_list|(
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|)
expr_stmt|;
comment|// invoke the on completion callback
if|if
condition|(
name|aggregationStrategy
operator|instanceof
name|CompletionAwareAggregationStrategy
condition|)
block|{
operator|(
operator|(
name|CompletionAwareAggregationStrategy
operator|)
name|aggregationStrategy
operator|)
operator|.
name|onCompletion
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
comment|// send this exchange
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing aggregated exchange: {}"
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
comment|// add on completion task so we remember to update the inProgressCompleteExchanges
name|exchange
operator|.
name|addOnCompletion
argument_list|(
operator|new
name|AggregateOnCompletion
argument_list|(
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|processor
operator|.
name|process
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|exchange
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|// log exception if there was a problem
if|if
condition|(
name|exchange
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// if there was an exception then let the exception handler handle it
name|getExceptionHandler
argument_list|()
operator|.
name|handleException
argument_list|(
literal|"Error processing aggregated exchange"
argument_list|,
name|exchange
argument_list|,
name|exchange
operator|.
name|getException
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Processing aggregated exchange: {} complete."
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**      * Restores the timeout map with timeout values from the aggregation repository.      *<p/>      * This is needed in case the aggregator has been stopped and started again (for example a server restart).      * Then the existing exchanges from the {@link AggregationRepository} must have its timeout conditions restored.      */
DECL|method|restoreTimeoutMapFromAggregationRepository ()
specifier|protected
name|void
name|restoreTimeoutMapFromAggregationRepository
parameter_list|()
throws|throws
name|Exception
block|{
comment|// grab the timeout value for each partly aggregated exchange
name|Set
argument_list|<
name|String
argument_list|>
name|keys
init|=
name|aggregationRepository
operator|.
name|getKeys
argument_list|()
decl_stmt|;
if|if
condition|(
name|keys
operator|==
literal|null
operator|||
name|keys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|StopWatch
name|watch
init|=
operator|new
name|StopWatch
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Starting restoring CompletionTimeout for {} existing exchanges from the aggregation repository..."
argument_list|,
name|keys
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|key
range|:
name|keys
control|)
block|{
name|Exchange
name|exchange
init|=
name|aggregationRepository
operator|.
name|get
argument_list|(
name|camelContext
argument_list|,
name|key
argument_list|)
decl_stmt|;
comment|// grab the timeout value
name|long
name|timeout
init|=
name|exchange
operator|.
name|hasProperties
argument_list|()
condition|?
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_TIMEOUT
argument_list|,
literal|0
argument_list|,
name|long
operator|.
name|class
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Restoring CompletionTimeout for exchangeId: {} with timeout: {} millis."
argument_list|,
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|addExchangeToTimeoutMap
argument_list|(
name|key
argument_list|,
name|exchange
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
comment|// log duration of this task so end user can see how long it takes to pre-check this upon starting
name|LOG
operator|.
name|info
argument_list|(
literal|"Restored {} CompletionTimeout conditions in the AggregationTimeoutChecker in {}"
argument_list|,
name|timeoutMap
operator|.
name|size
argument_list|()
argument_list|,
name|TimeUtils
operator|.
name|printDuration
argument_list|(
name|watch
operator|.
name|stop
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds the given exchange to the timeout map, which is used by the timeout checker task to trigger timeouts.      *      * @param key      the correlation key      * @param exchange the exchange      * @param timeout  the timeout value in millis      */
DECL|method|addExchangeToTimeoutMap (String key, Exchange exchange, long timeout)
specifier|private
name|void
name|addExchangeToTimeoutMap
parameter_list|(
name|String
name|key
parameter_list|,
name|Exchange
name|exchange
parameter_list|,
name|long
name|timeout
parameter_list|)
block|{
comment|// store the timeout value on the exchange as well, in case we need it later
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_TIMEOUT
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|timeoutMap
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
DECL|method|getCompletionPredicate ()
specifier|public
name|Predicate
name|getCompletionPredicate
parameter_list|()
block|{
return|return
name|completionPredicate
return|;
block|}
DECL|method|setCompletionPredicate (Predicate completionPredicate)
specifier|public
name|void
name|setCompletionPredicate
parameter_list|(
name|Predicate
name|completionPredicate
parameter_list|)
block|{
name|this
operator|.
name|completionPredicate
operator|=
name|completionPredicate
expr_stmt|;
block|}
DECL|method|isEagerCheckCompletion ()
specifier|public
name|boolean
name|isEagerCheckCompletion
parameter_list|()
block|{
return|return
name|eagerCheckCompletion
return|;
block|}
DECL|method|setEagerCheckCompletion (boolean eagerCheckCompletion)
specifier|public
name|void
name|setEagerCheckCompletion
parameter_list|(
name|boolean
name|eagerCheckCompletion
parameter_list|)
block|{
name|this
operator|.
name|eagerCheckCompletion
operator|=
name|eagerCheckCompletion
expr_stmt|;
block|}
DECL|method|getCompletionTimeout ()
specifier|public
name|long
name|getCompletionTimeout
parameter_list|()
block|{
return|return
name|completionTimeout
return|;
block|}
DECL|method|setCompletionTimeout (long completionTimeout)
specifier|public
name|void
name|setCompletionTimeout
parameter_list|(
name|long
name|completionTimeout
parameter_list|)
block|{
name|this
operator|.
name|completionTimeout
operator|=
name|completionTimeout
expr_stmt|;
block|}
DECL|method|getCompletionTimeoutExpression ()
specifier|public
name|Expression
name|getCompletionTimeoutExpression
parameter_list|()
block|{
return|return
name|completionTimeoutExpression
return|;
block|}
DECL|method|setCompletionTimeoutExpression (Expression completionTimeoutExpression)
specifier|public
name|void
name|setCompletionTimeoutExpression
parameter_list|(
name|Expression
name|completionTimeoutExpression
parameter_list|)
block|{
name|this
operator|.
name|completionTimeoutExpression
operator|=
name|completionTimeoutExpression
expr_stmt|;
block|}
DECL|method|getCompletionInterval ()
specifier|public
name|long
name|getCompletionInterval
parameter_list|()
block|{
return|return
name|completionInterval
return|;
block|}
DECL|method|setCompletionInterval (long completionInterval)
specifier|public
name|void
name|setCompletionInterval
parameter_list|(
name|long
name|completionInterval
parameter_list|)
block|{
name|this
operator|.
name|completionInterval
operator|=
name|completionInterval
expr_stmt|;
block|}
DECL|method|getCompletionSize ()
specifier|public
name|int
name|getCompletionSize
parameter_list|()
block|{
return|return
name|completionSize
return|;
block|}
DECL|method|setCompletionSize (int completionSize)
specifier|public
name|void
name|setCompletionSize
parameter_list|(
name|int
name|completionSize
parameter_list|)
block|{
name|this
operator|.
name|completionSize
operator|=
name|completionSize
expr_stmt|;
block|}
DECL|method|getCompletionSizeExpression ()
specifier|public
name|Expression
name|getCompletionSizeExpression
parameter_list|()
block|{
return|return
name|completionSizeExpression
return|;
block|}
DECL|method|setCompletionSizeExpression (Expression completionSizeExpression)
specifier|public
name|void
name|setCompletionSizeExpression
parameter_list|(
name|Expression
name|completionSizeExpression
parameter_list|)
block|{
name|this
operator|.
name|completionSizeExpression
operator|=
name|completionSizeExpression
expr_stmt|;
block|}
DECL|method|isIgnoreInvalidCorrelationKeys ()
specifier|public
name|boolean
name|isIgnoreInvalidCorrelationKeys
parameter_list|()
block|{
return|return
name|ignoreInvalidCorrelationKeys
return|;
block|}
DECL|method|setIgnoreInvalidCorrelationKeys (boolean ignoreInvalidCorrelationKeys)
specifier|public
name|void
name|setIgnoreInvalidCorrelationKeys
parameter_list|(
name|boolean
name|ignoreInvalidCorrelationKeys
parameter_list|)
block|{
name|this
operator|.
name|ignoreInvalidCorrelationKeys
operator|=
name|ignoreInvalidCorrelationKeys
expr_stmt|;
block|}
DECL|method|getCloseCorrelationKeyOnCompletion ()
specifier|public
name|Integer
name|getCloseCorrelationKeyOnCompletion
parameter_list|()
block|{
return|return
name|closeCorrelationKeyOnCompletion
return|;
block|}
DECL|method|setCloseCorrelationKeyOnCompletion (Integer closeCorrelationKeyOnCompletion)
specifier|public
name|void
name|setCloseCorrelationKeyOnCompletion
parameter_list|(
name|Integer
name|closeCorrelationKeyOnCompletion
parameter_list|)
block|{
name|this
operator|.
name|closeCorrelationKeyOnCompletion
operator|=
name|closeCorrelationKeyOnCompletion
expr_stmt|;
block|}
DECL|method|isCompletionFromBatchConsumer ()
specifier|public
name|boolean
name|isCompletionFromBatchConsumer
parameter_list|()
block|{
return|return
name|completionFromBatchConsumer
return|;
block|}
DECL|method|setCompletionFromBatchConsumer (boolean completionFromBatchConsumer)
specifier|public
name|void
name|setCompletionFromBatchConsumer
parameter_list|(
name|boolean
name|completionFromBatchConsumer
parameter_list|)
block|{
name|this
operator|.
name|completionFromBatchConsumer
operator|=
name|completionFromBatchConsumer
expr_stmt|;
block|}
DECL|method|getExceptionHandler ()
specifier|public
name|ExceptionHandler
name|getExceptionHandler
parameter_list|()
block|{
return|return
name|exceptionHandler
return|;
block|}
DECL|method|setExceptionHandler (ExceptionHandler exceptionHandler)
specifier|public
name|void
name|setExceptionHandler
parameter_list|(
name|ExceptionHandler
name|exceptionHandler
parameter_list|)
block|{
name|this
operator|.
name|exceptionHandler
operator|=
name|exceptionHandler
expr_stmt|;
block|}
DECL|method|isParallelProcessing ()
specifier|public
name|boolean
name|isParallelProcessing
parameter_list|()
block|{
return|return
name|parallelProcessing
return|;
block|}
DECL|method|setParallelProcessing (boolean parallelProcessing)
specifier|public
name|void
name|setParallelProcessing
parameter_list|(
name|boolean
name|parallelProcessing
parameter_list|)
block|{
name|this
operator|.
name|parallelProcessing
operator|=
name|parallelProcessing
expr_stmt|;
block|}
DECL|method|getAggregationRepository ()
specifier|public
name|AggregationRepository
name|getAggregationRepository
parameter_list|()
block|{
return|return
name|aggregationRepository
return|;
block|}
DECL|method|setAggregationRepository (AggregationRepository aggregationRepository)
specifier|public
name|void
name|setAggregationRepository
parameter_list|(
name|AggregationRepository
name|aggregationRepository
parameter_list|)
block|{
name|this
operator|.
name|aggregationRepository
operator|=
name|aggregationRepository
expr_stmt|;
block|}
DECL|method|isDiscardOnCompletionTimeout ()
specifier|public
name|boolean
name|isDiscardOnCompletionTimeout
parameter_list|()
block|{
return|return
name|discardOnCompletionTimeout
return|;
block|}
DECL|method|setDiscardOnCompletionTimeout (boolean discardOnCompletionTimeout)
specifier|public
name|void
name|setDiscardOnCompletionTimeout
parameter_list|(
name|boolean
name|discardOnCompletionTimeout
parameter_list|)
block|{
name|this
operator|.
name|discardOnCompletionTimeout
operator|=
name|discardOnCompletionTimeout
expr_stmt|;
block|}
DECL|method|setForceCompletionOnStop (boolean forceCompletionOnStop)
specifier|public
name|void
name|setForceCompletionOnStop
parameter_list|(
name|boolean
name|forceCompletionOnStop
parameter_list|)
block|{
name|this
operator|.
name|forceCompletionOnStop
operator|=
name|forceCompletionOnStop
expr_stmt|;
block|}
DECL|method|setTimeoutCheckerExecutorService (ScheduledExecutorService timeoutCheckerExecutorService)
specifier|public
name|void
name|setTimeoutCheckerExecutorService
parameter_list|(
name|ScheduledExecutorService
name|timeoutCheckerExecutorService
parameter_list|)
block|{
name|this
operator|.
name|timeoutCheckerExecutorService
operator|=
name|timeoutCheckerExecutorService
expr_stmt|;
block|}
DECL|method|getTimeoutCheckerExecutorService ()
specifier|public
name|ScheduledExecutorService
name|getTimeoutCheckerExecutorService
parameter_list|()
block|{
return|return
name|timeoutCheckerExecutorService
return|;
block|}
DECL|method|isShutdownTimeoutCheckerExecutorService ()
specifier|public
name|boolean
name|isShutdownTimeoutCheckerExecutorService
parameter_list|()
block|{
return|return
name|shutdownTimeoutCheckerExecutorService
return|;
block|}
DECL|method|setShutdownTimeoutCheckerExecutorService (boolean shutdownTimeoutCheckerExecutorService)
specifier|public
name|void
name|setShutdownTimeoutCheckerExecutorService
parameter_list|(
name|boolean
name|shutdownTimeoutCheckerExecutorService
parameter_list|)
block|{
name|this
operator|.
name|shutdownTimeoutCheckerExecutorService
operator|=
name|shutdownTimeoutCheckerExecutorService
expr_stmt|;
block|}
comment|/**      * On completion task which keeps the booking of the in progress up to date      */
DECL|class|AggregateOnCompletion
specifier|private
specifier|final
class|class
name|AggregateOnCompletion
implements|implements
name|Synchronization
block|{
DECL|field|exchangeId
specifier|private
specifier|final
name|String
name|exchangeId
decl_stmt|;
DECL|method|AggregateOnCompletion (String exchangeId)
specifier|private
name|AggregateOnCompletion
parameter_list|(
name|String
name|exchangeId
parameter_list|)
block|{
comment|// must use the original exchange id as it could potentially change if send over SEDA etc.
name|this
operator|.
name|exchangeId
operator|=
name|exchangeId
expr_stmt|;
block|}
DECL|method|onFailure (Exchange exchange)
specifier|public
name|void
name|onFailure
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Aggregated exchange onFailure: {}"
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
comment|// must remember to remove in progress when we failed
name|inProgressCompleteExchanges
operator|.
name|remove
argument_list|(
name|exchangeId
argument_list|)
expr_stmt|;
comment|// do not remove redelivery state as we need it when we redeliver again later
block|}
DECL|method|onComplete (Exchange exchange)
specifier|public
name|void
name|onComplete
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Aggregated exchange onComplete: {}"
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
comment|// only confirm if we processed without a problem
try|try
block|{
name|aggregationRepository
operator|.
name|confirm
argument_list|(
name|exchange
operator|.
name|getContext
argument_list|()
argument_list|,
name|exchangeId
argument_list|)
expr_stmt|;
comment|// and remove redelivery state as well
name|redeliveryState
operator|.
name|remove
argument_list|(
name|exchangeId
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// must remember to remove in progress when we are complete
name|inProgressCompleteExchanges
operator|.
name|remove
argument_list|(
name|exchangeId
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"AggregateOnCompletion"
return|;
block|}
block|}
comment|/**      * Background task that looks for aggregated exchanges which is triggered by completion timeouts.      */
DECL|class|AggregationTimeoutMap
specifier|private
specifier|final
class|class
name|AggregationTimeoutMap
extends|extends
name|DefaultTimeoutMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
block|{
DECL|method|AggregationTimeoutMap (ScheduledExecutorService executor, long requestMapPollTimeMillis)
specifier|private
name|AggregationTimeoutMap
parameter_list|(
name|ScheduledExecutorService
name|executor
parameter_list|,
name|long
name|requestMapPollTimeMillis
parameter_list|)
block|{
comment|// do NOT use locking on the timeout map as this aggregator has its own shared lock we will use instead
name|super
argument_list|(
name|executor
argument_list|,
name|requestMapPollTimeMillis
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|purge ()
specifier|public
name|void
name|purge
parameter_list|()
block|{
comment|// must acquire the shared aggregation lock to be able to purge
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|super
operator|.
name|purge
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|onEviction (String key, String exchangeId)
specifier|public
name|boolean
name|onEviction
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|exchangeId
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Completion timeout triggered for correlation key: {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|boolean
name|inProgress
init|=
name|inProgressCompleteExchanges
operator|.
name|contains
argument_list|(
name|exchangeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|inProgress
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Aggregated exchange with id: {} is already in progress."
argument_list|,
name|exchangeId
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// get the aggregated exchange
name|Exchange
name|answer
init|=
name|aggregationRepository
operator|.
name|get
argument_list|(
name|camelContext
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
comment|// indicate it was completed by timeout
name|answer
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_COMPLETED_BY
argument_list|,
literal|"timeout"
argument_list|)
expr_stmt|;
name|onCompletion
argument_list|(
name|key
argument_list|,
name|answer
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
comment|/**      * Background task that triggers completion based on interval.      */
DECL|class|AggregationIntervalTask
specifier|private
specifier|final
class|class
name|AggregationIntervalTask
implements|implements
name|Runnable
block|{
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// only run if CamelContext has been fully started
if|if
condition|(
operator|!
name|camelContext
operator|.
name|getStatus
argument_list|()
operator|.
name|isStarted
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Completion interval task cannot start due CamelContext({}) has not been started yet"
argument_list|,
name|camelContext
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"Starting completion interval task"
argument_list|)
expr_stmt|;
comment|// trigger completion for all in the repository
name|Set
argument_list|<
name|String
argument_list|>
name|keys
init|=
name|aggregationRepository
operator|.
name|getKeys
argument_list|()
decl_stmt|;
if|if
condition|(
name|keys
operator|!=
literal|null
operator|&&
operator|!
name|keys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// must acquire the shared aggregation lock to be able to trigger interval completion
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|String
name|key
range|:
name|keys
control|)
block|{
name|Exchange
name|exchange
init|=
name|aggregationRepository
operator|.
name|get
argument_list|(
name|camelContext
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|exchange
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Completion interval triggered for correlation key: {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|// indicate it was completed by interval
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_COMPLETED_BY
argument_list|,
literal|"interval"
argument_list|)
expr_stmt|;
name|onCompletion
argument_list|(
name|key
argument_list|,
name|exchange
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"Completion interval task complete"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Background task that looks for aggregated exchanges to recover.      */
DECL|class|RecoverTask
specifier|private
specifier|final
class|class
name|RecoverTask
implements|implements
name|Runnable
block|{
DECL|field|recoverable
specifier|private
specifier|final
name|RecoverableAggregationRepository
name|recoverable
decl_stmt|;
DECL|method|RecoverTask (RecoverableAggregationRepository recoverable)
specifier|private
name|RecoverTask
parameter_list|(
name|RecoverableAggregationRepository
name|recoverable
parameter_list|)
block|{
name|this
operator|.
name|recoverable
operator|=
name|recoverable
expr_stmt|;
block|}
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// only run if CamelContext has been fully started
if|if
condition|(
operator|!
name|camelContext
operator|.
name|getStatus
argument_list|()
operator|.
name|isStarted
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Recover check cannot start due CamelContext({}) has not been started yet"
argument_list|,
name|camelContext
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"Starting recover check"
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|exchangeIds
init|=
name|recoverable
operator|.
name|scan
argument_list|(
name|camelContext
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|exchangeId
range|:
name|exchangeIds
control|)
block|{
comment|// we may shutdown while doing recovery
if|if
condition|(
operator|!
name|isRunAllowed
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"We are shutting down so stop recovering"
argument_list|)
expr_stmt|;
return|return;
block|}
name|boolean
name|inProgress
init|=
name|inProgressCompleteExchanges
operator|.
name|contains
argument_list|(
name|exchangeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|inProgress
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Aggregated exchange with id: {} is already in progress."
argument_list|,
name|exchangeId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Loading aggregated exchange with id: {} to be recovered."
argument_list|,
name|exchangeId
argument_list|)
expr_stmt|;
name|Exchange
name|exchange
init|=
name|recoverable
operator|.
name|recover
argument_list|(
name|camelContext
argument_list|,
name|exchangeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|exchange
operator|!=
literal|null
condition|)
block|{
comment|// get the correlation key
name|String
name|key
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_CORRELATION_KEY
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// and mark it as redelivered
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|setHeader
argument_list|(
name|Exchange
operator|.
name|REDELIVERED
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
comment|// get the current redelivery data
name|RedeliveryData
name|data
init|=
name|redeliveryState
operator|.
name|get
argument_list|(
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|)
decl_stmt|;
comment|// if we are exhausted, then move to dead letter channel
if|if
condition|(
name|data
operator|!=
literal|null
operator|&&
name|recoverable
operator|.
name|getMaximumRedeliveries
argument_list|()
operator|>
literal|0
operator|&&
name|data
operator|.
name|redeliveryCounter
operator|>=
name|recoverable
operator|.
name|getMaximumRedeliveries
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The recovered exchange is exhausted after "
operator|+
name|recoverable
operator|.
name|getMaximumRedeliveries
argument_list|()
operator|+
literal|" attempts, will now be moved to dead letter channel: "
operator|+
name|recoverable
operator|.
name|getDeadLetterUri
argument_list|()
argument_list|)
expr_stmt|;
comment|// send to DLC
try|try
block|{
comment|// set redelivery counter
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|setHeader
argument_list|(
name|Exchange
operator|.
name|REDELIVERY_COUNTER
argument_list|,
name|data
operator|.
name|redeliveryCounter
argument_list|)
expr_stmt|;
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|setHeader
argument_list|(
name|Exchange
operator|.
name|REDELIVERY_EXHAUSTED
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|deadLetterProducerTemplate
operator|.
name|send
argument_list|(
name|recoverable
operator|.
name|getDeadLetterUri
argument_list|()
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|exchange
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|// handle if failed
if|if
condition|(
name|exchange
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|getExceptionHandler
argument_list|()
operator|.
name|handleException
argument_list|(
literal|"Failed to move recovered Exchange to dead letter channel: "
operator|+
name|recoverable
operator|.
name|getDeadLetterUri
argument_list|()
argument_list|,
name|exchange
operator|.
name|getException
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// it was ok, so confirm after it has been moved to dead letter channel, so we wont recover it again
name|recoverable
operator|.
name|confirm
argument_list|(
name|camelContext
argument_list|,
name|exchangeId
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// update current redelivery state
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
comment|// create new data
name|data
operator|=
operator|new
name|RedeliveryData
argument_list|()
expr_stmt|;
name|redeliveryState
operator|.
name|put
argument_list|(
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|data
operator|.
name|redeliveryCounter
operator|++
expr_stmt|;
comment|// set redelivery counter
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|setHeader
argument_list|(
name|Exchange
operator|.
name|REDELIVERY_COUNTER
argument_list|,
name|data
operator|.
name|redeliveryCounter
argument_list|)
expr_stmt|;
if|if
condition|(
name|recoverable
operator|.
name|getMaximumRedeliveries
argument_list|()
operator|>
literal|0
condition|)
block|{
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|setHeader
argument_list|(
name|Exchange
operator|.
name|REDELIVERY_MAX_COUNTER
argument_list|,
name|recoverable
operator|.
name|getMaximumRedeliveries
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Delivery attempt: {} to recover aggregated exchange with id: {}"
argument_list|,
name|data
operator|.
name|redeliveryCounter
argument_list|,
name|exchangeId
argument_list|)
expr_stmt|;
comment|// not exhaust so resubmit the recovered exchange
name|onSubmitCompletion
argument_list|(
name|key
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"Recover check complete"
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|doStart ()
specifier|protected
name|void
name|doStart
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|getCompletionTimeout
argument_list|()
operator|<=
literal|0
operator|&&
name|getCompletionInterval
argument_list|()
operator|<=
literal|0
operator|&&
name|getCompletionSize
argument_list|()
operator|<=
literal|0
operator|&&
name|getCompletionPredicate
argument_list|()
operator|==
literal|null
operator|&&
operator|!
name|isCompletionFromBatchConsumer
argument_list|()
operator|&&
name|getCompletionTimeoutExpression
argument_list|()
operator|==
literal|null
operator|&&
name|getCompletionSizeExpression
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"At least one of the completions options"
operator|+
literal|" [completionTimeout, completionInterval, completionSize, completionPredicate, completionFromBatchConsumer] must be set"
argument_list|)
throw|;
block|}
if|if
condition|(
name|getCloseCorrelationKeyOnCompletion
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|getCloseCorrelationKeyOnCompletion
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Using ClosedCorrelationKeys with a LRUCache with a capacity of "
operator|+
name|getCloseCorrelationKeyOnCompletion
argument_list|()
argument_list|)
expr_stmt|;
name|closedCorrelationKeys
operator|=
operator|new
name|LRUCache
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
argument_list|(
name|getCloseCorrelationKeyOnCompletion
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Using ClosedCorrelationKeys with unbounded capacity"
argument_list|)
expr_stmt|;
name|closedCorrelationKeys
operator|=
operator|new
name|HashMap
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
argument_list|()
expr_stmt|;
block|}
block|}
name|ServiceHelper
operator|.
name|startServices
argument_list|(
name|aggregationStrategy
argument_list|,
name|processor
argument_list|,
name|aggregationRepository
argument_list|)
expr_stmt|;
comment|// should we use recover checker
if|if
condition|(
name|aggregationRepository
operator|instanceof
name|RecoverableAggregationRepository
condition|)
block|{
name|RecoverableAggregationRepository
name|recoverable
init|=
operator|(
name|RecoverableAggregationRepository
operator|)
name|aggregationRepository
decl_stmt|;
if|if
condition|(
name|recoverable
operator|.
name|isUseRecovery
argument_list|()
condition|)
block|{
name|long
name|interval
init|=
name|recoverable
operator|.
name|getRecoveryIntervalInMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|interval
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"AggregationRepository has recovery enabled and the RecoveryInterval option must be a positive number, was: "
operator|+
name|interval
argument_list|)
throw|;
block|}
comment|// create a background recover thread to check every interval
name|recoverService
operator|=
name|camelContext
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|newScheduledThreadPool
argument_list|(
name|this
argument_list|,
literal|"AggregateRecoverChecker"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Runnable
name|recoverTask
init|=
operator|new
name|RecoverTask
argument_list|(
name|recoverable
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Using RecoverableAggregationRepository by scheduling recover checker to run every "
operator|+
name|interval
operator|+
literal|" millis."
argument_list|)
expr_stmt|;
comment|// use fixed delay so there is X interval between each run
name|recoverService
operator|.
name|scheduleWithFixedDelay
argument_list|(
name|recoverTask
argument_list|,
literal|1000L
argument_list|,
name|interval
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|recoverable
operator|.
name|getDeadLetterUri
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|int
name|max
init|=
name|recoverable
operator|.
name|getMaximumRedeliveries
argument_list|()
decl_stmt|;
if|if
condition|(
name|max
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Option maximumRedeliveries must be a positive number, was: "
operator|+
name|max
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"After "
operator|+
name|max
operator|+
literal|" failed redelivery attempts Exchanges will be moved to deadLetterUri: "
operator|+
name|recoverable
operator|.
name|getDeadLetterUri
argument_list|()
argument_list|)
expr_stmt|;
comment|// dead letter uri must be a valid endpoint
name|Endpoint
name|endpoint
init|=
name|camelContext
operator|.
name|getEndpoint
argument_list|(
name|recoverable
operator|.
name|getDeadLetterUri
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|endpoint
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchEndpointException
argument_list|(
name|recoverable
operator|.
name|getDeadLetterUri
argument_list|()
argument_list|)
throw|;
block|}
name|deadLetterProducerTemplate
operator|=
name|camelContext
operator|.
name|createProducerTemplate
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|getCompletionInterval
argument_list|()
operator|>
literal|0
operator|&&
name|getCompletionTimeout
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Only one of completionInterval or completionTimeout can be used, not both."
argument_list|)
throw|;
block|}
if|if
condition|(
name|getCompletionInterval
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Using CompletionInterval to run every "
operator|+
name|getCompletionInterval
argument_list|()
operator|+
literal|" millis."
argument_list|)
expr_stmt|;
if|if
condition|(
name|getTimeoutCheckerExecutorService
argument_list|()
operator|==
literal|null
condition|)
block|{
name|setTimeoutCheckerExecutorService
argument_list|(
name|camelContext
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|newScheduledThreadPool
argument_list|(
name|this
argument_list|,
name|AGGREGATE_TIMEOUT_CHECKER
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|shutdownTimeoutCheckerExecutorService
operator|=
literal|true
expr_stmt|;
block|}
comment|// trigger completion based on interval
name|getTimeoutCheckerExecutorService
argument_list|()
operator|.
name|scheduleAtFixedRate
argument_list|(
operator|new
name|AggregationIntervalTask
argument_list|()
argument_list|,
name|getCompletionInterval
argument_list|()
argument_list|,
name|getCompletionInterval
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
comment|// start timeout service if its in use
if|if
condition|(
name|getCompletionTimeout
argument_list|()
operator|>
literal|0
operator|||
name|getCompletionTimeoutExpression
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Using CompletionTimeout to trigger after "
operator|+
name|getCompletionTimeout
argument_list|()
operator|+
literal|" millis of inactivity."
argument_list|)
expr_stmt|;
if|if
condition|(
name|getTimeoutCheckerExecutorService
argument_list|()
operator|==
literal|null
condition|)
block|{
name|setTimeoutCheckerExecutorService
argument_list|(
name|camelContext
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|newScheduledThreadPool
argument_list|(
name|this
argument_list|,
name|AGGREGATE_TIMEOUT_CHECKER
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|shutdownTimeoutCheckerExecutorService
operator|=
literal|true
expr_stmt|;
block|}
comment|// check for timed out aggregated messages once every second
name|timeoutMap
operator|=
operator|new
name|AggregationTimeoutMap
argument_list|(
name|getTimeoutCheckerExecutorService
argument_list|()
argument_list|,
literal|1000L
argument_list|)
expr_stmt|;
comment|// fill in existing timeout values from the aggregation repository, for example if a restart occurred, then we
comment|// need to re-establish the timeout map so timeout can trigger
name|restoreTimeoutMapFromAggregationRepository
argument_list|()
expr_stmt|;
name|ServiceHelper
operator|.
name|startService
argument_list|(
name|timeoutMap
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|doStop ()
specifier|protected
name|void
name|doStop
parameter_list|()
throws|throws
name|Exception
block|{
comment|// note: we cannot do doForceCompletionOnStop from this doStop method
comment|// as this is handled in the prepareShutdown method which is also invoked when stopping a route
comment|// and is better suited for preparing to shutdown than this doStop method is
if|if
condition|(
name|recoverService
operator|!=
literal|null
condition|)
block|{
name|camelContext
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|shutdown
argument_list|(
name|recoverService
argument_list|)
expr_stmt|;
block|}
name|ServiceHelper
operator|.
name|stopServices
argument_list|(
name|timeoutMap
argument_list|,
name|processor
argument_list|,
name|deadLetterProducerTemplate
argument_list|)
expr_stmt|;
if|if
condition|(
name|closedCorrelationKeys
operator|!=
literal|null
condition|)
block|{
comment|// it may be a service so stop it as well
name|ServiceHelper
operator|.
name|stopService
argument_list|(
name|closedCorrelationKeys
argument_list|)
expr_stmt|;
name|closedCorrelationKeys
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|batchConsumerCorrelationKeys
operator|.
name|clear
argument_list|()
expr_stmt|;
name|redeliveryState
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|prepareShutdown (boolean forced)
specifier|public
name|void
name|prepareShutdown
parameter_list|(
name|boolean
name|forced
parameter_list|)
block|{
comment|// we are shutting down, so force completion if this option was enabled
comment|// but only do this when forced=false, as that is when we have chance to
comment|// send out new messages to be routed by Camel. When forced=true, then
comment|// we have to shutdown in a hurry
if|if
condition|(
operator|!
name|forced
operator|&&
name|forceCompletionOnStop
condition|)
block|{
name|doForceCompletionOnStop
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|doForceCompletionOnStop ()
specifier|private
name|void
name|doForceCompletionOnStop
parameter_list|()
block|{
name|int
name|expected
init|=
name|forceCompletionOfAllGroups
argument_list|()
decl_stmt|;
name|StopWatch
name|watch
init|=
operator|new
name|StopWatch
argument_list|()
decl_stmt|;
while|while
condition|(
name|inProgressCompleteExchanges
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Waiting for {} inflight exchanges to complete"
argument_list|,
name|inProgressCompleteExchanges
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// break out as we got interrupted such as the JVM terminating
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted while waiting for {} inflight exchanges to complete."
argument_list|,
name|inProgressCompleteExchanges
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|expected
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Forcing completion of all groups with {} exchanges completed in {}"
argument_list|,
name|expected
argument_list|,
name|TimeUtils
operator|.
name|printDuration
argument_list|(
name|watch
operator|.
name|stop
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|doShutdown ()
specifier|protected
name|void
name|doShutdown
parameter_list|()
throws|throws
name|Exception
block|{
comment|// shutdown aggregation repository and the strategy
name|ServiceHelper
operator|.
name|stopAndShutdownServices
argument_list|(
name|aggregationRepository
argument_list|,
name|aggregationStrategy
argument_list|)
expr_stmt|;
comment|// cleanup when shutting down
name|inProgressCompleteExchanges
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|shutdownExecutorService
condition|)
block|{
name|camelContext
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|shutdownNow
argument_list|(
name|executorService
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shutdownTimeoutCheckerExecutorService
condition|)
block|{
name|camelContext
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|shutdownNow
argument_list|(
name|timeoutCheckerExecutorService
argument_list|)
expr_stmt|;
name|timeoutCheckerExecutorService
operator|=
literal|null
expr_stmt|;
block|}
name|super
operator|.
name|doShutdown
argument_list|()
expr_stmt|;
block|}
DECL|method|forceCompletionOfAllGroups ()
specifier|public
name|int
name|forceCompletionOfAllGroups
parameter_list|()
block|{
comment|// only run if CamelContext has been fully started or is stopping
name|boolean
name|allow
init|=
name|camelContext
operator|.
name|getStatus
argument_list|()
operator|.
name|isStarted
argument_list|()
operator|||
name|camelContext
operator|.
name|getStatus
argument_list|()
operator|.
name|isStopping
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|allow
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot start force completion of all groups because CamelContext({}) has not been started"
argument_list|,
name|camelContext
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"Starting force completion of all groups task"
argument_list|)
expr_stmt|;
comment|// trigger completion for all in the repository
name|Set
argument_list|<
name|String
argument_list|>
name|keys
init|=
name|aggregationRepository
operator|.
name|getKeys
argument_list|()
decl_stmt|;
name|int
name|total
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|keys
operator|!=
literal|null
operator|&&
operator|!
name|keys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// must acquire the shared aggregation lock to be able to trigger force completion
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|total
operator|=
name|keys
operator|.
name|size
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|String
name|key
range|:
name|keys
control|)
block|{
name|Exchange
name|exchange
init|=
name|aggregationRepository
operator|.
name|get
argument_list|(
name|camelContext
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|exchange
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Force completion triggered for correlation key: {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|// indicate it was completed by a force completion request
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_COMPLETED_BY
argument_list|,
literal|"forceCompletion"
argument_list|)
expr_stmt|;
name|onCompletion
argument_list|(
name|key
argument_list|,
name|exchange
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"Completed force completion of all groups task"
argument_list|)
expr_stmt|;
if|if
condition|(
name|total
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Forcing completion of all groups with {} exchanges"
argument_list|,
name|total
argument_list|)
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
block|}
end_class

end_unit

