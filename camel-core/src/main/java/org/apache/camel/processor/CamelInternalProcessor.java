begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.processor
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RejectedExecutionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|AsyncCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|MessageHistory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Ordered
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Processor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Route
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|StatefulService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|StreamCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|api
operator|.
name|management
operator|.
name|PerformanceCounter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|management
operator|.
name|DelegatePerformanceCounter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|management
operator|.
name|mbean
operator|.
name|ManagedPerformanceCounter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|model
operator|.
name|ProcessorDefinition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|model
operator|.
name|ProcessorDefinitionHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
operator|.
name|interceptor
operator|.
name|BacklogDebugger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
operator|.
name|interceptor
operator|.
name|BacklogTracer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
operator|.
name|interceptor
operator|.
name|DefaultBacklogTracerEventMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|InflightRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|MessageHistoryFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|RouteContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|RoutePolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|StreamCachingStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|Transformer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|UnitOfWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|MessageHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|OrderedComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|StopWatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|UnitOfWorkHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Internal {@link Processor} that Camel routing engine used during routing for cross cutting functionality such as:  *<ul>  *<li>Execute {@link UnitOfWork}</li>  *<li>Keeping track which route currently is being routed</li>  *<li>Execute {@link RoutePolicy}</li>  *<li>Gather JMX performance statics</li>  *<li>Tracing</li>  *<li>Debugging</li>  *<li>Message History</li>  *<li>Stream Caching</li>  *<li>{@link Transformer}</li>  *</ul>  * ... and more.  *<p/>  * This implementation executes this cross cutting functionality as a {@link CamelInternalProcessorAdvice} advice (before and after advice)  * by executing the {@link CamelInternalProcessorAdvice#before(org.apache.camel.Exchange)} and  * {@link CamelInternalProcessorAdvice#after(org.apache.camel.Exchange, Object)} callbacks in correct order during routing.  * This reduces number of stack frames needed during routing, and reduce the number of lines in stacktraces, as well  * makes debugging the routing engine easier for end users.  *<p/>  *<b>Debugging tips:</b> Camel end users whom want to debug their Camel applications with the Camel source code, then make sure to  * read the source code of this class about the debugging tips, which you can find in the  * {@link #process(org.apache.camel.Exchange, org.apache.camel.AsyncCallback)} method.  *<p/>  * The added advices can implement {@link Ordered} to control in which order the advices are executed.  */
end_comment

begin_class
DECL|class|CamelInternalProcessor
specifier|public
class|class
name|CamelInternalProcessor
extends|extends
name|DelegateAsyncProcessor
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|CamelInternalProcessor
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|advices
specifier|private
specifier|final
name|List
argument_list|<
name|CamelInternalProcessorAdvice
argument_list|>
name|advices
init|=
operator|new
name|ArrayList
argument_list|<
name|CamelInternalProcessorAdvice
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|CamelInternalProcessor ()
specifier|public
name|CamelInternalProcessor
parameter_list|()
block|{     }
DECL|method|CamelInternalProcessor (Processor processor)
specifier|public
name|CamelInternalProcessor
parameter_list|(
name|Processor
name|processor
parameter_list|)
block|{
name|super
argument_list|(
name|processor
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds an {@link CamelInternalProcessorAdvice} advice to the list of advices to execute by this internal processor.      *      * @param advice  the advice to add      */
DECL|method|addAdvice (CamelInternalProcessorAdvice advice)
specifier|public
name|void
name|addAdvice
parameter_list|(
name|CamelInternalProcessorAdvice
name|advice
parameter_list|)
block|{
name|advices
operator|.
name|add
argument_list|(
name|advice
argument_list|)
expr_stmt|;
comment|// ensure advices are sorted so they are in the order we want
name|advices
operator|.
name|sort
argument_list|(
name|OrderedComparator
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Gets the advice with the given type.      *      * @param type  the type of the advice      * @return the advice if exists, or<tt>null</tt> if no advices has been added with the given type.      */
DECL|method|getAdvice (Class<T> type)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|getAdvice
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
for|for
control|(
name|CamelInternalProcessorAdvice
name|task
range|:
name|advices
control|)
block|{
if|if
condition|(
name|type
operator|.
name|isInstance
argument_list|(
name|task
argument_list|)
condition|)
block|{
return|return
name|type
operator|.
name|cast
argument_list|(
name|task
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|process (Exchange exchange, AsyncCallback callback)
specifier|public
name|boolean
name|process
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|AsyncCallback
name|callback
parameter_list|)
block|{
comment|// ----------------------------------------------------------
comment|// CAMEL END USER - READ ME FOR DEBUGGING TIPS
comment|// ----------------------------------------------------------
comment|// If you want to debug the Camel routing engine, then there is a lot of internal functionality
comment|// the routing engine executes during routing messages. You can skip debugging this internal
comment|// functionality and instead debug where the routing engine continues routing to the next node
comment|// in the routes. The CamelInternalProcessor is a vital part of the routing engine, as its
comment|// being used in between the nodes. As an end user you can just debug the code in this class
comment|// in between the:
comment|//   CAMEL END USER - DEBUG ME HERE +++ START +++
comment|//   CAMEL END USER - DEBUG ME HERE +++ END +++
comment|// you can see in the code below.
comment|// ----------------------------------------------------------
if|if
condition|(
name|processor
operator|==
literal|null
operator|||
operator|!
name|continueProcessing
argument_list|(
name|exchange
argument_list|)
condition|)
block|{
comment|// no processor or we should not continue then we are done
name|callback
operator|.
name|done
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|states
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|(
name|advices
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// optimise for loop using index access to avoid creating iterator object
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|advices
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|CamelInternalProcessorAdvice
name|task
init|=
name|advices
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
try|try
block|{
name|Object
name|state
init|=
name|task
operator|.
name|before
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
name|states
operator|.
name|add
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|exchange
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|callback
operator|.
name|done
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|// create internal callback which will execute the advices in reverse order when done
name|callback
operator|=
operator|new
name|InternalCallback
argument_list|(
name|states
argument_list|,
name|exchange
argument_list|,
name|callback
argument_list|)
expr_stmt|;
comment|// UNIT_OF_WORK_PROCESS_SYNC is @deprecated and we should remove it from Camel 3.0
name|Object
name|synchronous
init|=
name|exchange
operator|.
name|removeProperty
argument_list|(
name|Exchange
operator|.
name|UNIT_OF_WORK_PROCESS_SYNC
argument_list|)
decl_stmt|;
if|if
condition|(
name|exchange
operator|.
name|isTransacted
argument_list|()
operator|||
name|synchronous
operator|!=
literal|null
condition|)
block|{
comment|// must be synchronized for transacted exchanges
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|exchange
operator|.
name|isTransacted
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}"
argument_list|,
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Synchronous UnitOfWork Exchange must be routed synchronously for exchangeId: {} -> {}"
argument_list|,
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ----------------------------------------------------------
comment|// CAMEL END USER - DEBUG ME HERE +++ START +++
comment|// ----------------------------------------------------------
try|try
block|{
name|processor
operator|.
name|process
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|exchange
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|// ----------------------------------------------------------
comment|// CAMEL END USER - DEBUG ME HERE +++ END +++
comment|// ----------------------------------------------------------
name|callback
operator|.
name|done
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
specifier|final
name|UnitOfWork
name|uow
init|=
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
decl_stmt|;
comment|// allow unit of work to wrap callback in case it need to do some special work
comment|// for example the MDCUnitOfWork
name|AsyncCallback
name|async
init|=
name|callback
decl_stmt|;
if|if
condition|(
name|uow
operator|!=
literal|null
condition|)
block|{
name|async
operator|=
name|uow
operator|.
name|beforeProcess
argument_list|(
name|processor
argument_list|,
name|exchange
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
comment|// ----------------------------------------------------------
comment|// CAMEL END USER - DEBUG ME HERE +++ START +++
comment|// ----------------------------------------------------------
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Processing exchange for exchangeId: {} -> {}"
argument_list|,
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
name|boolean
name|sync
init|=
name|processor
operator|.
name|process
argument_list|(
name|exchange
argument_list|,
name|async
argument_list|)
decl_stmt|;
comment|// ----------------------------------------------------------
comment|// CAMEL END USER - DEBUG ME HERE +++ END +++
comment|// ----------------------------------------------------------
comment|// execute any after processor work (in current thread, not in the callback)
if|if
condition|(
name|uow
operator|!=
literal|null
condition|)
block|{
name|uow
operator|.
name|afterProcess
argument_list|(
name|processor
argument_list|,
name|exchange
argument_list|,
name|callback
argument_list|,
name|sync
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Exchange processed and is continued routed {} for exchangeId: {} -> {}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|sync
condition|?
literal|"synchronously"
else|:
literal|"asynchronously"
block|,
name|exchange
operator|.
name|getExchangeId
argument_list|()
block|,
name|exchange
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|sync
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|processor
operator|!=
literal|null
condition|?
name|processor
operator|.
name|toString
argument_list|()
else|:
name|super
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Internal callback that executes the after advices.      */
DECL|class|InternalCallback
specifier|private
specifier|final
class|class
name|InternalCallback
implements|implements
name|AsyncCallback
block|{
DECL|field|states
specifier|private
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|states
decl_stmt|;
DECL|field|exchange
specifier|private
specifier|final
name|Exchange
name|exchange
decl_stmt|;
DECL|field|callback
specifier|private
specifier|final
name|AsyncCallback
name|callback
decl_stmt|;
DECL|method|InternalCallback (List<Object> states, Exchange exchange, AsyncCallback callback)
specifier|private
name|InternalCallback
parameter_list|(
name|List
argument_list|<
name|Object
argument_list|>
name|states
parameter_list|,
name|Exchange
name|exchange
parameter_list|,
name|AsyncCallback
name|callback
parameter_list|)
block|{
name|this
operator|.
name|states
operator|=
name|states
expr_stmt|;
name|this
operator|.
name|exchange
operator|=
name|exchange
expr_stmt|;
name|this
operator|.
name|callback
operator|=
name|callback
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|done (boolean doneSync)
specifier|public
name|void
name|done
parameter_list|(
name|boolean
name|doneSync
parameter_list|)
block|{
comment|// NOTE: if you are debugging Camel routes, then all the code in the for loop below is internal only
comment|// so you can step straight to the finally block and invoke the callback
comment|// we should call after in reverse order
try|try
block|{
for|for
control|(
name|int
name|i
init|=
name|advices
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|CamelInternalProcessorAdvice
name|task
init|=
name|advices
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Object
name|state
init|=
name|states
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
try|try
block|{
name|task
operator|.
name|after
argument_list|(
name|exchange
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|exchange
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|// allow all advices to complete even if there was an exception
block|}
block|}
block|}
finally|finally
block|{
comment|// ----------------------------------------------------------
comment|// CAMEL END USER - DEBUG ME HERE +++ START +++
comment|// ----------------------------------------------------------
comment|// callback must be called
name|callback
operator|.
name|done
argument_list|(
name|doneSync
argument_list|)
expr_stmt|;
comment|// ----------------------------------------------------------
comment|// CAMEL END USER - DEBUG ME HERE +++ END +++
comment|// ----------------------------------------------------------
block|}
block|}
block|}
comment|/**      * Strategy to determine if we should continue processing the {@link Exchange}.      */
DECL|method|continueProcessing (Exchange exchange)
specifier|protected
name|boolean
name|continueProcessing
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|Object
name|stop
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|ROUTE_STOP
argument_list|)
decl_stmt|;
if|if
condition|(
name|stop
operator|!=
literal|null
condition|)
block|{
name|boolean
name|doStop
init|=
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|Boolean
operator|.
name|class
argument_list|,
name|stop
argument_list|)
decl_stmt|;
if|if
condition|(
name|doStop
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exchange is marked to stop routing: {}"
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|// determine if we can still run, or the camel context is forcing a shutdown
name|boolean
name|forceShutdown
init|=
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getShutdownStrategy
argument_list|()
operator|.
name|forceShutdown
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|forceShutdown
condition|)
block|{
name|String
name|msg
init|=
literal|"Run not allowed as ShutdownStrategy is forcing shutting down, will reject executing exchange: "
operator|+
name|exchange
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|exchange
operator|.
name|getException
argument_list|()
operator|==
literal|null
condition|)
block|{
name|exchange
operator|.
name|setException
argument_list|(
operator|new
name|RejectedExecutionException
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|// yes we can continue
return|return
literal|true
return|;
block|}
comment|/**      * Advice to invoke callbacks for before and after routing.      */
DECL|class|RouteLifecycleAdvice
specifier|public
specifier|static
class|class
name|RouteLifecycleAdvice
implements|implements
name|CamelInternalProcessorAdvice
argument_list|<
name|Object
argument_list|>
block|{
DECL|field|route
specifier|private
name|Route
name|route
decl_stmt|;
DECL|method|setRoute (Route route)
specifier|public
name|void
name|setRoute
parameter_list|(
name|Route
name|route
parameter_list|)
block|{
name|this
operator|.
name|route
operator|=
name|route
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|before (Exchange exchange)
specifier|public
name|Object
name|before
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
name|UnitOfWork
name|uow
init|=
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
decl_stmt|;
if|if
condition|(
name|uow
operator|!=
literal|null
condition|)
block|{
name|uow
operator|.
name|beforeRoute
argument_list|(
name|exchange
argument_list|,
name|route
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|after (Exchange exchange, Object object)
specifier|public
name|void
name|after
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|object
parameter_list|)
throws|throws
name|Exception
block|{
name|UnitOfWork
name|uow
init|=
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
decl_stmt|;
if|if
condition|(
name|uow
operator|!=
literal|null
condition|)
block|{
name|uow
operator|.
name|afterRoute
argument_list|(
name|exchange
argument_list|,
name|route
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Advice for JMX instrumentation of the process being invoked.      *<p/>      * This advice keeps track of JMX metrics for performance statistics.      *<p/>      * The current implementation of this advice is only used for route level statistics. For processor levels      * they are still wrapped in the route processor chains.      */
DECL|class|InstrumentationAdvice
specifier|public
specifier|static
class|class
name|InstrumentationAdvice
implements|implements
name|CamelInternalProcessorAdvice
argument_list|<
name|StopWatch
argument_list|>
block|{
DECL|field|counter
specifier|private
name|PerformanceCounter
name|counter
decl_stmt|;
DECL|field|type
specifier|private
name|String
name|type
decl_stmt|;
DECL|method|InstrumentationAdvice (String type)
specifier|public
name|InstrumentationAdvice
parameter_list|(
name|String
name|type
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
DECL|method|setCounter (Object counter)
specifier|public
name|void
name|setCounter
parameter_list|(
name|Object
name|counter
parameter_list|)
block|{
name|ManagedPerformanceCounter
name|mpc
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|counter
operator|instanceof
name|ManagedPerformanceCounter
condition|)
block|{
name|mpc
operator|=
operator|(
name|ManagedPerformanceCounter
operator|)
name|counter
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|counter
operator|instanceof
name|DelegatePerformanceCounter
condition|)
block|{
operator|(
operator|(
name|DelegatePerformanceCounter
operator|)
name|this
operator|.
name|counter
operator|)
operator|.
name|setCounter
argument_list|(
name|mpc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mpc
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|counter
operator|=
name|mpc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|counter
operator|instanceof
name|PerformanceCounter
condition|)
block|{
name|this
operator|.
name|counter
operator|=
operator|(
name|PerformanceCounter
operator|)
name|counter
expr_stmt|;
block|}
block|}
DECL|method|beginTime (Exchange exchange)
specifier|protected
name|void
name|beginTime
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|counter
operator|.
name|processExchange
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
DECL|method|recordTime (Exchange exchange, long duration)
specifier|protected
name|void
name|recordTime
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|long
name|duration
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}Recording duration: {} millis for exchange: {}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|type
operator|!=
literal|null
condition|?
name|type
operator|+
literal|": "
else|:
literal|""
block|,
name|duration
block|,
name|exchange
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|exchange
operator|.
name|isFailed
argument_list|()
operator|&&
name|exchange
operator|.
name|getException
argument_list|()
operator|==
literal|null
condition|)
block|{
name|counter
operator|.
name|completedExchange
argument_list|(
name|exchange
argument_list|,
name|duration
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|counter
operator|.
name|failedExchange
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getType ()
specifier|public
name|String
name|getType
parameter_list|()
block|{
return|return
name|type
return|;
block|}
DECL|method|setType (String type)
specifier|public
name|void
name|setType
parameter_list|(
name|String
name|type
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|before (Exchange exchange)
specifier|public
name|StopWatch
name|before
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
comment|// only record time if stats is enabled
name|StopWatch
name|answer
init|=
name|counter
operator|!=
literal|null
operator|&&
name|counter
operator|.
name|isStatisticsEnabled
argument_list|()
condition|?
operator|new
name|StopWatch
argument_list|()
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|beginTime
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|after (Exchange exchange, StopWatch watch)
specifier|public
name|void
name|after
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|StopWatch
name|watch
parameter_list|)
throws|throws
name|Exception
block|{
comment|// record end time
if|if
condition|(
name|watch
operator|!=
literal|null
condition|)
block|{
name|recordTime
argument_list|(
name|exchange
argument_list|,
name|watch
operator|.
name|taken
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Advice to inject the current {@link RouteContext} into the {@link UnitOfWork} on the {@link Exchange}      *      * @deprecated this logic has been merged into {@link org.apache.camel.processor.CamelInternalProcessor.UnitOfWorkProcessorAdvice}      */
annotation|@
name|Deprecated
DECL|class|RouteContextAdvice
specifier|public
specifier|static
class|class
name|RouteContextAdvice
implements|implements
name|CamelInternalProcessorAdvice
argument_list|<
name|UnitOfWork
argument_list|>
block|{
DECL|field|routeContext
specifier|private
specifier|final
name|RouteContext
name|routeContext
decl_stmt|;
DECL|method|RouteContextAdvice (RouteContext routeContext)
specifier|public
name|RouteContextAdvice
parameter_list|(
name|RouteContext
name|routeContext
parameter_list|)
block|{
name|this
operator|.
name|routeContext
operator|=
name|routeContext
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|before (Exchange exchange)
specifier|public
name|UnitOfWork
name|before
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
comment|// push the current route context
specifier|final
name|UnitOfWork
name|unitOfWork
init|=
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
decl_stmt|;
if|if
condition|(
name|unitOfWork
operator|!=
literal|null
condition|)
block|{
name|unitOfWork
operator|.
name|pushRouteContext
argument_list|(
name|routeContext
argument_list|)
expr_stmt|;
block|}
return|return
name|unitOfWork
return|;
block|}
annotation|@
name|Override
DECL|method|after (Exchange exchange, UnitOfWork unitOfWork)
specifier|public
name|void
name|after
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|UnitOfWork
name|unitOfWork
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|unitOfWork
operator|!=
literal|null
condition|)
block|{
name|unitOfWork
operator|.
name|popRouteContext
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Advice to keep the {@link InflightRepository} up to date.      */
DECL|class|RouteInflightRepositoryAdvice
specifier|public
specifier|static
class|class
name|RouteInflightRepositoryAdvice
implements|implements
name|CamelInternalProcessorAdvice
block|{
DECL|field|inflightRepository
specifier|private
specifier|final
name|InflightRepository
name|inflightRepository
decl_stmt|;
DECL|field|id
specifier|private
specifier|final
name|String
name|id
decl_stmt|;
DECL|method|RouteInflightRepositoryAdvice (InflightRepository inflightRepository, String id)
specifier|public
name|RouteInflightRepositoryAdvice
parameter_list|(
name|InflightRepository
name|inflightRepository
parameter_list|,
name|String
name|id
parameter_list|)
block|{
name|this
operator|.
name|inflightRepository
operator|=
name|inflightRepository
expr_stmt|;
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|before (Exchange exchange)
specifier|public
name|Object
name|before
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
name|inflightRepository
operator|.
name|add
argument_list|(
name|exchange
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|after (Exchange exchange, Object state)
specifier|public
name|void
name|after
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|state
parameter_list|)
throws|throws
name|Exception
block|{
name|inflightRepository
operator|.
name|remove
argument_list|(
name|exchange
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Advice to execute any {@link RoutePolicy} a route may have been configured with.      */
DECL|class|RoutePolicyAdvice
specifier|public
specifier|static
class|class
name|RoutePolicyAdvice
implements|implements
name|CamelInternalProcessorAdvice
block|{
DECL|field|routePolicies
specifier|private
specifier|final
name|List
argument_list|<
name|RoutePolicy
argument_list|>
name|routePolicies
decl_stmt|;
DECL|field|route
specifier|private
name|Route
name|route
decl_stmt|;
DECL|method|RoutePolicyAdvice (List<RoutePolicy> routePolicies)
specifier|public
name|RoutePolicyAdvice
parameter_list|(
name|List
argument_list|<
name|RoutePolicy
argument_list|>
name|routePolicies
parameter_list|)
block|{
name|this
operator|.
name|routePolicies
operator|=
name|routePolicies
expr_stmt|;
block|}
DECL|method|setRoute (Route route)
specifier|public
name|void
name|setRoute
parameter_list|(
name|Route
name|route
parameter_list|)
block|{
name|this
operator|.
name|route
operator|=
name|route
expr_stmt|;
block|}
comment|/**          * Strategy to determine if this policy is allowed to run          *          * @param policy the policy          * @return<tt>true</tt> to run          */
DECL|method|isRoutePolicyRunAllowed (RoutePolicy policy)
specifier|protected
name|boolean
name|isRoutePolicyRunAllowed
parameter_list|(
name|RoutePolicy
name|policy
parameter_list|)
block|{
if|if
condition|(
name|policy
operator|instanceof
name|StatefulService
condition|)
block|{
name|StatefulService
name|ss
init|=
operator|(
name|StatefulService
operator|)
name|policy
decl_stmt|;
return|return
name|ss
operator|.
name|isRunAllowed
argument_list|()
return|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|before (Exchange exchange)
specifier|public
name|Object
name|before
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
comment|// invoke begin
for|for
control|(
name|RoutePolicy
name|policy
range|:
name|routePolicies
control|)
block|{
try|try
block|{
if|if
condition|(
name|isRoutePolicyRunAllowed
argument_list|(
name|policy
argument_list|)
condition|)
block|{
name|policy
operator|.
name|onExchangeBegin
argument_list|(
name|route
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error occurred during onExchangeBegin on RoutePolicy: "
operator|+
name|policy
operator|+
literal|". This exception will be ignored"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|after (Exchange exchange, Object data)
specifier|public
name|void
name|after
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|data
parameter_list|)
throws|throws
name|Exception
block|{
comment|// do not invoke it if Camel is stopping as we don't want
comment|// the policy to start a consumer during Camel is stopping
if|if
condition|(
name|isCamelStopping
argument_list|(
name|exchange
operator|.
name|getContext
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
for|for
control|(
name|RoutePolicy
name|policy
range|:
name|routePolicies
control|)
block|{
try|try
block|{
if|if
condition|(
name|isRoutePolicyRunAllowed
argument_list|(
name|policy
argument_list|)
condition|)
block|{
name|policy
operator|.
name|onExchangeDone
argument_list|(
name|route
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error occurred during onExchangeDone on RoutePolicy: "
operator|+
name|policy
operator|+
literal|". This exception will be ignored"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|isCamelStopping (CamelContext context)
specifier|private
specifier|static
name|boolean
name|isCamelStopping
parameter_list|(
name|CamelContext
name|context
parameter_list|)
block|{
if|if
condition|(
name|context
operator|instanceof
name|StatefulService
condition|)
block|{
name|StatefulService
name|ss
init|=
operator|(
name|StatefulService
operator|)
name|context
decl_stmt|;
return|return
name|ss
operator|.
name|isStopping
argument_list|()
operator|||
name|ss
operator|.
name|isStopped
argument_list|()
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Advice to execute the {@link BacklogTracer} if enabled.      */
DECL|class|BacklogTracerAdvice
specifier|public
specifier|static
specifier|final
class|class
name|BacklogTracerAdvice
implements|implements
name|CamelInternalProcessorAdvice
implements|,
name|Ordered
block|{
DECL|field|backlogTracer
specifier|private
specifier|final
name|BacklogTracer
name|backlogTracer
decl_stmt|;
DECL|field|processorDefinition
specifier|private
specifier|final
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|processorDefinition
decl_stmt|;
DECL|field|routeDefinition
specifier|private
specifier|final
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|routeDefinition
decl_stmt|;
DECL|field|first
specifier|private
specifier|final
name|boolean
name|first
decl_stmt|;
DECL|method|BacklogTracerAdvice (BacklogTracer backlogTracer, ProcessorDefinition<?> processorDefinition, ProcessorDefinition<?> routeDefinition, boolean first)
specifier|public
name|BacklogTracerAdvice
parameter_list|(
name|BacklogTracer
name|backlogTracer
parameter_list|,
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|processorDefinition
parameter_list|,
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|routeDefinition
parameter_list|,
name|boolean
name|first
parameter_list|)
block|{
name|this
operator|.
name|backlogTracer
operator|=
name|backlogTracer
expr_stmt|;
name|this
operator|.
name|processorDefinition
operator|=
name|processorDefinition
expr_stmt|;
name|this
operator|.
name|routeDefinition
operator|=
name|routeDefinition
expr_stmt|;
name|this
operator|.
name|first
operator|=
name|first
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|before (Exchange exchange)
specifier|public
name|Object
name|before
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|backlogTracer
operator|.
name|shouldTrace
argument_list|(
name|processorDefinition
argument_list|,
name|exchange
argument_list|)
condition|)
block|{
name|Date
name|timestamp
init|=
operator|new
name|Date
argument_list|()
decl_stmt|;
name|String
name|toNode
init|=
name|processorDefinition
operator|.
name|getId
argument_list|()
decl_stmt|;
name|String
name|exchangeId
init|=
name|exchange
operator|.
name|getExchangeId
argument_list|()
decl_stmt|;
name|String
name|messageAsXml
init|=
name|MessageHelper
operator|.
name|dumpAsXml
argument_list|(
name|exchange
operator|.
name|getIn
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|4
argument_list|,
name|backlogTracer
operator|.
name|isBodyIncludeStreams
argument_list|()
argument_list|,
name|backlogTracer
operator|.
name|isBodyIncludeFiles
argument_list|()
argument_list|,
name|backlogTracer
operator|.
name|getBodyMaxChars
argument_list|()
argument_list|)
decl_stmt|;
comment|// if first we should add a pseudo trace message as well, so we have a starting message (eg from the route)
name|String
name|routeId
init|=
name|routeDefinition
operator|!=
literal|null
condition|?
name|routeDefinition
operator|.
name|getId
argument_list|()
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|Date
name|created
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|CREATED_TIMESTAMP
argument_list|,
name|timestamp
argument_list|,
name|Date
operator|.
name|class
argument_list|)
decl_stmt|;
name|DefaultBacklogTracerEventMessage
name|pseudo
init|=
operator|new
name|DefaultBacklogTracerEventMessage
argument_list|(
name|backlogTracer
operator|.
name|incrementTraceCounter
argument_list|()
argument_list|,
name|created
argument_list|,
name|routeId
argument_list|,
literal|null
argument_list|,
name|exchangeId
argument_list|,
name|messageAsXml
argument_list|)
decl_stmt|;
name|backlogTracer
operator|.
name|traceEvent
argument_list|(
name|pseudo
argument_list|)
expr_stmt|;
block|}
name|DefaultBacklogTracerEventMessage
name|event
init|=
operator|new
name|DefaultBacklogTracerEventMessage
argument_list|(
name|backlogTracer
operator|.
name|incrementTraceCounter
argument_list|()
argument_list|,
name|timestamp
argument_list|,
name|routeId
argument_list|,
name|toNode
argument_list|,
name|exchangeId
argument_list|,
name|messageAsXml
argument_list|)
decl_stmt|;
name|backlogTracer
operator|.
name|traceEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|after (Exchange exchange, Object data)
specifier|public
name|void
name|after
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|data
parameter_list|)
throws|throws
name|Exception
block|{
comment|// noop
block|}
annotation|@
name|Override
DECL|method|getOrder ()
specifier|public
name|int
name|getOrder
parameter_list|()
block|{
comment|// we want tracer just before calling the processor
return|return
name|Ordered
operator|.
name|LOWEST
operator|-
literal|1
return|;
block|}
block|}
comment|/**      * Advice to execute the {@link org.apache.camel.processor.interceptor.BacklogDebugger} if enabled.      */
DECL|class|BacklogDebuggerAdvice
specifier|public
specifier|static
specifier|final
class|class
name|BacklogDebuggerAdvice
implements|implements
name|CamelInternalProcessorAdvice
argument_list|<
name|StopWatch
argument_list|>
implements|,
name|Ordered
block|{
DECL|field|backlogDebugger
specifier|private
specifier|final
name|BacklogDebugger
name|backlogDebugger
decl_stmt|;
DECL|field|target
specifier|private
specifier|final
name|Processor
name|target
decl_stmt|;
DECL|field|definition
specifier|private
specifier|final
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|definition
decl_stmt|;
DECL|field|nodeId
specifier|private
specifier|final
name|String
name|nodeId
decl_stmt|;
DECL|method|BacklogDebuggerAdvice (BacklogDebugger backlogDebugger, Processor target, ProcessorDefinition<?> definition)
specifier|public
name|BacklogDebuggerAdvice
parameter_list|(
name|BacklogDebugger
name|backlogDebugger
parameter_list|,
name|Processor
name|target
parameter_list|,
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|definition
parameter_list|)
block|{
name|this
operator|.
name|backlogDebugger
operator|=
name|backlogDebugger
expr_stmt|;
name|this
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|this
operator|.
name|definition
operator|=
name|definition
expr_stmt|;
name|this
operator|.
name|nodeId
operator|=
name|definition
operator|.
name|getId
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|before (Exchange exchange)
specifier|public
name|StopWatch
name|before
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|backlogDebugger
operator|.
name|isEnabled
argument_list|()
operator|&&
operator|(
name|backlogDebugger
operator|.
name|hasBreakpoint
argument_list|(
name|nodeId
argument_list|)
operator|||
name|backlogDebugger
operator|.
name|isSingleStepMode
argument_list|()
operator|)
condition|)
block|{
name|StopWatch
name|watch
init|=
operator|new
name|StopWatch
argument_list|()
decl_stmt|;
name|backlogDebugger
operator|.
name|beforeProcess
argument_list|(
name|exchange
argument_list|,
name|target
argument_list|,
name|definition
argument_list|)
expr_stmt|;
return|return
name|watch
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|after (Exchange exchange, StopWatch stopWatch)
specifier|public
name|void
name|after
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|StopWatch
name|stopWatch
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|stopWatch
operator|!=
literal|null
condition|)
block|{
name|backlogDebugger
operator|.
name|afterProcess
argument_list|(
name|exchange
argument_list|,
name|target
argument_list|,
name|definition
argument_list|,
name|stopWatch
operator|.
name|taken
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getOrder ()
specifier|public
name|int
name|getOrder
parameter_list|()
block|{
comment|// we want debugger just before calling the processor
return|return
name|Ordered
operator|.
name|LOWEST
return|;
block|}
block|}
comment|/**      * Advice to inject new {@link UnitOfWork} to the {@link Exchange} if needed, and as well to ensure      * the {@link UnitOfWork} is done and stopped.      */
DECL|class|UnitOfWorkProcessorAdvice
specifier|public
specifier|static
class|class
name|UnitOfWorkProcessorAdvice
implements|implements
name|CamelInternalProcessorAdvice
argument_list|<
name|UnitOfWork
argument_list|>
block|{
DECL|field|routeContext
specifier|private
specifier|final
name|RouteContext
name|routeContext
decl_stmt|;
DECL|field|routeId
specifier|private
specifier|final
name|String
name|routeId
decl_stmt|;
DECL|method|UnitOfWorkProcessorAdvice (RouteContext routeContext)
specifier|public
name|UnitOfWorkProcessorAdvice
parameter_list|(
name|RouteContext
name|routeContext
parameter_list|)
block|{
name|this
operator|.
name|routeContext
operator|=
name|routeContext
expr_stmt|;
name|this
operator|.
name|routeId
operator|=
name|routeContext
operator|.
name|getRoute
argument_list|()
operator|.
name|idOrCreate
argument_list|(
name|routeContext
operator|.
name|getCamelContext
argument_list|()
operator|.
name|getNodeIdFactory
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|before (Exchange exchange)
specifier|public
name|UnitOfWork
name|before
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
comment|// if the exchange doesn't have from route id set, then set it if it originated
comment|// from this unit of work
if|if
condition|(
name|routeContext
operator|!=
literal|null
operator|&&
name|exchange
operator|.
name|getFromRouteId
argument_list|()
operator|==
literal|null
operator|&&
name|routeId
operator|!=
literal|null
condition|)
block|{
name|exchange
operator|.
name|setFromRouteId
argument_list|(
name|routeId
argument_list|)
expr_stmt|;
block|}
comment|// only return UnitOfWork if we created a new as then its us that handle the lifecycle to done the created UoW
name|UnitOfWork
name|created
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// If there is no existing UoW, then we should start one and
comment|// terminate it once processing is completed for the exchange.
name|created
operator|=
name|createUnitOfWork
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
name|exchange
operator|.
name|setUnitOfWork
argument_list|(
name|created
argument_list|)
expr_stmt|;
name|created
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|// for any exchange we should push/pop route context so we can keep track of which route we are routing
if|if
condition|(
name|routeContext
operator|!=
literal|null
condition|)
block|{
name|UnitOfWork
name|existing
init|=
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
decl_stmt|;
if|if
condition|(
name|existing
operator|!=
literal|null
condition|)
block|{
name|existing
operator|.
name|pushRouteContext
argument_list|(
name|routeContext
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|created
return|;
block|}
annotation|@
name|Override
DECL|method|after (Exchange exchange, UnitOfWork uow)
specifier|public
name|void
name|after
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|UnitOfWork
name|uow
parameter_list|)
throws|throws
name|Exception
block|{
name|UnitOfWork
name|existing
init|=
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
decl_stmt|;
comment|// execute done on uow if we created it, and the consumer is not doing it
if|if
condition|(
name|uow
operator|!=
literal|null
condition|)
block|{
name|UnitOfWorkHelper
operator|.
name|doneUow
argument_list|(
name|uow
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
comment|// after UoW is done lets pop the route context which must be done on every existing UoW
if|if
condition|(
name|routeContext
operator|!=
literal|null
operator|&&
name|existing
operator|!=
literal|null
condition|)
block|{
name|existing
operator|.
name|popRouteContext
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|createUnitOfWork (Exchange exchange)
specifier|protected
name|UnitOfWork
name|createUnitOfWork
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getUnitOfWorkFactory
argument_list|()
operator|.
name|createUnitOfWork
argument_list|(
name|exchange
argument_list|)
return|;
block|}
block|}
comment|/**      * Advice when an EIP uses the<tt>shareUnitOfWork</tt> functionality.      */
DECL|class|ChildUnitOfWorkProcessorAdvice
specifier|public
specifier|static
class|class
name|ChildUnitOfWorkProcessorAdvice
extends|extends
name|UnitOfWorkProcessorAdvice
block|{
DECL|field|parent
specifier|private
specifier|final
name|UnitOfWork
name|parent
decl_stmt|;
DECL|method|ChildUnitOfWorkProcessorAdvice (RouteContext routeContext, UnitOfWork parent)
specifier|public
name|ChildUnitOfWorkProcessorAdvice
parameter_list|(
name|RouteContext
name|routeContext
parameter_list|,
name|UnitOfWork
name|parent
parameter_list|)
block|{
name|super
argument_list|(
name|routeContext
argument_list|)
expr_stmt|;
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createUnitOfWork (Exchange exchange)
specifier|protected
name|UnitOfWork
name|createUnitOfWork
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
comment|// let the parent create a child unit of work to be used
return|return
name|parent
operator|.
name|createChildUnitOfWork
argument_list|(
name|exchange
argument_list|)
return|;
block|}
block|}
comment|/**      * Advice when an EIP uses the<tt>shareUnitOfWork</tt> functionality.      */
DECL|class|SubUnitOfWorkProcessorAdvice
specifier|public
specifier|static
class|class
name|SubUnitOfWorkProcessorAdvice
implements|implements
name|CamelInternalProcessorAdvice
argument_list|<
name|UnitOfWork
argument_list|>
block|{
annotation|@
name|Override
DECL|method|before (Exchange exchange)
specifier|public
name|UnitOfWork
name|before
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
comment|// begin savepoint
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
operator|.
name|beginSubUnitOfWork
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
return|return
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|after (Exchange exchange, UnitOfWork unitOfWork)
specifier|public
name|void
name|after
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|UnitOfWork
name|unitOfWork
parameter_list|)
throws|throws
name|Exception
block|{
comment|// end sub unit of work
name|unitOfWork
operator|.
name|endSubUnitOfWork
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Advice when Message History has been enabled.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|class|MessageHistoryAdvice
specifier|public
specifier|static
class|class
name|MessageHistoryAdvice
implements|implements
name|CamelInternalProcessorAdvice
argument_list|<
name|MessageHistory
argument_list|>
block|{
DECL|field|factory
specifier|private
specifier|final
name|MessageHistoryFactory
name|factory
decl_stmt|;
DECL|field|definition
specifier|private
specifier|final
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|definition
decl_stmt|;
DECL|field|routeId
specifier|private
specifier|final
name|String
name|routeId
decl_stmt|;
DECL|method|MessageHistoryAdvice (MessageHistoryFactory factory, ProcessorDefinition<?> definition)
specifier|public
name|MessageHistoryAdvice
parameter_list|(
name|MessageHistoryFactory
name|factory
parameter_list|,
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|definition
parameter_list|)
block|{
name|this
operator|.
name|factory
operator|=
name|factory
expr_stmt|;
name|this
operator|.
name|definition
operator|=
name|definition
expr_stmt|;
name|this
operator|.
name|routeId
operator|=
name|ProcessorDefinitionHelper
operator|.
name|getRouteId
argument_list|(
name|definition
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|before (Exchange exchange)
specifier|public
name|MessageHistory
name|before
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|MessageHistory
argument_list|>
name|list
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|MESSAGE_HISTORY
argument_list|,
name|List
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|null
condition|)
block|{
name|list
operator|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
expr_stmt|;
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|MESSAGE_HISTORY
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
comment|// we may be routing outside a route in an onException or interceptor and if so then grab
comment|// route id from the exchange UoW state
name|String
name|targetRouteId
init|=
name|this
operator|.
name|routeId
decl_stmt|;
if|if
condition|(
name|targetRouteId
operator|==
literal|null
condition|)
block|{
name|UnitOfWork
name|uow
init|=
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
decl_stmt|;
if|if
condition|(
name|uow
operator|!=
literal|null
operator|&&
name|uow
operator|.
name|getRouteContext
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|targetRouteId
operator|=
name|uow
operator|.
name|getRouteContext
argument_list|()
operator|.
name|getRoute
argument_list|()
operator|.
name|getId
argument_list|()
expr_stmt|;
block|}
block|}
name|MessageHistory
name|history
init|=
name|factory
operator|.
name|newMessageHistory
argument_list|(
name|targetRouteId
argument_list|,
name|definition
argument_list|,
operator|new
name|Date
argument_list|()
argument_list|)
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|history
argument_list|)
expr_stmt|;
return|return
name|history
return|;
block|}
annotation|@
name|Override
DECL|method|after (Exchange exchange, MessageHistory history)
specifier|public
name|void
name|after
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|MessageHistory
name|history
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|history
operator|!=
literal|null
condition|)
block|{
name|history
operator|.
name|nodeProcessingDone
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Advice for {@link org.apache.camel.spi.StreamCachingStrategy}      */
DECL|class|StreamCachingAdvice
specifier|public
specifier|static
class|class
name|StreamCachingAdvice
implements|implements
name|CamelInternalProcessorAdvice
argument_list|<
name|StreamCache
argument_list|>
implements|,
name|Ordered
block|{
DECL|field|strategy
specifier|private
specifier|final
name|StreamCachingStrategy
name|strategy
decl_stmt|;
DECL|method|StreamCachingAdvice (StreamCachingStrategy strategy)
specifier|public
name|StreamCachingAdvice
parameter_list|(
name|StreamCachingStrategy
name|strategy
parameter_list|)
block|{
name|this
operator|.
name|strategy
operator|=
name|strategy
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|before (Exchange exchange)
specifier|public
name|StreamCache
name|before
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
comment|// check if body is already cached
name|Object
name|body
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|()
decl_stmt|;
if|if
condition|(
name|body
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|body
operator|instanceof
name|StreamCache
condition|)
block|{
name|StreamCache
name|sc
init|=
operator|(
name|StreamCache
operator|)
name|body
decl_stmt|;
comment|// reset so the cache is ready to be used before processing
name|sc
operator|.
name|reset
argument_list|()
expr_stmt|;
return|return
name|sc
return|;
block|}
comment|// cache the body and if we could do that replace it as the new body
name|StreamCache
name|sc
init|=
name|strategy
operator|.
name|cache
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|!=
literal|null
condition|)
block|{
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|setBody
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
name|sc
return|;
block|}
annotation|@
name|Override
DECL|method|after (Exchange exchange, StreamCache sc)
specifier|public
name|void
name|after
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|StreamCache
name|sc
parameter_list|)
throws|throws
name|Exception
block|{
name|Object
name|body
decl_stmt|;
if|if
condition|(
name|exchange
operator|.
name|hasOut
argument_list|()
condition|)
block|{
name|body
operator|=
name|exchange
operator|.
name|getOut
argument_list|()
operator|.
name|getBody
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|body
operator|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|body
operator|!=
literal|null
operator|&&
name|body
operator|instanceof
name|StreamCache
condition|)
block|{
comment|// reset so the cache is ready to be reused after processing
operator|(
operator|(
name|StreamCache
operator|)
name|body
operator|)
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getOrder ()
specifier|public
name|int
name|getOrder
parameter_list|()
block|{
comment|// we want stream caching first
return|return
name|Ordered
operator|.
name|HIGHEST
return|;
block|}
block|}
comment|/**      * Advice for delaying      */
DECL|class|DelayerAdvice
specifier|public
specifier|static
class|class
name|DelayerAdvice
implements|implements
name|CamelInternalProcessorAdvice
block|{
DECL|field|delay
specifier|private
specifier|final
name|long
name|delay
decl_stmt|;
DECL|method|DelayerAdvice (long delay)
specifier|public
name|DelayerAdvice
parameter_list|(
name|long
name|delay
parameter_list|)
block|{
name|this
operator|.
name|delay
operator|=
name|delay
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|before (Exchange exchange)
specifier|public
name|Object
name|before
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
try|try
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Sleeping for: {} millis"
argument_list|,
name|delay
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sleep interrupted"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|after (Exchange exchange, Object data)
specifier|public
name|void
name|after
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|data
parameter_list|)
throws|throws
name|Exception
block|{
comment|// noop
block|}
block|}
block|}
end_class

end_unit

