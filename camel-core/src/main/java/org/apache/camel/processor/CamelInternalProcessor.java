begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.processor
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RejectedExecutionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|AsyncCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Processor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Route
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|StatefulService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|api
operator|.
name|management
operator|.
name|PerformanceCounter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|impl
operator|.
name|DefaultUnitOfWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|impl
operator|.
name|MDCUnitOfWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|management
operator|.
name|DelegatePerformanceCounter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|management
operator|.
name|mbean
operator|.
name|ManagedPerformanceCounter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|model
operator|.
name|ProcessorDefinition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
operator|.
name|interceptor
operator|.
name|BacklogDebugger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
operator|.
name|interceptor
operator|.
name|BacklogTracer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
operator|.
name|interceptor
operator|.
name|DefaultBacklogTracerEventMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|InflightRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|RouteContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|RoutePolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|UnitOfWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|MessageHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|StopWatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Internal {@link Processor} that Camel routing engine used during routing for cross cutting functionality such as:  *<ul>  *<li>Execute {@link UnitOfWork}</li>  *<li>Keeping track which route currently is being routed</li>  *<li>Execute {@link RoutePolicy}</li>  *<li>Gather JMX performance statics</li>  *<li>Tracing</li>  *<li>Debugging</li>  *</ul>  * ... and more.  *<p/>  * This implementation executes this cross cutting functionality as a {@link CamelInternalProcessorAdvice} advice (before and after advice)  * by executing the {@link CamelInternalProcessorAdvice#before(org.apache.camel.Exchange)} and  * {@link CamelInternalProcessorAdvice#after(org.apache.camel.Exchange, Object)} callbacks in correct order during routing.  * This reduces number of stack frames needed during routing, and reduce the number of lines in stacktraces, as well  * makes debugging the routing engine easier for end users.  *<p/>  *<b>Debugging tips:</b> Camel end users whom want to debug their Camel applications with the Camel source code, then make sure to  * read the source code of this class about the debugging tips, which you can find in the  * {@link #process(org.apache.camel.Exchange, org.apache.camel.AsyncCallback)} method.  */
end_comment

begin_class
DECL|class|CamelInternalProcessor
specifier|public
class|class
name|CamelInternalProcessor
extends|extends
name|DelegateAsyncProcessor
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|CamelInternalProcessor
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|advices
specifier|private
specifier|final
name|List
argument_list|<
name|CamelInternalProcessorAdvice
argument_list|>
name|advices
init|=
operator|new
name|ArrayList
argument_list|<
name|CamelInternalProcessorAdvice
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|CamelInternalProcessor ()
specifier|public
name|CamelInternalProcessor
parameter_list|()
block|{     }
DECL|method|CamelInternalProcessor (Processor processor)
specifier|public
name|CamelInternalProcessor
parameter_list|(
name|Processor
name|processor
parameter_list|)
block|{
name|super
argument_list|(
name|processor
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds an {@link CamelInternalProcessorAdvice} advice to the list of advices to execute by this internal processor.      *      * @param advice  the advice to add      */
DECL|method|addAdvice (CamelInternalProcessorAdvice advice)
specifier|public
name|void
name|addAdvice
parameter_list|(
name|CamelInternalProcessorAdvice
name|advice
parameter_list|)
block|{
name|advices
operator|.
name|add
argument_list|(
name|advice
argument_list|)
expr_stmt|;
block|}
comment|/**      * Gets the advice with the given type.      *      * @param type  the type of the advice      * @return the advice if exists, or<tt>null</tt> if no advices has been added with the given type.      */
DECL|method|getAdvice (Class<T> type)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|getAdvice
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
for|for
control|(
name|CamelInternalProcessorAdvice
name|task
range|:
name|advices
control|)
block|{
if|if
condition|(
name|type
operator|.
name|isInstance
argument_list|(
name|task
argument_list|)
condition|)
block|{
return|return
name|type
operator|.
name|cast
argument_list|(
name|task
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|process (Exchange exchange, AsyncCallback callback)
specifier|public
name|boolean
name|process
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|AsyncCallback
name|callback
parameter_list|)
block|{
comment|// ----------------------------------------------------------
comment|// CAMEL END USER - READ ME FOR DEBUGGING TIPS
comment|// ----------------------------------------------------------
comment|// If you want to debug the Camel routing engine, then there is a lot of internal functionality
comment|// the routing engine executes during routing messages. You can skip debugging this internal
comment|// functionality and instead debug where the routing engine continues routing to the next node
comment|// in the routes. The CamelInternalProcessor is a vital part of the routing engine, as its
comment|// being used in between the nodes. As an end user you can just debug the code in this class
comment|// in between the:
comment|//   CAMEL END USER - DEBUG ME HERE +++ START +++
comment|//   CAMEL END USER - DEBUG ME HERE +++ END +++
comment|// you can see in the code below.
comment|// ----------------------------------------------------------
if|if
condition|(
name|processor
operator|==
literal|null
operator|||
operator|!
name|continueProcessing
argument_list|(
name|exchange
argument_list|)
condition|)
block|{
comment|// no processor or we should not continue then we are done
name|callback
operator|.
name|done
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|states
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|(
name|advices
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|CamelInternalProcessorAdvice
name|task
range|:
name|advices
control|)
block|{
try|try
block|{
name|Object
name|state
init|=
name|task
operator|.
name|before
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
name|states
operator|.
name|add
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|exchange
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|callback
operator|.
name|done
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|// create internal callback which will execute the advices in reverse order when done
name|callback
operator|=
operator|new
name|InternalCallback
argument_list|(
name|states
argument_list|,
name|exchange
argument_list|,
name|callback
argument_list|)
expr_stmt|;
comment|// UNIT_OF_WORK_PROCESS_SYNC is @deprecated and we should remove it from Camel 3.0
name|Object
name|synchronous
init|=
name|exchange
operator|.
name|removeProperty
argument_list|(
name|Exchange
operator|.
name|UNIT_OF_WORK_PROCESS_SYNC
argument_list|)
decl_stmt|;
if|if
condition|(
name|exchange
operator|.
name|isTransacted
argument_list|()
operator|||
name|synchronous
operator|!=
literal|null
condition|)
block|{
comment|// must be synchronized for transacted exchanges
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|exchange
operator|.
name|isTransacted
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}"
argument_list|,
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Synchronous UnitOfWork Exchange must be routed synchronously for exchangeId: {} -> {}"
argument_list|,
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ----------------------------------------------------------
comment|// CAMEL END USER - DEBUG ME HERE +++ START +++
comment|// ----------------------------------------------------------
try|try
block|{
name|processor
operator|.
name|process
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|exchange
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|// ----------------------------------------------------------
comment|// CAMEL END USER - DEBUG ME HERE +++ END +++
comment|// ----------------------------------------------------------
name|callback
operator|.
name|done
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
specifier|final
name|UnitOfWork
name|uow
init|=
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
decl_stmt|;
comment|// allow unit of work to wrap callback in case it need to do some special work
comment|// for example the MDCUnitOfWork
name|AsyncCallback
name|async
init|=
name|callback
decl_stmt|;
if|if
condition|(
name|uow
operator|!=
literal|null
condition|)
block|{
name|async
operator|=
name|uow
operator|.
name|beforeProcess
argument_list|(
name|processor
argument_list|,
name|exchange
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
comment|// ----------------------------------------------------------
comment|// CAMEL END USER - DEBUG ME HERE +++ START +++
comment|// ----------------------------------------------------------
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Processing exchange for exchangeId: {} -> {}"
argument_list|,
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
name|boolean
name|sync
init|=
name|processor
operator|.
name|process
argument_list|(
name|exchange
argument_list|,
name|async
argument_list|)
decl_stmt|;
comment|// ----------------------------------------------------------
comment|// CAMEL END USER - DEBUG ME HERE +++ END +++
comment|// ----------------------------------------------------------
comment|// execute any after processor work (in current thread, not in the callback)
if|if
condition|(
name|uow
operator|!=
literal|null
condition|)
block|{
name|uow
operator|.
name|afterProcess
argument_list|(
name|processor
argument_list|,
name|exchange
argument_list|,
name|callback
argument_list|,
name|sync
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Exchange processed and is continued routed {} for exchangeId: {} -> {}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|sync
condition|?
literal|"synchronously"
else|:
literal|"asynchronously"
block|,
name|exchange
operator|.
name|getExchangeId
argument_list|()
block|,
name|exchange
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|sync
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|processor
operator|!=
literal|null
condition|?
name|processor
operator|.
name|toString
argument_list|()
else|:
name|super
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Internal callback that executes the after advices.      */
DECL|class|InternalCallback
specifier|private
specifier|final
class|class
name|InternalCallback
implements|implements
name|AsyncCallback
block|{
DECL|field|states
specifier|private
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|states
decl_stmt|;
DECL|field|exchange
specifier|private
specifier|final
name|Exchange
name|exchange
decl_stmt|;
DECL|field|callback
specifier|private
specifier|final
name|AsyncCallback
name|callback
decl_stmt|;
DECL|method|InternalCallback (List<Object> states, Exchange exchange, AsyncCallback callback)
specifier|private
name|InternalCallback
parameter_list|(
name|List
argument_list|<
name|Object
argument_list|>
name|states
parameter_list|,
name|Exchange
name|exchange
parameter_list|,
name|AsyncCallback
name|callback
parameter_list|)
block|{
name|this
operator|.
name|states
operator|=
name|states
expr_stmt|;
name|this
operator|.
name|exchange
operator|=
name|exchange
expr_stmt|;
name|this
operator|.
name|callback
operator|=
name|callback
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|done (boolean doneSync)
specifier|public
name|void
name|done
parameter_list|(
name|boolean
name|doneSync
parameter_list|)
block|{
comment|// NOTE: if you are debugging Camel routes, then all the code in the for loop below is internal only
comment|// so you can step straight to the finally block and invoke the callback
comment|// we should call after in reverse order
try|try
block|{
for|for
control|(
name|int
name|i
init|=
name|advices
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|CamelInternalProcessorAdvice
name|task
init|=
name|advices
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Object
name|state
init|=
name|states
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
try|try
block|{
name|task
operator|.
name|after
argument_list|(
name|exchange
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|exchange
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|// allow all advices to complete even if there was an exception
block|}
block|}
block|}
finally|finally
block|{
comment|// ----------------------------------------------------------
comment|// CAMEL END USER - DEBUG ME HERE +++ START +++
comment|// ----------------------------------------------------------
comment|// callback must be called
name|callback
operator|.
name|done
argument_list|(
name|doneSync
argument_list|)
expr_stmt|;
comment|// ----------------------------------------------------------
comment|// CAMEL END USER - DEBUG ME HERE +++ END +++
comment|// ----------------------------------------------------------
block|}
block|}
block|}
comment|/**      * Strategy to determine if we should continue processing the {@link Exchange}.      */
DECL|method|continueProcessing (Exchange exchange)
specifier|protected
name|boolean
name|continueProcessing
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|Object
name|stop
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|ROUTE_STOP
argument_list|)
decl_stmt|;
if|if
condition|(
name|stop
operator|!=
literal|null
condition|)
block|{
name|boolean
name|doStop
init|=
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|Boolean
operator|.
name|class
argument_list|,
name|stop
argument_list|)
decl_stmt|;
if|if
condition|(
name|doStop
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exchange is marked to stop routing: {}"
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|// determine if we can still run, or the camel context is forcing a shutdown
name|boolean
name|forceShutdown
init|=
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getShutdownStrategy
argument_list|()
operator|.
name|forceShutdown
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|forceShutdown
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Run not allowed as ShutdownStrategy is forcing shutting down, will reject executing exchange: {}"
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
if|if
condition|(
name|exchange
operator|.
name|getException
argument_list|()
operator|==
literal|null
condition|)
block|{
name|exchange
operator|.
name|setException
argument_list|(
operator|new
name|RejectedExecutionException
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|// yes we can continue
return|return
literal|true
return|;
block|}
comment|/**      * Advice for JMX instrumentation of the process being invoked.      *<p/>      * This advice keeps track of JMX metrics for performance statistics.      *<p/>      * The current implementation of this advice is only used for route level statistics. For processor levels      * they are still wrapped in the route processor chains.      */
DECL|class|InstrumentationAdvice
specifier|public
specifier|static
class|class
name|InstrumentationAdvice
implements|implements
name|CamelInternalProcessorAdvice
argument_list|<
name|StopWatch
argument_list|>
block|{
DECL|field|counter
specifier|private
name|PerformanceCounter
name|counter
decl_stmt|;
DECL|field|type
specifier|private
name|String
name|type
decl_stmt|;
DECL|method|InstrumentationAdvice (String type)
specifier|public
name|InstrumentationAdvice
parameter_list|(
name|String
name|type
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
DECL|method|setCounter (Object counter)
specifier|public
name|void
name|setCounter
parameter_list|(
name|Object
name|counter
parameter_list|)
block|{
name|ManagedPerformanceCounter
name|mpc
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|counter
operator|instanceof
name|ManagedPerformanceCounter
condition|)
block|{
name|mpc
operator|=
operator|(
name|ManagedPerformanceCounter
operator|)
name|counter
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|counter
operator|instanceof
name|DelegatePerformanceCounter
condition|)
block|{
operator|(
operator|(
name|DelegatePerformanceCounter
operator|)
name|this
operator|.
name|counter
operator|)
operator|.
name|setCounter
argument_list|(
name|mpc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mpc
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|counter
operator|=
name|mpc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|counter
operator|instanceof
name|PerformanceCounter
condition|)
block|{
name|this
operator|.
name|counter
operator|=
operator|(
name|PerformanceCounter
operator|)
name|counter
expr_stmt|;
block|}
block|}
DECL|method|recordTime (Exchange exchange, long duration)
specifier|protected
name|void
name|recordTime
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|long
name|duration
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}Recording duration: {} millis for exchange: {}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|type
operator|!=
literal|null
condition|?
name|type
operator|+
literal|": "
else|:
literal|""
block|,
name|duration
block|,
name|exchange
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|exchange
operator|.
name|isFailed
argument_list|()
operator|&&
name|exchange
operator|.
name|getException
argument_list|()
operator|==
literal|null
condition|)
block|{
name|counter
operator|.
name|completedExchange
argument_list|(
name|exchange
argument_list|,
name|duration
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|counter
operator|.
name|failedExchange
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getType ()
specifier|public
name|String
name|getType
parameter_list|()
block|{
return|return
name|type
return|;
block|}
DECL|method|setType (String type)
specifier|public
name|void
name|setType
parameter_list|(
name|String
name|type
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|before (Exchange exchange)
specifier|public
name|StopWatch
name|before
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
comment|// only record time if stats is enabled
return|return
operator|(
name|counter
operator|!=
literal|null
operator|&&
name|counter
operator|.
name|isStatisticsEnabled
argument_list|()
operator|)
condition|?
operator|new
name|StopWatch
argument_list|()
else|:
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|after (Exchange exchange, StopWatch watch)
specifier|public
name|void
name|after
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|StopWatch
name|watch
parameter_list|)
throws|throws
name|Exception
block|{
comment|// record end time
if|if
condition|(
name|watch
operator|!=
literal|null
condition|)
block|{
name|recordTime
argument_list|(
name|exchange
argument_list|,
name|watch
operator|.
name|stop
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Advice to inject the current {@link RouteContext} into the {@link UnitOfWork} on the {@link Exchange}      */
DECL|class|RouteContextAdvice
specifier|public
specifier|static
class|class
name|RouteContextAdvice
implements|implements
name|CamelInternalProcessorAdvice
argument_list|<
name|UnitOfWork
argument_list|>
block|{
DECL|field|routeContext
specifier|private
specifier|final
name|RouteContext
name|routeContext
decl_stmt|;
DECL|method|RouteContextAdvice (RouteContext routeContext)
specifier|public
name|RouteContextAdvice
parameter_list|(
name|RouteContext
name|routeContext
parameter_list|)
block|{
name|this
operator|.
name|routeContext
operator|=
name|routeContext
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|before (Exchange exchange)
specifier|public
name|UnitOfWork
name|before
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
comment|// push the current route context
specifier|final
name|UnitOfWork
name|unitOfWork
init|=
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
decl_stmt|;
if|if
condition|(
name|unitOfWork
operator|!=
literal|null
condition|)
block|{
name|unitOfWork
operator|.
name|pushRouteContext
argument_list|(
name|routeContext
argument_list|)
expr_stmt|;
block|}
return|return
name|unitOfWork
return|;
block|}
annotation|@
name|Override
DECL|method|after (Exchange exchange, UnitOfWork unitOfWork)
specifier|public
name|void
name|after
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|UnitOfWork
name|unitOfWork
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|unitOfWork
operator|!=
literal|null
condition|)
block|{
name|unitOfWork
operator|.
name|popRouteContext
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Advice to keep the {@link InflightRepository} up to date.      */
DECL|class|RouteInflightRepositoryAdvice
specifier|public
specifier|static
class|class
name|RouteInflightRepositoryAdvice
implements|implements
name|CamelInternalProcessorAdvice
block|{
DECL|field|inflightRepository
specifier|private
specifier|final
name|InflightRepository
name|inflightRepository
decl_stmt|;
DECL|field|id
specifier|private
specifier|final
name|String
name|id
decl_stmt|;
DECL|method|RouteInflightRepositoryAdvice (InflightRepository inflightRepository, String id)
specifier|public
name|RouteInflightRepositoryAdvice
parameter_list|(
name|InflightRepository
name|inflightRepository
parameter_list|,
name|String
name|id
parameter_list|)
block|{
name|this
operator|.
name|inflightRepository
operator|=
name|inflightRepository
expr_stmt|;
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|before (Exchange exchange)
specifier|public
name|Object
name|before
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
name|inflightRepository
operator|.
name|add
argument_list|(
name|exchange
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|after (Exchange exchange, Object state)
specifier|public
name|void
name|after
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|state
parameter_list|)
throws|throws
name|Exception
block|{
name|inflightRepository
operator|.
name|remove
argument_list|(
name|exchange
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Advice to execute any {@link RoutePolicy} a route may have been configured with.      */
DECL|class|RoutePolicyAdvice
specifier|public
specifier|static
class|class
name|RoutePolicyAdvice
implements|implements
name|CamelInternalProcessorAdvice
block|{
DECL|field|routePolicies
specifier|private
specifier|final
name|List
argument_list|<
name|RoutePolicy
argument_list|>
name|routePolicies
decl_stmt|;
DECL|field|route
specifier|private
name|Route
name|route
decl_stmt|;
DECL|method|RoutePolicyAdvice (List<RoutePolicy> routePolicies)
specifier|public
name|RoutePolicyAdvice
parameter_list|(
name|List
argument_list|<
name|RoutePolicy
argument_list|>
name|routePolicies
parameter_list|)
block|{
name|this
operator|.
name|routePolicies
operator|=
name|routePolicies
expr_stmt|;
block|}
DECL|method|setRoute (Route route)
specifier|public
name|void
name|setRoute
parameter_list|(
name|Route
name|route
parameter_list|)
block|{
name|this
operator|.
name|route
operator|=
name|route
expr_stmt|;
block|}
comment|/**          * Strategy to determine if this policy is allowed to run          *          * @param policy the policy          * @return<tt>true</tt> to run          */
DECL|method|isRoutePolicyRunAllowed (RoutePolicy policy)
specifier|protected
name|boolean
name|isRoutePolicyRunAllowed
parameter_list|(
name|RoutePolicy
name|policy
parameter_list|)
block|{
if|if
condition|(
name|policy
operator|instanceof
name|StatefulService
condition|)
block|{
name|StatefulService
name|ss
init|=
operator|(
name|StatefulService
operator|)
name|policy
decl_stmt|;
return|return
name|ss
operator|.
name|isRunAllowed
argument_list|()
return|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|before (Exchange exchange)
specifier|public
name|Object
name|before
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
comment|// invoke begin
for|for
control|(
name|RoutePolicy
name|policy
range|:
name|routePolicies
control|)
block|{
try|try
block|{
if|if
condition|(
name|isRoutePolicyRunAllowed
argument_list|(
name|policy
argument_list|)
condition|)
block|{
name|policy
operator|.
name|onExchangeBegin
argument_list|(
name|route
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error occurred during onExchangeBegin on RoutePolicy: "
operator|+
name|policy
operator|+
literal|". This exception will be ignored"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|after (Exchange exchange, Object data)
specifier|public
name|void
name|after
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|data
parameter_list|)
throws|throws
name|Exception
block|{
comment|// do not invoke it if Camel is stopping as we don't want
comment|// the policy to start a consumer during Camel is stopping
if|if
condition|(
name|isCamelStopping
argument_list|(
name|exchange
operator|.
name|getContext
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
for|for
control|(
name|RoutePolicy
name|policy
range|:
name|routePolicies
control|)
block|{
try|try
block|{
if|if
condition|(
name|isRoutePolicyRunAllowed
argument_list|(
name|policy
argument_list|)
condition|)
block|{
name|policy
operator|.
name|onExchangeDone
argument_list|(
name|route
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error occurred during onExchangeDone on RoutePolicy: "
operator|+
name|policy
operator|+
literal|". This exception will be ignored"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|isCamelStopping (CamelContext context)
specifier|private
specifier|static
name|boolean
name|isCamelStopping
parameter_list|(
name|CamelContext
name|context
parameter_list|)
block|{
if|if
condition|(
name|context
operator|instanceof
name|StatefulService
condition|)
block|{
name|StatefulService
name|ss
init|=
operator|(
name|StatefulService
operator|)
name|context
decl_stmt|;
return|return
name|ss
operator|.
name|isStopping
argument_list|()
operator|||
name|ss
operator|.
name|isStopped
argument_list|()
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Advice to execute the {@link BacklogTracer} if enabled.      */
DECL|class|BacklogTracerAdvice
specifier|public
specifier|static
specifier|final
class|class
name|BacklogTracerAdvice
implements|implements
name|CamelInternalProcessorAdvice
block|{
DECL|field|queue
specifier|private
specifier|final
name|Queue
argument_list|<
name|DefaultBacklogTracerEventMessage
argument_list|>
name|queue
decl_stmt|;
DECL|field|backlogTracer
specifier|private
specifier|final
name|BacklogTracer
name|backlogTracer
decl_stmt|;
DECL|field|processorDefinition
specifier|private
specifier|final
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|processorDefinition
decl_stmt|;
DECL|field|routeDefinition
specifier|private
specifier|final
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|routeDefinition
decl_stmt|;
DECL|field|first
specifier|private
specifier|final
name|boolean
name|first
decl_stmt|;
DECL|method|BacklogTracerAdvice (Queue<DefaultBacklogTracerEventMessage> queue, BacklogTracer backlogTracer, ProcessorDefinition<?> processorDefinition, ProcessorDefinition<?> routeDefinition, boolean first)
specifier|public
name|BacklogTracerAdvice
parameter_list|(
name|Queue
argument_list|<
name|DefaultBacklogTracerEventMessage
argument_list|>
name|queue
parameter_list|,
name|BacklogTracer
name|backlogTracer
parameter_list|,
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|processorDefinition
parameter_list|,
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|routeDefinition
parameter_list|,
name|boolean
name|first
parameter_list|)
block|{
name|this
operator|.
name|queue
operator|=
name|queue
expr_stmt|;
name|this
operator|.
name|backlogTracer
operator|=
name|backlogTracer
expr_stmt|;
name|this
operator|.
name|processorDefinition
operator|=
name|processorDefinition
expr_stmt|;
name|this
operator|.
name|routeDefinition
operator|=
name|routeDefinition
expr_stmt|;
name|this
operator|.
name|first
operator|=
name|first
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|before (Exchange exchange)
specifier|public
name|Object
name|before
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|backlogTracer
operator|.
name|shouldTrace
argument_list|(
name|processorDefinition
argument_list|,
name|exchange
argument_list|)
condition|)
block|{
comment|// ensure there is space on the queue
name|int
name|drain
init|=
name|queue
operator|.
name|size
argument_list|()
operator|-
name|backlogTracer
operator|.
name|getBacklogSize
argument_list|()
decl_stmt|;
comment|// and we need room for ourselves and possible also a first pseudo message as well
name|drain
operator|+=
name|first
condition|?
literal|2
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|drain
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|drain
condition|;
name|i
operator|++
control|)
block|{
name|queue
operator|.
name|poll
argument_list|()
expr_stmt|;
block|}
block|}
name|Date
name|timestamp
init|=
operator|new
name|Date
argument_list|()
decl_stmt|;
name|String
name|toNode
init|=
name|processorDefinition
operator|.
name|getId
argument_list|()
decl_stmt|;
name|String
name|exchangeId
init|=
name|exchange
operator|.
name|getExchangeId
argument_list|()
decl_stmt|;
name|String
name|messageAsXml
init|=
name|MessageHelper
operator|.
name|dumpAsXml
argument_list|(
name|exchange
operator|.
name|getIn
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|4
argument_list|,
name|backlogTracer
operator|.
name|isBodyIncludeStreams
argument_list|()
argument_list|,
name|backlogTracer
operator|.
name|isBodyIncludeFiles
argument_list|()
argument_list|,
name|backlogTracer
operator|.
name|getBodyMaxChars
argument_list|()
argument_list|)
decl_stmt|;
comment|// if first we should add a pseudo trace message as well, so we have a starting message (eg from the route)
name|String
name|routeId
init|=
name|routeDefinition
operator|.
name|getId
argument_list|()
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|Date
name|created
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|CREATED_TIMESTAMP
argument_list|,
name|timestamp
argument_list|,
name|Date
operator|.
name|class
argument_list|)
decl_stmt|;
name|DefaultBacklogTracerEventMessage
name|pseudo
init|=
operator|new
name|DefaultBacklogTracerEventMessage
argument_list|(
name|backlogTracer
operator|.
name|incrementTraceCounter
argument_list|()
argument_list|,
name|created
argument_list|,
name|routeId
argument_list|,
literal|null
argument_list|,
name|exchangeId
argument_list|,
name|messageAsXml
argument_list|)
decl_stmt|;
name|queue
operator|.
name|add
argument_list|(
name|pseudo
argument_list|)
expr_stmt|;
block|}
name|DefaultBacklogTracerEventMessage
name|event
init|=
operator|new
name|DefaultBacklogTracerEventMessage
argument_list|(
name|backlogTracer
operator|.
name|incrementTraceCounter
argument_list|()
argument_list|,
name|timestamp
argument_list|,
name|routeId
argument_list|,
name|toNode
argument_list|,
name|exchangeId
argument_list|,
name|messageAsXml
argument_list|)
decl_stmt|;
name|queue
operator|.
name|add
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|after (Exchange exchange, Object data)
specifier|public
name|void
name|after
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|data
parameter_list|)
throws|throws
name|Exception
block|{
comment|// noop
block|}
block|}
comment|/**      * Advice to execute the {@link org.apache.camel.processor.interceptor.BacklogDebugger} if enabled.      */
DECL|class|BacklogDebuggerAdvice
specifier|public
specifier|static
specifier|final
class|class
name|BacklogDebuggerAdvice
implements|implements
name|CamelInternalProcessorAdvice
argument_list|<
name|StopWatch
argument_list|>
block|{
DECL|field|backlogDebugger
specifier|private
specifier|final
name|BacklogDebugger
name|backlogDebugger
decl_stmt|;
DECL|field|target
specifier|private
specifier|final
name|Processor
name|target
decl_stmt|;
DECL|field|definition
specifier|private
specifier|final
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|definition
decl_stmt|;
DECL|field|nodeId
specifier|private
specifier|final
name|String
name|nodeId
decl_stmt|;
DECL|method|BacklogDebuggerAdvice (BacklogDebugger backlogDebugger, Processor target, ProcessorDefinition<?> definition)
specifier|public
name|BacklogDebuggerAdvice
parameter_list|(
name|BacklogDebugger
name|backlogDebugger
parameter_list|,
name|Processor
name|target
parameter_list|,
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|definition
parameter_list|)
block|{
name|this
operator|.
name|backlogDebugger
operator|=
name|backlogDebugger
expr_stmt|;
name|this
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|this
operator|.
name|definition
operator|=
name|definition
expr_stmt|;
name|this
operator|.
name|nodeId
operator|=
name|definition
operator|.
name|getId
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|before (Exchange exchange)
specifier|public
name|StopWatch
name|before
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|backlogDebugger
operator|.
name|isEnabled
argument_list|()
operator|&&
operator|(
name|backlogDebugger
operator|.
name|hasBreakpoint
argument_list|(
name|nodeId
argument_list|)
operator|||
name|backlogDebugger
operator|.
name|isSingleStepMode
argument_list|()
operator|)
condition|)
block|{
name|StopWatch
name|watch
init|=
operator|new
name|StopWatch
argument_list|()
decl_stmt|;
name|backlogDebugger
operator|.
name|beforeProcess
argument_list|(
name|exchange
argument_list|,
name|target
argument_list|,
name|definition
argument_list|)
expr_stmt|;
return|return
name|watch
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|after (Exchange exchange, StopWatch stopWatch)
specifier|public
name|void
name|after
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|StopWatch
name|stopWatch
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|stopWatch
operator|!=
literal|null
condition|)
block|{
name|backlogDebugger
operator|.
name|afterProcess
argument_list|(
name|exchange
argument_list|,
name|target
argument_list|,
name|definition
argument_list|,
name|stopWatch
operator|.
name|stop
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Advice to inject new {@link UnitOfWork} to the {@link Exchange} if needed, and as well to ensure      * the {@link UnitOfWork} is done and stopped.      */
DECL|class|UnitOfWorkProcessorAdvice
specifier|public
specifier|static
class|class
name|UnitOfWorkProcessorAdvice
implements|implements
name|CamelInternalProcessorAdvice
argument_list|<
name|UnitOfWork
argument_list|>
block|{
DECL|field|routeId
specifier|private
specifier|final
name|String
name|routeId
decl_stmt|;
DECL|method|UnitOfWorkProcessorAdvice (String routeId)
specifier|public
name|UnitOfWorkProcessorAdvice
parameter_list|(
name|String
name|routeId
parameter_list|)
block|{
name|this
operator|.
name|routeId
operator|=
name|routeId
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|before (Exchange exchange)
specifier|public
name|UnitOfWork
name|before
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
comment|// if the exchange doesn't have from route id set, then set it if it originated
comment|// from this unit of work
if|if
condition|(
name|routeId
operator|!=
literal|null
operator|&&
name|exchange
operator|.
name|getFromRouteId
argument_list|()
operator|==
literal|null
condition|)
block|{
name|exchange
operator|.
name|setFromRouteId
argument_list|(
name|routeId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// If there is no existing UoW, then we should start one and
comment|// terminate it once processing is completed for the exchange.
specifier|final
name|UnitOfWork
name|uow
init|=
name|createUnitOfWork
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
name|exchange
operator|.
name|setUnitOfWork
argument_list|(
name|uow
argument_list|)
expr_stmt|;
name|uow
operator|.
name|start
argument_list|()
expr_stmt|;
return|return
name|uow
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|after (Exchange exchange, UnitOfWork uow)
specifier|public
name|void
name|after
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|UnitOfWork
name|uow
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|uow
operator|!=
literal|null
condition|)
block|{
name|doneUow
argument_list|(
name|uow
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|createUnitOfWork (Exchange exchange)
specifier|protected
name|UnitOfWork
name|createUnitOfWork
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|UnitOfWork
name|answer
decl_stmt|;
if|if
condition|(
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|isUseMDCLogging
argument_list|()
condition|)
block|{
name|answer
operator|=
operator|new
name|MDCUnitOfWork
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|answer
operator|=
operator|new
name|DefaultUnitOfWork
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
DECL|method|doneUow (UnitOfWork uow, Exchange exchange)
specifier|private
name|void
name|doneUow
parameter_list|(
name|UnitOfWork
name|uow
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
comment|// unit of work is done
try|try
block|{
if|if
condition|(
name|uow
operator|!=
literal|null
condition|)
block|{
name|uow
operator|.
name|done
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception occurred during done UnitOfWork for Exchange: "
operator|+
name|exchange
operator|+
literal|". This exception will be ignored."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|uow
operator|!=
literal|null
condition|)
block|{
name|uow
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception occurred during stopping UnitOfWork for Exchange: "
operator|+
name|exchange
operator|+
literal|". This exception will be ignored."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// remove uow from exchange as its done
name|exchange
operator|.
name|setUnitOfWork
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Advice when an EIP uses the<tt>shareUnitOfWork</tt> functionality.      */
DECL|class|ChildUnitOfWorkProcessorAdvice
specifier|public
specifier|static
class|class
name|ChildUnitOfWorkProcessorAdvice
extends|extends
name|UnitOfWorkProcessorAdvice
block|{
DECL|field|parent
specifier|private
specifier|final
name|UnitOfWork
name|parent
decl_stmt|;
DECL|method|ChildUnitOfWorkProcessorAdvice (String routeId, UnitOfWork parent)
specifier|public
name|ChildUnitOfWorkProcessorAdvice
parameter_list|(
name|String
name|routeId
parameter_list|,
name|UnitOfWork
name|parent
parameter_list|)
block|{
name|super
argument_list|(
name|routeId
argument_list|)
expr_stmt|;
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createUnitOfWork (Exchange exchange)
specifier|protected
name|UnitOfWork
name|createUnitOfWork
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
comment|// let the parent create a child unit of work to be used
return|return
name|parent
operator|.
name|createChildUnitOfWork
argument_list|(
name|exchange
argument_list|)
return|;
block|}
block|}
comment|/**      * Advice when an EIP uses the<tt>shareUnitOfWork</tt> functionality.      */
DECL|class|SubUnitOfWorkProcessorAdvice
specifier|public
specifier|static
class|class
name|SubUnitOfWorkProcessorAdvice
implements|implements
name|CamelInternalProcessorAdvice
argument_list|<
name|UnitOfWork
argument_list|>
block|{
annotation|@
name|Override
DECL|method|before (Exchange exchange)
specifier|public
name|UnitOfWork
name|before
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
comment|// begin savepoint
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
operator|.
name|beginSubUnitOfWork
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
return|return
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|after (Exchange exchange, UnitOfWork unitOfWork)
specifier|public
name|void
name|after
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|UnitOfWork
name|unitOfWork
parameter_list|)
throws|throws
name|Exception
block|{
comment|// end sub unit of work
name|unitOfWork
operator|.
name|endSubUnitOfWork
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|MessageHistoryAdvice
specifier|public
specifier|static
class|class
name|MessageHistoryAdvice
implements|implements
name|CamelInternalProcessorAdvice
block|{
DECL|field|definition
specifier|private
specifier|final
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|definition
decl_stmt|;
DECL|method|MessageHistoryAdvice (ProcessorDefinition<?> definition)
specifier|public
name|MessageHistoryAdvice
parameter_list|(
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|definition
parameter_list|)
block|{
name|this
operator|.
name|definition
operator|=
name|definition
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|before (Exchange exchange)
specifier|public
name|Object
name|before
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
argument_list|>
name|history
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
literal|"CamelMessageHistory"
argument_list|,
name|List
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|history
operator|==
literal|null
condition|)
block|{
name|history
operator|=
operator|new
name|ArrayList
argument_list|<
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|exchange
operator|.
name|setProperty
argument_list|(
literal|"CamelMessageHistory"
argument_list|,
name|history
argument_list|)
expr_stmt|;
block|}
name|history
operator|.
name|add
argument_list|(
name|definition
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|after (Exchange exchange, Object data)
specifier|public
name|void
name|after
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|data
parameter_list|)
throws|throws
name|Exception
block|{
comment|// noop
block|}
block|}
block|}
end_class

end_unit

