begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.processor
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletionService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorCompletionService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|AsyncCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|AsyncProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelExchangeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Endpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|ErrorHandlerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Navigate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Processor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Producer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Traceable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
operator|.
name|aggregate
operator|.
name|AggregationStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
operator|.
name|aggregate
operator|.
name|TimeoutAwareAggregationStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|RouteContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|TracedRouteNodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|UnitOfWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|ServiceSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|AsyncProcessorConverterHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|AsyncProcessorHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|CastUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|EventHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ExchangeHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|KeyValueHolder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ObjectHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ServiceHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|StopWatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|concurrent
operator|.
name|AtomicException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|concurrent
operator|.
name|AtomicExchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|concurrent
operator|.
name|SubmitOrderedCompletionService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ObjectHelper
operator|.
name|notNull
import|;
end_import

begin_comment
comment|/**  * Implements the Multicast pattern to send a message exchange to a number of  * endpoints, each endpoint receiving a copy of the message exchange.  *  * @version   * @see Pipeline  */
end_comment

begin_class
DECL|class|MulticastProcessor
specifier|public
class|class
name|MulticastProcessor
extends|extends
name|ServiceSupport
implements|implements
name|AsyncProcessor
implements|,
name|Navigate
argument_list|<
name|Processor
argument_list|>
implements|,
name|Traceable
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
specifier|transient
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MulticastProcessor
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * Class that represent each step in the multicast route to do      */
DECL|class|DefaultProcessorExchangePair
specifier|static
specifier|final
class|class
name|DefaultProcessorExchangePair
implements|implements
name|ProcessorExchangePair
block|{
DECL|field|index
specifier|private
specifier|final
name|int
name|index
decl_stmt|;
DECL|field|processor
specifier|private
specifier|final
name|Processor
name|processor
decl_stmt|;
DECL|field|prepared
specifier|private
specifier|final
name|Processor
name|prepared
decl_stmt|;
DECL|field|exchange
specifier|private
specifier|final
name|Exchange
name|exchange
decl_stmt|;
DECL|method|DefaultProcessorExchangePair (int index, Processor processor, Processor prepared, Exchange exchange)
specifier|private
name|DefaultProcessorExchangePair
parameter_list|(
name|int
name|index
parameter_list|,
name|Processor
name|processor
parameter_list|,
name|Processor
name|prepared
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
name|this
operator|.
name|processor
operator|=
name|processor
expr_stmt|;
name|this
operator|.
name|prepared
operator|=
name|prepared
expr_stmt|;
name|this
operator|.
name|exchange
operator|=
name|exchange
expr_stmt|;
block|}
DECL|method|getIndex ()
specifier|public
name|int
name|getIndex
parameter_list|()
block|{
return|return
name|index
return|;
block|}
DECL|method|getExchange ()
specifier|public
name|Exchange
name|getExchange
parameter_list|()
block|{
return|return
name|exchange
return|;
block|}
DECL|method|getProducer ()
specifier|public
name|Producer
name|getProducer
parameter_list|()
block|{
if|if
condition|(
name|processor
operator|instanceof
name|Producer
condition|)
block|{
return|return
operator|(
name|Producer
operator|)
name|processor
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|getProcessor ()
specifier|public
name|Processor
name|getProcessor
parameter_list|()
block|{
return|return
name|prepared
return|;
block|}
DECL|method|begin ()
specifier|public
name|void
name|begin
parameter_list|()
block|{
comment|// noop
block|}
DECL|method|done ()
specifier|public
name|void
name|done
parameter_list|()
block|{
comment|// noop
block|}
block|}
comment|/**      * Class that represents prepared fine grained error handlers when processing multicasted/splitted exchanges      *<p/>      * See the<tt>createProcessorExchangePair</tt> and<tt>createErrorHandler</tt> methods.      */
DECL|class|PreparedErrorHandler
specifier|static
specifier|final
class|class
name|PreparedErrorHandler
extends|extends
name|KeyValueHolder
argument_list|<
name|RouteContext
argument_list|,
name|Processor
argument_list|>
block|{
DECL|method|PreparedErrorHandler (RouteContext key, Processor value)
specifier|public
name|PreparedErrorHandler
parameter_list|(
name|RouteContext
name|key
parameter_list|,
name|Processor
name|value
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|onPrepare
specifier|protected
specifier|final
name|Processor
name|onPrepare
decl_stmt|;
DECL|field|camelContext
specifier|private
specifier|final
name|CamelContext
name|camelContext
decl_stmt|;
DECL|field|processors
specifier|private
name|Collection
argument_list|<
name|Processor
argument_list|>
name|processors
decl_stmt|;
DECL|field|aggregationStrategy
specifier|private
specifier|final
name|AggregationStrategy
name|aggregationStrategy
decl_stmt|;
DECL|field|parallelProcessing
specifier|private
specifier|final
name|boolean
name|parallelProcessing
decl_stmt|;
DECL|field|streaming
specifier|private
specifier|final
name|boolean
name|streaming
decl_stmt|;
DECL|field|stopOnException
specifier|private
specifier|final
name|boolean
name|stopOnException
decl_stmt|;
DECL|field|executorService
specifier|private
specifier|final
name|ExecutorService
name|executorService
decl_stmt|;
DECL|field|shutdownExecutorService
specifier|private
specifier|final
name|boolean
name|shutdownExecutorService
decl_stmt|;
DECL|field|aggregateExecutorService
specifier|private
name|ExecutorService
name|aggregateExecutorService
decl_stmt|;
DECL|field|timeout
specifier|private
specifier|final
name|long
name|timeout
decl_stmt|;
DECL|field|errorHandlers
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|PreparedErrorHandler
argument_list|,
name|Processor
argument_list|>
name|errorHandlers
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|PreparedErrorHandler
argument_list|,
name|Processor
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|shareUnitOfWork
specifier|private
specifier|final
name|boolean
name|shareUnitOfWork
decl_stmt|;
DECL|method|MulticastProcessor (CamelContext camelContext, Collection<Processor> processors)
specifier|public
name|MulticastProcessor
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|,
name|Collection
argument_list|<
name|Processor
argument_list|>
name|processors
parameter_list|)
block|{
name|this
argument_list|(
name|camelContext
argument_list|,
name|processors
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|MulticastProcessor (CamelContext camelContext, Collection<Processor> processors, AggregationStrategy aggregationStrategy)
specifier|public
name|MulticastProcessor
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|,
name|Collection
argument_list|<
name|Processor
argument_list|>
name|processors
parameter_list|,
name|AggregationStrategy
name|aggregationStrategy
parameter_list|)
block|{
name|this
argument_list|(
name|camelContext
argument_list|,
name|processors
argument_list|,
name|aggregationStrategy
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|MulticastProcessor (CamelContext camelContext, Collection<Processor> processors, AggregationStrategy aggregationStrategy, boolean parallelProcessing, ExecutorService executorService, boolean shutdownExecutorService, boolean streaming, boolean stopOnException, long timeout, Processor onPrepare, boolean shareUnitOfWork)
specifier|public
name|MulticastProcessor
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|,
name|Collection
argument_list|<
name|Processor
argument_list|>
name|processors
parameter_list|,
name|AggregationStrategy
name|aggregationStrategy
parameter_list|,
name|boolean
name|parallelProcessing
parameter_list|,
name|ExecutorService
name|executorService
parameter_list|,
name|boolean
name|shutdownExecutorService
parameter_list|,
name|boolean
name|streaming
parameter_list|,
name|boolean
name|stopOnException
parameter_list|,
name|long
name|timeout
parameter_list|,
name|Processor
name|onPrepare
parameter_list|,
name|boolean
name|shareUnitOfWork
parameter_list|)
block|{
name|notNull
argument_list|(
name|camelContext
argument_list|,
literal|"camelContext"
argument_list|)
expr_stmt|;
name|this
operator|.
name|camelContext
operator|=
name|camelContext
expr_stmt|;
name|this
operator|.
name|processors
operator|=
name|processors
expr_stmt|;
name|this
operator|.
name|aggregationStrategy
operator|=
name|aggregationStrategy
expr_stmt|;
name|this
operator|.
name|executorService
operator|=
name|executorService
expr_stmt|;
name|this
operator|.
name|shutdownExecutorService
operator|=
name|shutdownExecutorService
expr_stmt|;
name|this
operator|.
name|streaming
operator|=
name|streaming
expr_stmt|;
name|this
operator|.
name|stopOnException
operator|=
name|stopOnException
expr_stmt|;
comment|// must enable parallel if executor service is provided
name|this
operator|.
name|parallelProcessing
operator|=
name|parallelProcessing
operator|||
name|executorService
operator|!=
literal|null
expr_stmt|;
name|this
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
name|this
operator|.
name|onPrepare
operator|=
name|onPrepare
expr_stmt|;
name|this
operator|.
name|shareUnitOfWork
operator|=
name|shareUnitOfWork
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Multicast["
operator|+
name|getProcessors
argument_list|()
operator|+
literal|"]"
return|;
block|}
DECL|method|getTraceLabel ()
specifier|public
name|String
name|getTraceLabel
parameter_list|()
block|{
return|return
literal|"multicast"
return|;
block|}
DECL|method|getCamelContext ()
specifier|public
name|CamelContext
name|getCamelContext
parameter_list|()
block|{
return|return
name|camelContext
return|;
block|}
DECL|method|process (Exchange exchange)
specifier|public
name|void
name|process
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
name|AsyncProcessorHelper
operator|.
name|process
argument_list|(
name|this
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
DECL|method|process (Exchange exchange, AsyncCallback callback)
specifier|public
name|boolean
name|process
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|AsyncCallback
name|callback
parameter_list|)
block|{
specifier|final
name|AtomicExchange
name|result
init|=
operator|new
name|AtomicExchange
argument_list|()
decl_stmt|;
specifier|final
name|Iterable
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|pairs
decl_stmt|;
comment|// multicast uses fine grained error handling on the output processors
comment|// so use try .. catch to cater for this
name|boolean
name|exhaust
init|=
literal|false
decl_stmt|;
try|try
block|{
name|boolean
name|sync
init|=
literal|true
decl_stmt|;
name|pairs
operator|=
name|createProcessorExchangePairs
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
comment|// after we have created the processors we consider the exchange as exhausted if an unhandled
comment|// exception was thrown, (used in the catch block)
comment|// if the processors is working in Streaming model, the exchange could not be processed at this point.
name|exhaust
operator|=
operator|!
name|isStreaming
argument_list|()
expr_stmt|;
if|if
condition|(
name|isParallelProcessing
argument_list|()
condition|)
block|{
comment|// ensure an executor is set when running in parallel
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|executorService
argument_list|,
literal|"executorService"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|doProcessParallel
argument_list|(
name|exchange
argument_list|,
name|result
argument_list|,
name|pairs
argument_list|,
name|isStreaming
argument_list|()
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sync
operator|=
name|doProcessSequential
argument_list|(
name|exchange
argument_list|,
name|result
argument_list|,
name|pairs
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sync
condition|)
block|{
comment|// the remainder of the multicast will be completed async
comment|// so we break out now, then the callback will be invoked which then continue routing from where we left here
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|exchange
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|// and do the done work
name|doDone
argument_list|(
name|exchange
argument_list|,
literal|null
argument_list|,
name|callback
argument_list|,
literal|true
argument_list|,
name|exhaust
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// multicasting was processed successfully
comment|// and do the done work
name|Exchange
name|subExchange
init|=
name|result
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|?
name|result
operator|.
name|get
argument_list|()
else|:
literal|null
decl_stmt|;
name|doDone
argument_list|(
name|exchange
argument_list|,
name|subExchange
argument_list|,
name|callback
argument_list|,
literal|true
argument_list|,
name|exhaust
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|doProcessParallel (final Exchange original, final AtomicExchange result, final Iterable<ProcessorExchangePair> pairs, final boolean streaming, final AsyncCallback callback)
specifier|protected
name|void
name|doProcessParallel
parameter_list|(
specifier|final
name|Exchange
name|original
parameter_list|,
specifier|final
name|AtomicExchange
name|result
parameter_list|,
specifier|final
name|Iterable
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|pairs
parameter_list|,
specifier|final
name|boolean
name|streaming
parameter_list|,
specifier|final
name|AsyncCallback
name|callback
parameter_list|)
throws|throws
name|Exception
block|{
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|executorService
argument_list|,
literal|"ExecutorService"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|aggregateExecutorService
argument_list|,
literal|"AggregateExecutorService"
argument_list|,
name|this
argument_list|)
expr_stmt|;
specifier|final
name|CompletionService
argument_list|<
name|Exchange
argument_list|>
name|completion
decl_stmt|;
if|if
condition|(
name|streaming
condition|)
block|{
comment|// execute tasks in parallel+streaming and aggregate in the order they are finished (out of order sequence)
name|completion
operator|=
operator|new
name|ExecutorCompletionService
argument_list|<
name|Exchange
argument_list|>
argument_list|(
name|executorService
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// execute tasks in parallel and aggregate in the order the tasks are submitted (in order sequence)
name|completion
operator|=
operator|new
name|SubmitOrderedCompletionService
argument_list|<
name|Exchange
argument_list|>
argument_list|(
name|executorService
argument_list|)
expr_stmt|;
block|}
specifier|final
name|AtomicInteger
name|total
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|it
init|=
name|pairs
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// when parallel then aggregate on the fly
specifier|final
name|AtomicBoolean
name|running
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|AtomicBoolean
name|allTasksSubmitted
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
specifier|final
name|CountDownLatch
name|aggregationOnTheFlyDone
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|AtomicException
name|executionException
init|=
operator|new
name|AtomicException
argument_list|()
decl_stmt|;
comment|// issue task to execute in separate thread so it can aggregate on-the-fly
comment|// while we submit new tasks, and those tasks complete concurrently
comment|// this allows us to optimize work and reduce memory consumption
specifier|final
name|AggregateOnTheFlyTask
name|aggregateOnTheFlyTask
init|=
operator|new
name|AggregateOnTheFlyTask
argument_list|(
name|result
argument_list|,
name|original
argument_list|,
name|total
argument_list|,
name|completion
argument_list|,
name|running
argument_list|,
name|aggregationOnTheFlyDone
argument_list|,
name|allTasksSubmitted
argument_list|,
name|executionException
argument_list|)
decl_stmt|;
specifier|final
name|AtomicBoolean
name|aggregationTaskSubmitted
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Starting to submit parallel tasks"
argument_list|)
expr_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|ProcessorExchangePair
name|pair
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|Exchange
name|subExchange
init|=
name|pair
operator|.
name|getExchange
argument_list|()
decl_stmt|;
name|updateNewExchange
argument_list|(
name|subExchange
argument_list|,
name|total
operator|.
name|intValue
argument_list|()
argument_list|,
name|pairs
argument_list|,
name|it
argument_list|)
expr_stmt|;
name|completion
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|Exchange
argument_list|>
argument_list|()
block|{
specifier|public
name|Exchange
name|call
parameter_list|()
throws|throws
name|Exception
block|{
comment|// only start the aggregation task when the task is being executed to avoid staring
comment|// the aggregation task to early and pile up too many threads
if|if
condition|(
name|aggregationTaskSubmitted
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
comment|// but only submit the task once
name|aggregateExecutorService
operator|.
name|submit
argument_list|(
name|aggregateOnTheFlyTask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|running
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// do not start processing the task if we are not running
return|return
name|subExchange
return|;
block|}
try|try
block|{
name|doProcessParallel
argument_list|(
name|pair
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|subExchange
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Decide whether to continue with the multicast or not; similar logic to the Pipeline
name|Integer
name|number
init|=
name|getExchangeIndex
argument_list|(
name|subExchange
argument_list|)
decl_stmt|;
name|boolean
name|continueProcessing
init|=
name|PipelineHelper
operator|.
name|continueProcessing
argument_list|(
name|subExchange
argument_list|,
literal|"Parallel processing failed for number "
operator|+
name|number
argument_list|,
name|LOG
argument_list|)
decl_stmt|;
if|if
condition|(
name|stopOnException
operator|&&
operator|!
name|continueProcessing
condition|)
block|{
comment|// signal to stop running
name|running
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// throw caused exception
if|if
condition|(
name|subExchange
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// wrap in exception to explain where it failed
throw|throw
operator|new
name|CamelExchangeException
argument_list|(
literal|"Parallel processing failed for number "
operator|+
name|number
argument_list|,
name|subExchange
argument_list|,
name|subExchange
operator|.
name|getException
argument_list|()
argument_list|)
throw|;
block|}
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"Parallel processing complete for exchange: {}"
argument_list|,
name|subExchange
argument_list|)
expr_stmt|;
return|return
name|subExchange
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|total
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|// signal all tasks has been submitted
name|LOG
operator|.
name|trace
argument_list|(
literal|"Signaling that all {} tasks has been submitted."
argument_list|,
name|total
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|allTasksSubmitted
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// its to hard to do parallel async routing so we let the caller thread be synchronously
comment|// and have it pickup the replies and do the aggregation (eg we use a latch to wait)
comment|// wait for aggregation to be done
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting for on-the-fly aggregation to complete aggregating {} responses for exchangeId: {}"
argument_list|,
name|total
operator|.
name|get
argument_list|()
argument_list|,
name|original
operator|.
name|getExchangeId
argument_list|()
argument_list|)
expr_stmt|;
name|aggregationOnTheFlyDone
operator|.
name|await
argument_list|()
expr_stmt|;
comment|// did we fail for whatever reason, if so throw that caused exception
if|if
condition|(
name|executionException
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Parallel processing failed due {}"
argument_list|,
name|executionException
operator|.
name|get
argument_list|()
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
throw|throw
name|executionException
operator|.
name|get
argument_list|()
throw|;
block|}
block|}
comment|// no everything is okay so we are done
name|LOG
operator|.
name|debug
argument_list|(
literal|"Done parallel processing {} exchanges"
argument_list|,
name|total
argument_list|)
expr_stmt|;
block|}
comment|/**      * Task to aggregate on-the-fly for completed tasks when using parallel processing.      *<p/>      * This ensures lower memory consumption as we do not need to keep all completed tasks in memory      * before we perform aggregation. Instead this separate thread will run and aggregate when new      * completed tasks is done.      *<p/>      * The logic is fairly complex as this implementation has to keep track how far it got, and also      * signal back to the<i>main</t> thread when its done, so the<i>main</t> thread can continue      * processing when the entire splitting is done.      */
DECL|class|AggregateOnTheFlyTask
specifier|private
specifier|final
class|class
name|AggregateOnTheFlyTask
implements|implements
name|Runnable
block|{
DECL|field|result
specifier|private
specifier|final
name|AtomicExchange
name|result
decl_stmt|;
DECL|field|original
specifier|private
specifier|final
name|Exchange
name|original
decl_stmt|;
DECL|field|total
specifier|private
specifier|final
name|AtomicInteger
name|total
decl_stmt|;
DECL|field|completion
specifier|private
specifier|final
name|CompletionService
argument_list|<
name|Exchange
argument_list|>
name|completion
decl_stmt|;
DECL|field|running
specifier|private
specifier|final
name|AtomicBoolean
name|running
decl_stmt|;
DECL|field|aggregationOnTheFlyDone
specifier|private
specifier|final
name|CountDownLatch
name|aggregationOnTheFlyDone
decl_stmt|;
DECL|field|allTasksSubmitted
specifier|private
specifier|final
name|AtomicBoolean
name|allTasksSubmitted
decl_stmt|;
DECL|field|executionException
specifier|private
specifier|final
name|AtomicException
name|executionException
decl_stmt|;
DECL|method|AggregateOnTheFlyTask (AtomicExchange result, Exchange original, AtomicInteger total, CompletionService<Exchange> completion, AtomicBoolean running, CountDownLatch aggregationOnTheFlyDone, AtomicBoolean allTasksSubmitted, AtomicException executionException)
specifier|private
name|AggregateOnTheFlyTask
parameter_list|(
name|AtomicExchange
name|result
parameter_list|,
name|Exchange
name|original
parameter_list|,
name|AtomicInteger
name|total
parameter_list|,
name|CompletionService
argument_list|<
name|Exchange
argument_list|>
name|completion
parameter_list|,
name|AtomicBoolean
name|running
parameter_list|,
name|CountDownLatch
name|aggregationOnTheFlyDone
parameter_list|,
name|AtomicBoolean
name|allTasksSubmitted
parameter_list|,
name|AtomicException
name|executionException
parameter_list|)
block|{
name|this
operator|.
name|result
operator|=
name|result
expr_stmt|;
name|this
operator|.
name|original
operator|=
name|original
expr_stmt|;
name|this
operator|.
name|total
operator|=
name|total
expr_stmt|;
name|this
operator|.
name|completion
operator|=
name|completion
expr_stmt|;
name|this
operator|.
name|running
operator|=
name|running
expr_stmt|;
name|this
operator|.
name|aggregationOnTheFlyDone
operator|=
name|aggregationOnTheFlyDone
expr_stmt|;
name|this
operator|.
name|allTasksSubmitted
operator|=
name|allTasksSubmitted
expr_stmt|;
name|this
operator|.
name|executionException
operator|=
name|executionException
expr_stmt|;
block|}
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Aggregate on the fly task started for exchangeId: {}"
argument_list|,
name|original
operator|.
name|getExchangeId
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|aggregateOnTheFly
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|Exception
condition|)
block|{
name|executionException
operator|.
name|set
argument_list|(
operator|(
name|Exception
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|executionException
operator|.
name|set
argument_list|(
name|ObjectHelper
operator|.
name|wrapRuntimeCamelException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|// must signal we are done so the latch can open and let the other thread continue processing
name|LOG
operator|.
name|debug
argument_list|(
literal|"Signaling we are done aggregating on the fly for exchangeId: {}"
argument_list|,
name|original
operator|.
name|getExchangeId
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Aggregate on the fly task done for exchangeId: {}"
argument_list|,
name|original
operator|.
name|getExchangeId
argument_list|()
argument_list|)
expr_stmt|;
name|aggregationOnTheFlyDone
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|aggregateOnTheFly ()
specifier|private
name|void
name|aggregateOnTheFly
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
block|{
name|boolean
name|timedOut
init|=
literal|false
decl_stmt|;
name|boolean
name|stoppedOnException
init|=
literal|false
decl_stmt|;
specifier|final
name|StopWatch
name|watch
init|=
operator|new
name|StopWatch
argument_list|()
decl_stmt|;
name|int
name|aggregated
init|=
literal|0
decl_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
comment|// not a for loop as on the fly may still run
while|while
condition|(
operator|!
name|done
condition|)
block|{
comment|// check if we have already aggregate everything
if|if
condition|(
name|allTasksSubmitted
operator|.
name|get
argument_list|()
operator|&&
name|aggregated
operator|>=
name|total
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Done aggregating {} exchanges on the fly."
argument_list|,
name|aggregated
argument_list|)
expr_stmt|;
break|break;
block|}
name|Future
argument_list|<
name|Exchange
argument_list|>
name|future
decl_stmt|;
if|if
condition|(
name|timedOut
condition|)
block|{
comment|// we are timed out but try to grab if some tasks has been completed
comment|// poll will return null if no tasks is present
name|future
operator|=
name|completion
operator|.
name|poll
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Polled completion task #{} after timeout to grab already completed tasks: {}"
argument_list|,
name|aggregated
argument_list|,
name|future
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
name|long
name|left
init|=
name|timeout
operator|-
name|watch
operator|.
name|taken
argument_list|()
decl_stmt|;
if|if
condition|(
name|left
operator|<
literal|0
condition|)
block|{
name|left
operator|=
literal|0
expr_stmt|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"Polling completion task #{} using timeout {} millis."
argument_list|,
name|aggregated
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|future
operator|=
name|completion
operator|.
name|poll
argument_list|(
name|left
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Polling completion task #{}"
argument_list|,
name|aggregated
argument_list|)
expr_stmt|;
comment|// we must not block so poll every second
name|future
operator|=
name|completion
operator|.
name|poll
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|future
operator|==
literal|null
condition|)
block|{
comment|// and continue loop which will recheck if we are done
continue|continue;
block|}
block|}
if|if
condition|(
name|future
operator|==
literal|null
operator|&&
name|timedOut
condition|)
block|{
comment|// we are timed out and no more tasks complete so break out
break|break;
block|}
elseif|else
if|if
condition|(
name|future
operator|==
literal|null
condition|)
block|{
comment|// timeout occurred
name|AggregationStrategy
name|strategy
init|=
name|getAggregationStrategy
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|strategy
operator|instanceof
name|TimeoutAwareAggregationStrategy
condition|)
block|{
comment|// notify the strategy we timed out
name|Exchange
name|oldExchange
init|=
name|result
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldExchange
operator|==
literal|null
condition|)
block|{
comment|// if they all timed out the result may not have been set yet, so use the original exchange
name|oldExchange
operator|=
name|original
expr_stmt|;
block|}
operator|(
operator|(
name|TimeoutAwareAggregationStrategy
operator|)
name|strategy
operator|)
operator|.
name|timeout
argument_list|(
name|oldExchange
argument_list|,
name|aggregated
argument_list|,
name|total
operator|.
name|intValue
argument_list|()
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// log a WARN we timed out since it will not be aggregated and the Exchange will be lost
name|LOG
operator|.
name|warn
argument_list|(
literal|"Parallel processing timed out after {} millis for number {}. This task will be cancelled and will not be aggregated."
argument_list|,
name|timeout
argument_list|,
name|aggregated
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Timeout occurred after {} millis for number {} task."
argument_list|,
name|timeout
argument_list|,
name|aggregated
argument_list|)
expr_stmt|;
name|timedOut
operator|=
literal|true
expr_stmt|;
comment|// mark that index as timed out, which allows us to try to retrieve
comment|// any already completed tasks in the next loop
if|if
condition|(
name|completion
operator|instanceof
name|SubmitOrderedCompletionService
condition|)
block|{
operator|(
operator|(
name|SubmitOrderedCompletionService
argument_list|<
name|?
argument_list|>
operator|)
name|completion
operator|)
operator|.
name|timeoutTask
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// there is a result to aggregate
name|Exchange
name|subExchange
init|=
name|future
operator|.
name|get
argument_list|()
decl_stmt|;
comment|// Decide whether to continue with the multicast or not; similar logic to the Pipeline
name|Integer
name|number
init|=
name|getExchangeIndex
argument_list|(
name|subExchange
argument_list|)
decl_stmt|;
name|boolean
name|continueProcessing
init|=
name|PipelineHelper
operator|.
name|continueProcessing
argument_list|(
name|subExchange
argument_list|,
literal|"Parallel processing failed for number "
operator|+
name|number
argument_list|,
name|LOG
argument_list|)
decl_stmt|;
if|if
condition|(
name|stopOnException
operator|&&
operator|!
name|continueProcessing
condition|)
block|{
comment|// we want to stop on exception and an exception or failure occurred
comment|// this is similar to what the pipeline does, so we should do the same to not surprise end users
comment|// so we should set the failed exchange as the result and break out
name|result
operator|.
name|set
argument_list|(
name|subExchange
argument_list|)
expr_stmt|;
name|stoppedOnException
operator|=
literal|true
expr_stmt|;
break|break;
block|}
comment|// we got a result so aggregate it
name|AggregationStrategy
name|strategy
init|=
name|getAggregationStrategy
argument_list|(
name|subExchange
argument_list|)
decl_stmt|;
name|doAggregate
argument_list|(
name|strategy
argument_list|,
name|result
argument_list|,
name|subExchange
argument_list|)
expr_stmt|;
block|}
name|aggregated
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|timedOut
operator|||
name|stoppedOnException
condition|)
block|{
if|if
condition|(
name|timedOut
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Cancelling tasks due timeout after {} millis."
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stoppedOnException
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Cancelling tasks due stopOnException."
argument_list|)
expr_stmt|;
block|}
comment|// cancel tasks as we timed out (its safe to cancel done tasks)
name|running
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|doProcessSequential (Exchange original, AtomicExchange result, Iterable<ProcessorExchangePair> pairs, AsyncCallback callback)
specifier|protected
name|boolean
name|doProcessSequential
parameter_list|(
name|Exchange
name|original
parameter_list|,
name|AtomicExchange
name|result
parameter_list|,
name|Iterable
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|pairs
parameter_list|,
name|AsyncCallback
name|callback
parameter_list|)
throws|throws
name|Exception
block|{
name|AtomicInteger
name|total
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|it
init|=
name|pairs
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|ProcessorExchangePair
name|pair
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|Exchange
name|subExchange
init|=
name|pair
operator|.
name|getExchange
argument_list|()
decl_stmt|;
name|updateNewExchange
argument_list|(
name|subExchange
argument_list|,
name|total
operator|.
name|get
argument_list|()
argument_list|,
name|pairs
argument_list|,
name|it
argument_list|)
expr_stmt|;
name|boolean
name|sync
init|=
name|doProcessSequential
argument_list|(
name|original
argument_list|,
name|result
argument_list|,
name|pairs
argument_list|,
name|it
argument_list|,
name|pair
argument_list|,
name|callback
argument_list|,
name|total
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sync
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Processing exchangeId: {} is continued being processed asynchronously"
argument_list|,
name|pair
operator|.
name|getExchange
argument_list|()
operator|.
name|getExchangeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// the remainder of the multicast will be completed async
comment|// so we break out now, then the callback will be invoked which then continue routing from where we left here
return|return
literal|false
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Processing exchangeId: {} is continued being processed synchronously"
argument_list|,
name|pair
operator|.
name|getExchange
argument_list|()
operator|.
name|getExchangeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Decide whether to continue with the multicast or not; similar logic to the Pipeline
comment|// remember to test for stop on exception and aggregate before copying back results
name|boolean
name|continueProcessing
init|=
name|PipelineHelper
operator|.
name|continueProcessing
argument_list|(
name|subExchange
argument_list|,
literal|"Sequential processing failed for number "
operator|+
name|total
operator|.
name|get
argument_list|()
argument_list|,
name|LOG
argument_list|)
decl_stmt|;
if|if
condition|(
name|stopOnException
operator|&&
operator|!
name|continueProcessing
condition|)
block|{
if|if
condition|(
name|subExchange
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// wrap in exception to explain where it failed
throw|throw
operator|new
name|CamelExchangeException
argument_list|(
literal|"Sequential processing failed for number "
operator|+
name|total
operator|.
name|get
argument_list|()
argument_list|,
name|subExchange
argument_list|,
name|subExchange
operator|.
name|getException
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
comment|// we want to stop on exception, and the exception was handled by the error handler
comment|// this is similar to what the pipeline does, so we should do the same to not surprise end users
comment|// so we should set the failed exchange as the result and be done
name|result
operator|.
name|set
argument_list|(
name|subExchange
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"Sequential processing complete for number {} exchange: {}"
argument_list|,
name|total
argument_list|,
name|subExchange
argument_list|)
expr_stmt|;
name|doAggregate
argument_list|(
name|getAggregationStrategy
argument_list|(
name|subExchange
argument_list|)
argument_list|,
name|result
argument_list|,
name|subExchange
argument_list|)
expr_stmt|;
name|total
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Done sequential processing {} exchanges"
argument_list|,
name|total
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|doProcessSequential (final Exchange original, final AtomicExchange result, final Iterable<ProcessorExchangePair> pairs, final Iterator<ProcessorExchangePair> it, final ProcessorExchangePair pair, final AsyncCallback callback, final AtomicInteger total)
specifier|private
name|boolean
name|doProcessSequential
parameter_list|(
specifier|final
name|Exchange
name|original
parameter_list|,
specifier|final
name|AtomicExchange
name|result
parameter_list|,
specifier|final
name|Iterable
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|pairs
parameter_list|,
specifier|final
name|Iterator
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|it
parameter_list|,
specifier|final
name|ProcessorExchangePair
name|pair
parameter_list|,
specifier|final
name|AsyncCallback
name|callback
parameter_list|,
specifier|final
name|AtomicInteger
name|total
parameter_list|)
block|{
name|boolean
name|sync
init|=
literal|true
decl_stmt|;
specifier|final
name|Exchange
name|exchange
init|=
name|pair
operator|.
name|getExchange
argument_list|()
decl_stmt|;
name|Processor
name|processor
init|=
name|pair
operator|.
name|getProcessor
argument_list|()
decl_stmt|;
name|Producer
name|producer
init|=
name|pair
operator|.
name|getProducer
argument_list|()
decl_stmt|;
name|TracedRouteNodes
name|traced
init|=
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
operator|!=
literal|null
condition|?
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
operator|.
name|getTracedRouteNodes
argument_list|()
else|:
literal|null
decl_stmt|;
comment|// compute time taken if sending to another endpoint
name|StopWatch
name|watch
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|producer
operator|!=
literal|null
condition|)
block|{
name|watch
operator|=
operator|new
name|StopWatch
argument_list|()
expr_stmt|;
block|}
try|try
block|{
comment|// prepare tracing starting from a new block
if|if
condition|(
name|traced
operator|!=
literal|null
condition|)
block|{
name|traced
operator|.
name|pushBlock
argument_list|()
expr_stmt|;
block|}
comment|// let the prepared process it, remember to begin the exchange pair
name|AsyncProcessor
name|async
init|=
name|AsyncProcessorConverterHelper
operator|.
name|convert
argument_list|(
name|processor
argument_list|)
decl_stmt|;
name|pair
operator|.
name|begin
argument_list|()
expr_stmt|;
name|sync
operator|=
name|AsyncProcessorHelper
operator|.
name|process
argument_list|(
name|async
argument_list|,
name|exchange
argument_list|,
operator|new
name|AsyncCallback
argument_list|()
block|{
specifier|public
name|void
name|done
parameter_list|(
name|boolean
name|doneSync
parameter_list|)
block|{
comment|// we are done with the exchange pair
name|pair
operator|.
name|done
argument_list|()
expr_stmt|;
comment|// we only have to handle async completion of the routing slip
if|if
condition|(
name|doneSync
condition|)
block|{
return|return;
block|}
comment|// continue processing the multicast asynchronously
name|Exchange
name|subExchange
init|=
name|exchange
decl_stmt|;
comment|// Decide whether to continue with the multicast or not; similar logic to the Pipeline
comment|// remember to test for stop on exception and aggregate before copying back results
name|boolean
name|continueProcessing
init|=
name|PipelineHelper
operator|.
name|continueProcessing
argument_list|(
name|subExchange
argument_list|,
literal|"Sequential processing failed for number "
operator|+
name|total
operator|.
name|get
argument_list|()
argument_list|,
name|LOG
argument_list|)
decl_stmt|;
if|if
condition|(
name|stopOnException
operator|&&
operator|!
name|continueProcessing
condition|)
block|{
if|if
condition|(
name|subExchange
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// wrap in exception to explain where it failed
name|subExchange
operator|.
name|setException
argument_list|(
operator|new
name|CamelExchangeException
argument_list|(
literal|"Sequential processing failed for number "
operator|+
name|total
argument_list|,
name|subExchange
argument_list|,
name|subExchange
operator|.
name|getException
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we want to stop on exception, and the exception was handled by the error handler
comment|// this is similar to what the pipeline does, so we should do the same to not surprise end users
comment|// so we should set the failed exchange as the result and be done
name|result
operator|.
name|set
argument_list|(
name|subExchange
argument_list|)
expr_stmt|;
block|}
comment|// and do the done work
name|doDone
argument_list|(
name|original
argument_list|,
name|subExchange
argument_list|,
name|callback
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
name|doAggregate
argument_list|(
name|getAggregationStrategy
argument_list|(
name|subExchange
argument_list|)
argument_list|,
name|result
argument_list|,
name|subExchange
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
comment|// wrap in exception to explain where it failed
name|subExchange
operator|.
name|setException
argument_list|(
operator|new
name|CamelExchangeException
argument_list|(
literal|"Sequential processing failed for number "
operator|+
name|total
argument_list|,
name|subExchange
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
comment|// and do the done work
name|doDone
argument_list|(
name|original
argument_list|,
name|subExchange
argument_list|,
name|callback
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
name|total
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
comment|// maybe there are more processors to multicast
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// prepare and run the next
name|ProcessorExchangePair
name|pair
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|subExchange
operator|=
name|pair
operator|.
name|getExchange
argument_list|()
expr_stmt|;
name|updateNewExchange
argument_list|(
name|subExchange
argument_list|,
name|total
operator|.
name|get
argument_list|()
argument_list|,
name|pairs
argument_list|,
name|it
argument_list|)
expr_stmt|;
name|boolean
name|sync
init|=
name|doProcessSequential
argument_list|(
name|original
argument_list|,
name|result
argument_list|,
name|pairs
argument_list|,
name|it
argument_list|,
name|pair
argument_list|,
name|callback
argument_list|,
name|total
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sync
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Processing exchangeId: {} is continued being processed asynchronously"
argument_list|,
name|original
operator|.
name|getExchangeId
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Decide whether to continue with the multicast or not; similar logic to the Pipeline
comment|// remember to test for stop on exception and aggregate before copying back results
name|continueProcessing
operator|=
name|PipelineHelper
operator|.
name|continueProcessing
argument_list|(
name|subExchange
argument_list|,
literal|"Sequential processing failed for number "
operator|+
name|total
operator|.
name|get
argument_list|()
argument_list|,
name|LOG
argument_list|)
expr_stmt|;
if|if
condition|(
name|stopOnException
operator|&&
operator|!
name|continueProcessing
condition|)
block|{
if|if
condition|(
name|subExchange
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// wrap in exception to explain where it failed
name|subExchange
operator|.
name|setException
argument_list|(
operator|new
name|CamelExchangeException
argument_list|(
literal|"Sequential processing failed for number "
operator|+
name|total
argument_list|,
name|subExchange
argument_list|,
name|subExchange
operator|.
name|getException
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we want to stop on exception, and the exception was handled by the error handler
comment|// this is similar to what the pipeline does, so we should do the same to not surprise end users
comment|// so we should set the failed exchange as the result and be done
name|result
operator|.
name|set
argument_list|(
name|subExchange
argument_list|)
expr_stmt|;
block|}
comment|// and do the done work
name|doDone
argument_list|(
name|original
argument_list|,
name|subExchange
argument_list|,
name|callback
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// must catch any exceptions from aggregation
try|try
block|{
name|doAggregate
argument_list|(
name|getAggregationStrategy
argument_list|(
name|subExchange
argument_list|)
argument_list|,
name|result
argument_list|,
name|subExchange
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
comment|// wrap in exception to explain where it failed
name|subExchange
operator|.
name|setException
argument_list|(
operator|new
name|CamelExchangeException
argument_list|(
literal|"Sequential processing failed for number "
operator|+
name|total
argument_list|,
name|subExchange
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
comment|// and do the done work
name|doDone
argument_list|(
name|original
argument_list|,
name|subExchange
argument_list|,
name|callback
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
name|total
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|// do the done work
name|subExchange
operator|=
name|result
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|?
name|result
operator|.
name|get
argument_list|()
else|:
literal|null
expr_stmt|;
name|doDone
argument_list|(
name|original
argument_list|,
name|subExchange
argument_list|,
name|callback
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// pop the block so by next round we have the same staring point and thus the tracing looks accurate
if|if
condition|(
name|traced
operator|!=
literal|null
condition|)
block|{
name|traced
operator|.
name|popBlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|producer
operator|!=
literal|null
condition|)
block|{
name|long
name|timeTaken
init|=
name|watch
operator|.
name|stop
argument_list|()
decl_stmt|;
name|Endpoint
name|endpoint
init|=
name|producer
operator|.
name|getEndpoint
argument_list|()
decl_stmt|;
comment|// emit event that the exchange was sent to the endpoint
name|EventHelper
operator|.
name|notifyExchangeSent
argument_list|(
name|exchange
operator|.
name|getContext
argument_list|()
argument_list|,
name|exchange
argument_list|,
name|endpoint
argument_list|,
name|timeTaken
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sync
return|;
block|}
DECL|method|doProcessParallel (final ProcessorExchangePair pair)
specifier|private
name|void
name|doProcessParallel
parameter_list|(
specifier|final
name|ProcessorExchangePair
name|pair
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|Exchange
name|exchange
init|=
name|pair
operator|.
name|getExchange
argument_list|()
decl_stmt|;
name|Processor
name|processor
init|=
name|pair
operator|.
name|getProcessor
argument_list|()
decl_stmt|;
name|Producer
name|producer
init|=
name|pair
operator|.
name|getProducer
argument_list|()
decl_stmt|;
name|TracedRouteNodes
name|traced
init|=
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
operator|!=
literal|null
condition|?
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
operator|.
name|getTracedRouteNodes
argument_list|()
else|:
literal|null
decl_stmt|;
comment|// compute time taken if sending to another endpoint
name|StopWatch
name|watch
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|producer
operator|!=
literal|null
condition|)
block|{
name|watch
operator|=
operator|new
name|StopWatch
argument_list|()
expr_stmt|;
block|}
try|try
block|{
comment|// prepare tracing starting from a new block
if|if
condition|(
name|traced
operator|!=
literal|null
condition|)
block|{
name|traced
operator|.
name|pushBlock
argument_list|()
expr_stmt|;
block|}
comment|// let the prepared process it, remember to begin the exchange pair
comment|// we invoke it synchronously as parallel async routing is too hard
name|AsyncProcessor
name|async
init|=
name|AsyncProcessorConverterHelper
operator|.
name|convert
argument_list|(
name|processor
argument_list|)
decl_stmt|;
name|pair
operator|.
name|begin
argument_list|()
expr_stmt|;
name|AsyncProcessorHelper
operator|.
name|process
argument_list|(
name|async
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|pair
operator|.
name|done
argument_list|()
expr_stmt|;
comment|// pop the block so by next round we have the same staring point and thus the tracing looks accurate
if|if
condition|(
name|traced
operator|!=
literal|null
condition|)
block|{
name|traced
operator|.
name|popBlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|producer
operator|!=
literal|null
condition|)
block|{
name|long
name|timeTaken
init|=
name|watch
operator|.
name|stop
argument_list|()
decl_stmt|;
name|Endpoint
name|endpoint
init|=
name|producer
operator|.
name|getEndpoint
argument_list|()
decl_stmt|;
comment|// emit event that the exchange was sent to the endpoint
name|EventHelper
operator|.
name|notifyExchangeSent
argument_list|(
name|exchange
operator|.
name|getContext
argument_list|()
argument_list|,
name|exchange
argument_list|,
name|endpoint
argument_list|,
name|timeTaken
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Common work which must be done when we are done multicasting.      *<p/>      * This logic applies for both running synchronous and asynchronous as there are multiple exist points      * when using the asynchronous routing engine. And therefore we want the logic in one method instead      * of being scattered.      *      * @param original    the original exchange      * @param subExchange the current sub exchange, can be<tt>null</tt> for the synchronous part      * @param callback    the callback      * @param doneSync    the<tt>doneSync</tt> parameter to call on callback      * @param exhaust     whether or not error handling is exhausted      */
DECL|method|doDone (Exchange original, Exchange subExchange, AsyncCallback callback, boolean doneSync, boolean exhaust)
specifier|protected
name|void
name|doDone
parameter_list|(
name|Exchange
name|original
parameter_list|,
name|Exchange
name|subExchange
parameter_list|,
name|AsyncCallback
name|callback
parameter_list|,
name|boolean
name|doneSync
parameter_list|,
name|boolean
name|exhaust
parameter_list|)
block|{
comment|// cleanup any per exchange aggregation strategy
name|removeAggregationStrategyFromExchange
argument_list|(
name|original
argument_list|)
expr_stmt|;
if|if
condition|(
name|original
operator|.
name|getException
argument_list|()
operator|!=
literal|null
operator|||
name|subExchange
operator|!=
literal|null
operator|&&
name|subExchange
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// multicast uses error handling on its output processors and they have tried to redeliver
comment|// so we shall signal back to the other error handlers that we are exhausted and they should not
comment|// also try to redeliver as we will then do that twice
name|original
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|REDELIVERY_EXHAUSTED
argument_list|,
name|exhaust
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|subExchange
operator|!=
literal|null
condition|)
block|{
comment|// and copy the current result to original so it will contain this result of this eip
name|ExchangeHelper
operator|.
name|copyResults
argument_list|(
name|original
argument_list|,
name|subExchange
argument_list|)
expr_stmt|;
block|}
name|callback
operator|.
name|done
argument_list|(
name|doneSync
argument_list|)
expr_stmt|;
block|}
comment|/**      * Aggregate the {@link Exchange} with the current result      *      * @param strategy the aggregation strategy to use      * @param result   the current result      * @param exchange the exchange to be added to the result      */
DECL|method|doAggregate (AggregationStrategy strategy, AtomicExchange result, Exchange exchange)
specifier|protected
specifier|synchronized
name|void
name|doAggregate
parameter_list|(
name|AggregationStrategy
name|strategy
parameter_list|,
name|AtomicExchange
name|result
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
name|strategy
operator|!=
literal|null
condition|)
block|{
comment|// prepare the exchanges for aggregation
name|Exchange
name|oldExchange
init|=
name|result
operator|.
name|get
argument_list|()
decl_stmt|;
name|ExchangeHelper
operator|.
name|prepareAggregation
argument_list|(
name|oldExchange
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
name|result
operator|.
name|set
argument_list|(
name|strategy
operator|.
name|aggregate
argument_list|(
name|oldExchange
argument_list|,
name|exchange
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|updateNewExchange (Exchange exchange, int index, Iterable<ProcessorExchangePair> allPairs, Iterator<ProcessorExchangePair> it)
specifier|protected
name|void
name|updateNewExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|int
name|index
parameter_list|,
name|Iterable
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|allPairs
parameter_list|,
name|Iterator
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|it
parameter_list|)
block|{
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|MULTICAST_INDEX
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|MULTICAST_COMPLETE
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|MULTICAST_COMPLETE
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getExchangeIndex (Exchange exchange)
specifier|protected
name|Integer
name|getExchangeIndex
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|MULTICAST_INDEX
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
return|;
block|}
DECL|method|createProcessorExchangePairs (Exchange exchange)
specifier|protected
name|Iterable
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|createProcessorExchangePairs
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|ProcessorExchangePair
argument_list|>
argument_list|(
name|processors
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Processor
name|processor
range|:
name|processors
control|)
block|{
comment|// copy exchange, and do not share the unit of work
name|Exchange
name|copy
init|=
name|ExchangeHelper
operator|.
name|createCorrelatedCopy
argument_list|(
name|exchange
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// if we share unit of work, we need to prepare the child exchange
if|if
condition|(
name|isShareUnitOfWork
argument_list|()
condition|)
block|{
name|prepareSharedUnitOfWork
argument_list|(
name|copy
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
comment|// and add the pair
name|RouteContext
name|routeContext
init|=
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
operator|!=
literal|null
condition|?
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
operator|.
name|getRouteContext
argument_list|()
else|:
literal|null
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|createProcessorExchangePair
argument_list|(
name|index
operator|++
argument_list|,
name|processor
argument_list|,
name|copy
argument_list|,
name|routeContext
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exchange
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// force any exceptions occurred during creation of exchange paris to be thrown
comment|// before returning the answer;
throw|throw
name|exchange
operator|.
name|getException
argument_list|()
throw|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * Creates the {@link ProcessorExchangePair} which holds the processor and exchange to be send out.      *<p/>      * You<b>must</b> use this method to create the instances of {@link ProcessorExchangePair} as they      * need to be specially prepared before use.      *      * @param index        the index      * @param processor    the processor      * @param exchange     the exchange      * @param routeContext the route context      * @return prepared for use      */
DECL|method|createProcessorExchangePair (int index, Processor processor, Exchange exchange, RouteContext routeContext)
specifier|protected
name|ProcessorExchangePair
name|createProcessorExchangePair
parameter_list|(
name|int
name|index
parameter_list|,
name|Processor
name|processor
parameter_list|,
name|Exchange
name|exchange
parameter_list|,
name|RouteContext
name|routeContext
parameter_list|)
block|{
name|Processor
name|prepared
init|=
name|processor
decl_stmt|;
comment|// set property which endpoint we send to
name|setToEndpoint
argument_list|(
name|exchange
argument_list|,
name|prepared
argument_list|)
expr_stmt|;
comment|// rework error handling to support fine grained error handling
name|prepared
operator|=
name|createErrorHandler
argument_list|(
name|routeContext
argument_list|,
name|exchange
argument_list|,
name|prepared
argument_list|)
expr_stmt|;
comment|// invoke on prepare on the exchange if specified
if|if
condition|(
name|onPrepare
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|onPrepare
operator|.
name|process
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|exchange
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|DefaultProcessorExchangePair
argument_list|(
name|index
argument_list|,
name|processor
argument_list|,
name|prepared
argument_list|,
name|exchange
argument_list|)
return|;
block|}
DECL|method|createErrorHandler (RouteContext routeContext, Exchange exchange, Processor processor)
specifier|protected
name|Processor
name|createErrorHandler
parameter_list|(
name|RouteContext
name|routeContext
parameter_list|,
name|Exchange
name|exchange
parameter_list|,
name|Processor
name|processor
parameter_list|)
block|{
name|Processor
name|answer
decl_stmt|;
if|if
condition|(
name|routeContext
operator|!=
literal|null
condition|)
block|{
comment|// wrap the producer in error handler so we have fine grained error handling on
comment|// the output side instead of the input side
comment|// this is needed to support redelivery on that output alone and not doing redelivery
comment|// for the entire multicast block again which will start from scratch again
comment|// create key for cache
specifier|final
name|PreparedErrorHandler
name|key
init|=
operator|new
name|PreparedErrorHandler
argument_list|(
name|routeContext
argument_list|,
name|processor
argument_list|)
decl_stmt|;
comment|// lookup cached first to reuse and preserve memory
name|answer
operator|=
name|errorHandlers
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Using existing error handler for: {}"
argument_list|,
name|processor
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"Creating error handler for: {}"
argument_list|,
name|processor
argument_list|)
expr_stmt|;
name|ErrorHandlerFactory
name|builder
init|=
name|routeContext
operator|.
name|getRoute
argument_list|()
operator|.
name|getErrorHandlerBuilder
argument_list|()
decl_stmt|;
comment|// create error handler (create error handler directly to keep it light weight,
comment|// instead of using ProcessorDefinition.wrapInErrorHandler)
try|try
block|{
name|processor
operator|=
name|builder
operator|.
name|createErrorHandler
argument_list|(
name|routeContext
argument_list|,
name|processor
argument_list|)
expr_stmt|;
comment|// and wrap in unit of work processor so the copy exchange also can run under UoW
name|answer
operator|=
name|createUnitOfWorkProcessor
argument_list|(
name|routeContext
argument_list|,
name|processor
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
comment|// must start the error handler
name|ServiceHelper
operator|.
name|startServices
argument_list|(
name|answer
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|ObjectHelper
operator|.
name|wrapRuntimeCamelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// add to cache
name|errorHandlers
operator|.
name|putIfAbsent
argument_list|(
name|key
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// and wrap in unit of work processor so the copy exchange also can run under UoW
name|answer
operator|=
name|createUnitOfWorkProcessor
argument_list|(
name|routeContext
argument_list|,
name|processor
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Strategy to create the {@link UnitOfWorkProcessor} to be used for the sub route      *      * @param routeContext the route context      * @param processor    the processor wrapped in this unit of work processor      * @param exchange     the exchange      * @return the unit of work processor      */
DECL|method|createUnitOfWorkProcessor (RouteContext routeContext, Processor processor, Exchange exchange)
specifier|protected
name|UnitOfWorkProcessor
name|createUnitOfWorkProcessor
parameter_list|(
name|RouteContext
name|routeContext
parameter_list|,
name|Processor
name|processor
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
name|UnitOfWork
name|parent
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|PARENT_UNIT_OF_WORK
argument_list|,
name|UnitOfWork
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|ChildUnitOfWorkProcessor
argument_list|(
name|parent
argument_list|,
name|routeContext
argument_list|,
name|processor
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|UnitOfWorkProcessor
argument_list|(
name|routeContext
argument_list|,
name|processor
argument_list|)
return|;
block|}
block|}
comment|/**      * Prepares the exchange for participating in a shared unit of work      *<p/>      * This ensures a child exchange can access its parent {@link UnitOfWork} when it participate      * in a shared unit of work.      *      * @param childExchange  the child exchange      * @param parentExchange the parent exchange      */
DECL|method|prepareSharedUnitOfWork (Exchange childExchange, Exchange parentExchange)
specifier|protected
name|void
name|prepareSharedUnitOfWork
parameter_list|(
name|Exchange
name|childExchange
parameter_list|,
name|Exchange
name|parentExchange
parameter_list|)
block|{
name|childExchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|PARENT_UNIT_OF_WORK
argument_list|,
name|parentExchange
operator|.
name|getUnitOfWork
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|doStart ()
specifier|protected
name|void
name|doStart
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|isParallelProcessing
argument_list|()
operator|&&
name|executorService
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"ParallelProcessing is enabled but ExecutorService has not been set"
argument_list|)
throw|;
block|}
if|if
condition|(
name|timeout
operator|>
literal|0
operator|&&
operator|!
name|isParallelProcessing
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Timeout is used but ParallelProcessing has not been enabled"
argument_list|)
throw|;
block|}
if|if
condition|(
name|isParallelProcessing
argument_list|()
operator|&&
name|aggregateExecutorService
operator|==
literal|null
condition|)
block|{
comment|// use unbounded thread pool so we ensure the aggregate on-the-fly task always will have assigned a thread
comment|// and run the tasks when the task is submitted. If not then the aggregate task may not be able to run
comment|// and signal completion during processing, which would lead to what would appear as a dead-lock or a slow processing
name|String
name|name
init|=
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"-AggregateTask"
decl_stmt|;
name|aggregateExecutorService
operator|=
name|createAggregateExecutorService
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|ServiceHelper
operator|.
name|startServices
argument_list|(
name|processors
argument_list|)
expr_stmt|;
block|}
comment|/**      * Strategy to create the thread pool for the aggregator background task which waits for and aggregates      * completed tasks when running in parallel mode.      *      * @param name  the suggested name for the background thread      * @return the thread pool      */
DECL|method|createAggregateExecutorService (String name)
specifier|protected
specifier|synchronized
name|ExecutorService
name|createAggregateExecutorService
parameter_list|(
name|String
name|name
parameter_list|)
block|{
comment|// use a cached thread pool so we each on-the-fly task has a dedicated thread to process completions as they come in
return|return
name|camelContext
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|newCachedThreadPool
argument_list|(
name|this
argument_list|,
name|name
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|doStop ()
specifier|protected
name|void
name|doStop
parameter_list|()
throws|throws
name|Exception
block|{
name|ServiceHelper
operator|.
name|stopServices
argument_list|(
name|processors
argument_list|,
name|errorHandlers
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doShutdown ()
specifier|protected
name|void
name|doShutdown
parameter_list|()
throws|throws
name|Exception
block|{
name|ServiceHelper
operator|.
name|stopAndShutdownServices
argument_list|(
name|processors
argument_list|,
name|errorHandlers
argument_list|)
expr_stmt|;
comment|// only clear error handlers when shutting down
name|errorHandlers
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|shutdownExecutorService
operator|&&
name|executorService
operator|!=
literal|null
condition|)
block|{
name|getCamelContext
argument_list|()
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|shutdownNow
argument_list|(
name|executorService
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|setToEndpoint (Exchange exchange, Processor processor)
specifier|protected
specifier|static
name|void
name|setToEndpoint
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Processor
name|processor
parameter_list|)
block|{
if|if
condition|(
name|processor
operator|instanceof
name|Producer
condition|)
block|{
name|Producer
name|producer
init|=
operator|(
name|Producer
operator|)
name|processor
decl_stmt|;
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|TO_ENDPOINT
argument_list|,
name|producer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|getEndpointUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getAggregationStrategy (Exchange exchange)
specifier|protected
name|AggregationStrategy
name|getAggregationStrategy
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|AggregationStrategy
name|answer
init|=
literal|null
decl_stmt|;
comment|// prefer to use per Exchange aggregation strategy over a global strategy
if|if
condition|(
name|exchange
operator|!=
literal|null
condition|)
block|{
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|property
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATION_STRATEGY
argument_list|,
name|Map
operator|.
name|class
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Object
argument_list|,
name|AggregationStrategy
argument_list|>
name|map
init|=
name|CastUtils
operator|.
name|cast
argument_list|(
name|property
argument_list|)
decl_stmt|;
if|if
condition|(
name|map
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|map
operator|.
name|get
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
comment|// fallback to global strategy
name|answer
operator|=
name|getAggregationStrategy
argument_list|()
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Sets the given {@link org.apache.camel.processor.aggregate.AggregationStrategy} on the {@link Exchange}.      *      * @param exchange            the exchange      * @param aggregationStrategy the strategy      */
DECL|method|setAggregationStrategyOnExchange (Exchange exchange, AggregationStrategy aggregationStrategy)
specifier|protected
name|void
name|setAggregationStrategyOnExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|AggregationStrategy
name|aggregationStrategy
parameter_list|)
block|{
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|property
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATION_STRATEGY
argument_list|,
name|Map
operator|.
name|class
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Object
argument_list|,
name|AggregationStrategy
argument_list|>
name|map
init|=
name|CastUtils
operator|.
name|cast
argument_list|(
name|property
argument_list|)
decl_stmt|;
if|if
condition|(
name|map
operator|==
literal|null
condition|)
block|{
name|map
operator|=
operator|new
name|HashMap
argument_list|<
name|Object
argument_list|,
name|AggregationStrategy
argument_list|>
argument_list|()
expr_stmt|;
block|}
comment|// store the strategy using this processor as the key
comment|// (so we can store multiple strategies on the same exchange)
name|map
operator|.
name|put
argument_list|(
name|this
argument_list|,
name|aggregationStrategy
argument_list|)
expr_stmt|;
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATION_STRATEGY
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes the associated {@link org.apache.camel.processor.aggregate.AggregationStrategy} from the {@link Exchange}      * which must be done after use.      *      * @param exchange the current exchange      */
DECL|method|removeAggregationStrategyFromExchange (Exchange exchange)
specifier|protected
name|void
name|removeAggregationStrategyFromExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|property
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATION_STRATEGY
argument_list|,
name|Map
operator|.
name|class
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Object
argument_list|,
name|AggregationStrategy
argument_list|>
name|map
init|=
name|CastUtils
operator|.
name|cast
argument_list|(
name|property
argument_list|)
decl_stmt|;
if|if
condition|(
name|map
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// remove the strategy using this processor as the key
name|map
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**      * Is the multicast processor working in streaming mode?      *<p/>      * In streaming mode:      *<ul>      *<li>we use {@link Iterable} to ensure we can send messages as soon as the data becomes available</li>      *<li>for parallel processing, we start aggregating responses as they get send back to the processor;      * this means the {@link org.apache.camel.processor.aggregate.AggregationStrategy} has to take care of handling out-of-order arrival of exchanges</li>      *</ul>      */
DECL|method|isStreaming ()
specifier|public
name|boolean
name|isStreaming
parameter_list|()
block|{
return|return
name|streaming
return|;
block|}
comment|/**      * Should the multicast processor stop processing further exchanges in case of an exception occurred?      */
DECL|method|isStopOnException ()
specifier|public
name|boolean
name|isStopOnException
parameter_list|()
block|{
return|return
name|stopOnException
return|;
block|}
comment|/**      * Returns the producers to multicast to      */
DECL|method|getProcessors ()
specifier|public
name|Collection
argument_list|<
name|Processor
argument_list|>
name|getProcessors
parameter_list|()
block|{
return|return
name|processors
return|;
block|}
comment|/**      * An optional timeout in millis when using parallel processing      */
DECL|method|getTimeout ()
specifier|public
name|long
name|getTimeout
parameter_list|()
block|{
return|return
name|timeout
return|;
block|}
comment|/**      * Use {@link #getAggregationStrategy(org.apache.camel.Exchange)} instead.      */
DECL|method|getAggregationStrategy ()
specifier|public
name|AggregationStrategy
name|getAggregationStrategy
parameter_list|()
block|{
return|return
name|aggregationStrategy
return|;
block|}
DECL|method|isParallelProcessing ()
specifier|public
name|boolean
name|isParallelProcessing
parameter_list|()
block|{
return|return
name|parallelProcessing
return|;
block|}
DECL|method|isShareUnitOfWork ()
specifier|public
name|boolean
name|isShareUnitOfWork
parameter_list|()
block|{
return|return
name|shareUnitOfWork
return|;
block|}
DECL|method|next ()
specifier|public
name|List
argument_list|<
name|Processor
argument_list|>
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|ArrayList
argument_list|<
name|Processor
argument_list|>
argument_list|(
name|processors
argument_list|)
return|;
block|}
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|processors
operator|!=
literal|null
operator|&&
operator|!
name|processors
operator|.
name|isEmpty
argument_list|()
return|;
block|}
block|}
end_class

end_unit

