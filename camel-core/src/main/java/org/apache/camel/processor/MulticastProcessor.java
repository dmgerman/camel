begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.processor
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletionService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorCompletionService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|AsyncCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|AsyncProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelExchangeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Endpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Navigate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Processor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Producer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|ErrorHandlerBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|impl
operator|.
name|ServiceSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|impl
operator|.
name|converter
operator|.
name|AsyncProcessorTypeConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
operator|.
name|aggregate
operator|.
name|AggregationStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
operator|.
name|aggregate
operator|.
name|TimeoutAwareAggregationStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|RouteContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|TracedRouteNodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|AsyncProcessorHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|CastUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|EventHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ExchangeHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|KeyValueHolder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ObjectHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ServiceHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|StopWatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|concurrent
operator|.
name|AtomicExchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|concurrent
operator|.
name|SubmitOrderedCompletionService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ObjectHelper
operator|.
name|notNull
import|;
end_import

begin_comment
comment|/**  * Implements the Multicast pattern to send a message exchange to a number of  * endpoints, each endpoint receiving a copy of the message exchange.  *  * @version $Revision$  * @see Pipeline  */
end_comment

begin_class
DECL|class|MulticastProcessor
specifier|public
class|class
name|MulticastProcessor
extends|extends
name|ServiceSupport
implements|implements
name|AsyncProcessor
implements|,
name|Navigate
argument_list|<
name|Processor
argument_list|>
implements|,
name|Traceable
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
specifier|transient
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|MulticastProcessor
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * Class that represent each step in the multicast route to do      */
DECL|class|DefaultProcessorExchangePair
specifier|static
specifier|final
class|class
name|DefaultProcessorExchangePair
implements|implements
name|ProcessorExchangePair
block|{
DECL|field|index
specifier|private
specifier|final
name|int
name|index
decl_stmt|;
DECL|field|processor
specifier|private
specifier|final
name|Processor
name|processor
decl_stmt|;
DECL|field|prepared
specifier|private
specifier|final
name|Processor
name|prepared
decl_stmt|;
DECL|field|exchange
specifier|private
specifier|final
name|Exchange
name|exchange
decl_stmt|;
DECL|method|DefaultProcessorExchangePair (int index, Processor processor, Processor prepared, Exchange exchange)
specifier|private
name|DefaultProcessorExchangePair
parameter_list|(
name|int
name|index
parameter_list|,
name|Processor
name|processor
parameter_list|,
name|Processor
name|prepared
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
name|this
operator|.
name|processor
operator|=
name|processor
expr_stmt|;
name|this
operator|.
name|prepared
operator|=
name|prepared
expr_stmt|;
name|this
operator|.
name|exchange
operator|=
name|exchange
expr_stmt|;
block|}
DECL|method|getIndex ()
specifier|public
name|int
name|getIndex
parameter_list|()
block|{
return|return
name|index
return|;
block|}
DECL|method|getExchange ()
specifier|public
name|Exchange
name|getExchange
parameter_list|()
block|{
return|return
name|exchange
return|;
block|}
DECL|method|getProducer ()
specifier|public
name|Producer
name|getProducer
parameter_list|()
block|{
if|if
condition|(
name|processor
operator|instanceof
name|Producer
condition|)
block|{
return|return
operator|(
name|Producer
operator|)
name|processor
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|getProcessor ()
specifier|public
name|Processor
name|getProcessor
parameter_list|()
block|{
return|return
name|prepared
return|;
block|}
DECL|method|begin ()
specifier|public
name|void
name|begin
parameter_list|()
block|{
comment|// noop
name|LOG
operator|.
name|trace
argument_list|(
literal|"ProcessorExchangePair #"
operator|+
name|index
operator|+
literal|" begin: "
operator|+
name|exchange
argument_list|)
expr_stmt|;
block|}
DECL|method|done ()
specifier|public
name|void
name|done
parameter_list|()
block|{
comment|// noop
name|LOG
operator|.
name|trace
argument_list|(
literal|"ProcessorExchangePair #"
operator|+
name|index
operator|+
literal|" done: "
operator|+
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Class that represents prepared fine grained error handlers when processing multicasted/splitted exchanges      *<p/>      * See the<tt>createProcessorExchangePair</tt> and<tt>createErrorHandler</tt> methods.      */
DECL|class|PreparedErrorHandler
specifier|static
specifier|final
class|class
name|PreparedErrorHandler
extends|extends
name|KeyValueHolder
argument_list|<
name|RouteContext
argument_list|,
name|Processor
argument_list|>
block|{
DECL|method|PreparedErrorHandler (RouteContext key, Processor value)
specifier|public
name|PreparedErrorHandler
parameter_list|(
name|RouteContext
name|key
parameter_list|,
name|Processor
name|value
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|camelContext
specifier|private
specifier|final
name|CamelContext
name|camelContext
decl_stmt|;
DECL|field|processors
specifier|private
name|Collection
argument_list|<
name|Processor
argument_list|>
name|processors
decl_stmt|;
DECL|field|aggregationStrategy
specifier|private
specifier|final
name|AggregationStrategy
name|aggregationStrategy
decl_stmt|;
DECL|field|parallelProcessing
specifier|private
specifier|final
name|boolean
name|parallelProcessing
decl_stmt|;
DECL|field|streaming
specifier|private
specifier|final
name|boolean
name|streaming
decl_stmt|;
DECL|field|stopOnException
specifier|private
specifier|final
name|boolean
name|stopOnException
decl_stmt|;
DECL|field|executorService
specifier|private
specifier|final
name|ExecutorService
name|executorService
decl_stmt|;
DECL|field|timeout
specifier|private
specifier|final
name|long
name|timeout
decl_stmt|;
DECL|field|errorHandlers
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|PreparedErrorHandler
argument_list|,
name|Processor
argument_list|>
name|errorHandlers
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|PreparedErrorHandler
argument_list|,
name|Processor
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|MulticastProcessor (CamelContext camelContext, Collection<Processor> processors)
specifier|public
name|MulticastProcessor
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|,
name|Collection
argument_list|<
name|Processor
argument_list|>
name|processors
parameter_list|)
block|{
name|this
argument_list|(
name|camelContext
argument_list|,
name|processors
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|MulticastProcessor (CamelContext camelContext, Collection<Processor> processors, AggregationStrategy aggregationStrategy)
specifier|public
name|MulticastProcessor
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|,
name|Collection
argument_list|<
name|Processor
argument_list|>
name|processors
parameter_list|,
name|AggregationStrategy
name|aggregationStrategy
parameter_list|)
block|{
name|this
argument_list|(
name|camelContext
argument_list|,
name|processors
argument_list|,
name|aggregationStrategy
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|MulticastProcessor (CamelContext camelContext, Collection<Processor> processors, AggregationStrategy aggregationStrategy, boolean parallelProcessing, ExecutorService executorService, boolean streaming, boolean stopOnException, long timeout)
specifier|public
name|MulticastProcessor
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|,
name|Collection
argument_list|<
name|Processor
argument_list|>
name|processors
parameter_list|,
name|AggregationStrategy
name|aggregationStrategy
parameter_list|,
name|boolean
name|parallelProcessing
parameter_list|,
name|ExecutorService
name|executorService
parameter_list|,
name|boolean
name|streaming
parameter_list|,
name|boolean
name|stopOnException
parameter_list|,
name|long
name|timeout
parameter_list|)
block|{
name|notNull
argument_list|(
name|camelContext
argument_list|,
literal|"camelContext"
argument_list|)
expr_stmt|;
name|this
operator|.
name|camelContext
operator|=
name|camelContext
expr_stmt|;
name|this
operator|.
name|processors
operator|=
name|processors
expr_stmt|;
name|this
operator|.
name|aggregationStrategy
operator|=
name|aggregationStrategy
expr_stmt|;
name|this
operator|.
name|executorService
operator|=
name|executorService
expr_stmt|;
name|this
operator|.
name|streaming
operator|=
name|streaming
expr_stmt|;
name|this
operator|.
name|stopOnException
operator|=
name|stopOnException
expr_stmt|;
comment|// must enable parallel if executor service is provided
name|this
operator|.
name|parallelProcessing
operator|=
name|parallelProcessing
operator|||
name|executorService
operator|!=
literal|null
expr_stmt|;
name|this
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Multicast["
operator|+
name|getProcessors
argument_list|()
operator|+
literal|"]"
return|;
block|}
DECL|method|getTraceLabel ()
specifier|public
name|String
name|getTraceLabel
parameter_list|()
block|{
return|return
literal|"multicast"
return|;
block|}
DECL|method|getCamelContext ()
specifier|public
name|CamelContext
name|getCamelContext
parameter_list|()
block|{
return|return
name|camelContext
return|;
block|}
DECL|method|process (Exchange exchange)
specifier|public
name|void
name|process
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
name|AsyncProcessorHelper
operator|.
name|process
argument_list|(
name|this
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
DECL|method|process (Exchange exchange, AsyncCallback callback)
specifier|public
name|boolean
name|process
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|AsyncCallback
name|callback
parameter_list|)
block|{
specifier|final
name|AtomicExchange
name|result
init|=
operator|new
name|AtomicExchange
argument_list|()
decl_stmt|;
specifier|final
name|Iterable
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|pairs
decl_stmt|;
comment|// multicast uses fine grained error handling on the output processors
comment|// so use try .. catch to cater for this
name|boolean
name|exhaust
init|=
literal|false
decl_stmt|;
try|try
block|{
name|boolean
name|sync
init|=
literal|true
decl_stmt|;
name|pairs
operator|=
name|createProcessorExchangePairs
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
comment|// after we have created the processors we consider the exchange as exhausted if an unhandled
comment|// exception was thrown, (used in the catch block)
name|exhaust
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|isParallelProcessing
argument_list|()
condition|)
block|{
comment|// ensure an executor is set when running in parallel
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|executorService
argument_list|,
literal|"executorService"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|doProcessParallel
argument_list|(
name|exchange
argument_list|,
name|result
argument_list|,
name|pairs
argument_list|,
name|isStreaming
argument_list|()
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sync
operator|=
name|doProcessSequential
argument_list|(
name|exchange
argument_list|,
name|result
argument_list|,
name|pairs
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sync
condition|)
block|{
comment|// the remainder of the multicast will be completed async
comment|// so we break out now, then the callback will be invoked which then continue routing from where we left here
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|exchange
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|// and do the done work
name|doDone
argument_list|(
name|exchange
argument_list|,
literal|null
argument_list|,
name|callback
argument_list|,
literal|true
argument_list|,
name|exhaust
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// multicasting was processed successfully
comment|// and do the done work
name|Exchange
name|subExchange
init|=
name|result
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|?
name|result
operator|.
name|get
argument_list|()
else|:
literal|null
decl_stmt|;
name|doDone
argument_list|(
name|exchange
argument_list|,
name|subExchange
argument_list|,
name|callback
argument_list|,
literal|true
argument_list|,
name|exhaust
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|doProcessParallel (final Exchange original, final AtomicExchange result, final Iterable<ProcessorExchangePair> pairs, final boolean streaming, final AsyncCallback callback)
specifier|protected
name|void
name|doProcessParallel
parameter_list|(
specifier|final
name|Exchange
name|original
parameter_list|,
specifier|final
name|AtomicExchange
name|result
parameter_list|,
specifier|final
name|Iterable
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|pairs
parameter_list|,
specifier|final
name|boolean
name|streaming
parameter_list|,
specifier|final
name|AsyncCallback
name|callback
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
block|{
specifier|final
name|CompletionService
argument_list|<
name|Exchange
argument_list|>
name|completion
decl_stmt|;
specifier|final
name|AtomicBoolean
name|running
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|streaming
condition|)
block|{
comment|// execute tasks in parallel+streaming and aggregate in the order they are finished (out of order sequence)
name|completion
operator|=
operator|new
name|ExecutorCompletionService
argument_list|<
name|Exchange
argument_list|>
argument_list|(
name|executorService
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// execute tasks in parallel and aggregate in the order the tasks are submitted (in order sequence)
name|completion
operator|=
operator|new
name|SubmitOrderedCompletionService
argument_list|<
name|Exchange
argument_list|>
argument_list|(
name|executorService
argument_list|)
expr_stmt|;
block|}
specifier|final
name|AtomicInteger
name|total
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|it
init|=
name|pairs
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|ProcessorExchangePair
name|pair
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|Exchange
name|subExchange
init|=
name|pair
operator|.
name|getExchange
argument_list|()
decl_stmt|;
name|updateNewExchange
argument_list|(
name|subExchange
argument_list|,
name|total
operator|.
name|intValue
argument_list|()
argument_list|,
name|pairs
argument_list|,
name|it
argument_list|)
expr_stmt|;
name|completion
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|Exchange
argument_list|>
argument_list|()
block|{
specifier|public
name|Exchange
name|call
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|running
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// do not start processing the task if we are not running
return|return
name|subExchange
return|;
block|}
try|try
block|{
name|doProcessParallel
argument_list|(
name|pair
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|subExchange
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Decide whether to continue with the multicast or not; similar logic to the Pipeline
name|Integer
name|number
init|=
name|getExchangeIndex
argument_list|(
name|subExchange
argument_list|)
decl_stmt|;
name|boolean
name|continueProcessing
init|=
name|PipelineHelper
operator|.
name|continueProcessing
argument_list|(
name|subExchange
argument_list|,
literal|"Parallel processing failed for number "
operator|+
name|number
argument_list|,
name|LOG
argument_list|)
decl_stmt|;
if|if
condition|(
name|stopOnException
operator|&&
operator|!
name|continueProcessing
condition|)
block|{
comment|// signal to stop running
name|running
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// throw caused exception
if|if
condition|(
name|subExchange
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// wrap in exception to explain where it failed
throw|throw
operator|new
name|CamelExchangeException
argument_list|(
literal|"Parallel processing failed for number "
operator|+
name|number
argument_list|,
name|subExchange
argument_list|,
name|subExchange
operator|.
name|getException
argument_list|()
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Parallel processing complete for exchange: "
operator|+
name|subExchange
argument_list|)
expr_stmt|;
block|}
return|return
name|subExchange
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|total
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|// its to hard to do parallel async routing so we let the caller thread be synchronously
comment|// and have it pickup the replies and do the aggregation
name|boolean
name|timedOut
init|=
literal|false
decl_stmt|;
name|boolean
name|stoppedOnException
init|=
literal|false
decl_stmt|;
specifier|final
name|StopWatch
name|watch
init|=
operator|new
name|StopWatch
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|total
operator|.
name|intValue
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Future
argument_list|<
name|Exchange
argument_list|>
name|future
decl_stmt|;
if|if
condition|(
name|timedOut
condition|)
block|{
comment|// we are timed out but try to grab if some tasks has been completed
comment|// poll will return null if no tasks is present
name|future
operator|=
name|completion
operator|.
name|poll
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
name|long
name|left
init|=
name|timeout
operator|-
name|watch
operator|.
name|taken
argument_list|()
decl_stmt|;
if|if
condition|(
name|left
operator|<
literal|0
condition|)
block|{
name|left
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Polling completion task #"
operator|+
name|i
operator|+
literal|" using timeout "
operator|+
name|left
operator|+
literal|" millis."
argument_list|)
expr_stmt|;
block|}
name|future
operator|=
name|completion
operator|.
name|poll
argument_list|(
name|left
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// take will wait until the task is complete
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Polling completion task #"
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|future
operator|=
name|completion
operator|.
name|take
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|future
operator|==
literal|null
operator|&&
name|timedOut
condition|)
block|{
comment|// we are timed out and no more tasks complete so break out
break|break;
block|}
elseif|else
if|if
condition|(
name|future
operator|==
literal|null
condition|)
block|{
comment|// timeout occurred
name|AggregationStrategy
name|strategy
init|=
name|getAggregationStrategy
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|strategy
operator|instanceof
name|TimeoutAwareAggregationStrategy
condition|)
block|{
comment|// notify the strategy we timed out
name|Exchange
name|oldExchange
init|=
name|result
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldExchange
operator|==
literal|null
condition|)
block|{
comment|// if they all timed out the result may not have been set yet, so use the original exchange
name|oldExchange
operator|=
name|original
expr_stmt|;
block|}
operator|(
operator|(
name|TimeoutAwareAggregationStrategy
operator|)
name|strategy
operator|)
operator|.
name|timeout
argument_list|(
name|oldExchange
argument_list|,
name|i
argument_list|,
name|total
operator|.
name|intValue
argument_list|()
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// log a WARN we timed out since it will not be aggregated and the Exchange will be lost
name|LOG
operator|.
name|warn
argument_list|(
literal|"Parallel processing timed out after "
operator|+
name|timeout
operator|+
literal|" millis for number "
operator|+
name|i
operator|+
literal|". This task will be cancelled and will not be aggregated."
argument_list|)
expr_stmt|;
block|}
name|timedOut
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// there is a result to aggregate
name|Exchange
name|subExchange
init|=
name|future
operator|.
name|get
argument_list|()
decl_stmt|;
comment|// Decide whether to continue with the multicast or not; similar logic to the Pipeline
name|Integer
name|number
init|=
name|getExchangeIndex
argument_list|(
name|subExchange
argument_list|)
decl_stmt|;
name|boolean
name|continueProcessing
init|=
name|PipelineHelper
operator|.
name|continueProcessing
argument_list|(
name|subExchange
argument_list|,
literal|"Parallel processing failed for number "
operator|+
name|number
argument_list|,
name|LOG
argument_list|)
decl_stmt|;
if|if
condition|(
name|stopOnException
operator|&&
operator|!
name|continueProcessing
condition|)
block|{
comment|// we want to stop on exception and an exception or failure occurred
comment|// this is similar to what the pipeline does, so we should do the same to not surprise end users
comment|// so we should set the failed exchange as the result and break out
name|result
operator|.
name|set
argument_list|(
name|subExchange
argument_list|)
expr_stmt|;
name|stoppedOnException
operator|=
literal|true
expr_stmt|;
break|break;
block|}
comment|// we got a result so aggregate it
name|AggregationStrategy
name|strategy
init|=
name|getAggregationStrategy
argument_list|(
name|subExchange
argument_list|)
decl_stmt|;
name|doAggregate
argument_list|(
name|strategy
argument_list|,
name|result
argument_list|,
name|subExchange
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|timedOut
operator|||
name|stoppedOnException
condition|)
block|{
if|if
condition|(
name|timedOut
operator|&&
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Cancelling tasks due timeout after "
operator|+
name|timeout
operator|+
literal|" millis."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stoppedOnException
operator|&&
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Cancelling tasks due stopOnException."
argument_list|)
expr_stmt|;
block|}
comment|// cancel tasks as we timed out (its safe to cancel done tasks)
name|running
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Done parallel processing "
operator|+
name|total
operator|+
literal|" exchanges"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doProcessSequential (Exchange original, AtomicExchange result, Iterable<ProcessorExchangePair> pairs, AsyncCallback callback)
specifier|protected
name|boolean
name|doProcessSequential
parameter_list|(
name|Exchange
name|original
parameter_list|,
name|AtomicExchange
name|result
parameter_list|,
name|Iterable
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|pairs
parameter_list|,
name|AsyncCallback
name|callback
parameter_list|)
throws|throws
name|Exception
block|{
name|AtomicInteger
name|total
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|it
init|=
name|pairs
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|ProcessorExchangePair
name|pair
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|Exchange
name|subExchange
init|=
name|pair
operator|.
name|getExchange
argument_list|()
decl_stmt|;
name|updateNewExchange
argument_list|(
name|subExchange
argument_list|,
name|total
operator|.
name|get
argument_list|()
argument_list|,
name|pairs
argument_list|,
name|it
argument_list|)
expr_stmt|;
name|boolean
name|sync
init|=
name|doProcessSequential
argument_list|(
name|original
argument_list|,
name|result
argument_list|,
name|pairs
argument_list|,
name|it
argument_list|,
name|pair
argument_list|,
name|callback
argument_list|,
name|total
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sync
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Processing exchangeId: "
operator|+
name|pair
operator|.
name|getExchange
argument_list|()
operator|.
name|getExchangeId
argument_list|()
operator|+
literal|" is continued being processed asynchronously"
argument_list|)
expr_stmt|;
block|}
comment|// the remainder of the multicast will be completed async
comment|// so we break out now, then the callback will be invoked which then continue routing from where we left here
return|return
literal|false
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Processing exchangeId: "
operator|+
name|pair
operator|.
name|getExchange
argument_list|()
operator|.
name|getExchangeId
argument_list|()
operator|+
literal|" is continued being processed synchronously"
argument_list|)
expr_stmt|;
block|}
comment|// Decide whether to continue with the multicast or not; similar logic to the Pipeline
comment|// remember to test for stop on exception and aggregate before copying back results
name|boolean
name|continueProcessing
init|=
name|PipelineHelper
operator|.
name|continueProcessing
argument_list|(
name|subExchange
argument_list|,
literal|"Sequential processing failed for number "
operator|+
name|total
operator|.
name|get
argument_list|()
argument_list|,
name|LOG
argument_list|)
decl_stmt|;
if|if
condition|(
name|stopOnException
operator|&&
operator|!
name|continueProcessing
condition|)
block|{
if|if
condition|(
name|subExchange
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// wrap in exception to explain where it failed
throw|throw
operator|new
name|CamelExchangeException
argument_list|(
literal|"Sequential processing failed for number "
operator|+
name|total
operator|.
name|get
argument_list|()
argument_list|,
name|subExchange
argument_list|,
name|subExchange
operator|.
name|getException
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
comment|// we want to stop on exception, and the exception was handled by the error handler
comment|// this is similar to what the pipeline does, so we should do the same to not surprise end users
comment|// so we should set the failed exchange as the result and be done
name|result
operator|.
name|set
argument_list|(
name|subExchange
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Sequential processing complete for number "
operator|+
name|total
operator|+
literal|" exchange: "
operator|+
name|subExchange
argument_list|)
expr_stmt|;
block|}
name|doAggregate
argument_list|(
name|getAggregationStrategy
argument_list|(
name|subExchange
argument_list|)
argument_list|,
name|result
argument_list|,
name|subExchange
argument_list|)
expr_stmt|;
name|total
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Done sequential processing "
operator|+
name|total
operator|+
literal|" exchanges"
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|doProcessSequential (final Exchange original, final AtomicExchange result, final Iterable<ProcessorExchangePair> pairs, final Iterator<ProcessorExchangePair> it, final ProcessorExchangePair pair, final AsyncCallback callback, final AtomicInteger total)
specifier|private
name|boolean
name|doProcessSequential
parameter_list|(
specifier|final
name|Exchange
name|original
parameter_list|,
specifier|final
name|AtomicExchange
name|result
parameter_list|,
specifier|final
name|Iterable
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|pairs
parameter_list|,
specifier|final
name|Iterator
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|it
parameter_list|,
specifier|final
name|ProcessorExchangePair
name|pair
parameter_list|,
specifier|final
name|AsyncCallback
name|callback
parameter_list|,
specifier|final
name|AtomicInteger
name|total
parameter_list|)
block|{
name|boolean
name|sync
init|=
literal|true
decl_stmt|;
specifier|final
name|Exchange
name|exchange
init|=
name|pair
operator|.
name|getExchange
argument_list|()
decl_stmt|;
name|Processor
name|processor
init|=
name|pair
operator|.
name|getProcessor
argument_list|()
decl_stmt|;
name|Producer
name|producer
init|=
name|pair
operator|.
name|getProducer
argument_list|()
decl_stmt|;
name|TracedRouteNodes
name|traced
init|=
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
operator|!=
literal|null
condition|?
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
operator|.
name|getTracedRouteNodes
argument_list|()
else|:
literal|null
decl_stmt|;
comment|// compute time taken if sending to another endpoint
name|StopWatch
name|watch
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|producer
operator|!=
literal|null
condition|)
block|{
name|watch
operator|=
operator|new
name|StopWatch
argument_list|()
expr_stmt|;
block|}
try|try
block|{
comment|// prepare tracing starting from a new block
if|if
condition|(
name|traced
operator|!=
literal|null
condition|)
block|{
name|traced
operator|.
name|pushBlock
argument_list|()
expr_stmt|;
block|}
comment|// let the prepared process it, remember to begin the exchange pair
name|AsyncProcessor
name|async
init|=
name|AsyncProcessorTypeConverter
operator|.
name|convert
argument_list|(
name|processor
argument_list|)
decl_stmt|;
name|pair
operator|.
name|begin
argument_list|()
expr_stmt|;
name|sync
operator|=
name|AsyncProcessorHelper
operator|.
name|process
argument_list|(
name|async
argument_list|,
name|exchange
argument_list|,
operator|new
name|AsyncCallback
argument_list|()
block|{
specifier|public
name|void
name|done
parameter_list|(
name|boolean
name|doneSync
parameter_list|)
block|{
comment|// we are done with the exchange pair
name|pair
operator|.
name|done
argument_list|()
expr_stmt|;
comment|// we only have to handle async completion of the routing slip
if|if
condition|(
name|doneSync
condition|)
block|{
return|return;
block|}
comment|// continue processing the multicast asynchronously
name|Exchange
name|subExchange
init|=
name|exchange
decl_stmt|;
comment|// Decide whether to continue with the multicast or not; similar logic to the Pipeline
comment|// remember to test for stop on exception and aggregate before copying back results
name|boolean
name|continueProcessing
init|=
name|PipelineHelper
operator|.
name|continueProcessing
argument_list|(
name|subExchange
argument_list|,
literal|"Sequential processing failed for number "
operator|+
name|total
operator|.
name|get
argument_list|()
argument_list|,
name|LOG
argument_list|)
decl_stmt|;
if|if
condition|(
name|stopOnException
operator|&&
operator|!
name|continueProcessing
condition|)
block|{
if|if
condition|(
name|subExchange
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// wrap in exception to explain where it failed
name|subExchange
operator|.
name|setException
argument_list|(
operator|new
name|CamelExchangeException
argument_list|(
literal|"Sequential processing failed for number "
operator|+
name|total
argument_list|,
name|subExchange
argument_list|,
name|subExchange
operator|.
name|getException
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we want to stop on exception, and the exception was handled by the error handler
comment|// this is similar to what the pipeline does, so we should do the same to not surprise end users
comment|// so we should set the failed exchange as the result and be done
name|result
operator|.
name|set
argument_list|(
name|subExchange
argument_list|)
expr_stmt|;
block|}
comment|// and do the done work
name|doDone
argument_list|(
name|original
argument_list|,
name|subExchange
argument_list|,
name|callback
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
name|doAggregate
argument_list|(
name|getAggregationStrategy
argument_list|(
name|subExchange
argument_list|)
argument_list|,
name|result
argument_list|,
name|subExchange
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
comment|// wrap in exception to explain where it failed
name|subExchange
operator|.
name|setException
argument_list|(
operator|new
name|CamelExchangeException
argument_list|(
literal|"Sequential processing failed for number "
operator|+
name|total
argument_list|,
name|subExchange
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
comment|// and do the done work
name|doDone
argument_list|(
name|original
argument_list|,
name|subExchange
argument_list|,
name|callback
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
name|total
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
comment|// maybe there are more processors to multicast
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// prepare and run the next
name|ProcessorExchangePair
name|pair
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|subExchange
operator|=
name|pair
operator|.
name|getExchange
argument_list|()
expr_stmt|;
name|updateNewExchange
argument_list|(
name|subExchange
argument_list|,
name|total
operator|.
name|get
argument_list|()
argument_list|,
name|pairs
argument_list|,
name|it
argument_list|)
expr_stmt|;
name|boolean
name|sync
init|=
name|doProcessSequential
argument_list|(
name|original
argument_list|,
name|result
argument_list|,
name|pairs
argument_list|,
name|it
argument_list|,
name|pair
argument_list|,
name|callback
argument_list|,
name|total
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sync
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Processing exchangeId: "
operator|+
name|original
operator|.
name|getExchangeId
argument_list|()
operator|+
literal|" is continued being processed asynchronously"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// Decide whether to continue with the multicast or not; similar logic to the Pipeline
comment|// remember to test for stop on exception and aggregate before copying back results
name|continueProcessing
operator|=
name|PipelineHelper
operator|.
name|continueProcessing
argument_list|(
name|subExchange
argument_list|,
literal|"Sequential processing failed for number "
operator|+
name|total
operator|.
name|get
argument_list|()
argument_list|,
name|LOG
argument_list|)
expr_stmt|;
if|if
condition|(
name|stopOnException
operator|&&
operator|!
name|continueProcessing
condition|)
block|{
if|if
condition|(
name|subExchange
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// wrap in exception to explain where it failed
name|subExchange
operator|.
name|setException
argument_list|(
operator|new
name|CamelExchangeException
argument_list|(
literal|"Sequential processing failed for number "
operator|+
name|total
argument_list|,
name|subExchange
argument_list|,
name|subExchange
operator|.
name|getException
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we want to stop on exception, and the exception was handled by the error handler
comment|// this is similar to what the pipeline does, so we should do the same to not surprise end users
comment|// so we should set the failed exchange as the result and be done
name|result
operator|.
name|set
argument_list|(
name|subExchange
argument_list|)
expr_stmt|;
block|}
comment|// and do the done work
name|doDone
argument_list|(
name|original
argument_list|,
name|subExchange
argument_list|,
name|callback
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
name|doAggregate
argument_list|(
name|getAggregationStrategy
argument_list|(
name|subExchange
argument_list|)
argument_list|,
name|result
argument_list|,
name|subExchange
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
comment|// wrap in exception to explain where it failed
name|subExchange
operator|.
name|setException
argument_list|(
operator|new
name|CamelExchangeException
argument_list|(
literal|"Sequential processing failed for number "
operator|+
name|total
argument_list|,
name|subExchange
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
comment|// and do the done work
name|doDone
argument_list|(
name|original
argument_list|,
name|subExchange
argument_list|,
name|callback
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
name|total
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|// do the done work
name|subExchange
operator|=
name|result
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|?
name|result
operator|.
name|get
argument_list|()
else|:
literal|null
expr_stmt|;
name|doDone
argument_list|(
name|original
argument_list|,
name|subExchange
argument_list|,
name|callback
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// pop the block so by next round we have the same staring point and thus the tracing looks accurate
if|if
condition|(
name|traced
operator|!=
literal|null
condition|)
block|{
name|traced
operator|.
name|popBlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|producer
operator|!=
literal|null
condition|)
block|{
name|long
name|timeTaken
init|=
name|watch
operator|.
name|stop
argument_list|()
decl_stmt|;
name|Endpoint
name|endpoint
init|=
name|producer
operator|.
name|getEndpoint
argument_list|()
decl_stmt|;
comment|// emit event that the exchange was sent to the endpoint
name|EventHelper
operator|.
name|notifyExchangeSent
argument_list|(
name|exchange
operator|.
name|getContext
argument_list|()
argument_list|,
name|exchange
argument_list|,
name|endpoint
argument_list|,
name|timeTaken
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sync
return|;
block|}
DECL|method|doProcessParallel (final ProcessorExchangePair pair)
specifier|private
name|void
name|doProcessParallel
parameter_list|(
specifier|final
name|ProcessorExchangePair
name|pair
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|Exchange
name|exchange
init|=
name|pair
operator|.
name|getExchange
argument_list|()
decl_stmt|;
name|Processor
name|processor
init|=
name|pair
operator|.
name|getProcessor
argument_list|()
decl_stmt|;
name|Producer
name|producer
init|=
name|pair
operator|.
name|getProducer
argument_list|()
decl_stmt|;
name|TracedRouteNodes
name|traced
init|=
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
operator|!=
literal|null
condition|?
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
operator|.
name|getTracedRouteNodes
argument_list|()
else|:
literal|null
decl_stmt|;
comment|// compute time taken if sending to another endpoint
name|StopWatch
name|watch
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|producer
operator|!=
literal|null
condition|)
block|{
name|watch
operator|=
operator|new
name|StopWatch
argument_list|()
expr_stmt|;
block|}
try|try
block|{
comment|// prepare tracing starting from a new block
if|if
condition|(
name|traced
operator|!=
literal|null
condition|)
block|{
name|traced
operator|.
name|pushBlock
argument_list|()
expr_stmt|;
block|}
comment|// let the prepared process it, remember to begin the exchange pair
comment|// we invoke it synchronously as parallel async routing is too hard
name|AsyncProcessor
name|async
init|=
name|AsyncProcessorTypeConverter
operator|.
name|convert
argument_list|(
name|processor
argument_list|)
decl_stmt|;
name|pair
operator|.
name|begin
argument_list|()
expr_stmt|;
name|AsyncProcessorHelper
operator|.
name|process
argument_list|(
name|async
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|pair
operator|.
name|done
argument_list|()
expr_stmt|;
comment|// pop the block so by next round we have the same staring point and thus the tracing looks accurate
if|if
condition|(
name|traced
operator|!=
literal|null
condition|)
block|{
name|traced
operator|.
name|popBlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|producer
operator|!=
literal|null
condition|)
block|{
name|long
name|timeTaken
init|=
name|watch
operator|.
name|stop
argument_list|()
decl_stmt|;
name|Endpoint
name|endpoint
init|=
name|producer
operator|.
name|getEndpoint
argument_list|()
decl_stmt|;
comment|// emit event that the exchange was sent to the endpoint
name|EventHelper
operator|.
name|notifyExchangeSent
argument_list|(
name|exchange
operator|.
name|getContext
argument_list|()
argument_list|,
name|exchange
argument_list|,
name|endpoint
argument_list|,
name|timeTaken
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Common work which must be done when we are done multicasting.      *<p/>      * This logic applies for both running synchronous and asynchronous as there are multiple exist points      * when using the asynchronous routing engine. And therefore we want the logic in one method instead      * of being scattered.      *      * @param original    the original exchange      * @param subExchange the current sub exchange, can be<tt>null</tt> for the synchronous part      * @param callback    the callback      * @param doneSync    the<tt>doneSync</tt> parameter to call on callback      * @param exhaust     whether or not error handling is exhausted      */
DECL|method|doDone (Exchange original, Exchange subExchange, AsyncCallback callback, boolean doneSync, boolean exhaust)
specifier|protected
name|void
name|doDone
parameter_list|(
name|Exchange
name|original
parameter_list|,
name|Exchange
name|subExchange
parameter_list|,
name|AsyncCallback
name|callback
parameter_list|,
name|boolean
name|doneSync
parameter_list|,
name|boolean
name|exhaust
parameter_list|)
block|{
comment|// cleanup any per exchange aggregation strategy
name|removeAggregationStrategyFromExchange
argument_list|(
name|original
argument_list|)
expr_stmt|;
if|if
condition|(
name|original
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// multicast uses error handling on its output processors and they have tried to redeliver
comment|// so we shall signal back to the other error handlers that we are exhausted and they should not
comment|// also try to redeliver as we will then do that twice
name|original
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|REDELIVERY_EXHAUSTED
argument_list|,
name|exhaust
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|subExchange
operator|!=
literal|null
condition|)
block|{
comment|// and copy the current result to original so it will contain this exception
name|ExchangeHelper
operator|.
name|copyResults
argument_list|(
name|original
argument_list|,
name|subExchange
argument_list|)
expr_stmt|;
block|}
name|callback
operator|.
name|done
argument_list|(
name|doneSync
argument_list|)
expr_stmt|;
block|}
comment|/**      * Aggregate the {@link Exchange} with the current result      *      * @param strategy the aggregation strategy to use      * @param result   the current result      * @param exchange the exchange to be added to the result      */
DECL|method|doAggregate (AggregationStrategy strategy, AtomicExchange result, Exchange exchange)
specifier|protected
specifier|synchronized
name|void
name|doAggregate
parameter_list|(
name|AggregationStrategy
name|strategy
parameter_list|,
name|AtomicExchange
name|result
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
name|strategy
operator|!=
literal|null
condition|)
block|{
comment|// prepare the exchanges for aggregation
name|Exchange
name|oldExchange
init|=
name|result
operator|.
name|get
argument_list|()
decl_stmt|;
name|ExchangeHelper
operator|.
name|prepareAggregation
argument_list|(
name|oldExchange
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
name|result
operator|.
name|set
argument_list|(
name|strategy
operator|.
name|aggregate
argument_list|(
name|oldExchange
argument_list|,
name|exchange
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|updateNewExchange (Exchange exchange, int index, Iterable<ProcessorExchangePair> allPairs, Iterator<ProcessorExchangePair> it)
specifier|protected
name|void
name|updateNewExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|int
name|index
parameter_list|,
name|Iterable
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|allPairs
parameter_list|,
name|Iterator
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|it
parameter_list|)
block|{
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|MULTICAST_INDEX
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|MULTICAST_COMPLETE
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|MULTICAST_COMPLETE
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getExchangeIndex (Exchange exchange)
specifier|protected
name|Integer
name|getExchangeIndex
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|MULTICAST_INDEX
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
return|;
block|}
DECL|method|createProcessorExchangePairs (Exchange exchange)
specifier|protected
name|Iterable
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|createProcessorExchangePairs
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|ProcessorExchangePair
argument_list|>
argument_list|(
name|processors
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Processor
name|processor
range|:
name|processors
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|createProcessorExchangePair
argument_list|(
name|index
operator|++
argument_list|,
name|processor
argument_list|,
name|exchange
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * Creates the {@link ProcessorExchangePair} which holds the processor and exchange to be send out.      *<p/>      * You<b>must</b> use this method to create the instances of {@link ProcessorExchangePair} as they      * need to be specially prepared before use.      *      * @param processor the processor      * @param exchange  the exchange      * @return prepared for use      */
DECL|method|createProcessorExchangePair (int index, Processor processor, Exchange exchange)
specifier|protected
name|ProcessorExchangePair
name|createProcessorExchangePair
parameter_list|(
name|int
name|index
parameter_list|,
name|Processor
name|processor
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
name|Processor
name|prepared
init|=
name|processor
decl_stmt|;
comment|// copy exchange, and do not share the unit of work
name|Exchange
name|copy
init|=
name|ExchangeHelper
operator|.
name|createCorrelatedCopy
argument_list|(
name|exchange
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// set property which endpoint we send to
name|setToEndpoint
argument_list|(
name|copy
argument_list|,
name|prepared
argument_list|)
expr_stmt|;
comment|// rework error handling to support fine grained error handling
name|prepared
operator|=
name|createErrorHandler
argument_list|(
name|exchange
argument_list|,
name|prepared
argument_list|)
expr_stmt|;
return|return
operator|new
name|DefaultProcessorExchangePair
argument_list|(
name|index
argument_list|,
name|processor
argument_list|,
name|prepared
argument_list|,
name|copy
argument_list|)
return|;
block|}
DECL|method|createErrorHandler (Exchange exchange, Processor processor)
specifier|protected
name|Processor
name|createErrorHandler
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Processor
name|processor
parameter_list|)
block|{
name|Processor
name|answer
init|=
name|processor
decl_stmt|;
if|if
condition|(
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
operator|!=
literal|null
operator|&&
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
operator|.
name|getRouteContext
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// wrap the producer in error handler so we have fine grained error handling on
comment|// the output side instead of the input side
comment|// this is needed to support redelivery on that output alone and not doing redelivery
comment|// for the entire multicast block again which will start from scratch again
name|RouteContext
name|routeContext
init|=
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
operator|.
name|getRouteContext
argument_list|()
decl_stmt|;
comment|// create key for cache
specifier|final
name|PreparedErrorHandler
name|key
init|=
operator|new
name|PreparedErrorHandler
argument_list|(
name|routeContext
argument_list|,
name|processor
argument_list|)
decl_stmt|;
comment|// lookup cached first to reuse and preserve memory
name|answer
operator|=
name|errorHandlers
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Using existing error handler for: "
operator|+
name|processor
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Creating error handler for: "
operator|+
name|processor
argument_list|)
expr_stmt|;
block|}
name|ErrorHandlerBuilder
name|builder
init|=
name|routeContext
operator|.
name|getRoute
argument_list|()
operator|.
name|getErrorHandlerBuilder
argument_list|()
decl_stmt|;
comment|// create error handler (create error handler directly to keep it light weight,
comment|// instead of using ProcessorDefinition.wrapInErrorHandler)
try|try
block|{
name|processor
operator|=
name|builder
operator|.
name|createErrorHandler
argument_list|(
name|routeContext
argument_list|,
name|processor
argument_list|)
expr_stmt|;
comment|// and wrap in unit of work processor so the copy exchange also can run under UoW
name|answer
operator|=
operator|new
name|UnitOfWorkProcessor
argument_list|(
name|processor
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|ObjectHelper
operator|.
name|wrapRuntimeCamelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// add to cache
name|errorHandlers
operator|.
name|putIfAbsent
argument_list|(
name|key
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
DECL|method|doStart ()
specifier|protected
name|void
name|doStart
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|isParallelProcessing
argument_list|()
operator|&&
name|executorService
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"ParallelProcessing is enabled but ExecutorService has not been set"
argument_list|)
throw|;
block|}
if|if
condition|(
name|timeout
operator|>
literal|0
operator|&&
operator|!
name|isParallelProcessing
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Timeout is used but ParallelProcessing has not been enabled"
argument_list|)
throw|;
block|}
name|ServiceHelper
operator|.
name|startServices
argument_list|(
name|processors
argument_list|)
expr_stmt|;
block|}
DECL|method|doStop ()
specifier|protected
name|void
name|doStop
parameter_list|()
throws|throws
name|Exception
block|{
name|ServiceHelper
operator|.
name|stopServices
argument_list|(
name|processors
argument_list|)
expr_stmt|;
name|errorHandlers
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|setToEndpoint (Exchange exchange, Processor processor)
specifier|protected
specifier|static
name|void
name|setToEndpoint
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Processor
name|processor
parameter_list|)
block|{
if|if
condition|(
name|processor
operator|instanceof
name|Producer
condition|)
block|{
name|Producer
name|producer
init|=
operator|(
name|Producer
operator|)
name|processor
decl_stmt|;
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|TO_ENDPOINT
argument_list|,
name|producer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|getEndpointUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getAggregationStrategy (Exchange exchange)
specifier|protected
name|AggregationStrategy
name|getAggregationStrategy
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|AggregationStrategy
name|answer
init|=
literal|null
decl_stmt|;
comment|// prefer to use per Exchange aggregation strategy over a global strategy
if|if
condition|(
name|exchange
operator|!=
literal|null
condition|)
block|{
name|Map
name|property
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATION_STRATEGY
argument_list|,
name|Map
operator|.
name|class
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Object
argument_list|,
name|AggregationStrategy
argument_list|>
name|map
init|=
name|CastUtils
operator|.
name|cast
argument_list|(
name|property
argument_list|)
decl_stmt|;
if|if
condition|(
name|map
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|map
operator|.
name|get
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
comment|// fallback to global strategy
name|answer
operator|=
name|getAggregationStrategy
argument_list|()
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Sets the given {@link org.apache.camel.processor.aggregate.AggregationStrategy} on the {@link Exchange}.      *      * @param exchange  the exchange      * @param aggregationStrategy  the strategy      */
DECL|method|setAggregationStrategyOnExchange (Exchange exchange, AggregationStrategy aggregationStrategy)
specifier|protected
name|void
name|setAggregationStrategyOnExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|AggregationStrategy
name|aggregationStrategy
parameter_list|)
block|{
name|Map
name|property
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATION_STRATEGY
argument_list|,
name|Map
operator|.
name|class
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Object
argument_list|,
name|AggregationStrategy
argument_list|>
name|map
init|=
name|CastUtils
operator|.
name|cast
argument_list|(
name|property
argument_list|)
decl_stmt|;
if|if
condition|(
name|map
operator|==
literal|null
condition|)
block|{
name|map
operator|=
operator|new
name|HashMap
argument_list|<
name|Object
argument_list|,
name|AggregationStrategy
argument_list|>
argument_list|()
expr_stmt|;
block|}
comment|// store the strategy using this processor as the key
comment|// (so we can store multiple strategies on the same exchange)
name|map
operator|.
name|put
argument_list|(
name|this
argument_list|,
name|aggregationStrategy
argument_list|)
expr_stmt|;
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATION_STRATEGY
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes the associated {@link org.apache.camel.processor.aggregate.AggregationStrategy} from the {@link Exchange}      * which must be done after use.      *      * @param exchange the current exchange      */
DECL|method|removeAggregationStrategyFromExchange (Exchange exchange)
specifier|protected
name|void
name|removeAggregationStrategyFromExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|Map
name|property
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATION_STRATEGY
argument_list|,
name|Map
operator|.
name|class
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Object
argument_list|,
name|AggregationStrategy
argument_list|>
name|map
init|=
name|CastUtils
operator|.
name|cast
argument_list|(
name|property
argument_list|)
decl_stmt|;
if|if
condition|(
name|map
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// remove the strategy using this processor as the key
name|map
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**      * Is the multicast processor working in streaming mode?      *<p/>      * In streaming mode:      *<ul>      *<li>we use {@link Iterable} to ensure we can send messages as soon as the data becomes available</li>      *<li>for parallel processing, we start aggregating responses as they get send back to the processor;      * this means the {@link org.apache.camel.processor.aggregate.AggregationStrategy} has to take care of handling out-of-order arrival of exchanges</li>      *</ul>      */
DECL|method|isStreaming ()
specifier|public
name|boolean
name|isStreaming
parameter_list|()
block|{
return|return
name|streaming
return|;
block|}
comment|/**      * Should the multicast processor stop processing further exchanges in case of an exception occurred?      */
DECL|method|isStopOnException ()
specifier|public
name|boolean
name|isStopOnException
parameter_list|()
block|{
return|return
name|stopOnException
return|;
block|}
comment|/**      * Returns the producers to multicast to      */
DECL|method|getProcessors ()
specifier|public
name|Collection
argument_list|<
name|Processor
argument_list|>
name|getProcessors
parameter_list|()
block|{
return|return
name|processors
return|;
block|}
comment|/**      * An optional timeout in millis when using parallel processing      */
DECL|method|getTimeout ()
specifier|public
name|long
name|getTimeout
parameter_list|()
block|{
return|return
name|timeout
return|;
block|}
comment|/**      * Use {@link #getAggregationStrategy(org.apache.camel.Exchange)} instead.      */
DECL|method|getAggregationStrategy ()
specifier|public
name|AggregationStrategy
name|getAggregationStrategy
parameter_list|()
block|{
return|return
name|aggregationStrategy
return|;
block|}
DECL|method|isParallelProcessing ()
specifier|public
name|boolean
name|isParallelProcessing
parameter_list|()
block|{
return|return
name|parallelProcessing
return|;
block|}
DECL|method|next ()
specifier|public
name|List
argument_list|<
name|Processor
argument_list|>
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|ArrayList
argument_list|<
name|Processor
argument_list|>
argument_list|(
name|processors
argument_list|)
return|;
block|}
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|processors
operator|!=
literal|null
operator|&&
operator|!
name|processors
operator|.
name|isEmpty
argument_list|()
return|;
block|}
block|}
end_class

end_unit

