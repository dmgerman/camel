begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.processor
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|AggregationStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|AsyncCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|AsyncProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContextAware
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelExchangeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Endpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|ErrorHandlerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Navigate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Processor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Producer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|RuntimeCamelException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|StreamCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Traceable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|model
operator|.
name|RouteDefinition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|IdAware
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|RouteContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|UnitOfWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|AsyncProcessorConverterHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|AsyncProcessorSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|EventHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|ExchangeHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|ReactiveHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|service
operator|.
name|ServiceHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|CastUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|IOHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|KeyValueHolder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|StopWatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|concurrent
operator|.
name|AsyncCompletionService
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ObjectHelper
operator|.
name|notNull
import|;
end_import

begin_comment
comment|/**  * Implements the Multicast pattern to send a message exchange to a number of  * endpoints, each endpoint receiving a copy of the message exchange.  * @see Pipeline  */
end_comment

begin_class
DECL|class|MulticastProcessor
specifier|public
class|class
name|MulticastProcessor
extends|extends
name|AsyncProcessorSupport
implements|implements
name|Navigate
argument_list|<
name|Processor
argument_list|>
implements|,
name|Traceable
implements|,
name|IdAware
block|{
comment|/**      * Class that represent each step in the multicast route to do      */
DECL|class|DefaultProcessorExchangePair
specifier|static
specifier|final
class|class
name|DefaultProcessorExchangePair
implements|implements
name|ProcessorExchangePair
block|{
DECL|field|index
specifier|private
specifier|final
name|int
name|index
decl_stmt|;
DECL|field|processor
specifier|private
specifier|final
name|Processor
name|processor
decl_stmt|;
DECL|field|prepared
specifier|private
specifier|final
name|Processor
name|prepared
decl_stmt|;
DECL|field|exchange
specifier|private
specifier|final
name|Exchange
name|exchange
decl_stmt|;
DECL|method|DefaultProcessorExchangePair (int index, Processor processor, Processor prepared, Exchange exchange)
specifier|private
name|DefaultProcessorExchangePair
parameter_list|(
name|int
name|index
parameter_list|,
name|Processor
name|processor
parameter_list|,
name|Processor
name|prepared
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
name|this
operator|.
name|processor
operator|=
name|processor
expr_stmt|;
name|this
operator|.
name|prepared
operator|=
name|prepared
expr_stmt|;
name|this
operator|.
name|exchange
operator|=
name|exchange
expr_stmt|;
block|}
DECL|method|getIndex ()
specifier|public
name|int
name|getIndex
parameter_list|()
block|{
return|return
name|index
return|;
block|}
DECL|method|getExchange ()
specifier|public
name|Exchange
name|getExchange
parameter_list|()
block|{
return|return
name|exchange
return|;
block|}
DECL|method|getProducer ()
specifier|public
name|Producer
name|getProducer
parameter_list|()
block|{
if|if
condition|(
name|processor
operator|instanceof
name|Producer
condition|)
block|{
return|return
operator|(
name|Producer
operator|)
name|processor
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|getProcessor ()
specifier|public
name|Processor
name|getProcessor
parameter_list|()
block|{
return|return
name|prepared
return|;
block|}
DECL|method|begin ()
specifier|public
name|void
name|begin
parameter_list|()
block|{
comment|// noop
block|}
DECL|method|done ()
specifier|public
name|void
name|done
parameter_list|()
block|{
comment|// noop
block|}
block|}
comment|/**      * Class that represents prepared fine grained error handlers when processing multicasted/splitted exchanges      *<p/>      * See the<tt>createProcessorExchangePair</tt> and<tt>createErrorHandler</tt> methods.      */
DECL|class|PreparedErrorHandler
specifier|static
specifier|final
class|class
name|PreparedErrorHandler
extends|extends
name|KeyValueHolder
argument_list|<
name|RouteContext
argument_list|,
name|Processor
argument_list|>
block|{
DECL|method|PreparedErrorHandler (RouteContext key, Processor value)
name|PreparedErrorHandler
parameter_list|(
name|RouteContext
name|key
parameter_list|,
name|Processor
name|value
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|onPrepare
specifier|protected
specifier|final
name|Processor
name|onPrepare
decl_stmt|;
DECL|field|camelContext
specifier|private
specifier|final
name|CamelContext
name|camelContext
decl_stmt|;
DECL|field|id
specifier|private
name|String
name|id
decl_stmt|;
DECL|field|processors
specifier|private
name|Collection
argument_list|<
name|Processor
argument_list|>
name|processors
decl_stmt|;
DECL|field|aggregationStrategy
specifier|private
specifier|final
name|AggregationStrategy
name|aggregationStrategy
decl_stmt|;
DECL|field|parallelProcessing
specifier|private
specifier|final
name|boolean
name|parallelProcessing
decl_stmt|;
DECL|field|streaming
specifier|private
specifier|final
name|boolean
name|streaming
decl_stmt|;
DECL|field|parallelAggregate
specifier|private
specifier|final
name|boolean
name|parallelAggregate
decl_stmt|;
DECL|field|stopOnAggregateException
specifier|private
specifier|final
name|boolean
name|stopOnAggregateException
decl_stmt|;
DECL|field|stopOnException
specifier|private
specifier|final
name|boolean
name|stopOnException
decl_stmt|;
DECL|field|executorService
specifier|private
specifier|final
name|ExecutorService
name|executorService
decl_stmt|;
DECL|field|shutdownExecutorService
specifier|private
specifier|final
name|boolean
name|shutdownExecutorService
decl_stmt|;
DECL|field|aggregateExecutorService
specifier|private
name|ExecutorService
name|aggregateExecutorService
decl_stmt|;
DECL|field|timeout
specifier|private
specifier|final
name|long
name|timeout
decl_stmt|;
DECL|field|errorHandlers
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|PreparedErrorHandler
argument_list|,
name|Processor
argument_list|>
name|errorHandlers
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|shareUnitOfWork
specifier|private
specifier|final
name|boolean
name|shareUnitOfWork
decl_stmt|;
DECL|method|MulticastProcessor (CamelContext camelContext, Collection<Processor> processors)
specifier|public
name|MulticastProcessor
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|,
name|Collection
argument_list|<
name|Processor
argument_list|>
name|processors
parameter_list|)
block|{
name|this
argument_list|(
name|camelContext
argument_list|,
name|processors
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|MulticastProcessor (CamelContext camelContext, Collection<Processor> processors, AggregationStrategy aggregationStrategy)
specifier|public
name|MulticastProcessor
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|,
name|Collection
argument_list|<
name|Processor
argument_list|>
name|processors
parameter_list|,
name|AggregationStrategy
name|aggregationStrategy
parameter_list|)
block|{
name|this
argument_list|(
name|camelContext
argument_list|,
name|processors
argument_list|,
name|aggregationStrategy
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|MulticastProcessor (CamelContext camelContext, Collection<Processor> processors, AggregationStrategy aggregationStrategy, boolean parallelProcessing, ExecutorService executorService, boolean shutdownExecutorService, boolean streaming, boolean stopOnException, long timeout, Processor onPrepare, boolean shareUnitOfWork, boolean parallelAggregate)
specifier|public
name|MulticastProcessor
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|,
name|Collection
argument_list|<
name|Processor
argument_list|>
name|processors
parameter_list|,
name|AggregationStrategy
name|aggregationStrategy
parameter_list|,
name|boolean
name|parallelProcessing
parameter_list|,
name|ExecutorService
name|executorService
parameter_list|,
name|boolean
name|shutdownExecutorService
parameter_list|,
name|boolean
name|streaming
parameter_list|,
name|boolean
name|stopOnException
parameter_list|,
name|long
name|timeout
parameter_list|,
name|Processor
name|onPrepare
parameter_list|,
name|boolean
name|shareUnitOfWork
parameter_list|,
name|boolean
name|parallelAggregate
parameter_list|)
block|{
name|this
argument_list|(
name|camelContext
argument_list|,
name|processors
argument_list|,
name|aggregationStrategy
argument_list|,
name|parallelProcessing
argument_list|,
name|executorService
argument_list|,
name|shutdownExecutorService
argument_list|,
name|streaming
argument_list|,
name|stopOnException
argument_list|,
name|timeout
argument_list|,
name|onPrepare
argument_list|,
name|shareUnitOfWork
argument_list|,
name|parallelAggregate
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|MulticastProcessor (CamelContext camelContext, Collection<Processor> processors, AggregationStrategy aggregationStrategy, boolean parallelProcessing, ExecutorService executorService, boolean shutdownExecutorService, boolean streaming, boolean stopOnException, long timeout, Processor onPrepare, boolean shareUnitOfWork, boolean parallelAggregate, boolean stopOnAggregateException)
specifier|public
name|MulticastProcessor
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|,
name|Collection
argument_list|<
name|Processor
argument_list|>
name|processors
parameter_list|,
name|AggregationStrategy
name|aggregationStrategy
parameter_list|,
name|boolean
name|parallelProcessing
parameter_list|,
name|ExecutorService
name|executorService
parameter_list|,
name|boolean
name|shutdownExecutorService
parameter_list|,
name|boolean
name|streaming
parameter_list|,
name|boolean
name|stopOnException
parameter_list|,
name|long
name|timeout
parameter_list|,
name|Processor
name|onPrepare
parameter_list|,
name|boolean
name|shareUnitOfWork
parameter_list|,
name|boolean
name|parallelAggregate
parameter_list|,
name|boolean
name|stopOnAggregateException
parameter_list|)
block|{
name|notNull
argument_list|(
name|camelContext
argument_list|,
literal|"camelContext"
argument_list|)
expr_stmt|;
name|this
operator|.
name|camelContext
operator|=
name|camelContext
expr_stmt|;
name|this
operator|.
name|processors
operator|=
name|processors
expr_stmt|;
name|this
operator|.
name|aggregationStrategy
operator|=
name|aggregationStrategy
expr_stmt|;
name|this
operator|.
name|executorService
operator|=
name|executorService
expr_stmt|;
name|this
operator|.
name|shutdownExecutorService
operator|=
name|shutdownExecutorService
expr_stmt|;
name|this
operator|.
name|streaming
operator|=
name|streaming
expr_stmt|;
name|this
operator|.
name|stopOnException
operator|=
name|stopOnException
expr_stmt|;
comment|// must enable parallel if executor service is provided
name|this
operator|.
name|parallelProcessing
operator|=
name|parallelProcessing
operator|||
name|executorService
operator|!=
literal|null
expr_stmt|;
name|this
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
name|this
operator|.
name|onPrepare
operator|=
name|onPrepare
expr_stmt|;
name|this
operator|.
name|shareUnitOfWork
operator|=
name|shareUnitOfWork
expr_stmt|;
name|this
operator|.
name|parallelAggregate
operator|=
name|parallelAggregate
expr_stmt|;
name|this
operator|.
name|stopOnAggregateException
operator|=
name|stopOnAggregateException
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Multicast["
operator|+
name|getProcessors
argument_list|()
operator|+
literal|"]"
return|;
block|}
DECL|method|getId ()
specifier|public
name|String
name|getId
parameter_list|()
block|{
return|return
name|id
return|;
block|}
DECL|method|setId (String id)
specifier|public
name|void
name|setId
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
block|}
DECL|method|getTraceLabel ()
specifier|public
name|String
name|getTraceLabel
parameter_list|()
block|{
return|return
literal|"multicast"
return|;
block|}
DECL|method|getCamelContext ()
specifier|public
name|CamelContext
name|getCamelContext
parameter_list|()
block|{
return|return
name|camelContext
return|;
block|}
DECL|method|process (Exchange exchange, AsyncCallback callback)
specifier|public
name|boolean
name|process
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|AsyncCallback
name|callback
parameter_list|)
block|{
name|Iterable
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|pairs
decl_stmt|;
try|try
block|{
name|pairs
operator|=
name|createProcessorExchangePairs
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|exchange
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|// unexpected exception was thrown, maybe from iterator etc. so do not regard as exhausted
comment|// and do the done work
name|doDone
argument_list|(
name|exchange
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|callback
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|MulticastState
name|state
init|=
operator|new
name|MulticastState
argument_list|(
name|exchange
argument_list|,
name|pairs
argument_list|,
name|callback
argument_list|)
decl_stmt|;
if|if
condition|(
name|isParallelProcessing
argument_list|()
condition|)
block|{
name|executorService
operator|.
name|submit
argument_list|(
parameter_list|()
lambda|->
name|ReactiveHelper
operator|.
name|schedule
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|exchange
operator|.
name|isTransacted
argument_list|()
condition|)
block|{
name|ReactiveHelper
operator|.
name|scheduleSync
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ReactiveHelper
operator|.
name|scheduleMain
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
block|}
comment|// the remainder of the multicast will be completed async
comment|// so we break out now, then the callback will be invoked which then
comment|// continue routing from where we left here
return|return
literal|false
return|;
block|}
DECL|method|schedule (Runnable runnable)
specifier|protected
name|void
name|schedule
parameter_list|(
name|Runnable
name|runnable
parameter_list|)
block|{
if|if
condition|(
name|isParallelProcessing
argument_list|()
condition|)
block|{
name|executorService
operator|.
name|submit
argument_list|(
parameter_list|()
lambda|->
name|ReactiveHelper
operator|.
name|schedule
argument_list|(
name|runnable
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ReactiveHelper
operator|.
name|schedule
argument_list|(
name|runnable
argument_list|,
literal|"Multicast next step"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|MulticastState
specifier|protected
class|class
name|MulticastState
implements|implements
name|Runnable
block|{
DECL|field|original
specifier|final
name|Exchange
name|original
decl_stmt|;
DECL|field|pairs
specifier|final
name|Iterable
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|pairs
decl_stmt|;
DECL|field|callback
specifier|final
name|AsyncCallback
name|callback
decl_stmt|;
DECL|field|iterator
specifier|final
name|Iterator
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|iterator
decl_stmt|;
DECL|field|lock
specifier|final
name|ReentrantLock
name|lock
decl_stmt|;
DECL|field|completion
specifier|final
name|AsyncCompletionService
argument_list|<
name|Exchange
argument_list|>
name|completion
decl_stmt|;
DECL|field|result
specifier|final
name|AtomicReference
argument_list|<
name|Exchange
argument_list|>
name|result
decl_stmt|;
DECL|field|nbExchangeSent
specifier|final
name|AtomicInteger
name|nbExchangeSent
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|field|nbAggregated
specifier|final
name|AtomicInteger
name|nbAggregated
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|field|allSent
specifier|final
name|AtomicBoolean
name|allSent
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
DECL|field|done
specifier|final
name|AtomicBoolean
name|done
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
DECL|method|MulticastState (Exchange original, Iterable<ProcessorExchangePair> pairs, AsyncCallback callback)
name|MulticastState
parameter_list|(
name|Exchange
name|original
parameter_list|,
name|Iterable
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|pairs
parameter_list|,
name|AsyncCallback
name|callback
parameter_list|)
block|{
name|this
operator|.
name|original
operator|=
name|original
expr_stmt|;
name|this
operator|.
name|pairs
operator|=
name|pairs
expr_stmt|;
name|this
operator|.
name|callback
operator|=
name|callback
expr_stmt|;
name|this
operator|.
name|iterator
operator|=
name|pairs
operator|.
name|iterator
argument_list|()
expr_stmt|;
name|this
operator|.
name|lock
operator|=
operator|new
name|ReentrantLock
argument_list|()
expr_stmt|;
name|this
operator|.
name|completion
operator|=
operator|new
name|AsyncCompletionService
argument_list|<>
argument_list|(
name|MulticastProcessor
operator|.
name|this
operator|::
name|schedule
argument_list|,
operator|!
name|isStreaming
argument_list|()
argument_list|,
name|lock
argument_list|)
expr_stmt|;
name|this
operator|.
name|result
operator|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|()
expr_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
name|schedule
argument_list|(
name|aggregateExecutorService
argument_list|,
name|this
operator|::
name|timeout
argument_list|,
name|timeout
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Step["
operator|+
name|original
operator|.
name|getExchangeId
argument_list|()
operator|+
literal|","
operator|+
name|MulticastProcessor
operator|.
name|this
operator|+
literal|"]"
return|;
block|}
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|done
operator|.
name|get
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// Check if the iterator is empty
comment|// This can happen the very first time we check the existence
comment|// of an item before queuing the run.
comment|// or some iterators may return true for hasNext() but then null in next()
if|if
condition|(
operator|!
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|doDone
argument_list|(
name|result
operator|.
name|get
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
name|ProcessorExchangePair
name|pair
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|boolean
name|hasNext
init|=
name|iterator
operator|.
name|hasNext
argument_list|()
decl_stmt|;
comment|// some iterators may return true for hasNext() but then null in next()
if|if
condition|(
name|pair
operator|==
literal|null
operator|&&
operator|!
name|hasNext
condition|)
block|{
name|doDone
argument_list|(
name|result
operator|.
name|get
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
name|Exchange
name|exchange
init|=
name|pair
operator|.
name|getExchange
argument_list|()
decl_stmt|;
name|int
name|index
init|=
name|nbExchangeSent
operator|.
name|getAndIncrement
argument_list|()
decl_stmt|;
name|updateNewExchange
argument_list|(
name|exchange
argument_list|,
name|index
argument_list|,
name|pairs
argument_list|,
name|hasNext
argument_list|)
expr_stmt|;
comment|// Schedule the processing of the next pair
if|if
condition|(
name|hasNext
condition|)
block|{
if|if
condition|(
name|isParallelProcessing
argument_list|()
condition|)
block|{
name|schedule
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|allSent
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|completion
operator|.
name|submit
argument_list|(
name|exchangeResult
lambda|->
block|{
comment|// compute time taken if sending to another endpoint
name|StopWatch
name|watch
init|=
name|beforeSend
argument_list|(
name|pair
argument_list|)
decl_stmt|;
name|AsyncProcessor
name|async
init|=
name|AsyncProcessorConverterHelper
operator|.
name|convert
argument_list|(
name|pair
operator|.
name|getProcessor
argument_list|()
argument_list|)
decl_stmt|;
name|async
operator|.
name|process
argument_list|(
name|exchange
argument_list|,
name|doneSync
lambda|->
block|{
name|afterSend
argument_list|(
name|pair
argument_list|,
name|watch
argument_list|)
expr_stmt|;
comment|// Decide whether to continue with the multicast or not; similar logic to the Pipeline
comment|// remember to test for stop on exception and aggregate before copying back results
name|boolean
name|continueProcessing
init|=
name|PipelineHelper
operator|.
name|continueProcessing
argument_list|(
name|exchange
argument_list|,
literal|"Multicast processing failed for number "
operator|+
name|index
argument_list|,
name|log
argument_list|)
decl_stmt|;
if|if
condition|(
name|stopOnException
operator|&&
operator|!
name|continueProcessing
condition|)
block|{
if|if
condition|(
name|exchange
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// wrap in exception to explain where it failed
name|exchange
operator|.
name|setException
argument_list|(
operator|new
name|CamelExchangeException
argument_list|(
literal|"Multicast processing failed for number "
operator|+
name|index
argument_list|,
name|exchange
argument_list|,
name|exchange
operator|.
name|getException
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we want to stop on exception, and the exception was handled by the error handler
comment|// this is similar to what the pipeline does, so we should do the same to not surprise end users
comment|// so we should set the failed exchange as the result and be done
name|result
operator|.
name|set
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
comment|// and do the done work
name|doDone
argument_list|(
name|exchange
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
name|exchangeResult
operator|.
name|accept
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
comment|// aggregate exchanges if any
name|aggregate
argument_list|()
expr_stmt|;
comment|// next step
if|if
condition|(
name|hasNext
operator|&&
operator|!
name|isParallelProcessing
argument_list|()
condition|)
block|{
name|schedule
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|original
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|doDone
argument_list|(
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|aggregate ()
specifier|protected
name|void
name|aggregate
parameter_list|()
block|{
name|Lock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
if|if
condition|(
name|lock
operator|.
name|tryLock
argument_list|()
condition|)
block|{
try|try
block|{
name|Exchange
name|exchange
decl_stmt|;
while|while
condition|(
operator|!
name|done
operator|.
name|get
argument_list|()
operator|&&
operator|(
name|exchange
operator|=
name|completion
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|doAggregate
argument_list|(
name|result
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbAggregated
operator|.
name|incrementAndGet
argument_list|()
operator|>=
name|nbExchangeSent
operator|.
name|get
argument_list|()
operator|&&
name|allSent
operator|.
name|get
argument_list|()
condition|)
block|{
name|doDone
argument_list|(
name|result
operator|.
name|get
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|original
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|// and do the done work
name|doDone
argument_list|(
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|timeout ()
specifier|protected
name|void
name|timeout
parameter_list|()
block|{
name|Lock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
if|if
condition|(
name|lock
operator|.
name|tryLock
argument_list|()
condition|)
block|{
try|try
block|{
while|while
condition|(
name|nbAggregated
operator|.
name|get
argument_list|()
operator|<
name|nbExchangeSent
operator|.
name|get
argument_list|()
condition|)
block|{
name|Exchange
name|exchange
init|=
name|completion
operator|.
name|pollUnordered
argument_list|()
decl_stmt|;
name|int
name|index
init|=
name|exchange
operator|!=
literal|null
condition|?
name|getExchangeIndex
argument_list|(
name|exchange
argument_list|)
else|:
name|nbExchangeSent
operator|.
name|get
argument_list|()
decl_stmt|;
while|while
condition|(
name|nbAggregated
operator|.
name|get
argument_list|()
operator|<
name|index
condition|)
block|{
name|AggregationStrategy
name|strategy
init|=
name|getAggregationStrategy
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|strategy
operator|.
name|timeout
argument_list|(
name|result
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|?
name|result
operator|.
name|get
argument_list|()
else|:
name|original
argument_list|,
name|nbAggregated
operator|.
name|getAndIncrement
argument_list|()
argument_list|,
name|nbExchangeSent
operator|.
name|get
argument_list|()
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exchange
operator|!=
literal|null
condition|)
block|{
name|doAggregate
argument_list|(
name|result
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
name|nbAggregated
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
name|doDone
argument_list|(
name|result
operator|.
name|get
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|original
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|// and do the done work
name|doDone
argument_list|(
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|doDone (Exchange exchange, boolean forceExhaust)
specifier|protected
name|void
name|doDone
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|boolean
name|forceExhaust
parameter_list|)
block|{
if|if
condition|(
name|done
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|MulticastProcessor
operator|.
name|this
operator|.
name|doDone
argument_list|(
name|original
argument_list|,
name|exchange
argument_list|,
name|pairs
argument_list|,
name|callback
argument_list|,
literal|false
argument_list|,
name|forceExhaust
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|schedule (Executor executor, Runnable runnable, long delay, TimeUnit unit)
specifier|protected
name|void
name|schedule
parameter_list|(
name|Executor
name|executor
parameter_list|,
name|Runnable
name|runnable
parameter_list|,
name|long
name|delay
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|instanceof
name|ScheduledExecutorService
condition|)
block|{
operator|(
operator|(
name|ScheduledExecutorService
operator|)
name|executor
operator|)
operator|.
name|schedule
argument_list|(
name|runnable
argument_list|,
name|delay
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|executor
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
name|runnable
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|beforeSend (ProcessorExchangePair pair)
specifier|protected
name|StopWatch
name|beforeSend
parameter_list|(
name|ProcessorExchangePair
name|pair
parameter_list|)
block|{
name|StopWatch
name|watch
decl_stmt|;
specifier|final
name|Exchange
name|e
init|=
name|pair
operator|.
name|getExchange
argument_list|()
decl_stmt|;
specifier|final
name|Producer
name|p
init|=
name|pair
operator|.
name|getProducer
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|boolean
name|sending
init|=
name|EventHelper
operator|.
name|notifyExchangeSending
argument_list|(
name|e
operator|.
name|getContext
argument_list|()
argument_list|,
name|e
argument_list|,
name|p
operator|.
name|getEndpoint
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|sending
condition|)
block|{
name|watch
operator|=
operator|new
name|StopWatch
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|watch
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
name|watch
operator|=
literal|null
expr_stmt|;
block|}
comment|// let the prepared process it, remember to begin the exchange pair
name|pair
operator|.
name|begin
argument_list|()
expr_stmt|;
comment|// return the watch
return|return
name|watch
return|;
block|}
DECL|method|afterSend (ProcessorExchangePair pair, StopWatch watch)
specifier|protected
name|void
name|afterSend
parameter_list|(
name|ProcessorExchangePair
name|pair
parameter_list|,
name|StopWatch
name|watch
parameter_list|)
block|{
comment|// we are done with the exchange pair
name|pair
operator|.
name|done
argument_list|()
expr_stmt|;
comment|// okay we are done, so notify the exchange was sent
specifier|final
name|Producer
name|producer
init|=
name|pair
operator|.
name|getProducer
argument_list|()
decl_stmt|;
if|if
condition|(
name|producer
operator|!=
literal|null
operator|&&
name|watch
operator|!=
literal|null
condition|)
block|{
name|long
name|timeTaken
init|=
name|watch
operator|.
name|taken
argument_list|()
decl_stmt|;
specifier|final
name|Exchange
name|e
init|=
name|pair
operator|.
name|getExchange
argument_list|()
decl_stmt|;
name|Endpoint
name|endpoint
init|=
name|producer
operator|.
name|getEndpoint
argument_list|()
decl_stmt|;
comment|// emit event that the exchange was sent to the endpoint
name|EventHelper
operator|.
name|notifyExchangeSent
argument_list|(
name|e
operator|.
name|getContext
argument_list|()
argument_list|,
name|e
argument_list|,
name|endpoint
argument_list|,
name|timeTaken
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Common work which must be done when we are done multicasting.      *<p/>      * This logic applies for both running synchronous and asynchronous as there are multiple exist points      * when using the asynchronous routing engine. And therefore we want the logic in one method instead      * of being scattered.      *      * @param original     the original exchange      * @param subExchange  the current sub exchange, can be<tt>null</tt> for the synchronous part      * @param pairs        the pairs with the exchanges to process      * @param callback     the callback      * @param doneSync     the<tt>doneSync</tt> parameter to call on callback      * @param forceExhaust whether or not error handling is exhausted      */
DECL|method|doDone (Exchange original, Exchange subExchange, final Iterable<ProcessorExchangePair> pairs, AsyncCallback callback, boolean doneSync, boolean forceExhaust)
specifier|protected
name|void
name|doDone
parameter_list|(
name|Exchange
name|original
parameter_list|,
name|Exchange
name|subExchange
parameter_list|,
specifier|final
name|Iterable
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|pairs
parameter_list|,
name|AsyncCallback
name|callback
parameter_list|,
name|boolean
name|doneSync
parameter_list|,
name|boolean
name|forceExhaust
parameter_list|)
block|{
comment|// we are done so close the pairs iterator
if|if
condition|(
name|pairs
operator|instanceof
name|Closeable
condition|)
block|{
name|IOHelper
operator|.
name|close
argument_list|(
operator|(
name|Closeable
operator|)
name|pairs
argument_list|,
literal|"pairs"
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
name|AggregationStrategy
name|strategy
init|=
name|getAggregationStrategy
argument_list|(
name|subExchange
argument_list|)
decl_stmt|;
comment|// invoke the on completion callback
if|if
condition|(
name|strategy
operator|!=
literal|null
condition|)
block|{
name|strategy
operator|.
name|onCompletion
argument_list|(
name|subExchange
argument_list|)
expr_stmt|;
block|}
comment|// cleanup any per exchange aggregation strategy
name|removeAggregationStrategyFromExchange
argument_list|(
name|original
argument_list|)
expr_stmt|;
comment|// we need to know if there was an exception, and if the stopOnException option was enabled
comment|// also we would need to know if any error handler has attempted redelivery and exhausted
name|boolean
name|stoppedOnException
init|=
literal|false
decl_stmt|;
name|boolean
name|exception
init|=
literal|false
decl_stmt|;
name|boolean
name|exhaust
init|=
name|forceExhaust
operator|||
name|subExchange
operator|!=
literal|null
operator|&&
operator|(
name|subExchange
operator|.
name|getException
argument_list|()
operator|!=
literal|null
operator|||
name|ExchangeHelper
operator|.
name|isRedeliveryExhausted
argument_list|(
name|subExchange
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|original
operator|.
name|getException
argument_list|()
operator|!=
literal|null
operator|||
name|subExchange
operator|!=
literal|null
operator|&&
name|subExchange
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// there was an exception and we stopped
name|stoppedOnException
operator|=
name|isStopOnException
argument_list|()
expr_stmt|;
name|exception
operator|=
literal|true
expr_stmt|;
block|}
comment|// must copy results at this point
if|if
condition|(
name|subExchange
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|stoppedOnException
condition|)
block|{
comment|// if we stopped due an exception then only propagate the exception
name|original
operator|.
name|setException
argument_list|(
name|subExchange
operator|.
name|getException
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// copy the current result to original so it will contain this result of this eip
name|ExchangeHelper
operator|.
name|copyResults
argument_list|(
name|original
argument_list|,
name|subExchange
argument_list|)
expr_stmt|;
block|}
block|}
comment|// .. and then if there was an exception we need to configure the redelivery exhaust
comment|// for example the noErrorHandler will not cause redelivery exhaust so if this error
comment|// handled has been in use, then the exhaust would be false (if not forced)
if|if
condition|(
name|exception
condition|)
block|{
comment|// multicast uses error handling on its output processors and they have tried to redeliver
comment|// so we shall signal back to the other error handlers that we are exhausted and they should not
comment|// also try to redeliver as we would then do that twice
name|original
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|REDELIVERY_EXHAUSTED
argument_list|,
name|exhaust
argument_list|)
expr_stmt|;
block|}
name|ReactiveHelper
operator|.
name|callback
argument_list|(
name|callback
argument_list|)
expr_stmt|;
block|}
comment|/**      * Aggregate the {@link Exchange} with the current result.      * This method is synchronized and is called directly when parallelAggregate is disabled (by default).      *      * @param result   the current result      * @param exchange the exchange to be added to the result      * @see #doAggregateInternal(AggregationStrategy, AtomicReference, org.apache.camel.Exchange)      * @see #doAggregateSync(AggregationStrategy, AtomicReference, org.apache.camel.Exchange)      */
DECL|method|doAggregate (AtomicReference<Exchange> result, Exchange exchange)
specifier|protected
name|void
name|doAggregate
parameter_list|(
name|AtomicReference
argument_list|<
name|Exchange
argument_list|>
name|result
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
name|parallelAggregate
condition|)
block|{
name|doAggregateInternal
argument_list|(
name|getAggregationStrategy
argument_list|(
name|exchange
argument_list|)
argument_list|,
name|result
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doAggregateSync
argument_list|(
name|getAggregationStrategy
argument_list|(
name|exchange
argument_list|)
argument_list|,
name|result
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Aggregate the {@link Exchange} with the current result.      * This method is synchronized and is called directly when parallelAggregate is disabled (by default).      *      * @param strategy the aggregation strategy to use      * @param result   the current result      * @param exchange the exchange to be added to the result      * @see #doAggregateInternal(AggregationStrategy, AtomicReference, org.apache.camel.Exchange)      */
DECL|method|doAggregateSync (AggregationStrategy strategy, AtomicReference<Exchange> result, Exchange exchange)
specifier|protected
specifier|synchronized
name|void
name|doAggregateSync
parameter_list|(
name|AggregationStrategy
name|strategy
parameter_list|,
name|AtomicReference
argument_list|<
name|Exchange
argument_list|>
name|result
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
name|doAggregateInternal
argument_list|(
name|strategy
argument_list|,
name|result
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
comment|/**      * Aggregate the {@link Exchange} with the current result.      * This method is unsynchronized and is called directly when parallelAggregate is enabled.      * In all other cases, this method is called from the doAggregate which is a synchronized method      *      * @param strategy the aggregation strategy to use      * @param result   the current result      * @param exchange the exchange to be added to the result      * @see #doAggregateSync      */
DECL|method|doAggregateInternal (AggregationStrategy strategy, AtomicReference<Exchange> result, Exchange exchange)
specifier|protected
name|void
name|doAggregateInternal
parameter_list|(
name|AggregationStrategy
name|strategy
parameter_list|,
name|AtomicReference
argument_list|<
name|Exchange
argument_list|>
name|result
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
name|strategy
operator|!=
literal|null
condition|)
block|{
comment|// prepare the exchanges for aggregation
name|Exchange
name|oldExchange
init|=
name|result
operator|.
name|get
argument_list|()
decl_stmt|;
name|ExchangeHelper
operator|.
name|prepareAggregation
argument_list|(
name|oldExchange
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
name|result
operator|.
name|set
argument_list|(
name|strategy
operator|.
name|aggregate
argument_list|(
name|oldExchange
argument_list|,
name|exchange
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|updateNewExchange (Exchange exchange, int index, Iterable<ProcessorExchangePair> allPairs, boolean hasNext)
specifier|protected
name|void
name|updateNewExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|int
name|index
parameter_list|,
name|Iterable
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|allPairs
parameter_list|,
name|boolean
name|hasNext
parameter_list|)
block|{
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|MULTICAST_INDEX
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasNext
condition|)
block|{
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|MULTICAST_COMPLETE
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|MULTICAST_COMPLETE
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getExchangeIndex (Exchange exchange)
specifier|protected
name|Integer
name|getExchangeIndex
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|MULTICAST_INDEX
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
return|;
block|}
DECL|method|createProcessorExchangePairs (Exchange exchange)
specifier|protected
name|Iterable
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|createProcessorExchangePairs
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|ProcessorExchangePair
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|processors
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|StreamCache
name|streamCache
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isParallelProcessing
argument_list|()
operator|&&
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|()
operator|instanceof
name|StreamCache
condition|)
block|{
comment|// in parallel processing case, the stream must be copied, therefore get the stream
name|streamCache
operator|=
operator|(
name|StreamCache
operator|)
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|()
expr_stmt|;
block|}
name|int
name|index
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Processor
name|processor
range|:
name|processors
control|)
block|{
comment|// copy exchange, and do not share the unit of work
name|Exchange
name|copy
init|=
name|ExchangeHelper
operator|.
name|createCorrelatedCopy
argument_list|(
name|exchange
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|streamCache
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|index
operator|>
literal|0
condition|)
block|{
comment|// copy it otherwise parallel processing is not possible,
comment|// because streams can only be read once
name|StreamCache
name|copiedStreamCache
init|=
name|streamCache
operator|.
name|copy
argument_list|(
name|copy
argument_list|)
decl_stmt|;
if|if
condition|(
name|copiedStreamCache
operator|!=
literal|null
condition|)
block|{
name|copy
operator|.
name|getIn
argument_list|()
operator|.
name|setBody
argument_list|(
name|copiedStreamCache
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// If the multi-cast processor has an aggregation strategy
comment|// then the StreamCache created by the child routes must not be
comment|// closed by the unit of work of the child route, but by the unit of
comment|// work of the parent route or grand parent route or grand grand parent route ...(in case of nesting).
comment|// Set therefore the unit of work of the  parent route as stream cache unit of work,
comment|// if it is not already set.
if|if
condition|(
name|copy
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|STREAM_CACHE_UNIT_OF_WORK
argument_list|)
operator|==
literal|null
condition|)
block|{
name|copy
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|STREAM_CACHE_UNIT_OF_WORK
argument_list|,
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// if we share unit of work, we need to prepare the child exchange
if|if
condition|(
name|isShareUnitOfWork
argument_list|()
condition|)
block|{
name|prepareSharedUnitOfWork
argument_list|(
name|copy
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
comment|// and add the pair
name|RouteContext
name|routeContext
init|=
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
operator|!=
literal|null
condition|?
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
operator|.
name|getRouteContext
argument_list|()
else|:
literal|null
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|createProcessorExchangePair
argument_list|(
name|index
operator|++
argument_list|,
name|processor
argument_list|,
name|copy
argument_list|,
name|routeContext
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exchange
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// force any exceptions occurred during creation of exchange paris to be thrown
comment|// before returning the answer;
throw|throw
name|exchange
operator|.
name|getException
argument_list|()
throw|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * Creates the {@link ProcessorExchangePair} which holds the processor and exchange to be send out.      *<p/>      * You<b>must</b> use this method to create the instances of {@link ProcessorExchangePair} as they      * need to be specially prepared before use.      *      * @param index        the index      * @param processor    the processor      * @param exchange     the exchange      * @param routeContext the route context      * @return prepared for use      */
DECL|method|createProcessorExchangePair (int index, Processor processor, Exchange exchange, RouteContext routeContext)
specifier|protected
name|ProcessorExchangePair
name|createProcessorExchangePair
parameter_list|(
name|int
name|index
parameter_list|,
name|Processor
name|processor
parameter_list|,
name|Exchange
name|exchange
parameter_list|,
name|RouteContext
name|routeContext
parameter_list|)
block|{
name|Processor
name|prepared
init|=
name|processor
decl_stmt|;
comment|// set property which endpoint we send to
name|setToEndpoint
argument_list|(
name|exchange
argument_list|,
name|prepared
argument_list|)
expr_stmt|;
comment|// rework error handling to support fine grained error handling
name|prepared
operator|=
name|createErrorHandler
argument_list|(
name|routeContext
argument_list|,
name|exchange
argument_list|,
name|prepared
argument_list|)
expr_stmt|;
comment|// invoke on prepare on the exchange if specified
if|if
condition|(
name|onPrepare
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|onPrepare
operator|.
name|process
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|exchange
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|DefaultProcessorExchangePair
argument_list|(
name|index
argument_list|,
name|processor
argument_list|,
name|prepared
argument_list|,
name|exchange
argument_list|)
return|;
block|}
DECL|method|createErrorHandler (RouteContext routeContext, Exchange exchange, Processor processor)
specifier|protected
name|Processor
name|createErrorHandler
parameter_list|(
name|RouteContext
name|routeContext
parameter_list|,
name|Exchange
name|exchange
parameter_list|,
name|Processor
name|processor
parameter_list|)
block|{
name|Processor
name|answer
decl_stmt|;
name|boolean
name|tryBlock
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|TRY_ROUTE_BLOCK
argument_list|,
literal|false
argument_list|,
name|boolean
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// do not wrap in error handler if we are inside a try block
if|if
condition|(
operator|!
name|tryBlock
operator|&&
name|routeContext
operator|!=
literal|null
condition|)
block|{
comment|// wrap the producer in error handler so we have fine grained error handling on
comment|// the output side instead of the input side
comment|// this is needed to support redelivery on that output alone and not doing redelivery
comment|// for the entire multicast block again which will start from scratch again
comment|// create key for cache
specifier|final
name|PreparedErrorHandler
name|key
init|=
operator|new
name|PreparedErrorHandler
argument_list|(
name|routeContext
argument_list|,
name|processor
argument_list|)
decl_stmt|;
comment|// lookup cached first to reuse and preserve memory
name|answer
operator|=
name|errorHandlers
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Using existing error handler for: {}"
argument_list|,
name|processor
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
name|log
operator|.
name|trace
argument_list|(
literal|"Creating error handler for: {}"
argument_list|,
name|processor
argument_list|)
expr_stmt|;
name|RouteDefinition
name|route
init|=
operator|(
name|RouteDefinition
operator|)
name|routeContext
operator|.
name|getRoute
argument_list|()
decl_stmt|;
name|ErrorHandlerFactory
name|builder
init|=
name|route
operator|.
name|getErrorHandlerBuilder
argument_list|()
decl_stmt|;
comment|// create error handler (create error handler directly to keep it light weight,
comment|// instead of using ProcessorDefinition.wrapInErrorHandler)
try|try
block|{
name|processor
operator|=
name|builder
operator|.
name|createErrorHandler
argument_list|(
name|routeContext
argument_list|,
name|processor
argument_list|)
expr_stmt|;
comment|// and wrap in unit of work processor so the copy exchange also can run under UoW
name|answer
operator|=
name|createUnitOfWorkProcessor
argument_list|(
name|routeContext
argument_list|,
name|processor
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
name|boolean
name|child
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|PARENT_UNIT_OF_WORK
argument_list|,
name|UnitOfWork
operator|.
name|class
argument_list|)
operator|!=
literal|null
decl_stmt|;
comment|// must start the error handler
name|ServiceHelper
operator|.
name|startService
argument_list|(
name|answer
argument_list|)
expr_stmt|;
comment|// here we don't cache the child unit of work
if|if
condition|(
operator|!
name|child
condition|)
block|{
comment|// add to cache
name|errorHandlers
operator|.
name|putIfAbsent
argument_list|(
name|key
argument_list|,
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|RuntimeCamelException
operator|.
name|wrapRuntimeCamelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// and wrap in unit of work processor so the copy exchange also can run under UoW
name|answer
operator|=
name|createUnitOfWorkProcessor
argument_list|(
name|routeContext
argument_list|,
name|processor
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Strategy to create the unit of work to be used for the sub route      *      * @param routeContext the route context      * @param processor    the processor      * @param exchange     the exchange      * @return the unit of work processor      */
DECL|method|createUnitOfWorkProcessor (RouteContext routeContext, Processor processor, Exchange exchange)
specifier|protected
name|Processor
name|createUnitOfWorkProcessor
parameter_list|(
name|RouteContext
name|routeContext
parameter_list|,
name|Processor
name|processor
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
name|CamelInternalProcessor
name|internal
init|=
operator|new
name|CamelInternalProcessor
argument_list|(
name|processor
argument_list|)
decl_stmt|;
comment|// and wrap it in a unit of work so the UoW is on the top, so the entire route will be in the same UoW
name|UnitOfWork
name|parent
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|PARENT_UNIT_OF_WORK
argument_list|,
name|UnitOfWork
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|internal
operator|.
name|addAdvice
argument_list|(
operator|new
name|CamelInternalProcessor
operator|.
name|ChildUnitOfWorkProcessorAdvice
argument_list|(
name|routeContext
argument_list|,
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|internal
operator|.
name|addAdvice
argument_list|(
operator|new
name|CamelInternalProcessor
operator|.
name|UnitOfWorkProcessorAdvice
argument_list|(
name|routeContext
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|internal
return|;
block|}
comment|/**      * Prepares the exchange for participating in a shared unit of work      *<p/>      * This ensures a child exchange can access its parent {@link UnitOfWork} when it participate      * in a shared unit of work.      *      * @param childExchange  the child exchange      * @param parentExchange the parent exchange      */
DECL|method|prepareSharedUnitOfWork (Exchange childExchange, Exchange parentExchange)
specifier|protected
name|void
name|prepareSharedUnitOfWork
parameter_list|(
name|Exchange
name|childExchange
parameter_list|,
name|Exchange
name|parentExchange
parameter_list|)
block|{
name|childExchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|PARENT_UNIT_OF_WORK
argument_list|,
name|parentExchange
operator|.
name|getUnitOfWork
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|doStart ()
specifier|protected
name|void
name|doStart
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|isParallelProcessing
argument_list|()
operator|&&
name|executorService
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"ParallelProcessing is enabled but ExecutorService has not been set"
argument_list|)
throw|;
block|}
if|if
condition|(
name|aggregateExecutorService
operator|==
literal|null
condition|)
block|{
comment|// use unbounded thread pool so we ensure the aggregate on-the-fly task always will have assigned a thread
comment|// and run the tasks when the task is submitted. If not then the aggregate task may not be able to run
comment|// and signal completion during processing, which would lead to what would appear as a dead-lock or a slow processing
name|String
name|name
init|=
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"-AggregateTask"
decl_stmt|;
name|aggregateExecutorService
operator|=
name|createAggregateExecutorService
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aggregationStrategy
operator|instanceof
name|CamelContextAware
condition|)
block|{
operator|(
operator|(
name|CamelContextAware
operator|)
name|aggregationStrategy
operator|)
operator|.
name|setCamelContext
argument_list|(
name|camelContext
argument_list|)
expr_stmt|;
block|}
name|ServiceHelper
operator|.
name|startService
argument_list|(
name|aggregationStrategy
argument_list|,
name|processors
argument_list|)
expr_stmt|;
block|}
comment|/**      * Strategy to create the thread pool for the aggregator background task which waits for and aggregates      * completed tasks when running in parallel mode.      *      * @param name  the suggested name for the background thread      * @return the thread pool      */
DECL|method|createAggregateExecutorService (String name)
specifier|protected
specifier|synchronized
name|ExecutorService
name|createAggregateExecutorService
parameter_list|(
name|String
name|name
parameter_list|)
block|{
comment|// use a cached thread pool so we each on-the-fly task has a dedicated thread to process completions as they come in
return|return
name|camelContext
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|newScheduledThreadPool
argument_list|(
name|this
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|doStop ()
specifier|protected
name|void
name|doStop
parameter_list|()
throws|throws
name|Exception
block|{
name|ServiceHelper
operator|.
name|stopService
argument_list|(
name|processors
argument_list|,
name|errorHandlers
argument_list|,
name|aggregationStrategy
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doShutdown ()
specifier|protected
name|void
name|doShutdown
parameter_list|()
throws|throws
name|Exception
block|{
name|ServiceHelper
operator|.
name|stopAndShutdownServices
argument_list|(
name|processors
argument_list|,
name|errorHandlers
argument_list|,
name|aggregationStrategy
argument_list|)
expr_stmt|;
comment|// only clear error handlers when shutting down
name|errorHandlers
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|shutdownExecutorService
operator|&&
name|executorService
operator|!=
literal|null
condition|)
block|{
name|getCamelContext
argument_list|()
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|shutdownNow
argument_list|(
name|executorService
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aggregateExecutorService
operator|!=
literal|null
condition|)
block|{
name|getCamelContext
argument_list|()
operator|.
name|getExecutorServiceManager
argument_list|()
operator|.
name|shutdownNow
argument_list|(
name|aggregateExecutorService
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|setToEndpoint (Exchange exchange, Processor processor)
specifier|protected
specifier|static
name|void
name|setToEndpoint
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Processor
name|processor
parameter_list|)
block|{
if|if
condition|(
name|processor
operator|instanceof
name|Producer
condition|)
block|{
name|Producer
name|producer
init|=
operator|(
name|Producer
operator|)
name|processor
decl_stmt|;
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|TO_ENDPOINT
argument_list|,
name|producer
operator|.
name|getEndpoint
argument_list|()
operator|.
name|getEndpointUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getAggregationStrategy (Exchange exchange)
specifier|protected
name|AggregationStrategy
name|getAggregationStrategy
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|AggregationStrategy
name|answer
init|=
literal|null
decl_stmt|;
comment|// prefer to use per Exchange aggregation strategy over a global strategy
if|if
condition|(
name|exchange
operator|!=
literal|null
condition|)
block|{
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|property
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATION_STRATEGY
argument_list|,
name|Map
operator|.
name|class
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Object
argument_list|,
name|AggregationStrategy
argument_list|>
name|map
init|=
name|CastUtils
operator|.
name|cast
argument_list|(
name|property
argument_list|)
decl_stmt|;
if|if
condition|(
name|map
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|map
operator|.
name|get
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
comment|// fallback to global strategy
name|answer
operator|=
name|getAggregationStrategy
argument_list|()
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Sets the given {@link AggregationStrategy} on the {@link Exchange}.      *      * @param exchange            the exchange      * @param aggregationStrategy the strategy      */
DECL|method|setAggregationStrategyOnExchange (Exchange exchange, AggregationStrategy aggregationStrategy)
specifier|protected
name|void
name|setAggregationStrategyOnExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|AggregationStrategy
name|aggregationStrategy
parameter_list|)
block|{
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|property
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATION_STRATEGY
argument_list|,
name|Map
operator|.
name|class
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Object
argument_list|,
name|AggregationStrategy
argument_list|>
name|map
init|=
name|CastUtils
operator|.
name|cast
argument_list|(
name|property
argument_list|)
decl_stmt|;
if|if
condition|(
name|map
operator|==
literal|null
condition|)
block|{
name|map
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// it is not safe to use the map directly as the exchange doesn't have the deep copy of it's properties
comment|// we just create a new copy if we need to change the map
name|map
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
comment|// store the strategy using this processor as the key
comment|// (so we can store multiple strategies on the same exchange)
name|map
operator|.
name|put
argument_list|(
name|this
argument_list|,
name|aggregationStrategy
argument_list|)
expr_stmt|;
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATION_STRATEGY
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes the associated {@link AggregationStrategy} from the {@link Exchange}      * which must be done after use.      *      * @param exchange the current exchange      */
DECL|method|removeAggregationStrategyFromExchange (Exchange exchange)
specifier|protected
name|void
name|removeAggregationStrategyFromExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|property
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATION_STRATEGY
argument_list|,
name|Map
operator|.
name|class
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Object
argument_list|,
name|AggregationStrategy
argument_list|>
name|map
init|=
name|CastUtils
operator|.
name|cast
argument_list|(
name|property
argument_list|)
decl_stmt|;
if|if
condition|(
name|map
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// remove the strategy using this processor as the key
name|map
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**      * Is the multicast processor working in streaming mode?      *<p/>      * In streaming mode:      *<ul>      *<li>we use {@link Iterable} to ensure we can send messages as soon as the data becomes available</li>      *<li>for parallel processing, we start aggregating responses as they get send back to the processor;      * this means the {@link AggregationStrategy} has to take care of handling out-of-order arrival of exchanges</li>      *</ul>      */
DECL|method|isStreaming ()
specifier|public
name|boolean
name|isStreaming
parameter_list|()
block|{
return|return
name|streaming
return|;
block|}
comment|/**      * Should the multicast processor stop processing further exchanges in case of an exception occurred?      */
DECL|method|isStopOnException ()
specifier|public
name|boolean
name|isStopOnException
parameter_list|()
block|{
return|return
name|stopOnException
return|;
block|}
comment|/**      * Returns the producers to multicast to      */
DECL|method|getProcessors ()
specifier|public
name|Collection
argument_list|<
name|Processor
argument_list|>
name|getProcessors
parameter_list|()
block|{
return|return
name|processors
return|;
block|}
comment|/**      * An optional timeout in millis when using parallel processing      */
DECL|method|getTimeout ()
specifier|public
name|long
name|getTimeout
parameter_list|()
block|{
return|return
name|timeout
return|;
block|}
comment|/**      * Use {@link #getAggregationStrategy(org.apache.camel.Exchange)} instead.      */
DECL|method|getAggregationStrategy ()
specifier|public
name|AggregationStrategy
name|getAggregationStrategy
parameter_list|()
block|{
return|return
name|aggregationStrategy
return|;
block|}
DECL|method|isParallelProcessing ()
specifier|public
name|boolean
name|isParallelProcessing
parameter_list|()
block|{
return|return
name|parallelProcessing
return|;
block|}
DECL|method|isParallelAggregate ()
specifier|public
name|boolean
name|isParallelAggregate
parameter_list|()
block|{
return|return
name|parallelAggregate
return|;
block|}
DECL|method|isStopOnAggregateException ()
specifier|public
name|boolean
name|isStopOnAggregateException
parameter_list|()
block|{
return|return
name|stopOnAggregateException
return|;
block|}
DECL|method|isShareUnitOfWork ()
specifier|public
name|boolean
name|isShareUnitOfWork
parameter_list|()
block|{
return|return
name|shareUnitOfWork
return|;
block|}
DECL|method|next ()
specifier|public
name|List
argument_list|<
name|Processor
argument_list|>
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|processors
argument_list|)
return|;
block|}
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|processors
operator|!=
literal|null
operator|&&
operator|!
name|processors
operator|.
name|isEmpty
argument_list|()
return|;
block|}
block|}
end_class

end_unit

