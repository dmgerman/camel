begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.model
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|model
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|namespace
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|NamedNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|ExecutorServiceManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|RouteContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|CamelContextHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|IntrospectionSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ObjectHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|StringHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Helper class for ProcessorDefinition and the other model classes.  */
end_comment

begin_class
DECL|class|ProcessorDefinitionHelper
specifier|public
specifier|final
class|class
name|ProcessorDefinitionHelper
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ProcessorDefinitionHelper
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|CURRENT_RESTORE_ACTION
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|RestoreAction
argument_list|>
name|CURRENT_RESTORE_ACTION
init|=
operator|new
name|ThreadLocal
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|ProcessorDefinitionHelper ()
specifier|private
name|ProcessorDefinitionHelper
parameter_list|()
block|{     }
comment|/**      * Looks for the given type in the list of outputs and recurring all the children as well.      *      * @param outputs list of outputs, can be null or empty.      * @param type    the type to look for      * @return the found definitions, or<tt>null</tt> if not found      */
DECL|method|filterTypeInOutputs (List<ProcessorDefinition<?>> outputs, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|filterTypeInOutputs
parameter_list|(
name|List
argument_list|<
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
argument_list|>
name|outputs
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
return|return
name|filterTypeInOutputs
argument_list|(
name|outputs
argument_list|,
name|type
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**      * Looks for the given type in the list of outputs and recurring all the children as well.      *      * @param outputs list of outputs, can be null or empty.      * @param type    the type to look for      * @param maxDeep maximum levels deep to traverse      * @return the found definitions, or<tt>null</tt> if not found      */
DECL|method|filterTypeInOutputs (List<ProcessorDefinition<?>> outputs, Class<T> type, int maxDeep)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|filterTypeInOutputs
parameter_list|(
name|List
argument_list|<
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
argument_list|>
name|outputs
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|int
name|maxDeep
parameter_list|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|found
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|doFindType
argument_list|(
name|outputs
argument_list|,
name|type
argument_list|,
name|found
argument_list|,
name|maxDeep
argument_list|)
expr_stmt|;
return|return
name|found
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|/**      * Looks for the given type in the list of outputs and recurring all the children as well.      * Will stop at first found and return it.      *      * @param outputs list of outputs, can be null or empty.      * @param type    the type to look for      * @return the first found type, or<tt>null</tt> if not found      */
DECL|method|findFirstTypeInOutputs (List<ProcessorDefinition<?>> outputs, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|findFirstTypeInOutputs
parameter_list|(
name|List
argument_list|<
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
argument_list|>
name|outputs
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|found
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|doFindType
argument_list|(
name|outputs
argument_list|,
name|type
argument_list|,
name|found
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|found
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
return|;
block|}
comment|/**      * Is the given child the first in the outputs from the parent?      *      * @param parentType the type the parent must be      * @param node       the node      * @return<tt>true</tt> if first child,<tt>false</tt> otherwise      */
DECL|method|isFirstChildOfType (Class<?> parentType, ProcessorDefinition<?> node)
specifier|public
specifier|static
name|boolean
name|isFirstChildOfType
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|parentType
parameter_list|,
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
operator|||
name|node
operator|.
name|getParent
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|node
operator|.
name|getParent
argument_list|()
operator|.
name|getOutputs
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|node
operator|.
name|getParent
argument_list|()
operator|.
name|getClass
argument_list|()
operator|.
name|equals
argument_list|(
name|parentType
argument_list|)
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|node
operator|.
name|getParent
argument_list|()
operator|.
name|getOutputs
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|equals
argument_list|(
name|node
argument_list|)
return|;
block|}
comment|/**      * Is the given node parent(s) of the given type      *      * @param parentType the parent type      * @param node       the current node      * @param recursive  whether or not to check grand parent(s) as well      * @return<tt>true</tt> if parent(s) is of given type,<tt>false</tt> otherwise      */
DECL|method|isParentOfType (Class<?> parentType, ProcessorDefinition<?> node, boolean recursive)
specifier|public
specifier|static
name|boolean
name|isParentOfType
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|parentType
parameter_list|,
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|node
parameter_list|,
name|boolean
name|recursive
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
operator|||
name|node
operator|.
name|getParent
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|parentType
operator|.
name|isAssignableFrom
argument_list|(
name|node
operator|.
name|getParent
argument_list|()
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|recursive
condition|)
block|{
comment|// recursive up the tree of parents
return|return
name|isParentOfType
argument_list|(
name|parentType
argument_list|,
name|node
operator|.
name|getParent
argument_list|()
argument_list|,
literal|true
argument_list|)
return|;
block|}
else|else
block|{
comment|// no match
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Gets the route definition the given node belongs to.      *      * @param node the node      * @return the route, or<tt>null</tt> if not possible to find      */
DECL|method|getRoute (NamedNode node)
specifier|public
specifier|static
name|RouteDefinition
name|getRoute
parameter_list|(
name|NamedNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|def
init|=
operator|(
name|ProcessorDefinition
operator|)
name|node
decl_stmt|;
comment|// drill to the top
while|while
condition|(
name|def
operator|!=
literal|null
operator|&&
name|def
operator|.
name|getParent
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|def
operator|=
name|def
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|def
operator|instanceof
name|RouteDefinition
condition|)
block|{
return|return
operator|(
name|RouteDefinition
operator|)
name|def
return|;
block|}
else|else
block|{
comment|// not found
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Gets the route id the given node belongs to.      *      * @param node the node      * @return the route id, or<tt>null</tt> if not possible to find      */
DECL|method|getRouteId (NamedNode node)
specifier|public
specifier|static
name|String
name|getRouteId
parameter_list|(
name|NamedNode
name|node
parameter_list|)
block|{
name|RouteDefinition
name|route
init|=
name|getRoute
argument_list|(
name|node
argument_list|)
decl_stmt|;
return|return
name|route
operator|!=
literal|null
condition|?
name|route
operator|.
name|getId
argument_list|()
else|:
literal|null
return|;
block|}
comment|/**      * Traverses the node, including its children (recursive), and gathers all the node ids.      *      * @param node            the target node      * @param set             set to store ids, if<tt>null</tt> a new set will be created      * @param onlyCustomId    whether to only store custom assigned ids (ie. {@link org.apache.camel.model.OptionalIdentifiedDefinition#hasCustomIdAssigned()}      * @param includeAbstract whether to include abstract nodes (ie. {@link org.apache.camel.model.ProcessorDefinition#isAbstract()}      * @return the set with the found ids.      */
DECL|method|gatherAllNodeIds (ProcessorDefinition<?> node, Set<String> set, boolean onlyCustomId, boolean includeAbstract)
specifier|public
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|gatherAllNodeIds
parameter_list|(
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|node
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|set
parameter_list|,
name|boolean
name|onlyCustomId
parameter_list|,
name|boolean
name|includeAbstract
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return
name|set
return|;
block|}
comment|// skip abstract
if|if
condition|(
name|node
operator|.
name|isAbstract
argument_list|()
operator|&&
operator|!
name|includeAbstract
condition|)
block|{
return|return
name|set
return|;
block|}
if|if
condition|(
name|set
operator|==
literal|null
condition|)
block|{
name|set
operator|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
expr_stmt|;
block|}
comment|// add ourselves
if|if
condition|(
name|node
operator|.
name|getId
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|onlyCustomId
operator|||
name|node
operator|.
name|hasCustomIdAssigned
argument_list|()
operator|&&
name|onlyCustomId
condition|)
block|{
name|set
operator|.
name|add
argument_list|(
name|node
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// traverse outputs and recursive children as well
name|List
argument_list|<
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
argument_list|>
name|children
init|=
name|node
operator|.
name|getOutputs
argument_list|()
decl_stmt|;
if|if
condition|(
name|children
operator|!=
literal|null
operator|&&
operator|!
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|child
range|:
name|children
control|)
block|{
comment|// traverse children also
name|gatherAllNodeIds
argument_list|(
name|child
argument_list|,
name|set
argument_list|,
name|onlyCustomId
argument_list|,
name|includeAbstract
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|set
return|;
block|}
DECL|method|doFindType (List<ProcessorDefinition<?>> outputs, Class<T> type, List<T> found, int maxDeep)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|void
name|doFindType
parameter_list|(
name|List
argument_list|<
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
argument_list|>
name|outputs
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|List
argument_list|<
name|T
argument_list|>
name|found
parameter_list|,
name|int
name|maxDeep
parameter_list|)
block|{
comment|// do we have any top level abstracts, then we should max deep one more level down
comment|// as that is really what we want to traverse as well
if|if
condition|(
name|maxDeep
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
name|out
range|:
name|outputs
control|)
block|{
if|if
condition|(
name|out
operator|.
name|isAbstract
argument_list|()
operator|&&
name|out
operator|.
name|isTopLevelOnly
argument_list|()
condition|)
block|{
name|maxDeep
operator|=
name|maxDeep
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|// start from level 1
name|doFindType
argument_list|(
name|outputs
argument_list|,
name|type
argument_list|,
name|found
argument_list|,
literal|1
argument_list|,
name|maxDeep
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|,
literal|"rawtypes"
block|}
argument_list|)
DECL|method|doFindType (List<ProcessorDefinition<?>> outputs, Class<T> type, List<T> found, int current, int maxDeep)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|void
name|doFindType
parameter_list|(
name|List
argument_list|<
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
argument_list|>
name|outputs
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|List
argument_list|<
name|T
argument_list|>
name|found
parameter_list|,
name|int
name|current
parameter_list|,
name|int
name|maxDeep
parameter_list|)
block|{
if|if
condition|(
name|outputs
operator|==
literal|null
operator|||
name|outputs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// break out
if|if
condition|(
name|maxDeep
operator|>
literal|0
operator|&&
name|current
operator|>
name|maxDeep
condition|)
block|{
return|return;
block|}
for|for
control|(
name|ProcessorDefinition
name|out
range|:
name|outputs
control|)
block|{
comment|// send is much common
if|if
condition|(
name|out
operator|instanceof
name|SendDefinition
condition|)
block|{
name|SendDefinition
name|send
init|=
operator|(
name|SendDefinition
operator|)
name|out
decl_stmt|;
name|List
argument_list|<
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
argument_list|>
name|children
init|=
name|send
operator|.
name|getOutputs
argument_list|()
decl_stmt|;
name|doFindType
argument_list|(
name|children
argument_list|,
name|type
argument_list|,
name|found
argument_list|,
operator|++
name|current
argument_list|,
name|maxDeep
argument_list|)
expr_stmt|;
block|}
comment|// special for choice
if|if
condition|(
name|out
operator|instanceof
name|ChoiceDefinition
condition|)
block|{
name|ChoiceDefinition
name|choice
init|=
operator|(
name|ChoiceDefinition
operator|)
name|out
decl_stmt|;
comment|// ensure to add ourself if we match also
if|if
condition|(
name|type
operator|.
name|isInstance
argument_list|(
name|choice
argument_list|)
condition|)
block|{
name|found
operator|.
name|add
argument_list|(
operator|(
name|T
operator|)
name|choice
argument_list|)
expr_stmt|;
block|}
comment|// only look at when/otherwise if current< maxDeep (or max deep is disabled)
if|if
condition|(
name|maxDeep
operator|<
literal|0
operator|||
name|current
operator|<
name|maxDeep
condition|)
block|{
for|for
control|(
name|WhenDefinition
name|when
range|:
name|choice
operator|.
name|getWhenClauses
argument_list|()
control|)
block|{
if|if
condition|(
name|type
operator|.
name|isInstance
argument_list|(
name|when
argument_list|)
condition|)
block|{
name|found
operator|.
name|add
argument_list|(
operator|(
name|T
operator|)
name|when
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
argument_list|>
name|children
init|=
name|when
operator|.
name|getOutputs
argument_list|()
decl_stmt|;
name|doFindType
argument_list|(
name|children
argument_list|,
name|type
argument_list|,
name|found
argument_list|,
operator|++
name|current
argument_list|,
name|maxDeep
argument_list|)
expr_stmt|;
block|}
comment|// otherwise is optional
if|if
condition|(
name|choice
operator|.
name|getOtherwise
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
argument_list|>
name|children
init|=
name|choice
operator|.
name|getOtherwise
argument_list|()
operator|.
name|getOutputs
argument_list|()
decl_stmt|;
name|doFindType
argument_list|(
name|children
argument_list|,
name|type
argument_list|,
name|found
argument_list|,
operator|++
name|current
argument_list|,
name|maxDeep
argument_list|)
expr_stmt|;
block|}
block|}
comment|// do not check children as we already did that
continue|continue;
block|}
comment|// special for try ... catch ... finally
if|if
condition|(
name|out
operator|instanceof
name|TryDefinition
condition|)
block|{
name|TryDefinition
name|doTry
init|=
operator|(
name|TryDefinition
operator|)
name|out
decl_stmt|;
comment|// ensure to add ourself if we match also
if|if
condition|(
name|type
operator|.
name|isInstance
argument_list|(
name|doTry
argument_list|)
condition|)
block|{
name|found
operator|.
name|add
argument_list|(
operator|(
name|T
operator|)
name|doTry
argument_list|)
expr_stmt|;
block|}
comment|// only look at children if current< maxDeep (or max deep is disabled)
if|if
condition|(
name|maxDeep
operator|<
literal|0
operator|||
name|current
operator|<
name|maxDeep
condition|)
block|{
name|List
argument_list|<
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
argument_list|>
name|doTryOut
init|=
name|doTry
operator|.
name|getOutputsWithoutCatches
argument_list|()
decl_stmt|;
name|doFindType
argument_list|(
name|doTryOut
argument_list|,
name|type
argument_list|,
name|found
argument_list|,
operator|++
name|current
argument_list|,
name|maxDeep
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|CatchDefinition
argument_list|>
name|doTryCatch
init|=
name|doTry
operator|.
name|getCatchClauses
argument_list|()
decl_stmt|;
for|for
control|(
name|CatchDefinition
name|doCatch
range|:
name|doTryCatch
control|)
block|{
name|doFindType
argument_list|(
name|doCatch
operator|.
name|getOutputs
argument_list|()
argument_list|,
name|type
argument_list|,
name|found
argument_list|,
operator|++
name|current
argument_list|,
name|maxDeep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doTry
operator|.
name|getFinallyClause
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|doFindType
argument_list|(
name|doTry
operator|.
name|getFinallyClause
argument_list|()
operator|.
name|getOutputs
argument_list|()
argument_list|,
name|type
argument_list|,
name|found
argument_list|,
operator|++
name|current
argument_list|,
name|maxDeep
argument_list|)
expr_stmt|;
block|}
block|}
comment|// do not check children as we already did that
continue|continue;
block|}
comment|// special for some types which has special outputs
if|if
condition|(
name|out
operator|instanceof
name|OutputDefinition
condition|)
block|{
name|OutputDefinition
name|outDef
init|=
operator|(
name|OutputDefinition
operator|)
name|out
decl_stmt|;
comment|// ensure to add ourself if we match also
if|if
condition|(
name|type
operator|.
name|isInstance
argument_list|(
name|outDef
argument_list|)
condition|)
block|{
name|found
operator|.
name|add
argument_list|(
operator|(
name|T
operator|)
name|outDef
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
argument_list|>
name|outDefOut
init|=
name|outDef
operator|.
name|getOutputs
argument_list|()
decl_stmt|;
name|doFindType
argument_list|(
name|outDefOut
argument_list|,
name|type
argument_list|,
name|found
argument_list|,
operator|++
name|current
argument_list|,
name|maxDeep
argument_list|)
expr_stmt|;
comment|// do not check children as we already did that
continue|continue;
block|}
if|if
condition|(
name|type
operator|.
name|isInstance
argument_list|(
name|out
argument_list|)
condition|)
block|{
name|found
operator|.
name|add
argument_list|(
operator|(
name|T
operator|)
name|out
argument_list|)
expr_stmt|;
block|}
comment|// try children as well
name|List
argument_list|<
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
argument_list|>
name|children
init|=
name|out
operator|.
name|getOutputs
argument_list|()
decl_stmt|;
name|doFindType
argument_list|(
name|children
argument_list|,
name|type
argument_list|,
name|found
argument_list|,
operator|++
name|current
argument_list|,
name|maxDeep
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Is there any outputs in the given list.      *<p/>      * Is used for check if the route output has any real outputs (non abstracts)      *      * @param outputs         the outputs      * @param excludeAbstract whether or not to exclude abstract outputs (e.g. skip onException etc.)      * @return<tt>true</tt> if has outputs, otherwise<tt>false</tt> is returned      */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|,
literal|"rawtypes"
block|}
argument_list|)
DECL|method|hasOutputs (List<ProcessorDefinition<?>> outputs, boolean excludeAbstract)
specifier|public
specifier|static
name|boolean
name|hasOutputs
parameter_list|(
name|List
argument_list|<
name|ProcessorDefinition
argument_list|<
name|?
argument_list|>
argument_list|>
name|outputs
parameter_list|,
name|boolean
name|excludeAbstract
parameter_list|)
block|{
if|if
condition|(
name|outputs
operator|==
literal|null
operator|||
name|outputs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|excludeAbstract
condition|)
block|{
return|return
operator|!
name|outputs
operator|.
name|isEmpty
argument_list|()
return|;
block|}
for|for
control|(
name|ProcessorDefinition
name|output
range|:
name|outputs
control|)
block|{
if|if
condition|(
name|output
operator|.
name|isWrappingEntireOutput
argument_list|()
condition|)
block|{
comment|// special for those as they wrap entire output, so we should just check its output
return|return
name|hasOutputs
argument_list|(
name|output
operator|.
name|getOutputs
argument_list|()
argument_list|,
name|excludeAbstract
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|output
operator|.
name|isAbstract
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Determines whether a new thread pool will be created or not.      *<p/>      * This is used to know if a new thread pool will be created, and therefore is not shared by others, and therefore      * exclusive to the definition.      *      * @param routeContext the route context      * @param definition   the node definition which may leverage executor service.      * @param useDefault   whether to fallback and use a default thread pool, if no explicit configured      * @return<tt>true</tt> if a new thread pool will be created,<tt>false</tt> if not      * @see #getConfiguredExecutorService(org.apache.camel.spi.RouteContext, String, ExecutorServiceAwareDefinition, boolean)      */
DECL|method|willCreateNewThreadPool (RouteContext routeContext, ExecutorServiceAwareDefinition<?> definition, boolean useDefault)
specifier|public
specifier|static
name|boolean
name|willCreateNewThreadPool
parameter_list|(
name|RouteContext
name|routeContext
parameter_list|,
name|ExecutorServiceAwareDefinition
argument_list|<
name|?
argument_list|>
name|definition
parameter_list|,
name|boolean
name|useDefault
parameter_list|)
block|{
name|ExecutorServiceManager
name|manager
init|=
name|routeContext
operator|.
name|getCamelContext
argument_list|()
operator|.
name|getExecutorServiceManager
argument_list|()
decl_stmt|;
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|manager
argument_list|,
literal|"ExecutorServiceManager"
argument_list|,
name|routeContext
operator|.
name|getCamelContext
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|definition
operator|.
name|getExecutorService
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// no there is a custom thread pool configured
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|definition
operator|.
name|getExecutorServiceRef
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|ExecutorService
name|answer
init|=
name|routeContext
operator|.
name|getCamelContext
argument_list|()
operator|.
name|getRegistry
argument_list|()
operator|.
name|lookupByNameAndType
argument_list|(
name|definition
operator|.
name|getExecutorServiceRef
argument_list|()
argument_list|,
name|ExecutorService
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// if no existing thread pool, then we will have to create a new thread pool
return|return
name|answer
operator|==
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|useDefault
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Will lookup in {@link org.apache.camel.spi.Registry} for a {@link ExecutorService} registered with the given      *<tt>executorServiceRef</tt> name.      *<p/>      * This method will lookup for configured thread pool in the following order      *<ul>      *<li>from the {@link org.apache.camel.spi.Registry} if found</li>      *<li>from the known list of {@link org.apache.camel.spi.ThreadPoolProfile ThreadPoolProfile(s)}.</li>      *<li>if none found, then<tt>null</tt> is returned.</li>      *</ul>      *      * @param routeContext       the route context      * @param name               name which is appended to the thread name, when the {@link java.util.concurrent.ExecutorService}      *                           is created based on a {@link org.apache.camel.spi.ThreadPoolProfile}.      * @param source             the source to use the thread pool      * @param executorServiceRef reference name of the thread pool      * @return the executor service, or<tt>null</tt> if none was found.      */
DECL|method|lookupExecutorServiceRef (RouteContext routeContext, String name, Object source, String executorServiceRef)
specifier|public
specifier|static
name|ExecutorService
name|lookupExecutorServiceRef
parameter_list|(
name|RouteContext
name|routeContext
parameter_list|,
name|String
name|name
parameter_list|,
name|Object
name|source
parameter_list|,
name|String
name|executorServiceRef
parameter_list|)
block|{
name|ExecutorServiceManager
name|manager
init|=
name|routeContext
operator|.
name|getCamelContext
argument_list|()
operator|.
name|getExecutorServiceManager
argument_list|()
decl_stmt|;
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|manager
argument_list|,
literal|"ExecutorServiceManager"
argument_list|,
name|routeContext
operator|.
name|getCamelContext
argument_list|()
argument_list|)
expr_stmt|;
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|executorServiceRef
argument_list|,
literal|"executorServiceRef"
argument_list|)
expr_stmt|;
comment|// lookup in registry first and use existing thread pool if exists
name|ExecutorService
name|answer
init|=
name|routeContext
operator|.
name|getCamelContext
argument_list|()
operator|.
name|getRegistry
argument_list|()
operator|.
name|lookupByNameAndType
argument_list|(
name|executorServiceRef
argument_list|,
name|ExecutorService
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
comment|// then create a thread pool assuming the ref is a thread pool profile id
name|answer
operator|=
name|manager
operator|.
name|newThreadPool
argument_list|(
name|source
argument_list|,
name|name
argument_list|,
name|executorServiceRef
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Will lookup and get the configured {@link java.util.concurrent.ExecutorService} from the given definition.      *<p/>      * This method will lookup for configured thread pool in the following order      *<ul>      *<li>from the definition if any explicit configured executor service.</li>      *<li>from the {@link org.apache.camel.spi.Registry} if found</li>      *<li>from the known list of {@link org.apache.camel.spi.ThreadPoolProfile ThreadPoolProfile(s)}.</li>      *<li>if none found, then<tt>null</tt> is returned.</li>      *</ul>      * The various {@link ExecutorServiceAwareDefinition} should use this helper method to ensure they support      * configured executor services in the same coherent way.      *      * @param routeContext the route context      * @param name         name which is appended to the thread name, when the {@link java.util.concurrent.ExecutorService}      *                     is created based on a {@link org.apache.camel.spi.ThreadPoolProfile}.      * @param definition   the node definition which may leverage executor service.      * @param useDefault   whether to fallback and use a default thread pool, if no explicit configured      * @return the configured executor service, or<tt>null</tt> if none was configured.      * @throws IllegalArgumentException is thrown if lookup of executor service in {@link org.apache.camel.spi.Registry} was not found      */
DECL|method|getConfiguredExecutorService (RouteContext routeContext, String name, ExecutorServiceAwareDefinition<?> definition, boolean useDefault)
specifier|public
specifier|static
name|ExecutorService
name|getConfiguredExecutorService
parameter_list|(
name|RouteContext
name|routeContext
parameter_list|,
name|String
name|name
parameter_list|,
name|ExecutorServiceAwareDefinition
argument_list|<
name|?
argument_list|>
name|definition
parameter_list|,
name|boolean
name|useDefault
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|ExecutorServiceManager
name|manager
init|=
name|routeContext
operator|.
name|getCamelContext
argument_list|()
operator|.
name|getExecutorServiceManager
argument_list|()
decl_stmt|;
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|manager
argument_list|,
literal|"ExecutorServiceManager"
argument_list|,
name|routeContext
operator|.
name|getCamelContext
argument_list|()
argument_list|)
expr_stmt|;
comment|// prefer to use explicit configured executor on the definition
if|if
condition|(
name|definition
operator|.
name|getExecutorService
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|definition
operator|.
name|getExecutorService
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|definition
operator|.
name|getExecutorServiceRef
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// lookup in registry first and use existing thread pool if exists
name|ExecutorService
name|answer
init|=
name|lookupExecutorServiceRef
argument_list|(
name|routeContext
argument_list|,
name|name
argument_list|,
name|definition
argument_list|,
name|definition
operator|.
name|getExecutorServiceRef
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"ExecutorServiceRef "
operator|+
name|definition
operator|.
name|getExecutorServiceRef
argument_list|()
operator|+
literal|" not found in registry (as an ExecutorService instance) or as a thread pool profile."
argument_list|)
throw|;
block|}
return|return
name|answer
return|;
block|}
elseif|else
if|if
condition|(
name|useDefault
condition|)
block|{
return|return
name|manager
operator|.
name|newDefaultThreadPool
argument_list|(
name|definition
argument_list|,
name|name
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Will lookup in {@link org.apache.camel.spi.Registry} for a {@link ScheduledExecutorService} registered with the given      *<tt>executorServiceRef</tt> name.      *<p/>      * This method will lookup for configured thread pool in the following order      *<ul>      *<li>from the {@link org.apache.camel.spi.Registry} if found</li>      *<li>from the known list of {@link org.apache.camel.spi.ThreadPoolProfile ThreadPoolProfile(s)}.</li>      *<li>if none found, then<tt>null</tt> is returned.</li>      *</ul>      *      * @param routeContext       the route context      * @param name               name which is appended to the thread name, when the {@link java.util.concurrent.ExecutorService}      *                           is created based on a {@link org.apache.camel.spi.ThreadPoolProfile}.      * @param source             the source to use the thread pool      * @param executorServiceRef reference name of the thread pool      * @return the executor service, or<tt>null</tt> if none was found.      */
DECL|method|lookupScheduledExecutorServiceRef (RouteContext routeContext, String name, Object source, String executorServiceRef)
specifier|public
specifier|static
name|ScheduledExecutorService
name|lookupScheduledExecutorServiceRef
parameter_list|(
name|RouteContext
name|routeContext
parameter_list|,
name|String
name|name
parameter_list|,
name|Object
name|source
parameter_list|,
name|String
name|executorServiceRef
parameter_list|)
block|{
name|ExecutorServiceManager
name|manager
init|=
name|routeContext
operator|.
name|getCamelContext
argument_list|()
operator|.
name|getExecutorServiceManager
argument_list|()
decl_stmt|;
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|manager
argument_list|,
literal|"ExecutorServiceManager"
argument_list|,
name|routeContext
operator|.
name|getCamelContext
argument_list|()
argument_list|)
expr_stmt|;
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|executorServiceRef
argument_list|,
literal|"executorServiceRef"
argument_list|)
expr_stmt|;
comment|// lookup in registry first and use existing thread pool if exists
name|ScheduledExecutorService
name|answer
init|=
name|routeContext
operator|.
name|getCamelContext
argument_list|()
operator|.
name|getRegistry
argument_list|()
operator|.
name|lookupByNameAndType
argument_list|(
name|executorServiceRef
argument_list|,
name|ScheduledExecutorService
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
comment|// then create a thread pool assuming the ref is a thread pool profile id
name|answer
operator|=
name|manager
operator|.
name|newScheduledThreadPool
argument_list|(
name|source
argument_list|,
name|name
argument_list|,
name|executorServiceRef
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Will lookup and get the configured {@link java.util.concurrent.ScheduledExecutorService} from the given definition.      *<p/>      * This method will lookup for configured thread pool in the following order      *<ul>      *<li>from the definition if any explicit configured executor service.</li>      *<li>from the {@link org.apache.camel.spi.Registry} if found</li>      *<li>from the known list of {@link org.apache.camel.spi.ThreadPoolProfile ThreadPoolProfile(s)}.</li>      *<li>if none found, then<tt>null</tt> is returned.</li>      *</ul>      * The various {@link ExecutorServiceAwareDefinition} should use this helper method to ensure they support      * configured executor services in the same coherent way.      *      * @param routeContext the rout context      * @param name         name which is appended to the thread name, when the {@link java.util.concurrent.ExecutorService}      *                     is created based on a {@link org.apache.camel.spi.ThreadPoolProfile}.      * @param definition   the node definition which may leverage executor service.      * @param useDefault   whether to fallback and use a default thread pool, if no explicit configured      * @return the configured executor service, or<tt>null</tt> if none was configured.      * @throws IllegalArgumentException is thrown if the found instance is not a ScheduledExecutorService type,      *                                  or lookup of executor service in {@link org.apache.camel.spi.Registry} was not found      */
DECL|method|getConfiguredScheduledExecutorService (RouteContext routeContext, String name, ExecutorServiceAwareDefinition<?> definition, boolean useDefault)
specifier|public
specifier|static
name|ScheduledExecutorService
name|getConfiguredScheduledExecutorService
parameter_list|(
name|RouteContext
name|routeContext
parameter_list|,
name|String
name|name
parameter_list|,
name|ExecutorServiceAwareDefinition
argument_list|<
name|?
argument_list|>
name|definition
parameter_list|,
name|boolean
name|useDefault
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|ExecutorServiceManager
name|manager
init|=
name|routeContext
operator|.
name|getCamelContext
argument_list|()
operator|.
name|getExecutorServiceManager
argument_list|()
decl_stmt|;
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|manager
argument_list|,
literal|"ExecutorServiceManager"
argument_list|,
name|routeContext
operator|.
name|getCamelContext
argument_list|()
argument_list|)
expr_stmt|;
comment|// prefer to use explicit configured executor on the definition
if|if
condition|(
name|definition
operator|.
name|getExecutorService
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|ExecutorService
name|executorService
init|=
name|definition
operator|.
name|getExecutorService
argument_list|()
decl_stmt|;
if|if
condition|(
name|executorService
operator|instanceof
name|ScheduledExecutorService
condition|)
block|{
return|return
operator|(
name|ScheduledExecutorService
operator|)
name|executorService
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"ExecutorServiceRef "
operator|+
name|definition
operator|.
name|getExecutorServiceRef
argument_list|()
operator|+
literal|" is not an ScheduledExecutorService instance"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|definition
operator|.
name|getExecutorServiceRef
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|ScheduledExecutorService
name|answer
init|=
name|lookupScheduledExecutorServiceRef
argument_list|(
name|routeContext
argument_list|,
name|name
argument_list|,
name|definition
argument_list|,
name|definition
operator|.
name|getExecutorServiceRef
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"ExecutorServiceRef "
operator|+
name|definition
operator|.
name|getExecutorServiceRef
argument_list|()
operator|+
literal|" not found in registry (as an ScheduledExecutorService instance) or as a thread pool profile."
argument_list|)
throw|;
block|}
return|return
name|answer
return|;
block|}
elseif|else
if|if
condition|(
name|useDefault
condition|)
block|{
return|return
name|manager
operator|.
name|newDefaultScheduledThreadPool
argument_list|(
name|definition
argument_list|,
name|name
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * The RestoreAction is used to track all the undo/restore actions      * that need to be performed to undo any resolution to property placeholders      * that have been applied to the camel route defs.  This class is private      * so it does not get used directly.  It's mainly used by the {@see createPropertyPlaceholdersChangeReverter()}      * method.      */
DECL|class|RestoreAction
specifier|private
specifier|static
specifier|final
class|class
name|RestoreAction
implements|implements
name|Runnable
block|{
DECL|field|prevChange
specifier|private
specifier|final
name|RestoreAction
name|prevChange
decl_stmt|;
DECL|field|actions
specifier|private
specifier|final
name|ArrayList
argument_list|<
name|Runnable
argument_list|>
name|actions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|RestoreAction (RestoreAction prevChange)
specifier|private
name|RestoreAction
parameter_list|(
name|RestoreAction
name|prevChange
parameter_list|)
block|{
name|this
operator|.
name|prevChange
operator|=
name|prevChange
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
for|for
control|(
name|Runnable
name|action
range|:
name|actions
control|)
block|{
name|action
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
name|actions
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|prevChange
operator|==
literal|null
condition|)
block|{
name|CURRENT_RESTORE_ACTION
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|CURRENT_RESTORE_ACTION
operator|.
name|set
argument_list|(
name|prevChange
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Creates a Runnable which when run will revert property placeholder      * updates to the camel route definitions that were done after this method      * is called.  The Runnable MUST be executed and MUST be executed in the      * same thread this method is called from.  Therefore it's recommend you      * use it in try/finally block like in the following example:      *<p/>      *<pre>      *   Runnable undo = ProcessorDefinitionHelper.createPropertyPlaceholdersChangeReverter();      *   try {      *       // All property resolutions in this block will be reverted.      *   } finally {      *       undo.run();      *   }      *</pre>      *      * @return a Runnable that when run, will revert any property place holder      * changes that occurred on the current thread .      */
DECL|method|createPropertyPlaceholdersChangeReverter ()
specifier|public
specifier|static
name|Runnable
name|createPropertyPlaceholdersChangeReverter
parameter_list|()
block|{
name|RestoreAction
name|prevChanges
init|=
name|CURRENT_RESTORE_ACTION
operator|.
name|get
argument_list|()
decl_stmt|;
name|RestoreAction
name|rc
init|=
operator|new
name|RestoreAction
argument_list|(
name|prevChanges
argument_list|)
decl_stmt|;
name|CURRENT_RESTORE_ACTION
operator|.
name|set
argument_list|(
name|rc
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
DECL|method|addRestoreAction (final Object target, final Map<String, Object> properties)
specifier|private
specifier|static
name|void
name|addRestoreAction
parameter_list|(
specifier|final
name|Object
name|target
parameter_list|,
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|properties
parameter_list|)
block|{
name|addRestoreAction
argument_list|(
literal|null
argument_list|,
name|target
argument_list|,
name|properties
argument_list|)
expr_stmt|;
block|}
DECL|method|addRestoreAction (final CamelContext context, final Object target, final Map<String, Object> properties)
specifier|private
specifier|static
name|void
name|addRestoreAction
parameter_list|(
specifier|final
name|CamelContext
name|context
parameter_list|,
specifier|final
name|Object
name|target
parameter_list|,
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|properties
parameter_list|)
block|{
if|if
condition|(
name|properties
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|RestoreAction
name|restoreAction
init|=
name|CURRENT_RESTORE_ACTION
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|restoreAction
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|restoreAction
operator|.
name|actions
operator|.
name|add
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|IntrospectionSupport
operator|.
name|setProperties
argument_list|(
name|context
argument_list|,
literal|null
argument_list|,
name|target
argument_list|,
name|properties
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not restore definition properties"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|addPropertyPlaceholdersChangeRevertAction (Runnable action)
specifier|public
specifier|static
name|void
name|addPropertyPlaceholdersChangeRevertAction
parameter_list|(
name|Runnable
name|action
parameter_list|)
block|{
name|RestoreAction
name|restoreAction
init|=
name|CURRENT_RESTORE_ACTION
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|restoreAction
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|restoreAction
operator|.
name|actions
operator|.
name|add
argument_list|(
name|action
argument_list|)
expr_stmt|;
block|}
comment|/**      * Inspects the given definition and resolves any property placeholders from its properties.      *<p/>      * This implementation will check all the getter/setter pairs on this instance and for all the values      * (which is a String type) will be property placeholder resolved. The definition should implement {@link OtherAttributesAware}      *      * @param camelContext the Camel context      * @param definition   the definition which should implement {@link OtherAttributesAware}      * @throws Exception is thrown if property placeholders was used and there was an error resolving them      * @see org.apache.camel.CamelContext#resolvePropertyPlaceholders(String)      * @see org.apache.camel.component.properties.PropertiesComponent      */
DECL|method|resolvePropertyPlaceholders (CamelContext camelContext, Object definition)
specifier|public
specifier|static
name|void
name|resolvePropertyPlaceholders
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|,
name|Object
name|definition
parameter_list|)
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Resolving property placeholders for: {}"
argument_list|,
name|definition
argument_list|)
expr_stmt|;
comment|// find all getter/setter which we can use for property placeholders
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|properties
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|IntrospectionSupport
operator|.
name|getProperties
argument_list|(
name|definition
argument_list|,
name|properties
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|OtherAttributesAware
name|other
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|definition
operator|instanceof
name|OtherAttributesAware
condition|)
block|{
name|other
operator|=
operator|(
name|OtherAttributesAware
operator|)
name|definition
expr_stmt|;
block|}
comment|// include additional properties which have the Camel placeholder QName
comment|// and when the definition parameter is this (otherAttributes belong to this)
if|if
condition|(
name|other
operator|!=
literal|null
operator|&&
name|other
operator|.
name|getOtherAttributes
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|QName
name|key
range|:
name|other
operator|.
name|getOtherAttributes
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|Constants
operator|.
name|PLACEHOLDER_QNAME
operator|.
name|equals
argument_list|(
name|key
operator|.
name|getNamespaceURI
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|local
init|=
name|key
operator|.
name|getLocalPart
argument_list|()
decl_stmt|;
name|Object
name|value
init|=
name|other
operator|.
name|getOtherAttributes
argument_list|()
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
comment|// enforce a properties component to be created if none existed
name|camelContext
operator|.
name|getPropertiesComponent
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// value must be enclosed with placeholder tokens
name|String
name|s
init|=
operator|(
name|String
operator|)
name|value
decl_stmt|;
name|String
name|prefixToken
init|=
name|camelContext
operator|.
name|getPropertyPrefixToken
argument_list|()
decl_stmt|;
name|String
name|suffixToken
init|=
name|camelContext
operator|.
name|getPropertySuffixToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|prefixToken
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Property with name ["
operator|+
name|local
operator|+
literal|"] uses property placeholders; however, no properties component is configured."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|s
operator|.
name|startsWith
argument_list|(
name|prefixToken
argument_list|)
condition|)
block|{
name|s
operator|=
name|prefixToken
operator|+
name|s
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
operator|.
name|endsWith
argument_list|(
name|suffixToken
argument_list|)
condition|)
block|{
name|s
operator|=
name|s
operator|+
name|suffixToken
expr_stmt|;
block|}
name|value
operator|=
name|s
expr_stmt|;
block|}
name|properties
operator|.
name|put
argument_list|(
name|local
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|changedProperties
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|properties
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"There are {} properties on: {}"
argument_list|,
name|properties
operator|.
name|size
argument_list|()
argument_list|,
name|definition
argument_list|)
expr_stmt|;
comment|// lookup and resolve properties for String based properties
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|properties
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// the name is always a String
name|String
name|name
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Object
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
comment|// value must be a String, as a String is the key for a property placeholder
name|String
name|text
init|=
operator|(
name|String
operator|)
name|value
decl_stmt|;
name|text
operator|=
name|camelContext
operator|.
name|resolvePropertyPlaceholders
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|!=
name|value
condition|)
block|{
comment|// invoke setter as the text has changed
name|boolean
name|changed
init|=
name|IntrospectionSupport
operator|.
name|setProperty
argument_list|(
name|camelContext
operator|.
name|getTypeConverter
argument_list|()
argument_list|,
name|definition
argument_list|,
name|name
argument_list|,
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|changed
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No setter to set property: "
operator|+
name|name
operator|+
literal|" to: "
operator|+
name|text
operator|+
literal|" on: "
operator|+
name|definition
argument_list|)
throw|;
block|}
name|changedProperties
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Changed property [{}] from: {} to: {}"
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|addRestoreAction
argument_list|(
name|camelContext
argument_list|,
name|definition
argument_list|,
name|changedProperties
argument_list|)
expr_stmt|;
block|}
comment|/**      * Inspects the given definition and resolves known fields      *<p/>      * This implementation will check all the getter/setter pairs on this instance and for all the values      * (which is a String type) will check if it refers to a known field (such as on Exchange).      *      * @param definition the definition      */
DECL|method|resolveKnownConstantFields (Object definition)
specifier|public
specifier|static
name|void
name|resolveKnownConstantFields
parameter_list|(
name|Object
name|definition
parameter_list|)
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Resolving known fields for: {}"
argument_list|,
name|definition
argument_list|)
expr_stmt|;
comment|// find all String getter/setter
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|properties
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|IntrospectionSupport
operator|.
name|getProperties
argument_list|(
name|definition
argument_list|,
name|properties
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|changedProperties
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|properties
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"There are {} properties on: {}"
argument_list|,
name|properties
operator|.
name|size
argument_list|()
argument_list|,
name|definition
argument_list|)
expr_stmt|;
comment|// lookup and resolve known constant fields for String based properties
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|properties
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Object
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
comment|// we can only resolve String typed values
name|String
name|text
init|=
operator|(
name|String
operator|)
name|value
decl_stmt|;
comment|// is the value a known field (currently we only support constants from Exchange.class)
if|if
condition|(
name|text
operator|.
name|startsWith
argument_list|(
literal|"Exchange."
argument_list|)
condition|)
block|{
name|String
name|field
init|=
name|StringHelper
operator|.
name|after
argument_list|(
name|text
argument_list|,
literal|"Exchange."
argument_list|)
decl_stmt|;
name|String
name|constant
init|=
name|ObjectHelper
operator|.
name|lookupConstantFieldValue
argument_list|(
name|Exchange
operator|.
name|class
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|constant
operator|!=
literal|null
condition|)
block|{
comment|// invoke setter as the text has changed
name|IntrospectionSupport
operator|.
name|setProperty
argument_list|(
name|definition
argument_list|,
name|name
argument_list|,
name|constant
argument_list|)
expr_stmt|;
name|changedProperties
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Changed property [{}] from: {} to: {}"
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|constant
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Constant field with name: "
operator|+
name|field
operator|+
literal|" not found on Exchange.class"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
block|}
name|addRestoreAction
argument_list|(
name|definition
argument_list|,
name|changedProperties
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

