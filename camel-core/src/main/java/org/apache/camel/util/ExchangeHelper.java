begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.util
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelExecutionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Endpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|ExchangePattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|InvalidPayloadException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|NoSuchBeanException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|NoSuchEndpointException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|NoSuchHeaderException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|NoSuchPropertyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|NoTypeConversionAvailableException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|TypeConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|UnitOfWork
import|;
end_import

begin_comment
comment|/**  * Some helper methods for working with {@link Exchange} objects  *  * @version   */
end_comment

begin_class
DECL|class|ExchangeHelper
specifier|public
specifier|final
class|class
name|ExchangeHelper
block|{
comment|/**      * Utility classes should not have a public constructor.      */
DECL|method|ExchangeHelper ()
specifier|private
name|ExchangeHelper
parameter_list|()
block|{     }
comment|/**      * Extracts the Exchange.BINDING of the given type or null if not present      *      * @param exchange the message exchange      * @param type     the expected binding type      * @return the binding object of the given type or null if it could not be found or converted      */
DECL|method|getBinding (Exchange exchange, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getBinding
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
return|return
name|exchange
operator|!=
literal|null
condition|?
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|BINDING
argument_list|,
name|type
argument_list|)
else|:
literal|null
return|;
block|}
comment|/**      * Attempts to resolve the endpoint for the given value      *      * @param exchange the message exchange being processed      * @param value    the value which can be an {@link Endpoint} or an object      *                 which provides a String representation of an endpoint via      *                 {@link #toString()}      * @return the endpoint      * @throws NoSuchEndpointException if the endpoint cannot be resolved      */
DECL|method|resolveEndpoint (Exchange exchange, Object value)
specifier|public
specifier|static
name|Endpoint
name|resolveEndpoint
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|value
parameter_list|)
throws|throws
name|NoSuchEndpointException
block|{
name|Endpoint
name|endpoint
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Endpoint
condition|)
block|{
name|endpoint
operator|=
operator|(
name|Endpoint
operator|)
name|value
expr_stmt|;
block|}
else|else
block|{
name|String
name|uri
init|=
name|value
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
name|endpoint
operator|=
name|CamelContextHelper
operator|.
name|getMandatoryEndpoint
argument_list|(
name|exchange
operator|.
name|getContext
argument_list|()
argument_list|,
name|uri
argument_list|)
expr_stmt|;
block|}
return|return
name|endpoint
return|;
block|}
DECL|method|getMandatoryProperty (Exchange exchange, String propertyName, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getMandatoryProperty
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|propertyName
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
throws|throws
name|NoSuchPropertyException
block|{
name|T
name|result
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|propertyName
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
throw|throw
operator|new
name|NoSuchPropertyException
argument_list|(
name|exchange
argument_list|,
name|propertyName
argument_list|,
name|type
argument_list|)
throw|;
block|}
DECL|method|getMandatoryHeader (Exchange exchange, String propertyName, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getMandatoryHeader
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|propertyName
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
throws|throws
name|NoSuchHeaderException
block|{
name|T
name|answer
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|propertyName
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchHeaderException
argument_list|(
name|exchange
argument_list|,
name|propertyName
argument_list|,
name|type
argument_list|)
throw|;
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Returns the mandatory inbound message body of the correct type or throws      * an exception if it is not present      */
DECL|method|getMandatoryInBody (Exchange exchange)
specifier|public
specifier|static
name|Object
name|getMandatoryInBody
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|InvalidPayloadException
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getMandatoryBody
argument_list|()
return|;
block|}
comment|/**      * Returns the mandatory inbound message body of the correct type or throws      * an exception if it is not present      */
DECL|method|getMandatoryInBody (Exchange exchange, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getMandatoryInBody
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
throws|throws
name|InvalidPayloadException
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getMandatoryBody
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/**      * Returns the mandatory outbound message body of the correct type or throws      * an exception if it is not present      */
DECL|method|getMandatoryOutBody (Exchange exchange)
specifier|public
specifier|static
name|Object
name|getMandatoryOutBody
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|InvalidPayloadException
block|{
return|return
name|exchange
operator|.
name|getOut
argument_list|()
operator|.
name|getMandatoryBody
argument_list|()
return|;
block|}
comment|/**      * Returns the mandatory outbound message body of the correct type or throws      * an exception if it is not present      */
DECL|method|getMandatoryOutBody (Exchange exchange, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getMandatoryOutBody
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
throws|throws
name|InvalidPayloadException
block|{
return|return
name|exchange
operator|.
name|getOut
argument_list|()
operator|.
name|getMandatoryBody
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/**      * Converts the value to the given expected type or throws an exception      */
DECL|method|convertToMandatoryType (Exchange exchange, Class<T> type, Object value)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|convertToMandatoryType
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|Object
name|value
parameter_list|)
throws|throws
name|NoTypeConversionAvailableException
block|{
name|CamelContext
name|camelContext
init|=
name|exchange
operator|.
name|getContext
argument_list|()
decl_stmt|;
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|camelContext
argument_list|,
literal|"CamelContext of Exchange"
argument_list|)
expr_stmt|;
name|TypeConverter
name|converter
init|=
name|camelContext
operator|.
name|getTypeConverter
argument_list|()
decl_stmt|;
if|if
condition|(
name|converter
operator|!=
literal|null
condition|)
block|{
return|return
name|converter
operator|.
name|mandatoryConvertTo
argument_list|(
name|type
argument_list|,
name|exchange
argument_list|,
name|value
argument_list|)
return|;
block|}
throw|throw
operator|new
name|NoTypeConversionAvailableException
argument_list|(
name|value
argument_list|,
name|type
argument_list|)
throw|;
block|}
comment|/**      * Converts the value to the given expected type returning null if it could      * not be converted      */
DECL|method|convertToType (Exchange exchange, Class<T> type, Object value)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|convertToType
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|CamelContext
name|camelContext
init|=
name|exchange
operator|.
name|getContext
argument_list|()
decl_stmt|;
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|camelContext
argument_list|,
literal|"CamelContext of Exchange"
argument_list|)
expr_stmt|;
name|TypeConverter
name|converter
init|=
name|camelContext
operator|.
name|getTypeConverter
argument_list|()
decl_stmt|;
if|if
condition|(
name|converter
operator|!=
literal|null
condition|)
block|{
return|return
name|converter
operator|.
name|convertTo
argument_list|(
name|type
argument_list|,
name|exchange
argument_list|,
name|value
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Creates a new instance and copies from the current message exchange so that it can be      * forwarded to another destination as a new instance. Unlike regular copy this operation      * will not share the same {@link org.apache.camel.spi.UnitOfWork} so its should be used      * for async messaging, where the original and copied exchange are independent.      *      * @param exchange original copy of the exchange      * @param handover whether the on completion callbacks should be handed over to the new copy.      */
DECL|method|createCorrelatedCopy (Exchange exchange, boolean handover)
specifier|public
specifier|static
name|Exchange
name|createCorrelatedCopy
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|boolean
name|handover
parameter_list|)
block|{
name|String
name|id
init|=
name|exchange
operator|.
name|getExchangeId
argument_list|()
decl_stmt|;
name|Exchange
name|copy
init|=
name|exchange
operator|.
name|copy
argument_list|()
decl_stmt|;
comment|// do not share the unit of work
name|copy
operator|.
name|setUnitOfWork
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// hand over on completion to the copy if we got any
name|UnitOfWork
name|uow
init|=
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
decl_stmt|;
if|if
condition|(
name|handover
operator|&&
name|uow
operator|!=
literal|null
condition|)
block|{
name|uow
operator|.
name|handoverSynchronization
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
comment|// set a correlation id so we can track back the original exchange
name|copy
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|CORRELATION_ID
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
comment|/**      * Creates a new instance and copies from the current message exchange so that it can be      * forwarded to another destination as a new instance.      *      * @param exchange original copy of the exchange      * @param preserveExchangeId whether or not the exchange id should be preserved      * @return the copy      */
DECL|method|createCopy (Exchange exchange, boolean preserveExchangeId)
specifier|public
specifier|static
name|Exchange
name|createCopy
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|boolean
name|preserveExchangeId
parameter_list|)
block|{
name|Exchange
name|copy
init|=
name|exchange
operator|.
name|copy
argument_list|()
decl_stmt|;
if|if
condition|(
name|preserveExchangeId
condition|)
block|{
name|copy
operator|.
name|setExchangeId
argument_list|(
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|copy
return|;
block|}
comment|/**      * Copies the results of a message exchange from the source exchange to the result exchange      * which will copy the out and fault message contents and the exception      *      * @param result the result exchange which will have the output and error state added      * @param source the source exchange which is not modified      */
DECL|method|copyResults (Exchange result, Exchange source)
specifier|public
specifier|static
name|void
name|copyResults
parameter_list|(
name|Exchange
name|result
parameter_list|,
name|Exchange
name|source
parameter_list|)
block|{
comment|// --------------------------------------------------------------------
comment|//  TODO: merge logic with that of copyResultsPreservePattern()
comment|// --------------------------------------------------------------------
if|if
condition|(
name|result
operator|!=
name|source
condition|)
block|{
name|result
operator|.
name|setException
argument_list|(
name|source
operator|.
name|getException
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|.
name|hasOut
argument_list|()
condition|)
block|{
name|result
operator|.
name|getOut
argument_list|()
operator|.
name|copyFrom
argument_list|(
name|source
operator|.
name|getOut
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|.
name|getPattern
argument_list|()
operator|==
name|ExchangePattern
operator|.
name|InOptionalOut
condition|)
block|{
comment|// special case where the result is InOptionalOut and with no OUT response
comment|// so we should return null to indicate this fact
name|result
operator|.
name|setOut
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// no results so lets copy the last input
comment|// as the final processor on a pipeline might not
comment|// have created any OUT; such as a mock:endpoint
comment|// so lets assume the last IN is the OUT
if|if
condition|(
name|result
operator|.
name|getPattern
argument_list|()
operator|.
name|isOutCapable
argument_list|()
condition|)
block|{
comment|// only set OUT if its OUT capable
name|result
operator|.
name|getOut
argument_list|()
operator|.
name|copyFrom
argument_list|(
name|source
operator|.
name|getIn
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// if not replace IN instead to keep the MEP
name|result
operator|.
name|getIn
argument_list|()
operator|.
name|copyFrom
argument_list|(
name|source
operator|.
name|getIn
argument_list|()
argument_list|)
expr_stmt|;
comment|// clear any existing OUT as the result is on the IN
if|if
condition|(
name|result
operator|.
name|hasOut
argument_list|()
condition|)
block|{
name|result
operator|.
name|setOut
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|source
operator|.
name|hasProperties
argument_list|()
condition|)
block|{
name|result
operator|.
name|getProperties
argument_list|()
operator|.
name|putAll
argument_list|(
name|source
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Copies the<code>source</code> exchange to<code>target</code> exchange      * preserving the {@link ExchangePattern} of<code>target</code>.      *      * @param source source exchange.      * @param result target exchange.      */
DECL|method|copyResultsPreservePattern (Exchange result, Exchange source)
specifier|public
specifier|static
name|void
name|copyResultsPreservePattern
parameter_list|(
name|Exchange
name|result
parameter_list|,
name|Exchange
name|source
parameter_list|)
block|{
comment|// --------------------------------------------------------------------
comment|//  TODO: merge logic with that of copyResults()
comment|// --------------------------------------------------------------------
if|if
condition|(
name|source
operator|==
name|result
condition|)
block|{
comment|// no need to copy
return|return;
block|}
comment|// copy in message
name|result
operator|.
name|getIn
argument_list|()
operator|.
name|copyFrom
argument_list|(
name|source
operator|.
name|getIn
argument_list|()
argument_list|)
expr_stmt|;
comment|// copy out message
if|if
condition|(
name|source
operator|.
name|hasOut
argument_list|()
condition|)
block|{
comment|// exchange pattern sensitive
name|Message
name|resultMessage
init|=
name|source
operator|.
name|getOut
argument_list|()
operator|.
name|isFault
argument_list|()
condition|?
name|result
operator|.
name|getOut
argument_list|()
else|:
name|getResultMessage
argument_list|(
name|result
argument_list|)
decl_stmt|;
name|resultMessage
operator|.
name|copyFrom
argument_list|(
name|source
operator|.
name|getOut
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// copy exception
name|result
operator|.
name|setException
argument_list|(
name|source
operator|.
name|getException
argument_list|()
argument_list|)
expr_stmt|;
comment|// copy properties
if|if
condition|(
name|source
operator|.
name|hasProperties
argument_list|()
condition|)
block|{
name|result
operator|.
name|getProperties
argument_list|()
operator|.
name|putAll
argument_list|(
name|source
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns the message where to write results in an      * exchange-pattern-sensitive way.      *      * @param exchange message exchange.      * @return result message.      */
DECL|method|getResultMessage (Exchange exchange)
specifier|public
specifier|static
name|Message
name|getResultMessage
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
name|exchange
operator|.
name|getPattern
argument_list|()
operator|.
name|isOutCapable
argument_list|()
condition|)
block|{
return|return
name|exchange
operator|.
name|getOut
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
return|;
block|}
block|}
comment|/**      * Returns true if the given exchange pattern (if defined) can support OUT messages      *      * @param exchange the exchange to interrogate      * @return true if the exchange is defined as an {@link ExchangePattern} which supports      *         OUT messages      */
DECL|method|isOutCapable (Exchange exchange)
specifier|public
specifier|static
name|boolean
name|isOutCapable
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|ExchangePattern
name|pattern
init|=
name|exchange
operator|.
name|getPattern
argument_list|()
decl_stmt|;
return|return
name|pattern
operator|!=
literal|null
operator|&&
name|pattern
operator|.
name|isOutCapable
argument_list|()
return|;
block|}
comment|/**      * Creates a new instance of the given type from the injector      */
DECL|method|newInstance (Exchange exchange, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|newInstance
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getInjector
argument_list|()
operator|.
name|newInstance
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/**      * Creates a Map of the variables which are made available to a script or template      *      * @param exchange the exchange to make available      * @return a Map populated with the require variables      */
DECL|method|createVariableMap (Exchange exchange)
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|createVariableMap
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|answer
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|populateVariableMap
argument_list|(
name|exchange
argument_list|,
name|answer
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
comment|/**      * Populates the Map with the variables which are made available to a script or template      *      * @param exchange the exchange to make available      * @param map      the map to populate      */
DECL|method|populateVariableMap (Exchange exchange, Map<String, Object> map)
specifier|public
specifier|static
name|void
name|populateVariableMap
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|map
parameter_list|)
block|{
name|map
operator|.
name|put
argument_list|(
literal|"exchange"
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
name|Message
name|in
init|=
name|exchange
operator|.
name|getIn
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"in"
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"request"
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"headers"
argument_list|,
name|in
operator|.
name|getHeaders
argument_list|()
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"body"
argument_list|,
name|in
operator|.
name|getBody
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isOutCapable
argument_list|(
name|exchange
argument_list|)
condition|)
block|{
comment|// if we are out capable then set out and response as well
comment|// however only grab OUT if it exists, otherwise reuse IN
comment|// this prevents side effects to alter the Exchange if we force creating an OUT message
name|Message
name|msg
init|=
name|exchange
operator|.
name|hasOut
argument_list|()
condition|?
name|exchange
operator|.
name|getOut
argument_list|()
else|:
name|exchange
operator|.
name|getIn
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"out"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"response"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
name|map
operator|.
name|put
argument_list|(
literal|"camelContext"
argument_list|,
name|exchange
operator|.
name|getContext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the MIME content type on the input message or null if one is not defined      */
DECL|method|getContentType (Exchange exchange)
specifier|public
specifier|static
name|String
name|getContentType
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|MessageHelper
operator|.
name|getContentType
argument_list|(
name|exchange
operator|.
name|getIn
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns the MIME content encoding on the input message or null if one is not defined      */
DECL|method|getContentEncoding (Exchange exchange)
specifier|public
specifier|static
name|String
name|getContentEncoding
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|MessageHelper
operator|.
name|getContentEncoding
argument_list|(
name|exchange
operator|.
name|getIn
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Performs a lookup in the registry of the mandatory bean name and throws an exception if it could not be found      */
DECL|method|lookupMandatoryBean (Exchange exchange, String name)
specifier|public
specifier|static
name|Object
name|lookupMandatoryBean
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|Object
name|value
init|=
name|lookupBean
argument_list|(
name|exchange
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchBeanException
argument_list|(
name|name
argument_list|)
throw|;
block|}
return|return
name|value
return|;
block|}
comment|/**      * Performs a lookup in the registry of the mandatory bean name and throws an exception if it could not be found      */
DECL|method|lookupMandatoryBean (Exchange exchange, String name, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|lookupMandatoryBean
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|name
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
name|T
name|value
init|=
name|lookupBean
argument_list|(
name|exchange
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchBeanException
argument_list|(
name|name
argument_list|)
throw|;
block|}
return|return
name|value
return|;
block|}
comment|/**      * Performs a lookup in the registry of the bean name      */
DECL|method|lookupBean (Exchange exchange, String name)
specifier|public
specifier|static
name|Object
name|lookupBean
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getRegistry
argument_list|()
operator|.
name|lookup
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**      * Performs a lookup in the registry of the bean name and type      */
DECL|method|lookupBean (Exchange exchange, String name, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|lookupBean
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|name
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getRegistry
argument_list|()
operator|.
name|lookup
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/**      * Returns the first exchange in the given collection of exchanges which has the same exchange ID as the one given      * or null if none could be found      */
DECL|method|getExchangeById (Iterable<Exchange> exchanges, String exchangeId)
specifier|public
specifier|static
name|Exchange
name|getExchangeById
parameter_list|(
name|Iterable
argument_list|<
name|Exchange
argument_list|>
name|exchanges
parameter_list|,
name|String
name|exchangeId
parameter_list|)
block|{
for|for
control|(
name|Exchange
name|exchange
range|:
name|exchanges
control|)
block|{
name|String
name|id
init|=
name|exchange
operator|.
name|getExchangeId
argument_list|()
decl_stmt|;
if|if
condition|(
name|id
operator|!=
literal|null
operator|&&
name|id
operator|.
name|equals
argument_list|(
name|exchangeId
argument_list|)
condition|)
block|{
return|return
name|exchange
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Prepares the exchanges for aggregation.      *<p/>      * This implementation will copy the OUT body to the IN body so when you do      * aggregation the body is<b>only</b> in the IN body to avoid confusing end users.      *      * @param oldExchange the old exchange      * @param newExchange the new exchange      */
DECL|method|prepareAggregation (Exchange oldExchange, Exchange newExchange)
specifier|public
specifier|static
name|void
name|prepareAggregation
parameter_list|(
name|Exchange
name|oldExchange
parameter_list|,
name|Exchange
name|newExchange
parameter_list|)
block|{
comment|// move body/header from OUT to IN
if|if
condition|(
name|oldExchange
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|oldExchange
operator|.
name|hasOut
argument_list|()
condition|)
block|{
name|oldExchange
operator|.
name|setIn
argument_list|(
name|oldExchange
operator|.
name|getOut
argument_list|()
argument_list|)
expr_stmt|;
name|oldExchange
operator|.
name|setOut
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newExchange
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|newExchange
operator|.
name|hasOut
argument_list|()
condition|)
block|{
name|newExchange
operator|.
name|setIn
argument_list|(
name|newExchange
operator|.
name|getOut
argument_list|()
argument_list|)
expr_stmt|;
name|newExchange
operator|.
name|setOut
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|isFailureHandled (Exchange exchange)
specifier|public
specifier|static
name|boolean
name|isFailureHandled
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|FAILURE_HANDLED
argument_list|,
literal|false
argument_list|,
name|Boolean
operator|.
name|class
argument_list|)
return|;
block|}
DECL|method|isUnitOfWorkExhausted (Exchange exchange)
specifier|public
specifier|static
name|boolean
name|isUnitOfWorkExhausted
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|UNIT_OF_WORK_EXHAUSTED
argument_list|,
literal|false
argument_list|,
name|Boolean
operator|.
name|class
argument_list|)
return|;
block|}
DECL|method|setFailureHandled (Exchange exchange)
specifier|public
specifier|static
name|void
name|setFailureHandled
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|FAILURE_HANDLED
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
comment|// clear exception since its failure handled
name|exchange
operator|.
name|setException
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|isRedeliveryExhausted (Exchange exchange)
specifier|public
specifier|static
name|boolean
name|isRedeliveryExhausted
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|REDELIVERY_EXHAUSTED
argument_list|,
literal|false
argument_list|,
name|Boolean
operator|.
name|class
argument_list|)
return|;
block|}
DECL|method|isRedelivered (Exchange exchange)
specifier|public
specifier|static
name|boolean
name|isRedelivered
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|hasHeaders
argument_list|()
operator|&&
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|Exchange
operator|.
name|REDELIVERED
argument_list|,
literal|false
argument_list|,
name|Boolean
operator|.
name|class
argument_list|)
return|;
block|}
DECL|method|isInterrupted (Exchange exchange)
specifier|public
specifier|static
name|boolean
name|isInterrupted
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getException
argument_list|(
name|InterruptedException
operator|.
name|class
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**      * Extracts the body from the given exchange.      *<p/>      * If the exchange pattern is provided it will try to honor it and retrieve the body      * from either IN or OUT according to the pattern.      *      * @param exchange the exchange      * @param pattern  exchange pattern if given, can be<tt>null</tt>      * @return the result body, can be<tt>null</tt>.      * @throws CamelExecutionException is thrown if the processing of the exchange failed      */
DECL|method|extractResultBody (Exchange exchange, ExchangePattern pattern)
specifier|public
specifier|static
name|Object
name|extractResultBody
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|ExchangePattern
name|pattern
parameter_list|)
block|{
name|Object
name|answer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|exchange
operator|!=
literal|null
condition|)
block|{
comment|// rethrow if there was an exception during execution
if|if
condition|(
name|exchange
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
throw|throw
name|ObjectHelper
operator|.
name|wrapCamelExecutionException
argument_list|(
name|exchange
argument_list|,
name|exchange
operator|.
name|getException
argument_list|()
argument_list|)
throw|;
block|}
comment|// result could have a fault message
if|if
condition|(
name|hasFaultMessage
argument_list|(
name|exchange
argument_list|)
condition|)
block|{
return|return
name|exchange
operator|.
name|getOut
argument_list|()
operator|.
name|getBody
argument_list|()
return|;
block|}
comment|// okay no fault then return the response according to the pattern
comment|// try to honor pattern if provided
name|boolean
name|notOut
init|=
name|pattern
operator|!=
literal|null
operator|&&
operator|!
name|pattern
operator|.
name|isOutCapable
argument_list|()
decl_stmt|;
name|boolean
name|hasOut
init|=
name|exchange
operator|.
name|hasOut
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasOut
operator|&&
operator|!
name|notOut
condition|)
block|{
comment|// we have a response in out and the pattern is out capable
name|answer
operator|=
name|exchange
operator|.
name|getOut
argument_list|()
operator|.
name|getBody
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|hasOut
operator|&&
name|exchange
operator|.
name|getPattern
argument_list|()
operator|==
name|ExchangePattern
operator|.
name|InOptionalOut
condition|)
block|{
comment|// special case where the result is InOptionalOut and with no OUT response
comment|// so we should return null to indicate this fact
name|answer
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
comment|// use IN as the response
name|answer
operator|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Tests whether the exchange has a fault message set and that its not null.      *      * @param exchange the exchange      * @return<tt>true</tt> if fault message exists      */
DECL|method|hasFaultMessage (Exchange exchange)
specifier|public
specifier|static
name|boolean
name|hasFaultMessage
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|hasOut
argument_list|()
operator|&&
name|exchange
operator|.
name|getOut
argument_list|()
operator|.
name|isFault
argument_list|()
operator|&&
name|exchange
operator|.
name|getOut
argument_list|()
operator|.
name|getBody
argument_list|()
operator|!=
literal|null
return|;
block|}
comment|/**      * Tests whether the exchange has already been handled by the error handler      *      * @param exchange the exchange      * @return<tt>true</tt> if handled already by error handler,<tt>false</tt> otherwise      */
DECL|method|hasExceptionBeenHandledByErrorHandler (Exchange exchange)
specifier|public
specifier|static
name|boolean
name|hasExceptionBeenHandledByErrorHandler
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|Boolean
operator|.
name|TRUE
operator|.
name|equals
argument_list|(
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|ERRORHANDLER_HANDLED
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Extracts the body from the given future, that represents a handle to an asynchronous exchange.      *<p/>      * Will wait until the future task is complete.      *      * @param context the camel context      * @param future  the future handle      * @param type    the expected body response type      * @return the result body, can be<tt>null</tt>.      * @throws CamelExecutionException is thrown if the processing of the exchange failed      */
DECL|method|extractFutureBody (CamelContext context, Future<Object> future, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|extractFutureBody
parameter_list|(
name|CamelContext
name|context
parameter_list|,
name|Future
argument_list|<
name|Object
argument_list|>
name|future
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
try|try
block|{
return|return
name|doExtractFutureBody
argument_list|(
name|context
argument_list|,
name|future
operator|.
name|get
argument_list|()
argument_list|,
name|type
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
name|ObjectHelper
operator|.
name|wrapRuntimeCamelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
comment|// execution failed due to an exception so rethrow the cause
throw|throw
name|ObjectHelper
operator|.
name|wrapCamelExecutionException
argument_list|(
literal|null
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
finally|finally
block|{
comment|// its harmless to cancel if task is already completed
comment|// and in any case we do not want to get hold of the task a 2nd time
comment|// and its recommended to cancel according to Brian Goetz in his Java Concurrency in Practice book
name|future
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Extracts the body from the given future, that represents a handle to an asynchronous exchange.      *<p/>      * Will wait for the future task to complete, but waiting at most the timeout value.      *      * @param context the camel context      * @param future  the future handle      * @param timeout timeout value      * @param unit    timeout unit      * @param type    the expected body response type      * @return the result body, can be<tt>null</tt>.      * @throws CamelExecutionException is thrown if the processing of the exchange failed      * @throws java.util.concurrent.TimeoutException      *                                 is thrown if a timeout triggered      */
DECL|method|extractFutureBody (CamelContext context, Future<Object> future, long timeout, TimeUnit unit, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|extractFutureBody
parameter_list|(
name|CamelContext
name|context
parameter_list|,
name|Future
argument_list|<
name|Object
argument_list|>
name|future
parameter_list|,
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
throws|throws
name|TimeoutException
block|{
try|try
block|{
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
return|return
name|doExtractFutureBody
argument_list|(
name|context
argument_list|,
name|future
operator|.
name|get
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|doExtractFutureBody
argument_list|(
name|context
argument_list|,
name|future
operator|.
name|get
argument_list|()
argument_list|,
name|type
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// execution failed due interruption so rethrow the cause
throw|throw
name|ObjectHelper
operator|.
name|wrapCamelExecutionException
argument_list|(
literal|null
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
comment|// execution failed due to an exception so rethrow the cause
throw|throw
name|ObjectHelper
operator|.
name|wrapCamelExecutionException
argument_list|(
literal|null
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
finally|finally
block|{
comment|// its harmless to cancel if task is already completed
comment|// and in any case we do not want to get hold of the task a 2nd time
comment|// and its recommended to cancel according to Brian Goetz in his Java Concurrency in Practice book
name|future
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doExtractFutureBody (CamelContext context, Object result, Class<T> type)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|doExtractFutureBody
parameter_list|(
name|CamelContext
name|context
parameter_list|,
name|Object
name|result
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|type
operator|.
name|isAssignableFrom
argument_list|(
name|result
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|type
operator|.
name|cast
argument_list|(
name|result
argument_list|)
return|;
block|}
if|if
condition|(
name|result
operator|instanceof
name|Exchange
condition|)
block|{
name|Exchange
name|exchange
init|=
operator|(
name|Exchange
operator|)
name|result
decl_stmt|;
name|Object
name|answer
init|=
name|ExchangeHelper
operator|.
name|extractResultBody
argument_list|(
name|exchange
argument_list|,
name|exchange
operator|.
name|getPattern
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|context
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|type
argument_list|,
name|answer
argument_list|)
return|;
block|}
return|return
name|context
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|type
argument_list|,
name|result
argument_list|)
return|;
block|}
comment|/**      * Creates an exception message with the provided details.      *<p/>      * All fields is optional so you can pass in only an exception, or just a message etc. or any combination.      *      * @param message  the message      * @param exchange the exchange      * @param cause    the caused exception      * @return an error message (without stacktrace from exception)      */
DECL|method|createExceptionMessage (String message, Exchange exchange, Throwable cause)
specifier|public
specifier|static
name|String
name|createExceptionMessage
parameter_list|(
name|String
name|message
parameter_list|,
name|Exchange
name|exchange
parameter_list|,
name|Throwable
name|cause
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|message
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exchange
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|". "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|". "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"Caused by: ["
operator|+
name|cause
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" - "
operator|+
name|cause
operator|.
name|getMessage
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
return|;
block|}
comment|/**      * Strategy to prepare results before next iterator or when we are complete,      * which is done by copying OUT to IN, so there is only an IN as input      * for the next iteration.      *      * @param exchange the exchange to prepare      */
DECL|method|prepareOutToIn (Exchange exchange)
specifier|public
specifier|static
name|void
name|prepareOutToIn
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
comment|// we are routing using pipes and filters so we need to manually copy OUT to IN
if|if
condition|(
name|exchange
operator|.
name|hasOut
argument_list|()
condition|)
block|{
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|copyFrom
argument_list|(
name|exchange
operator|.
name|getOut
argument_list|()
argument_list|)
expr_stmt|;
name|exchange
operator|.
name|setOut
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

