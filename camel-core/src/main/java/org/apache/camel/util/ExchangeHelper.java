begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.util
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelExchangeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelExecutionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Endpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|ExchangePattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|InvalidPayloadException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|MessageHistory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|NoSuchBeanException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|NoSuchEndpointException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|NoSuchHeaderException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|NoSuchPropertyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|NoTypeConversionAvailableException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Route
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|TypeConversionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|TypeConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|impl
operator|.
name|DefaultExchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|impl
operator|.
name|MessageSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|Synchronization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|UnitOfWork
import|;
end_import

begin_comment
comment|/**  * Some helper methods for working with {@link Exchange} objects  *  * @version  */
end_comment

begin_class
DECL|class|ExchangeHelper
specifier|public
specifier|final
class|class
name|ExchangeHelper
block|{
comment|/**      * Utility classes should not have a public constructor.      */
DECL|method|ExchangeHelper ()
specifier|private
name|ExchangeHelper
parameter_list|()
block|{     }
comment|/**      * Extracts the Exchange.BINDING of the given type or null if not present      *      * @param exchange the message exchange      * @param type     the expected binding type      * @return the binding object of the given type or null if it could not be found or converted      */
DECL|method|getBinding (Exchange exchange, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getBinding
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
return|return
name|exchange
operator|!=
literal|null
condition|?
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|BINDING
argument_list|,
name|type
argument_list|)
else|:
literal|null
return|;
block|}
comment|/**      * Attempts to resolve the endpoint for the given value      *      * @param exchange the message exchange being processed      * @param value    the value which can be an {@link Endpoint} or an object      *                 which provides a String representation of an endpoint via      *                 {@link #toString()}      * @return the endpoint      * @throws NoSuchEndpointException if the endpoint cannot be resolved      */
DECL|method|resolveEndpoint (Exchange exchange, Object value)
specifier|public
specifier|static
name|Endpoint
name|resolveEndpoint
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|value
parameter_list|)
throws|throws
name|NoSuchEndpointException
block|{
name|Endpoint
name|endpoint
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Endpoint
condition|)
block|{
name|endpoint
operator|=
operator|(
name|Endpoint
operator|)
name|value
expr_stmt|;
block|}
else|else
block|{
name|String
name|uri
init|=
name|value
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
name|endpoint
operator|=
name|CamelContextHelper
operator|.
name|getMandatoryEndpoint
argument_list|(
name|exchange
operator|.
name|getContext
argument_list|()
argument_list|,
name|uri
argument_list|)
expr_stmt|;
block|}
return|return
name|endpoint
return|;
block|}
comment|/**      * Gets the mandatory property of the exchange of the correct type      *      * @param exchange      the exchange      * @param propertyName  the property name      * @param type          the type      * @return the property value      * @throws TypeConversionException is thrown if error during type conversion      * @throws NoSuchPropertyException is thrown if no property exists      */
DECL|method|getMandatoryProperty (Exchange exchange, String propertyName, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getMandatoryProperty
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|propertyName
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
throws|throws
name|NoSuchPropertyException
block|{
name|T
name|result
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|propertyName
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
throw|throw
operator|new
name|NoSuchPropertyException
argument_list|(
name|exchange
argument_list|,
name|propertyName
argument_list|,
name|type
argument_list|)
throw|;
block|}
comment|/**      * Gets the mandatory inbound header of the correct type      *      * @param exchange      the exchange      * @param headerName    the header name      * @param type          the type      * @return the header value      * @throws TypeConversionException is thrown if error during type conversion      * @throws NoSuchHeaderException is thrown if no headers exists      */
DECL|method|getMandatoryHeader (Exchange exchange, String headerName, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getMandatoryHeader
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|headerName
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
throws|throws
name|TypeConversionException
throws|,
name|NoSuchHeaderException
block|{
name|T
name|answer
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|headerName
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchHeaderException
argument_list|(
name|exchange
argument_list|,
name|headerName
argument_list|,
name|type
argument_list|)
throw|;
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Gets the mandatory inbound header of the correct type      *      * @param message       the message      * @param headerName    the header name      * @param type          the type      * @return the header value      * @throws TypeConversionException is thrown if error during type conversion      * @throws NoSuchHeaderException is thrown if no headers exists      */
DECL|method|getMandatoryHeader (Message message, String headerName, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getMandatoryHeader
parameter_list|(
name|Message
name|message
parameter_list|,
name|String
name|headerName
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
throws|throws
name|TypeConversionException
throws|,
name|NoSuchHeaderException
block|{
name|T
name|answer
init|=
name|message
operator|.
name|getHeader
argument_list|(
name|headerName
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchHeaderException
argument_list|(
name|message
operator|.
name|getExchange
argument_list|()
argument_list|,
name|headerName
argument_list|,
name|type
argument_list|)
throw|;
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Gets an header or property of the correct type      *      * @param exchange      the exchange      * @param name          the name of the header or the property      * @param type          the type      * @return the header or property value      * @throws TypeConversionException is thrown if error during type conversion      * @throws NoSuchHeaderException is thrown if no headers exists      */
DECL|method|getHeaderOrProperty (Exchange exchange, String name, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getHeaderOrProperty
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|name
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
throws|throws
name|TypeConversionException
block|{
name|T
name|answer
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
name|answer
operator|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Converts the value to the given expected type or throws an exception      *      * @return the converted value      * @throws TypeConversionException is thrown if error during type conversion      * @throws NoTypeConversionAvailableException} if no type converters exists to convert to the given type      */
DECL|method|convertToMandatoryType (Exchange exchange, Class<T> type, Object value)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|convertToMandatoryType
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|Object
name|value
parameter_list|)
throws|throws
name|TypeConversionException
throws|,
name|NoTypeConversionAvailableException
block|{
name|CamelContext
name|camelContext
init|=
name|exchange
operator|.
name|getContext
argument_list|()
decl_stmt|;
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|camelContext
argument_list|,
literal|"CamelContext of Exchange"
argument_list|)
expr_stmt|;
name|TypeConverter
name|converter
init|=
name|camelContext
operator|.
name|getTypeConverter
argument_list|()
decl_stmt|;
if|if
condition|(
name|converter
operator|!=
literal|null
condition|)
block|{
return|return
name|converter
operator|.
name|mandatoryConvertTo
argument_list|(
name|type
argument_list|,
name|exchange
argument_list|,
name|value
argument_list|)
return|;
block|}
throw|throw
operator|new
name|NoTypeConversionAvailableException
argument_list|(
name|value
argument_list|,
name|type
argument_list|)
throw|;
block|}
comment|/**      * Converts the value to the given expected type      *      * @return the converted value      * @throws org.apache.camel.TypeConversionException is thrown if error during type conversion      */
DECL|method|convertToType (Exchange exchange, Class<T> type, Object value)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|convertToType
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|Object
name|value
parameter_list|)
throws|throws
name|TypeConversionException
block|{
name|CamelContext
name|camelContext
init|=
name|exchange
operator|.
name|getContext
argument_list|()
decl_stmt|;
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|camelContext
argument_list|,
literal|"CamelContext of Exchange"
argument_list|)
expr_stmt|;
name|TypeConverter
name|converter
init|=
name|camelContext
operator|.
name|getTypeConverter
argument_list|()
decl_stmt|;
if|if
condition|(
name|converter
operator|!=
literal|null
condition|)
block|{
return|return
name|converter
operator|.
name|convertTo
argument_list|(
name|type
argument_list|,
name|exchange
argument_list|,
name|value
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Creates a new instance and copies from the current message exchange so that it can be      * forwarded to another destination as a new instance. Unlike regular copy this operation      * will not share the same {@link org.apache.camel.spi.UnitOfWork} so its should be used      * for async messaging, where the original and copied exchange are independent.      *      * @param exchange original copy of the exchange      * @param handover whether the on completion callbacks should be handed over to the new copy.      */
DECL|method|createCorrelatedCopy (Exchange exchange, boolean handover)
specifier|public
specifier|static
name|Exchange
name|createCorrelatedCopy
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|boolean
name|handover
parameter_list|)
block|{
return|return
name|createCorrelatedCopy
argument_list|(
name|exchange
argument_list|,
name|handover
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Creates a new instance and copies from the current message exchange so that it can be      * forwarded to another destination as a new instance. Unlike regular copy this operation      * will not share the same {@link org.apache.camel.spi.UnitOfWork} so its should be used      * for async messaging, where the original and copied exchange are independent.      *      * @param exchange original copy of the exchange      * @param handover whether the on completion callbacks should be handed over to the new copy.      * @param useSameMessageId whether to use same message id on the copy message.      */
DECL|method|createCorrelatedCopy (Exchange exchange, boolean handover, boolean useSameMessageId)
specifier|public
specifier|static
name|Exchange
name|createCorrelatedCopy
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|boolean
name|handover
parameter_list|,
name|boolean
name|useSameMessageId
parameter_list|)
block|{
return|return
name|createCorrelatedCopy
argument_list|(
name|exchange
argument_list|,
name|handover
argument_list|,
name|useSameMessageId
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Creates a new instance and copies from the current message exchange so that it can be      * forwarded to another destination as a new instance. Unlike regular copy this operation      * will not share the same {@link org.apache.camel.spi.UnitOfWork} so its should be used      * for async messaging, where the original and copied exchange are independent.      *      * @param exchange original copy of the exchange      * @param handover whether the on completion callbacks should be handed over to the new copy.      * @param useSameMessageId whether to use same message id on the copy message.      * @param filter whether to handover the on completion      */
DECL|method|createCorrelatedCopy (Exchange exchange, boolean handover, boolean useSameMessageId, Predicate<Synchronization> filter)
specifier|public
specifier|static
name|Exchange
name|createCorrelatedCopy
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|boolean
name|handover
parameter_list|,
name|boolean
name|useSameMessageId
parameter_list|,
name|Predicate
argument_list|<
name|Synchronization
argument_list|>
name|filter
parameter_list|)
block|{
name|String
name|id
init|=
name|exchange
operator|.
name|getExchangeId
argument_list|()
decl_stmt|;
comment|// make sure to do a safe copy as the correlated copy can be routed independently of the source.
name|Exchange
name|copy
init|=
name|exchange
operator|.
name|copy
argument_list|()
decl_stmt|;
comment|// do not reuse message id on copy
if|if
condition|(
operator|!
name|useSameMessageId
condition|)
block|{
if|if
condition|(
name|copy
operator|.
name|hasOut
argument_list|()
condition|)
block|{
name|copy
operator|.
name|getOut
argument_list|()
operator|.
name|setMessageId
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|copy
operator|.
name|getIn
argument_list|()
operator|.
name|setMessageId
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// do not share the unit of work
name|copy
operator|.
name|setUnitOfWork
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// do not reuse the message id
comment|// hand over on completion to the copy if we got any
name|UnitOfWork
name|uow
init|=
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
decl_stmt|;
if|if
condition|(
name|handover
operator|&&
name|uow
operator|!=
literal|null
condition|)
block|{
name|uow
operator|.
name|handoverSynchronization
argument_list|(
name|copy
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
comment|// set a correlation id so we can track back the original exchange
name|copy
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|CORRELATION_ID
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
comment|/**      * Creates a new instance and copies from the current message exchange so that it can be      * forwarded to another destination as a new instance.      *      * @param exchange original copy of the exchange      * @param preserveExchangeId whether or not the exchange id should be preserved      * @return the copy      */
DECL|method|createCopy (Exchange exchange, boolean preserveExchangeId)
specifier|public
specifier|static
name|Exchange
name|createCopy
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|boolean
name|preserveExchangeId
parameter_list|)
block|{
name|Exchange
name|copy
init|=
name|exchange
operator|.
name|copy
argument_list|()
decl_stmt|;
if|if
condition|(
name|preserveExchangeId
condition|)
block|{
comment|// must preserve exchange id
name|copy
operator|.
name|setExchangeId
argument_list|(
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|copy
return|;
block|}
comment|/**      * Copies the results of a message exchange from the source exchange to the result exchange      * which will copy the message contents, exchange properties and the exception.      * Notice the {@link ExchangePattern} is<b>not</b> copied/altered.      *      * @param result the result exchange which will have the output and error state added      * @param source the source exchange which is not modified      */
DECL|method|copyResults (Exchange result, Exchange source)
specifier|public
specifier|static
name|void
name|copyResults
parameter_list|(
name|Exchange
name|result
parameter_list|,
name|Exchange
name|source
parameter_list|)
block|{
comment|// --------------------------------------------------------------------
comment|//  TODO: merge logic with that of copyResultsPreservePattern()
comment|// --------------------------------------------------------------------
if|if
condition|(
name|result
operator|==
name|source
condition|)
block|{
comment|// we just need to ensure MEP is as expected (eg copy result to OUT if out capable)
comment|// and the result is not failed
if|if
condition|(
name|result
operator|.
name|getPattern
argument_list|()
operator|==
name|ExchangePattern
operator|.
name|InOptionalOut
condition|)
block|{
comment|// keep as is
block|}
elseif|else
if|if
condition|(
name|result
operator|.
name|getPattern
argument_list|()
operator|.
name|isOutCapable
argument_list|()
operator|&&
operator|!
name|result
operator|.
name|hasOut
argument_list|()
operator|&&
operator|!
name|result
operator|.
name|isFailed
argument_list|()
condition|)
block|{
comment|// copy IN to OUT as we expect a OUT response
name|result
operator|.
name|getOut
argument_list|()
operator|.
name|copyFrom
argument_list|(
name|source
operator|.
name|getIn
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|result
operator|!=
name|source
condition|)
block|{
name|result
operator|.
name|setException
argument_list|(
name|source
operator|.
name|getException
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|.
name|hasOut
argument_list|()
condition|)
block|{
name|result
operator|.
name|getOut
argument_list|()
operator|.
name|copyFrom
argument_list|(
name|source
operator|.
name|getOut
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|.
name|getPattern
argument_list|()
operator|==
name|ExchangePattern
operator|.
name|InOptionalOut
condition|)
block|{
comment|// special case where the result is InOptionalOut and with no OUT response
comment|// so we should return null to indicate this fact
name|result
operator|.
name|setOut
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// no results so lets copy the last input
comment|// as the final processor on a pipeline might not
comment|// have created any OUT; such as a mock:endpoint
comment|// so lets assume the last IN is the OUT
if|if
condition|(
name|result
operator|.
name|getPattern
argument_list|()
operator|.
name|isOutCapable
argument_list|()
condition|)
block|{
comment|// only set OUT if its OUT capable
name|result
operator|.
name|getOut
argument_list|()
operator|.
name|copyFrom
argument_list|(
name|source
operator|.
name|getIn
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// if not replace IN instead to keep the MEP
name|result
operator|.
name|getIn
argument_list|()
operator|.
name|copyFrom
argument_list|(
name|source
operator|.
name|getIn
argument_list|()
argument_list|)
expr_stmt|;
comment|// clear any existing OUT as the result is on the IN
if|if
condition|(
name|result
operator|.
name|hasOut
argument_list|()
condition|)
block|{
name|result
operator|.
name|setOut
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|source
operator|.
name|hasProperties
argument_list|()
condition|)
block|{
name|result
operator|.
name|getProperties
argument_list|()
operator|.
name|putAll
argument_list|(
name|source
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Copies the<code>source</code> exchange to<code>target</code> exchange      * preserving the {@link ExchangePattern} of<code>target</code>.      *      * @param result target exchange.      * @param source source exchange.      */
DECL|method|copyResultsPreservePattern (Exchange result, Exchange source)
specifier|public
specifier|static
name|void
name|copyResultsPreservePattern
parameter_list|(
name|Exchange
name|result
parameter_list|,
name|Exchange
name|source
parameter_list|)
block|{
comment|// --------------------------------------------------------------------
comment|//  TODO: merge logic with that of copyResults()
comment|// --------------------------------------------------------------------
if|if
condition|(
name|result
operator|==
name|source
condition|)
block|{
comment|// we just need to ensure MEP is as expected (eg copy result to OUT if out capable)
comment|// and the result is not failed
if|if
condition|(
name|result
operator|.
name|getPattern
argument_list|()
operator|==
name|ExchangePattern
operator|.
name|InOptionalOut
condition|)
block|{
comment|// keep as is
block|}
elseif|else
if|if
condition|(
name|result
operator|.
name|getPattern
argument_list|()
operator|.
name|isOutCapable
argument_list|()
operator|&&
operator|!
name|result
operator|.
name|hasOut
argument_list|()
operator|&&
operator|!
name|result
operator|.
name|isFailed
argument_list|()
condition|)
block|{
comment|// copy IN to OUT as we expect a OUT response
name|result
operator|.
name|getOut
argument_list|()
operator|.
name|copyFrom
argument_list|(
name|source
operator|.
name|getIn
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// copy in message
name|result
operator|.
name|getIn
argument_list|()
operator|.
name|copyFrom
argument_list|(
name|source
operator|.
name|getIn
argument_list|()
argument_list|)
expr_stmt|;
comment|// copy out message
if|if
condition|(
name|source
operator|.
name|hasOut
argument_list|()
condition|)
block|{
comment|// exchange pattern sensitive
name|Message
name|resultMessage
init|=
name|source
operator|.
name|getOut
argument_list|()
operator|.
name|isFault
argument_list|()
condition|?
name|result
operator|.
name|getOut
argument_list|()
else|:
name|getResultMessage
argument_list|(
name|result
argument_list|)
decl_stmt|;
name|resultMessage
operator|.
name|copyFrom
argument_list|(
name|source
operator|.
name|getOut
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// copy exception
name|result
operator|.
name|setException
argument_list|(
name|source
operator|.
name|getException
argument_list|()
argument_list|)
expr_stmt|;
comment|// copy properties
if|if
condition|(
name|source
operator|.
name|hasProperties
argument_list|()
condition|)
block|{
name|result
operator|.
name|getProperties
argument_list|()
operator|.
name|putAll
argument_list|(
name|source
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns the message where to write results in an      * exchange-pattern-sensitive way.      *      * @param exchange message exchange.      * @return result message.      */
DECL|method|getResultMessage (Exchange exchange)
specifier|public
specifier|static
name|Message
name|getResultMessage
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
name|exchange
operator|.
name|getPattern
argument_list|()
operator|.
name|isOutCapable
argument_list|()
condition|)
block|{
return|return
name|exchange
operator|.
name|getOut
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
return|;
block|}
block|}
comment|/**      * Returns true if the given exchange pattern (if defined) can support OUT messages      *      * @param exchange the exchange to interrogate      * @return true if the exchange is defined as an {@link ExchangePattern} which supports      *         OUT messages      */
DECL|method|isOutCapable (Exchange exchange)
specifier|public
specifier|static
name|boolean
name|isOutCapable
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|ExchangePattern
name|pattern
init|=
name|exchange
operator|.
name|getPattern
argument_list|()
decl_stmt|;
return|return
name|pattern
operator|!=
literal|null
operator|&&
name|pattern
operator|.
name|isOutCapable
argument_list|()
return|;
block|}
comment|/**      * Creates a new instance of the given type from the injector      *      * @param exchange the exchange      * @param type     the given type      * @return the created instance of the given type      */
DECL|method|newInstance (Exchange exchange, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|newInstance
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getInjector
argument_list|()
operator|.
name|newInstance
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/**      * Creates a Map of the variables which are made available to a script or template      *      * @param exchange the exchange to make available      * @return a Map populated with the require variables      */
DECL|method|createVariableMap (Exchange exchange)
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|createVariableMap
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|answer
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|populateVariableMap
argument_list|(
name|exchange
argument_list|,
name|answer
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
comment|/**      * Populates the Map with the variables which are made available to a script or template      *      * @param exchange the exchange to make available      * @param map      the map to populate      */
DECL|method|populateVariableMap (Exchange exchange, Map<String, Object> map)
specifier|public
specifier|static
name|void
name|populateVariableMap
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|map
parameter_list|)
block|{
name|map
operator|.
name|put
argument_list|(
literal|"exchange"
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
name|Message
name|in
init|=
name|exchange
operator|.
name|getIn
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"in"
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"request"
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"headers"
argument_list|,
name|in
operator|.
name|getHeaders
argument_list|()
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"body"
argument_list|,
name|in
operator|.
name|getBody
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isOutCapable
argument_list|(
name|exchange
argument_list|)
condition|)
block|{
comment|// if we are out capable then set out and response as well
comment|// however only grab OUT if it exists, otherwise reuse IN
comment|// this prevents side effects to alter the Exchange if we force creating an OUT message
name|Message
name|msg
init|=
name|exchange
operator|.
name|hasOut
argument_list|()
condition|?
name|exchange
operator|.
name|getOut
argument_list|()
else|:
name|exchange
operator|.
name|getIn
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"out"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"response"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
name|map
operator|.
name|put
argument_list|(
literal|"camelContext"
argument_list|,
name|exchange
operator|.
name|getContext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the MIME content type on the input message or null if one is not defined      *      * @param exchange the exchange      * @return the MIME content type      */
DECL|method|getContentType (Exchange exchange)
specifier|public
specifier|static
name|String
name|getContentType
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|MessageHelper
operator|.
name|getContentType
argument_list|(
name|exchange
operator|.
name|getIn
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns the MIME content encoding on the input message or null if one is not defined      *      * @param exchange the exchange      * @return the MIME content encoding      */
DECL|method|getContentEncoding (Exchange exchange)
specifier|public
specifier|static
name|String
name|getContentEncoding
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|MessageHelper
operator|.
name|getContentEncoding
argument_list|(
name|exchange
operator|.
name|getIn
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Performs a lookup in the registry of the mandatory bean name and throws an exception if it could not be found      *      * @param exchange the exchange      * @param name     the bean name      * @return the bean      * @throws NoSuchBeanException if no bean could be found in the registry      */
DECL|method|lookupMandatoryBean (Exchange exchange, String name)
specifier|public
specifier|static
name|Object
name|lookupMandatoryBean
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|name
parameter_list|)
throws|throws
name|NoSuchBeanException
block|{
name|Object
name|value
init|=
name|lookupBean
argument_list|(
name|exchange
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchBeanException
argument_list|(
name|name
argument_list|)
throw|;
block|}
return|return
name|value
return|;
block|}
comment|/**      * Performs a lookup in the registry of the mandatory bean name and throws an exception if it could not be found      *      * @param exchange the exchange      * @param name     the bean name      * @param type     the expected bean type      * @return the bean      * @throws NoSuchBeanException if no bean could be found in the registry      */
DECL|method|lookupMandatoryBean (Exchange exchange, String name, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|lookupMandatoryBean
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|name
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
name|T
name|value
init|=
name|lookupBean
argument_list|(
name|exchange
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchBeanException
argument_list|(
name|name
argument_list|)
throw|;
block|}
return|return
name|value
return|;
block|}
comment|/**      * Performs a lookup in the registry of the bean name      *      * @param exchange the exchange      * @param name     the bean name      * @return the bean, or<tt>null</tt> if no bean could be found      */
DECL|method|lookupBean (Exchange exchange, String name)
specifier|public
specifier|static
name|Object
name|lookupBean
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getRegistry
argument_list|()
operator|.
name|lookupByName
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**      * Performs a lookup in the registry of the bean name and type      *      * @param exchange the exchange      * @param name     the bean name      * @param type     the expected bean type      * @return the bean, or<tt>null</tt> if no bean could be found      */
DECL|method|lookupBean (Exchange exchange, String name, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|lookupBean
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|name
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getRegistry
argument_list|()
operator|.
name|lookupByNameAndType
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/**      * Returns the first exchange in the given collection of exchanges which has the same exchange ID as the one given      * or null if none could be found      *      * @param exchanges  the exchanges      * @param exchangeId the exchangeId to find      * @return matching exchange, or<tt>null</tt> if none found      */
DECL|method|getExchangeById (Iterable<Exchange> exchanges, String exchangeId)
specifier|public
specifier|static
name|Exchange
name|getExchangeById
parameter_list|(
name|Iterable
argument_list|<
name|Exchange
argument_list|>
name|exchanges
parameter_list|,
name|String
name|exchangeId
parameter_list|)
block|{
for|for
control|(
name|Exchange
name|exchange
range|:
name|exchanges
control|)
block|{
name|String
name|id
init|=
name|exchange
operator|.
name|getExchangeId
argument_list|()
decl_stmt|;
if|if
condition|(
name|id
operator|!=
literal|null
operator|&&
name|id
operator|.
name|equals
argument_list|(
name|exchangeId
argument_list|)
condition|)
block|{
return|return
name|exchange
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Prepares the exchanges for aggregation.      *<p/>      * This implementation will copy the OUT body to the IN body so when you do      * aggregation the body is<b>only</b> in the IN body to avoid confusing end users.      *      * @param oldExchange the old exchange      * @param newExchange the new exchange      */
DECL|method|prepareAggregation (Exchange oldExchange, Exchange newExchange)
specifier|public
specifier|static
name|void
name|prepareAggregation
parameter_list|(
name|Exchange
name|oldExchange
parameter_list|,
name|Exchange
name|newExchange
parameter_list|)
block|{
comment|// move body/header from OUT to IN
if|if
condition|(
name|oldExchange
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|oldExchange
operator|.
name|hasOut
argument_list|()
condition|)
block|{
name|oldExchange
operator|.
name|setIn
argument_list|(
name|oldExchange
operator|.
name|getOut
argument_list|()
argument_list|)
expr_stmt|;
name|oldExchange
operator|.
name|setOut
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newExchange
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|newExchange
operator|.
name|hasOut
argument_list|()
condition|)
block|{
name|newExchange
operator|.
name|setIn
argument_list|(
name|newExchange
operator|.
name|getOut
argument_list|()
argument_list|)
expr_stmt|;
name|newExchange
operator|.
name|setOut
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Checks whether the exchange has been failure handed      *      * @param exchange  the exchange      * @return<tt>true</tt> if failure handled,<tt>false</tt> otherwise      */
DECL|method|isFailureHandled (Exchange exchange)
specifier|public
specifier|static
name|boolean
name|isFailureHandled
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|FAILURE_HANDLED
argument_list|,
literal|false
argument_list|,
name|Boolean
operator|.
name|class
argument_list|)
return|;
block|}
comment|/**      * Checks whether the exchange {@link UnitOfWork} is exhausted      *      * @param exchange  the exchange      * @return<tt>true</tt> if exhausted,<tt>false</tt> otherwise      */
DECL|method|isUnitOfWorkExhausted (Exchange exchange)
specifier|public
specifier|static
name|boolean
name|isUnitOfWorkExhausted
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|UNIT_OF_WORK_EXHAUSTED
argument_list|,
literal|false
argument_list|,
name|Boolean
operator|.
name|class
argument_list|)
return|;
block|}
comment|/**      * Sets the exchange to be failure handled.      *      * @param exchange  the exchange      */
DECL|method|setFailureHandled (Exchange exchange)
specifier|public
specifier|static
name|void
name|setFailureHandled
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|exchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|FAILURE_HANDLED
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
comment|// clear exception since its failure handled
name|exchange
operator|.
name|setException
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Checks whether the exchange is redelivery exhausted      *      * @param exchange  the exchange      * @return<tt>true</tt> if exhausted,<tt>false</tt> otherwise      */
DECL|method|isRedeliveryExhausted (Exchange exchange)
specifier|public
specifier|static
name|boolean
name|isRedeliveryExhausted
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|REDELIVERY_EXHAUSTED
argument_list|,
literal|false
argument_list|,
name|Boolean
operator|.
name|class
argument_list|)
return|;
block|}
comment|/**      * Checks whether the exchange {@link UnitOfWork} is redelivered      *      * @param exchange  the exchange      * @return<tt>true</tt> if redelivered,<tt>false</tt> otherwise      */
DECL|method|isRedelivered (Exchange exchange)
specifier|public
specifier|static
name|boolean
name|isRedelivered
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|hasHeaders
argument_list|()
operator|&&
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|Exchange
operator|.
name|REDELIVERED
argument_list|,
literal|false
argument_list|,
name|Boolean
operator|.
name|class
argument_list|)
return|;
block|}
comment|/**      * Checks whether the exchange {@link UnitOfWork} has been interrupted during processing      *      * @param exchange  the exchange      * @return<tt>true</tt> if interrupted,<tt>false</tt> otherwise      */
DECL|method|isInterrupted (Exchange exchange)
specifier|public
specifier|static
name|boolean
name|isInterrupted
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|Object
name|value
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|INTERRUPTED
argument_list|)
decl_stmt|;
return|return
name|value
operator|!=
literal|null
operator|&&
name|Boolean
operator|.
name|TRUE
operator|==
name|value
return|;
block|}
comment|/**      * Check whether or not stream caching is enabled for the given route or globally.      *      * @param exchange  the exchange      * @return<tt>true</tt> if enabled,<tt>false</tt> otherwise      */
DECL|method|isStreamCachingEnabled (final Exchange exchange)
specifier|public
specifier|static
name|boolean
name|isStreamCachingEnabled
parameter_list|(
specifier|final
name|Exchange
name|exchange
parameter_list|)
block|{
name|Route
name|route
init|=
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getRoute
argument_list|(
name|exchange
operator|.
name|getFromRouteId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|route
operator|!=
literal|null
condition|)
block|{
return|return
name|route
operator|.
name|getRouteContext
argument_list|()
operator|.
name|isStreamCaching
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getStreamCachingStrategy
argument_list|()
operator|.
name|isEnabled
argument_list|()
return|;
block|}
block|}
comment|/**      * Extracts the body from the given exchange.      *<p/>      * If the exchange pattern is provided it will try to honor it and retrieve the body      * from either IN or OUT according to the pattern.      *      * @param exchange the exchange      * @param pattern  exchange pattern if given, can be<tt>null</tt>      * @return the result body, can be<tt>null</tt>.      * @throws CamelExecutionException is thrown if the processing of the exchange failed      */
DECL|method|extractResultBody (Exchange exchange, ExchangePattern pattern)
specifier|public
specifier|static
name|Object
name|extractResultBody
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|ExchangePattern
name|pattern
parameter_list|)
block|{
name|Object
name|answer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|exchange
operator|!=
literal|null
condition|)
block|{
comment|// rethrow if there was an exception during execution
if|if
condition|(
name|exchange
operator|.
name|getException
argument_list|()
operator|!=
literal|null
condition|)
block|{
throw|throw
name|ObjectHelper
operator|.
name|wrapCamelExecutionException
argument_list|(
name|exchange
argument_list|,
name|exchange
operator|.
name|getException
argument_list|()
argument_list|)
throw|;
block|}
comment|// result could have a fault message
if|if
condition|(
name|hasFaultMessage
argument_list|(
name|exchange
argument_list|)
condition|)
block|{
name|Message
name|msg
init|=
name|exchange
operator|.
name|hasOut
argument_list|()
condition|?
name|exchange
operator|.
name|getOut
argument_list|()
else|:
name|exchange
operator|.
name|getIn
argument_list|()
decl_stmt|;
name|answer
operator|=
name|msg
operator|.
name|getBody
argument_list|()
expr_stmt|;
return|return
name|answer
return|;
block|}
comment|// okay no fault then return the response according to the pattern
comment|// try to honor pattern if provided
name|boolean
name|notOut
init|=
name|pattern
operator|!=
literal|null
operator|&&
operator|!
name|pattern
operator|.
name|isOutCapable
argument_list|()
decl_stmt|;
name|boolean
name|hasOut
init|=
name|exchange
operator|.
name|hasOut
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasOut
operator|&&
operator|!
name|notOut
condition|)
block|{
comment|// we have a response in out and the pattern is out capable
name|answer
operator|=
name|exchange
operator|.
name|getOut
argument_list|()
operator|.
name|getBody
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|hasOut
operator|&&
name|exchange
operator|.
name|getPattern
argument_list|()
operator|==
name|ExchangePattern
operator|.
name|InOptionalOut
condition|)
block|{
comment|// special case where the result is InOptionalOut and with no OUT response
comment|// so we should return null to indicate this fact
name|answer
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
comment|// use IN as the response
name|answer
operator|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Tests whether the exchange has a fault message set and that its not null.      *      * @param exchange the exchange      * @return<tt>true</tt> if fault message exists      */
DECL|method|hasFaultMessage (Exchange exchange)
specifier|public
specifier|static
name|boolean
name|hasFaultMessage
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|Message
name|msg
init|=
name|exchange
operator|.
name|hasOut
argument_list|()
condition|?
name|exchange
operator|.
name|getOut
argument_list|()
else|:
name|exchange
operator|.
name|getIn
argument_list|()
decl_stmt|;
return|return
name|msg
operator|.
name|isFault
argument_list|()
operator|&&
name|msg
operator|.
name|getBody
argument_list|()
operator|!=
literal|null
return|;
block|}
comment|/**      * Tests whether the exchange has already been handled by the error handler      *      * @param exchange the exchange      * @return<tt>true</tt> if handled already by error handler,<tt>false</tt> otherwise      */
DECL|method|hasExceptionBeenHandledByErrorHandler (Exchange exchange)
specifier|public
specifier|static
name|boolean
name|hasExceptionBeenHandledByErrorHandler
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|Boolean
operator|.
name|TRUE
operator|.
name|equals
argument_list|(
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|ERRORHANDLER_HANDLED
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Extracts the body from the given future, that represents a handle to an asynchronous exchange.      *<p/>      * Will wait until the future task is complete.      *      * @param context the camel context      * @param future  the future handle      * @param type    the expected body response type      * @return the result body, can be<tt>null</tt>.      * @throws CamelExecutionException is thrown if the processing of the exchange failed      */
DECL|method|extractFutureBody (CamelContext context, Future<?> future, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|extractFutureBody
parameter_list|(
name|CamelContext
name|context
parameter_list|,
name|Future
argument_list|<
name|?
argument_list|>
name|future
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
try|try
block|{
return|return
name|doExtractFutureBody
argument_list|(
name|context
argument_list|,
name|future
operator|.
name|get
argument_list|()
argument_list|,
name|type
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
name|ObjectHelper
operator|.
name|wrapRuntimeCamelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
comment|// execution failed due to an exception so rethrow the cause
throw|throw
name|ObjectHelper
operator|.
name|wrapCamelExecutionException
argument_list|(
literal|null
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
finally|finally
block|{
comment|// its harmless to cancel if task is already completed
comment|// and in any case we do not want to get hold of the task a 2nd time
comment|// and its recommended to cancel according to Brian Goetz in his Java Concurrency in Practice book
name|future
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Extracts the body from the given future, that represents a handle to an asynchronous exchange.      *<p/>      * Will wait for the future task to complete, but waiting at most the timeout value.      *      * @param context the camel context      * @param future  the future handle      * @param timeout timeout value      * @param unit    timeout unit      * @param type    the expected body response type      * @return the result body, can be<tt>null</tt>.      * @throws CamelExecutionException is thrown if the processing of the exchange failed      * @throws java.util.concurrent.TimeoutException is thrown if a timeout triggered      */
DECL|method|extractFutureBody (CamelContext context, Future<?> future, long timeout, TimeUnit unit, Class<T> type)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|extractFutureBody
parameter_list|(
name|CamelContext
name|context
parameter_list|,
name|Future
argument_list|<
name|?
argument_list|>
name|future
parameter_list|,
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
throws|throws
name|TimeoutException
block|{
try|try
block|{
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
return|return
name|doExtractFutureBody
argument_list|(
name|context
argument_list|,
name|future
operator|.
name|get
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|doExtractFutureBody
argument_list|(
name|context
argument_list|,
name|future
operator|.
name|get
argument_list|()
argument_list|,
name|type
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// execution failed due interruption so rethrow the cause
throw|throw
name|ObjectHelper
operator|.
name|wrapCamelExecutionException
argument_list|(
literal|null
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
comment|// execution failed due to an exception so rethrow the cause
throw|throw
name|ObjectHelper
operator|.
name|wrapCamelExecutionException
argument_list|(
literal|null
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
finally|finally
block|{
comment|// its harmless to cancel if task is already completed
comment|// and in any case we do not want to get hold of the task a 2nd time
comment|// and its recommended to cancel according to Brian Goetz in his Java Concurrency in Practice book
name|future
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doExtractFutureBody (CamelContext context, Object result, Class<T> type)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|doExtractFutureBody
parameter_list|(
name|CamelContext
name|context
parameter_list|,
name|Object
name|result
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|type
operator|.
name|isAssignableFrom
argument_list|(
name|result
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|type
operator|.
name|cast
argument_list|(
name|result
argument_list|)
return|;
block|}
if|if
condition|(
name|result
operator|instanceof
name|Exchange
condition|)
block|{
name|Exchange
name|exchange
init|=
operator|(
name|Exchange
operator|)
name|result
decl_stmt|;
name|Object
name|answer
init|=
name|ExchangeHelper
operator|.
name|extractResultBody
argument_list|(
name|exchange
argument_list|,
name|exchange
operator|.
name|getPattern
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|context
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|type
argument_list|,
name|exchange
argument_list|,
name|answer
argument_list|)
return|;
block|}
return|return
name|context
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|type
argument_list|,
name|result
argument_list|)
return|;
block|}
comment|/**      * Strategy to prepare results before next iterator or when we are complete,      * which is done by copying OUT to IN, so there is only an IN as input      * for the next iteration.      *      * @param exchange the exchange to prepare      */
DECL|method|prepareOutToIn (Exchange exchange)
specifier|public
specifier|static
name|void
name|prepareOutToIn
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
comment|// we are routing using pipes and filters so we need to manually copy OUT to IN
if|if
condition|(
name|exchange
operator|.
name|hasOut
argument_list|()
condition|)
block|{
name|exchange
operator|.
name|setIn
argument_list|(
name|exchange
operator|.
name|getOut
argument_list|()
argument_list|)
expr_stmt|;
name|exchange
operator|.
name|setOut
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Gets both the messageId and exchangeId to be used for logging purposes.      *<p/>      * Logging both ids, can help to correlate exchanges which may be redelivered messages      * from for example a JMS broker.      *      * @param exchange the exchange      * @return a log message with both the messageId and exchangeId      */
DECL|method|logIds (Exchange exchange)
specifier|public
specifier|static
name|String
name|logIds
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|String
name|msgId
init|=
name|exchange
operator|.
name|hasOut
argument_list|()
condition|?
name|exchange
operator|.
name|getOut
argument_list|()
operator|.
name|getMessageId
argument_list|()
else|:
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getMessageId
argument_list|()
decl_stmt|;
return|return
literal|"(MessageId: "
operator|+
name|msgId
operator|+
literal|" on ExchangeId: "
operator|+
name|exchange
operator|.
name|getExchangeId
argument_list|()
operator|+
literal|")"
return|;
block|}
comment|/**      * Copies the exchange but the copy will be tied to the given context      *      * @param exchange  the source exchange      * @param context   the camel context      * @return a copy with the given camel context      */
DECL|method|copyExchangeAndSetCamelContext (Exchange exchange, CamelContext context)
specifier|public
specifier|static
name|Exchange
name|copyExchangeAndSetCamelContext
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|CamelContext
name|context
parameter_list|)
block|{
return|return
name|copyExchangeAndSetCamelContext
argument_list|(
name|exchange
argument_list|,
name|context
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Copies the exchange but the copy will be tied to the given context      *      * @param exchange  the source exchange      * @param context   the camel context      * @param handover  whether to handover on completions from the source to the copy      * @return a copy with the given camel context      */
DECL|method|copyExchangeAndSetCamelContext (Exchange exchange, CamelContext context, boolean handover)
specifier|public
specifier|static
name|Exchange
name|copyExchangeAndSetCamelContext
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|CamelContext
name|context
parameter_list|,
name|boolean
name|handover
parameter_list|)
block|{
name|DefaultExchange
name|answer
init|=
operator|new
name|DefaultExchange
argument_list|(
name|context
argument_list|,
name|exchange
operator|.
name|getPattern
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|exchange
operator|.
name|hasProperties
argument_list|()
condition|)
block|{
name|answer
operator|.
name|setProperties
argument_list|(
name|safeCopyProperties
argument_list|(
name|exchange
operator|.
name|getProperties
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|handover
condition|)
block|{
comment|// Need to hand over the completion for async invocation
name|exchange
operator|.
name|handoverCompletions
argument_list|(
name|answer
argument_list|)
expr_stmt|;
block|}
name|answer
operator|.
name|setIn
argument_list|(
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|copy
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|exchange
operator|.
name|hasOut
argument_list|()
condition|)
block|{
name|answer
operator|.
name|setOut
argument_list|(
name|exchange
operator|.
name|getOut
argument_list|()
operator|.
name|copy
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|answer
operator|.
name|setException
argument_list|(
name|exchange
operator|.
name|getException
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
comment|/**      * Replaces the existing message with the new message      *      * @param exchange  the exchange      * @param newMessage the new message      * @param outOnly    whether to replace the message as OUT message      */
DECL|method|replaceMessage (Exchange exchange, Message newMessage, boolean outOnly)
specifier|public
specifier|static
name|void
name|replaceMessage
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Message
name|newMessage
parameter_list|,
name|boolean
name|outOnly
parameter_list|)
block|{
name|Message
name|old
init|=
name|exchange
operator|.
name|hasOut
argument_list|()
condition|?
name|exchange
operator|.
name|getOut
argument_list|()
else|:
name|exchange
operator|.
name|getIn
argument_list|()
decl_stmt|;
if|if
condition|(
name|outOnly
operator|||
name|exchange
operator|.
name|hasOut
argument_list|()
condition|)
block|{
name|exchange
operator|.
name|setOut
argument_list|(
name|newMessage
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exchange
operator|.
name|setIn
argument_list|(
name|newMessage
argument_list|)
expr_stmt|;
block|}
comment|// need to de-reference old from the exchange so it can be GC
if|if
condition|(
name|old
operator|instanceof
name|MessageSupport
condition|)
block|{
operator|(
operator|(
name|MessageSupport
operator|)
name|old
operator|)
operator|.
name|setExchange
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Gets the original IN {@link Message} this Unit of Work was started with.      *<p/>      * The original message is only returned if the option {@link org.apache.camel.RuntimeConfiguration#isAllowUseOriginalMessage()}      * is enabled. If its disabled, then<tt>null</tt> is returned.      *      * @return the original IN {@link Message}, or<tt>null</tt> if using original message is disabled.      */
DECL|method|getOriginalInMessage (Exchange exchange)
specifier|public
specifier|static
name|Message
name|getOriginalInMessage
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|Message
name|answer
init|=
literal|null
decl_stmt|;
comment|// try parent first
name|UnitOfWork
name|uow
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|PARENT_UNIT_OF_WORK
argument_list|,
name|UnitOfWork
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|uow
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|uow
operator|.
name|getOriginalInMessage
argument_list|()
expr_stmt|;
block|}
comment|// fallback to the current exchange
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
name|uow
operator|=
name|exchange
operator|.
name|getUnitOfWork
argument_list|()
expr_stmt|;
if|if
condition|(
name|uow
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|uow
operator|.
name|getOriginalInMessage
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Resolve the component scheme (aka name) from the given endpoint uri      *      * @param uri  the endpoint uri      * @return     the component scheme (name), or<tt>null</tt> if not possible to resolve      */
DECL|method|resolveScheme (String uri)
specifier|public
specifier|static
name|String
name|resolveScheme
parameter_list|(
name|String
name|uri
parameter_list|)
block|{
name|String
name|scheme
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|uri
operator|!=
literal|null
condition|)
block|{
comment|// Use the URI prefix to find the component.
name|String
name|splitURI
index|[]
init|=
name|StringHelper
operator|.
name|splitOnCharacter
argument_list|(
name|uri
argument_list|,
literal|":"
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|splitURI
index|[
literal|1
index|]
operator|!=
literal|null
condition|)
block|{
name|scheme
operator|=
name|splitURI
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
return|return
name|scheme
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|safeCopyProperties (Map<String, Object> properties)
specifier|private
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|safeCopyProperties
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|properties
parameter_list|)
block|{
if|if
condition|(
name|properties
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|answer
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|properties
argument_list|)
decl_stmt|;
comment|// safe copy message history using a defensive copy
name|List
argument_list|<
name|MessageHistory
argument_list|>
name|history
init|=
operator|(
name|List
argument_list|<
name|MessageHistory
argument_list|>
operator|)
name|answer
operator|.
name|remove
argument_list|(
name|Exchange
operator|.
name|MESSAGE_HISTORY
argument_list|)
decl_stmt|;
if|if
condition|(
name|history
operator|!=
literal|null
condition|)
block|{
name|answer
operator|.
name|put
argument_list|(
name|Exchange
operator|.
name|MESSAGE_HISTORY
argument_list|,
operator|new
name|LinkedList
argument_list|<>
argument_list|(
name|history
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
block|}
end_class

end_unit

