begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.util.toolbox
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|toolbox
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Expression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|TypeConversionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|ExpressionBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
operator|.
name|aggregate
operator|.
name|AggregationStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
operator|.
name|aggregate
operator|.
name|CompletionAwareAggregationStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|processor
operator|.
name|aggregate
operator|.
name|TimeoutAwareAggregationStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ExchangeHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ObjectHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * The Flexible Aggregation Strategy is a highly customizable, fluently configurable aggregation strategy. It allows you to quickly   * allows you to quickly whip up an {@link AggregationStrategy} that is capable of performing the most typical aggregation duties,   * with zero Java code.   *<p/>  * It can perform the following logic:  *<ul>  *<li>Filtering results based on a defined {@link Predicate} written in any language, such as XPath, OGNL, Simple, Javascript, etc.</li>  *<li>Picking specific data elements for aggregation.</li>  *<li>Accumulating results in any designated {@link Collection} type, e.g. in a HashSet, LinkedList, ArrayList, etc.</li>  *<li>Storing the output in a specific place in the Exchange: a property, a header or in the body.</li>  *</ul>  *   * It also includes the ability to specify both aggregation batch completion actions and timeout actions, in an abbreviated manner.  *<p/>  * This Aggregation Strategy is suitable for usage in aggregate, split, multicast, enrich and recipient list EIPs.  *   */
end_comment

begin_class
DECL|class|FlexibleAggregationStrategy
specifier|public
class|class
name|FlexibleAggregationStrategy
parameter_list|<
name|E
extends|extends
name|Object
parameter_list|>
implements|implements
name|AggregationStrategy
implements|,
name|CompletionAwareAggregationStrategy
implements|,
name|TimeoutAwareAggregationStrategy
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|FlexibleAggregationStrategy
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|pickExpression
specifier|private
name|Expression
name|pickExpression
init|=
name|ExpressionBuilder
operator|.
name|bodyExpression
argument_list|()
decl_stmt|;
DECL|field|conditionPredicate
specifier|private
name|Predicate
name|conditionPredicate
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
DECL|field|collectionType
specifier|private
name|Class
argument_list|<
name|?
extends|extends
name|Collection
argument_list|>
name|collectionType
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|field|castAs
specifier|private
name|Class
argument_list|<
name|E
argument_list|>
name|castAs
init|=
operator|(
name|Class
argument_list|<
name|E
argument_list|>
operator|)
name|Object
operator|.
name|class
decl_stmt|;
DECL|field|storeNulls
specifier|private
name|boolean
name|storeNulls
decl_stmt|;
DECL|field|ignoreInvalidCasts
specifier|private
name|boolean
name|ignoreInvalidCasts
decl_stmt|;
comment|// = false
DECL|field|injector
specifier|private
name|FlexibleAggregationStrategyInjector
name|injector
init|=
operator|new
name|BodyInjector
argument_list|(
name|castAs
argument_list|)
decl_stmt|;
DECL|field|timeoutMixin
specifier|private
name|TimeoutAwareMixin
name|timeoutMixin
decl_stmt|;
DECL|field|completionMixin
specifier|private
name|CompletionAwareMixin
name|completionMixin
decl_stmt|;
comment|/**      * Initializes a new instance with {@link Object} as the {@link FlexibleAggregationStrategy#castAs} type.      */
DECL|method|FlexibleAggregationStrategy ()
specifier|public
name|FlexibleAggregationStrategy
parameter_list|()
block|{     }
comment|/**      * Initializes a new instance with the specified type as the {@link FlexibleAggregationStrategy#castAs} type.      * @param type The castAs type.      */
DECL|method|FlexibleAggregationStrategy (Class<E> type)
specifier|public
name|FlexibleAggregationStrategy
parameter_list|(
name|Class
argument_list|<
name|E
argument_list|>
name|type
parameter_list|)
block|{
name|this
operator|.
name|castAs
operator|=
name|type
expr_stmt|;
block|}
comment|/**      * Set an expression to extract the element to be aggregated from the incoming {@link Exchange}.      * All results are cast to the {@link FlexibleAggregationStrategy#castAs} type (or the type specified in the constructor).      *<p/>      * By default, it picks the full IN message body of the incoming exchange.       * @param expression The picking expression.      * @return This instance.      */
DECL|method|pick (Expression expression)
specifier|public
name|FlexibleAggregationStrategy
argument_list|<
name|E
argument_list|>
name|pick
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
name|this
operator|.
name|pickExpression
operator|=
name|expression
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Set a filter condition such as only results satisfying it will be aggregated.       * By default, all picked values will be processed.      * @param predicate The condition.      * @return This instance.      */
DECL|method|condition (Predicate predicate)
specifier|public
name|FlexibleAggregationStrategy
argument_list|<
name|E
argument_list|>
name|condition
parameter_list|(
name|Predicate
name|predicate
parameter_list|)
block|{
name|this
operator|.
name|conditionPredicate
operator|=
name|predicate
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Accumulate the result of the<i>pick expression</i> in a collection of the designated type.       * No<tt>null</tt>s will stored unless the {@link FlexibleAggregationStrategy#storeNulls()} option is enabled.      * @param collectionType The type of the Collection to aggregate into.      * @return This instance.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
DECL|method|accumulateInCollection (Class<? extends Collection> collectionType)
specifier|public
name|FlexibleAggregationStrategy
argument_list|<
name|E
argument_list|>
name|accumulateInCollection
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Collection
argument_list|>
name|collectionType
parameter_list|)
block|{
name|this
operator|.
name|collectionType
operator|=
name|collectionType
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Store the result of this Aggregation Strategy (whether an atomic element or a Collection) in a property with      * the designated name.      * @param propertyName The property name.      * @return This instance.      */
DECL|method|storeInProperty (String propertyName)
specifier|public
name|FlexibleAggregationStrategy
argument_list|<
name|E
argument_list|>
name|storeInProperty
parameter_list|(
name|String
name|propertyName
parameter_list|)
block|{
name|this
operator|.
name|injector
operator|=
operator|new
name|PropertyInjector
argument_list|(
name|castAs
argument_list|,
name|propertyName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Store the result of this Aggregation Strategy (whether an atomic element or a Collection) in an IN message header with      * the designated name.      * @param headerName The header name.      * @return This instance.      */
DECL|method|storeInHeader (String headerName)
specifier|public
name|FlexibleAggregationStrategy
argument_list|<
name|E
argument_list|>
name|storeInHeader
parameter_list|(
name|String
name|headerName
parameter_list|)
block|{
name|this
operator|.
name|injector
operator|=
operator|new
name|HeaderInjector
argument_list|(
name|castAs
argument_list|,
name|headerName
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Store the result of this Aggregation Strategy (whether an atomic element or a Collection) in the body of the IN message.      * @return This instance.      */
DECL|method|storeInBody ()
specifier|public
name|FlexibleAggregationStrategy
argument_list|<
name|E
argument_list|>
name|storeInBody
parameter_list|()
block|{
name|this
operator|.
name|injector
operator|=
operator|new
name|BodyInjector
argument_list|(
name|castAs
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Cast the result of the<i>pick expression</i> to this type.      * @param castAs Type for the cast.      * @return This instance.      */
DECL|method|castAs (Class<E> castAs)
specifier|public
name|FlexibleAggregationStrategy
argument_list|<
name|E
argument_list|>
name|castAs
parameter_list|(
name|Class
argument_list|<
name|E
argument_list|>
name|castAs
parameter_list|)
block|{
name|this
operator|.
name|castAs
operator|=
name|castAs
expr_stmt|;
name|injector
operator|.
name|setType
argument_list|(
name|castAs
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Enables storing null values in the resulting collection.      * By default, this aggregation strategy will drop null values.      * @return This instance.      */
DECL|method|storeNulls ()
specifier|public
name|FlexibleAggregationStrategy
argument_list|<
name|E
argument_list|>
name|storeNulls
parameter_list|()
block|{
name|this
operator|.
name|storeNulls
operator|=
literal|true
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Ignores invalid casts instead of throwing an exception if the<i>pick expression</i> result cannot be casted to the       * specified type.      * By default, this aggregation strategy will throw an exception if an invalid cast occurs.      * @return This instance.      */
DECL|method|ignoreInvalidCasts ()
specifier|public
name|FlexibleAggregationStrategy
argument_list|<
name|E
argument_list|>
name|ignoreInvalidCasts
parameter_list|()
block|{
name|this
operator|.
name|ignoreInvalidCasts
operator|=
literal|true
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Plugs in logic to execute when a timeout occurs.      * @param timeoutMixin      * @return This instance.      */
DECL|method|timeoutAware (TimeoutAwareMixin timeoutMixin)
specifier|public
name|FlexibleAggregationStrategy
argument_list|<
name|E
argument_list|>
name|timeoutAware
parameter_list|(
name|TimeoutAwareMixin
name|timeoutMixin
parameter_list|)
block|{
name|this
operator|.
name|timeoutMixin
operator|=
name|timeoutMixin
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Plugs in logic to execute when an aggregation batch completes.      * @param completionMixin      * @return This instance.      */
DECL|method|completionAware (CompletionAwareMixin completionMixin)
specifier|public
name|FlexibleAggregationStrategy
argument_list|<
name|E
argument_list|>
name|completionAware
parameter_list|(
name|CompletionAwareMixin
name|completionMixin
parameter_list|)
block|{
name|this
operator|.
name|completionMixin
operator|=
name|completionMixin
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|aggregate (Exchange oldExchange, Exchange newExchange)
specifier|public
name|Exchange
name|aggregate
parameter_list|(
name|Exchange
name|oldExchange
parameter_list|,
name|Exchange
name|newExchange
parameter_list|)
block|{
name|Exchange
name|exchange
init|=
name|oldExchange
decl_stmt|;
if|if
condition|(
name|exchange
operator|==
literal|null
condition|)
block|{
name|exchange
operator|=
name|ExchangeHelper
operator|.
name|createCorrelatedCopy
argument_list|(
name|newExchange
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|injector
operator|.
name|prepareAggregationExchange
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
comment|// 1. Apply the condition and reject the aggregation if unmatched
if|if
condition|(
name|conditionPredicate
operator|!=
literal|null
operator|&&
operator|!
name|conditionPredicate
operator|.
name|matches
argument_list|(
name|newExchange
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Dropped exchange {} from aggregation as predicate {} was not matched"
argument_list|,
name|newExchange
argument_list|,
name|conditionPredicate
argument_list|)
expr_stmt|;
return|return
name|exchange
return|;
block|}
comment|// 2. Pick the appropriate element of the incoming message, casting it to the specified class
comment|//    If null, act accordingly based on storeNulls
name|E
name|picked
init|=
literal|null
decl_stmt|;
try|try
block|{
name|picked
operator|=
name|pickExpression
operator|.
name|evaluate
argument_list|(
name|newExchange
argument_list|,
name|castAs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TypeConversionException
name|exception
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ignoreInvalidCasts
condition|)
block|{
throw|throw
name|exception
throw|;
block|}
block|}
if|if
condition|(
name|picked
operator|==
literal|null
operator|&&
operator|!
name|storeNulls
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Dropped exchange {} from aggregation as pick expression returned null and storing nulls is not enabled"
argument_list|,
name|newExchange
argument_list|)
expr_stmt|;
return|return
name|exchange
return|;
block|}
if|if
condition|(
name|collectionType
operator|==
literal|null
condition|)
block|{
name|injectAsRawValue
argument_list|(
name|exchange
argument_list|,
name|picked
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|injectAsCollection
argument_list|(
name|exchange
argument_list|,
name|picked
argument_list|,
name|collectionType
argument_list|)
expr_stmt|;
block|}
return|return
name|exchange
return|;
block|}
annotation|@
name|Override
DECL|method|timeout (Exchange oldExchange, int index, int total, long timeout)
specifier|public
name|void
name|timeout
parameter_list|(
name|Exchange
name|oldExchange
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|total
parameter_list|,
name|long
name|timeout
parameter_list|)
block|{
if|if
condition|(
name|timeoutMixin
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|timeoutMixin
operator|.
name|timeout
argument_list|(
name|oldExchange
argument_list|,
name|index
argument_list|,
name|total
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onCompletion (Exchange exchange)
specifier|public
name|void
name|onCompletion
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
name|completionMixin
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|completionMixin
operator|.
name|onCompletion
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
DECL|method|injectAsRawValue (Exchange oldExchange, E picked)
specifier|private
name|void
name|injectAsRawValue
parameter_list|(
name|Exchange
name|oldExchange
parameter_list|,
name|E
name|picked
parameter_list|)
block|{
name|injector
operator|.
name|setValue
argument_list|(
name|oldExchange
argument_list|,
name|picked
argument_list|)
expr_stmt|;
block|}
DECL|method|injectAsCollection (Exchange oldExchange, E picked, Class<? extends Collection> collectionType)
specifier|private
name|void
name|injectAsCollection
parameter_list|(
name|Exchange
name|oldExchange
parameter_list|,
name|E
name|picked
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Collection
argument_list|>
name|collectionType
parameter_list|)
block|{
name|Collection
argument_list|<
name|E
argument_list|>
name|col
init|=
name|injector
operator|.
name|getValueAsCollection
argument_list|(
name|oldExchange
argument_list|,
name|collectionType
argument_list|)
decl_stmt|;
name|col
operator|=
name|safeInsertIntoCollection
argument_list|(
name|oldExchange
argument_list|,
name|col
argument_list|,
name|picked
argument_list|)
expr_stmt|;
name|injector
operator|.
name|setValueAsCollection
argument_list|(
name|oldExchange
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|safeInsertIntoCollection (Exchange oldExchange, Collection<E> oldValue, E toInsert)
specifier|private
name|Collection
argument_list|<
name|E
argument_list|>
name|safeInsertIntoCollection
parameter_list|(
name|Exchange
name|oldExchange
parameter_list|,
name|Collection
argument_list|<
name|E
argument_list|>
name|oldValue
parameter_list|,
name|E
name|toInsert
parameter_list|)
block|{
name|Collection
argument_list|<
name|E
argument_list|>
name|collection
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|oldValue
operator|==
literal|null
operator|||
name|oldExchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_COLLECTION_GUARD
argument_list|,
name|Boolean
operator|.
name|class
argument_list|)
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|collection
operator|=
name|collectionType
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not instantiate collection of type {}. Aborting aggregation."
argument_list|,
name|collectionType
argument_list|)
expr_stmt|;
throw|throw
name|ObjectHelper
operator|.
name|wrapCamelExecutionException
argument_list|(
name|oldExchange
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|oldExchange
operator|.
name|setProperty
argument_list|(
name|Exchange
operator|.
name|AGGREGATED_COLLECTION_GUARD
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|collection
operator|=
name|collectionType
operator|.
name|cast
argument_list|(
name|oldValue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|collection
operator|!=
literal|null
condition|)
block|{
name|collection
operator|.
name|add
argument_list|(
name|toInsert
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|exception
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ignoreInvalidCasts
condition|)
block|{
throw|throw
name|exception
throw|;
block|}
block|}
return|return
name|collection
return|;
block|}
DECL|interface|TimeoutAwareMixin
specifier|public
interface|interface
name|TimeoutAwareMixin
block|{
DECL|method|timeout (Exchange exchange, int index, int total, long timeout)
name|void
name|timeout
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|total
parameter_list|,
name|long
name|timeout
parameter_list|)
function_decl|;
block|}
DECL|interface|CompletionAwareMixin
specifier|public
interface|interface
name|CompletionAwareMixin
block|{
DECL|method|onCompletion (Exchange exchange)
name|void
name|onCompletion
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
function_decl|;
block|}
DECL|class|FlexibleAggregationStrategyInjector
specifier|private
specifier|abstract
class|class
name|FlexibleAggregationStrategyInjector
block|{
DECL|field|type
specifier|protected
name|Class
argument_list|<
name|E
argument_list|>
name|type
decl_stmt|;
DECL|method|FlexibleAggregationStrategyInjector (Class<E> type)
name|FlexibleAggregationStrategyInjector
parameter_list|(
name|Class
argument_list|<
name|E
argument_list|>
name|type
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
DECL|method|setType (Class<E> type)
specifier|public
name|void
name|setType
parameter_list|(
name|Class
argument_list|<
name|E
argument_list|>
name|type
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
DECL|method|prepareAggregationExchange (Exchange exchange)
specifier|public
specifier|abstract
name|void
name|prepareAggregationExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
function_decl|;
DECL|method|getValue (Exchange exchange)
specifier|public
specifier|abstract
name|E
name|getValue
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
function_decl|;
DECL|method|setValue (Exchange exchange, E obj)
specifier|public
specifier|abstract
name|void
name|setValue
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|E
name|obj
parameter_list|)
function_decl|;
DECL|method|getValueAsCollection (Exchange exchange, Class<? extends Collection> type)
specifier|public
specifier|abstract
name|Collection
argument_list|<
name|E
argument_list|>
name|getValueAsCollection
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Collection
argument_list|>
name|type
parameter_list|)
function_decl|;
DECL|method|setValueAsCollection (Exchange exchange, Collection<E> obj)
specifier|public
specifier|abstract
name|void
name|setValueAsCollection
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Collection
argument_list|<
name|E
argument_list|>
name|obj
parameter_list|)
function_decl|;
block|}
DECL|class|PropertyInjector
specifier|private
class|class
name|PropertyInjector
extends|extends
name|FlexibleAggregationStrategyInjector
block|{
DECL|field|propertyName
specifier|private
name|String
name|propertyName
decl_stmt|;
DECL|method|PropertyInjector (Class<E> type, String propertyName)
name|PropertyInjector
parameter_list|(
name|Class
argument_list|<
name|E
argument_list|>
name|type
parameter_list|,
name|String
name|propertyName
parameter_list|)
block|{
name|super
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|this
operator|.
name|propertyName
operator|=
name|propertyName
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|prepareAggregationExchange (Exchange exchange)
specifier|public
name|void
name|prepareAggregationExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|exchange
operator|.
name|removeProperty
argument_list|(
name|propertyName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getValue (Exchange exchange)
specifier|public
name|E
name|getValue
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getProperty
argument_list|(
name|propertyName
argument_list|,
name|type
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setValue (Exchange exchange, E obj)
specifier|public
name|void
name|setValue
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|E
name|obj
parameter_list|)
block|{
name|exchange
operator|.
name|setProperty
argument_list|(
name|propertyName
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getValueAsCollection (Exchange exchange, Class<? extends Collection> type)
specifier|public
name|Collection
argument_list|<
name|E
argument_list|>
name|getValueAsCollection
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Collection
argument_list|>
name|type
parameter_list|)
block|{
name|Object
name|value
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
comment|// empty so create a new collection to host this
return|return
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getInjector
argument_list|()
operator|.
name|newInstance
argument_list|(
name|type
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|exchange
operator|.
name|getProperty
argument_list|(
name|propertyName
argument_list|,
name|type
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|setValueAsCollection (Exchange exchange, Collection<E> obj)
specifier|public
name|void
name|setValueAsCollection
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Collection
argument_list|<
name|E
argument_list|>
name|obj
parameter_list|)
block|{
name|exchange
operator|.
name|setProperty
argument_list|(
name|propertyName
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|HeaderInjector
specifier|private
class|class
name|HeaderInjector
extends|extends
name|FlexibleAggregationStrategyInjector
block|{
DECL|field|headerName
specifier|private
name|String
name|headerName
decl_stmt|;
DECL|method|HeaderInjector (Class<E> type, String headerName)
name|HeaderInjector
parameter_list|(
name|Class
argument_list|<
name|E
argument_list|>
name|type
parameter_list|,
name|String
name|headerName
parameter_list|)
block|{
name|super
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|this
operator|.
name|headerName
operator|=
name|headerName
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|prepareAggregationExchange (Exchange exchange)
specifier|public
name|void
name|prepareAggregationExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|removeHeader
argument_list|(
name|headerName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getValue (Exchange exchange)
specifier|public
name|E
name|getValue
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|headerName
argument_list|,
name|type
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setValue (Exchange exchange, E obj)
specifier|public
name|void
name|setValue
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|E
name|obj
parameter_list|)
block|{
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|setHeader
argument_list|(
name|headerName
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getValueAsCollection (Exchange exchange, Class<? extends Collection> type)
specifier|public
name|Collection
argument_list|<
name|E
argument_list|>
name|getValueAsCollection
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Collection
argument_list|>
name|type
parameter_list|)
block|{
name|Object
name|value
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|headerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
comment|// empty so create a new collection to host this
return|return
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getInjector
argument_list|()
operator|.
name|newInstance
argument_list|(
name|type
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|headerName
argument_list|,
name|type
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|setValueAsCollection (Exchange exchange, Collection<E> obj)
specifier|public
name|void
name|setValueAsCollection
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Collection
argument_list|<
name|E
argument_list|>
name|obj
parameter_list|)
block|{
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|setHeader
argument_list|(
name|headerName
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|BodyInjector
specifier|private
class|class
name|BodyInjector
extends|extends
name|FlexibleAggregationStrategyInjector
block|{
DECL|method|BodyInjector (Class<E> type)
name|BodyInjector
parameter_list|(
name|Class
argument_list|<
name|E
argument_list|>
name|type
parameter_list|)
block|{
name|super
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|prepareAggregationExchange (Exchange exchange)
specifier|public
name|void
name|prepareAggregationExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|setBody
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getValue (Exchange exchange)
specifier|public
name|E
name|getValue
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|(
name|type
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setValue (Exchange exchange, E obj)
specifier|public
name|void
name|setValue
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|E
name|obj
parameter_list|)
block|{
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|setBody
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getValueAsCollection (Exchange exchange, Class<? extends Collection> type)
specifier|public
name|Collection
argument_list|<
name|E
argument_list|>
name|getValueAsCollection
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Collection
argument_list|>
name|type
parameter_list|)
block|{
name|Object
name|value
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
comment|// empty so create a new collection to host this
return|return
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getInjector
argument_list|()
operator|.
name|newInstance
argument_list|(
name|type
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|(
name|type
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|setValueAsCollection (Exchange exchange, Collection<E> obj)
specifier|public
name|void
name|setValueAsCollection
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Collection
argument_list|<
name|E
argument_list|>
name|obj
parameter_list|)
block|{
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|setBody
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

