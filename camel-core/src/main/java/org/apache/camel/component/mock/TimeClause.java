begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.component.mock
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|mock
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Expression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|BinaryPredicateSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Represents time based clauses for setting expectations on the mocks.  * Such as time constrains for the received messages.  *  * @version   */
end_comment

begin_class
DECL|class|TimeClause
specifier|public
class|class
name|TimeClause
extends|extends
name|BinaryPredicateSupport
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TimeClause
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|timeFrom
specifier|private
name|Time
name|timeFrom
decl_stmt|;
DECL|field|timeTo
specifier|private
name|Time
name|timeTo
decl_stmt|;
DECL|field|beforeNext
specifier|private
name|boolean
name|beforeNext
decl_stmt|;
DECL|field|was
specifier|private
name|String
name|was
decl_stmt|;
DECL|method|TimeClause (Expression left, Expression right)
specifier|public
name|TimeClause
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
comment|// previous, next
name|super
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
comment|// TimeUnit DSL
comment|// -------------------------------------------------------------------------
DECL|class|TimeClassUnit
specifier|public
class|class
name|TimeClassUnit
block|{
DECL|field|clause
specifier|private
specifier|final
name|TimeClause
name|clause
decl_stmt|;
DECL|field|from
specifier|private
name|int
name|from
decl_stmt|;
DECL|field|to
specifier|private
name|int
name|to
decl_stmt|;
DECL|method|TimeClassUnit (TimeClause clause, int to)
specifier|public
name|TimeClassUnit
parameter_list|(
name|TimeClause
name|clause
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|this
argument_list|(
name|clause
argument_list|,
operator|-
literal|1
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
DECL|method|TimeClassUnit (TimeClause clause, int from, int to)
specifier|public
name|TimeClassUnit
parameter_list|(
name|TimeClause
name|clause
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|this
operator|.
name|clause
operator|=
name|clause
expr_stmt|;
name|this
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|this
operator|.
name|to
operator|=
name|to
expr_stmt|;
block|}
DECL|method|millis ()
specifier|public
name|TimeClause
name|millis
parameter_list|()
block|{
name|period
argument_list|(
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
return|return
name|clause
return|;
block|}
DECL|method|seconds ()
specifier|public
name|TimeClause
name|seconds
parameter_list|()
block|{
name|period
argument_list|(
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
return|return
name|clause
return|;
block|}
DECL|method|minutes ()
specifier|public
name|TimeClause
name|minutes
parameter_list|()
block|{
name|period
argument_list|(
name|TimeUnit
operator|.
name|MINUTES
argument_list|)
expr_stmt|;
return|return
name|clause
return|;
block|}
DECL|method|period (TimeUnit unit)
specifier|private
name|void
name|period
parameter_list|(
name|TimeUnit
name|unit
parameter_list|)
block|{
if|if
condition|(
name|from
operator|>
literal|0
condition|)
block|{
name|timeFrom
operator|=
operator|new
name|Time
argument_list|(
name|from
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
name|timeTo
operator|=
operator|new
name|Time
argument_list|(
name|to
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
comment|// DSL
comment|// -------------------------------------------------------------------------
DECL|method|noLaterThan (int period)
specifier|public
name|TimeClassUnit
name|noLaterThan
parameter_list|(
name|int
name|period
parameter_list|)
block|{
name|TimeClassUnit
name|unit
init|=
operator|new
name|TimeClassUnit
argument_list|(
name|this
argument_list|,
name|period
argument_list|)
decl_stmt|;
return|return
name|unit
return|;
block|}
DECL|method|between (int from, int to)
specifier|public
name|TimeClassUnit
name|between
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|TimeClassUnit
name|unit
init|=
operator|new
name|TimeClassUnit
argument_list|(
name|this
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
decl_stmt|;
return|return
name|unit
return|;
block|}
DECL|method|beforeNext ()
specifier|public
name|void
name|beforeNext
parameter_list|()
block|{
name|this
operator|.
name|beforeNext
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|afterPrevious ()
specifier|public
name|void
name|afterPrevious
parameter_list|()
block|{
name|this
operator|.
name|beforeNext
operator|=
literal|false
expr_stmt|;
block|}
comment|// Implementation
comment|// -------------------------------------------------------------------------
DECL|method|matches (Exchange exchange, Object leftValue, Object rightValue)
specifier|protected
name|boolean
name|matches
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|leftValue
parameter_list|,
name|Object
name|rightValue
parameter_list|)
block|{
name|was
operator|=
literal|null
expr_stmt|;
name|boolean
name|answer
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|timeTo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The time period has not been set. Ensure to include the time unit as well."
argument_list|)
throw|;
block|}
name|Date
name|currentDate
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
name|Exchange
operator|.
name|RECEIVED_TIMESTAMP
argument_list|,
name|Date
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// the other date is either the previous or the next
name|Date
name|otherDate
decl_stmt|;
if|if
condition|(
name|beforeNext
condition|)
block|{
comment|// grab the previous value (left)
if|if
condition|(
name|leftValue
operator|!=
literal|null
condition|)
block|{
name|otherDate
operator|=
operator|(
name|Date
operator|)
name|leftValue
expr_stmt|;
block|}
else|else
block|{
comment|// we hit a boundary so grab the other
name|otherDate
operator|=
operator|(
name|Date
operator|)
name|rightValue
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// grab the next value (right)
if|if
condition|(
name|rightValue
operator|!=
literal|null
condition|)
block|{
name|otherDate
operator|=
operator|(
name|Date
operator|)
name|rightValue
expr_stmt|;
block|}
else|else
block|{
comment|// we hit a boundary so grab the other
name|otherDate
operator|=
operator|(
name|Date
operator|)
name|leftValue
expr_stmt|;
block|}
block|}
comment|// if we could not grab the value, we hit a boundary (ie. either 0 message or last message)
if|if
condition|(
name|otherDate
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// compute if we were within the allowed time range
name|Time
name|current
init|=
operator|new
name|Time
argument_list|(
name|currentDate
operator|.
name|getTime
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
name|Time
name|other
init|=
operator|new
name|Time
argument_list|(
name|otherDate
operator|.
name|getTime
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
comment|// must absolute delta as when we hit the boundaries the delta would negative
name|long
name|delta
init|=
name|Math
operator|.
name|abs
argument_list|(
name|other
operator|.
name|toMillis
argument_list|()
operator|-
name|current
operator|.
name|toMillis
argument_list|()
argument_list|)
decl_stmt|;
name|was
operator|=
literal|"delta: "
operator|+
name|delta
operator|+
literal|" millis"
expr_stmt|;
if|if
condition|(
name|timeFrom
operator|!=
literal|null
condition|)
block|{
name|long
name|from
init|=
name|timeFrom
operator|.
name|toMillis
argument_list|()
decl_stmt|;
name|answer
operator|=
name|delta
operator|>=
name|from
expr_stmt|;
block|}
if|if
condition|(
name|answer
condition|)
block|{
name|long
name|to
init|=
name|timeTo
operator|.
name|toMillis
argument_list|()
decl_stmt|;
name|answer
operator|=
name|delta
operator|<=
name|to
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Evaluated time clause [{}] with current: {}, other: {} -> {}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|toString
argument_list|()
block|,
name|currentDate
block|,
name|otherDate
block|,
name|answer
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
annotation|@
name|Override
DECL|method|getOperationText ()
specifier|protected
name|String
name|getOperationText
parameter_list|()
block|{
return|return
name|beforeNext
condition|?
literal|"before next"
else|:
literal|"after previous"
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|timeFrom
operator|==
literal|null
condition|)
block|{
return|return
literal|"no later than "
operator|+
name|timeTo
operator|+
literal|" "
operator|+
name|getOperationText
argument_list|()
operator|+
literal|" ("
operator|+
name|was
operator|+
literal|")"
return|;
block|}
else|else
block|{
return|return
literal|"between "
operator|+
name|timeFrom
operator|.
name|getNumber
argument_list|()
operator|+
literal|"-"
operator|+
name|timeTo
operator|.
name|getNumber
argument_list|()
operator|+
literal|" "
operator|+
name|timeTo
operator|.
name|getTimeUnit
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
operator|+
literal|" "
operator|+
name|getOperationText
argument_list|()
operator|+
literal|" ("
operator|+
name|was
operator|+
literal|")"
return|;
block|}
block|}
block|}
end_class

end_unit

