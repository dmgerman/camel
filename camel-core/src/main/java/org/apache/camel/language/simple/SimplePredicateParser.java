begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.language.simple
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|language
operator|.
name|simple
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Expression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|PredicateBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|language
operator|.
name|simple
operator|.
name|ast
operator|.
name|BinaryExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|language
operator|.
name|simple
operator|.
name|ast
operator|.
name|DoubleQuoteEnd
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|language
operator|.
name|simple
operator|.
name|ast
operator|.
name|DoubleQuoteStart
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|language
operator|.
name|simple
operator|.
name|ast
operator|.
name|LiteralExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|language
operator|.
name|simple
operator|.
name|ast
operator|.
name|LiteralNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|language
operator|.
name|simple
operator|.
name|ast
operator|.
name|LogicalExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|language
operator|.
name|simple
operator|.
name|ast
operator|.
name|NullExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|language
operator|.
name|simple
operator|.
name|ast
operator|.
name|SimpleFunctionEnd
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|language
operator|.
name|simple
operator|.
name|ast
operator|.
name|SimpleFunctionStart
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|language
operator|.
name|simple
operator|.
name|ast
operator|.
name|SimpleNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|language
operator|.
name|simple
operator|.
name|ast
operator|.
name|SingleQuoteEnd
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|language
operator|.
name|simple
operator|.
name|ast
operator|.
name|SingleQuoteStart
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|language
operator|.
name|simple
operator|.
name|ast
operator|.
name|UnaryExpression
import|;
end_import

begin_comment
comment|/**  * A parser to parse simple language as a Camel {@link Predicate}  */
end_comment

begin_class
DECL|class|SimplePredicateParser
specifier|public
class|class
name|SimplePredicateParser
extends|extends
name|BaseSimpleParser
block|{
DECL|method|SimplePredicateParser (String expression)
specifier|public
name|SimplePredicateParser
parameter_list|(
name|String
name|expression
parameter_list|)
block|{
name|super
argument_list|(
name|expression
argument_list|)
expr_stmt|;
block|}
DECL|method|parsePredicate ()
specifier|public
name|Predicate
name|parsePredicate
parameter_list|()
block|{
name|clear
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|doParsePredicate
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SimpleParserException
name|e
parameter_list|)
block|{
comment|// catch parser exception and turn that into a syntax exceptions
throw|throw
operator|new
name|SimpleIllegalSyntaxException
argument_list|(
name|expression
argument_list|,
name|e
operator|.
name|getIndex
argument_list|()
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// include exception in rethrown exception
throw|throw
operator|new
name|SimpleIllegalSyntaxException
argument_list|(
name|expression
argument_list|,
operator|-
literal|1
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|doParsePredicate ()
specifier|protected
name|Predicate
name|doParsePredicate
parameter_list|()
block|{
comment|// parse using the following grammar
name|nextToken
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isEol
argument_list|()
condition|)
block|{
comment|// predicate supports quotes, functions, operators and whitespaces
comment|//CHECKSTYLE:OFF
if|if
condition|(
operator|!
name|singleQuotedLiteralWithFunctionsText
argument_list|()
operator|&&
operator|!
name|doubleQuotedLiteralWithFunctionsText
argument_list|()
operator|&&
operator|!
name|functionText
argument_list|()
operator|&&
operator|!
name|unaryOperator
argument_list|()
operator|&&
operator|!
name|binaryOperator
argument_list|()
operator|&&
operator|!
name|logicalOperator
argument_list|()
operator|&&
operator|!
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isWhitespace
argument_list|()
operator|&&
operator|!
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isEol
argument_list|()
condition|)
block|{
comment|// okay the symbol was not one of the above, so its not supported
comment|// use the previous index as that is where the problem is
throw|throw
operator|new
name|SimpleParserException
argument_list|(
literal|"Unexpected token "
operator|+
name|token
argument_list|,
name|previousIndex
argument_list|)
throw|;
block|}
comment|//CHECKSTYLE:ON
comment|// take the next token
name|nextToken
argument_list|()
expr_stmt|;
block|}
comment|// now after parsing we need a bit of work to do, to make it easier to turn the tokens
comment|// into and ast, and then from the ast, to Camel predicate(s).
comment|// hence why there is a number of tasks going on below to accomplish this
comment|// remove any ignorable white space tokens
name|removeIgnorableWhiteSpaceTokens
argument_list|()
expr_stmt|;
comment|// turn the tokens into the ast model
name|parseTokensAndCreateNodes
argument_list|()
expr_stmt|;
comment|// compact and stack blocks (eg function start/end, quotes start/end, etc.)
name|prepareBlocks
argument_list|()
expr_stmt|;
comment|// compact and stack unary expressions
name|prepareUnaryExpressions
argument_list|()
expr_stmt|;
comment|// compact and stack binary expressions
name|prepareBinaryExpressions
argument_list|()
expr_stmt|;
comment|// compact and stack logical expressions
name|prepareLogicalExpressions
argument_list|()
expr_stmt|;
comment|// create and return as a Camel predicate
name|List
argument_list|<
name|Predicate
argument_list|>
name|predicates
init|=
name|createPredicates
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicates
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|predicates
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|predicates
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|PredicateBuilder
operator|.
name|and
argument_list|(
name|predicates
argument_list|)
return|;
block|}
block|}
comment|/**      * Parses the tokens and crates the AST nodes.      *<p/>      * After the initial parsing of the input (input -> tokens) then we      * parse again (tokens -> ast).      *<p/>      * In this parsing the balance of the blocks is checked, so that each block has a matching      * start and end token. For example a single quote block, or a function block etc.      */
DECL|method|parseTokensAndCreateNodes ()
specifier|protected
name|void
name|parseTokensAndCreateNodes
parameter_list|()
block|{
comment|// we loop the tokens and create a sequence of ast nodes
comment|// we need to keep a bit of state for keeping track of single and double quotes
comment|// which need to be balanced and have matching start/end pairs
name|SimpleNode
name|lastSingle
init|=
literal|null
decl_stmt|;
name|SimpleNode
name|lastDouble
init|=
literal|null
decl_stmt|;
name|SimpleNode
name|lastFunction
init|=
literal|null
decl_stmt|;
name|AtomicBoolean
name|startSingle
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|AtomicBoolean
name|startDouble
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|AtomicBoolean
name|startFunction
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|LiteralNode
name|imageToken
init|=
literal|null
decl_stmt|;
for|for
control|(
name|SimpleToken
name|token
range|:
name|tokens
control|)
block|{
comment|// break if eol
if|if
condition|(
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isEol
argument_list|()
condition|)
block|{
break|break;
block|}
comment|// create a node from the token
name|SimpleNode
name|node
init|=
name|createNode
argument_list|(
name|token
argument_list|,
name|startSingle
argument_list|,
name|startDouble
argument_list|,
name|startFunction
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
comment|// keep state of last single/double
if|if
condition|(
name|node
operator|instanceof
name|SingleQuoteStart
condition|)
block|{
name|lastSingle
operator|=
name|node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|instanceof
name|DoubleQuoteStart
condition|)
block|{
name|lastDouble
operator|=
name|node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|instanceof
name|SimpleFunctionStart
condition|)
block|{
name|lastFunction
operator|=
name|node
expr_stmt|;
block|}
comment|// a new token was created so the current image token need to be added first
if|if
condition|(
name|imageToken
operator|!=
literal|null
condition|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|imageToken
argument_list|)
expr_stmt|;
name|imageToken
operator|=
literal|null
expr_stmt|;
block|}
comment|// and then add the created node
name|nodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// continue to next
continue|continue;
block|}
comment|// if no token was created then its a character/whitespace/escaped symbol
comment|// which we need to add together in the same image
if|if
condition|(
name|imageToken
operator|==
literal|null
condition|)
block|{
name|imageToken
operator|=
operator|new
name|LiteralExpression
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
name|imageToken
operator|.
name|addText
argument_list|(
name|token
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// append any leftover image tokens (when we reached eol)
if|if
condition|(
name|imageToken
operator|!=
literal|null
condition|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|imageToken
argument_list|)
expr_stmt|;
block|}
comment|// validate the single, double quote pairs and functions is in balance
if|if
condition|(
name|startSingle
operator|.
name|get
argument_list|()
condition|)
block|{
name|int
name|index
init|=
name|lastSingle
operator|!=
literal|null
condition|?
name|lastSingle
operator|.
name|getToken
argument_list|()
operator|.
name|getIndex
argument_list|()
else|:
literal|0
decl_stmt|;
throw|throw
operator|new
name|SimpleParserException
argument_list|(
literal|"single quote has no ending quote"
argument_list|,
name|index
argument_list|)
throw|;
block|}
if|if
condition|(
name|startDouble
operator|.
name|get
argument_list|()
condition|)
block|{
name|int
name|index
init|=
name|lastDouble
operator|!=
literal|null
condition|?
name|lastDouble
operator|.
name|getToken
argument_list|()
operator|.
name|getIndex
argument_list|()
else|:
literal|0
decl_stmt|;
throw|throw
operator|new
name|SimpleParserException
argument_list|(
literal|"double quote has no ending quote"
argument_list|,
name|index
argument_list|)
throw|;
block|}
if|if
condition|(
name|startFunction
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// we have a start function, but no ending function
name|int
name|index
init|=
name|lastFunction
operator|!=
literal|null
condition|?
name|lastFunction
operator|.
name|getToken
argument_list|()
operator|.
name|getIndex
argument_list|()
else|:
literal|0
decl_stmt|;
throw|throw
operator|new
name|SimpleParserException
argument_list|(
literal|"function has no ending token"
argument_list|,
name|index
argument_list|)
throw|;
block|}
block|}
comment|/**      * Creates a node from the given token      *      * @param token         the token      * @param startSingle   state of single quoted blocks      * @param startDouble   state of double quoted blocks      * @param startFunction state of function blocks      * @return the created node, or<tt>null</tt> to let a default node be created instead.      */
DECL|method|createNode (SimpleToken token, AtomicBoolean startSingle, AtomicBoolean startDouble, AtomicBoolean startFunction)
specifier|private
name|SimpleNode
name|createNode
parameter_list|(
name|SimpleToken
name|token
parameter_list|,
name|AtomicBoolean
name|startSingle
parameter_list|,
name|AtomicBoolean
name|startDouble
parameter_list|,
name|AtomicBoolean
name|startFunction
parameter_list|)
block|{
if|if
condition|(
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isFunctionStart
argument_list|()
condition|)
block|{
name|startFunction
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
operator|new
name|SimpleFunctionStart
argument_list|(
name|token
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isFunctionEnd
argument_list|()
condition|)
block|{
name|startFunction
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
operator|new
name|SimpleFunctionEnd
argument_list|(
name|token
argument_list|)
return|;
block|}
comment|// if we are inside a function, then we do not support any other kind of tokens
comment|// as we want all the tokens to be literal instead
if|if
condition|(
name|startFunction
operator|.
name|get
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// okay so far we also want to support quotes
if|if
condition|(
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isSingleQuote
argument_list|()
condition|)
block|{
name|SimpleNode
name|answer
decl_stmt|;
name|boolean
name|start
init|=
name|startSingle
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|start
condition|)
block|{
name|answer
operator|=
operator|new
name|SingleQuoteStart
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|answer
operator|=
operator|new
name|SingleQuoteEnd
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
comment|// flip state on start/end flag
name|startSingle
operator|.
name|set
argument_list|(
operator|!
name|start
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isDoubleQuote
argument_list|()
condition|)
block|{
name|SimpleNode
name|answer
decl_stmt|;
name|boolean
name|start
init|=
name|startDouble
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|start
condition|)
block|{
name|answer
operator|=
operator|new
name|DoubleQuoteStart
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|answer
operator|=
operator|new
name|DoubleQuoteEnd
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
comment|// flip state on start/end flag
name|startDouble
operator|.
name|set
argument_list|(
operator|!
name|start
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
comment|// if we are inside a quote, then we do not support any further kind of tokens
comment|// as we want to only support embedded functions and all other kinds to be literal tokens
if|if
condition|(
name|startSingle
operator|.
name|get
argument_list|()
operator|||
name|startDouble
operator|.
name|get
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// okay we are not inside a function or quote, so we want to support operators
comment|// and the special null value as well
if|if
condition|(
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isUnary
argument_list|()
condition|)
block|{
return|return
operator|new
name|UnaryExpression
argument_list|(
name|token
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isBinary
argument_list|()
condition|)
block|{
return|return
operator|new
name|BinaryExpression
argument_list|(
name|token
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isLogical
argument_list|()
condition|)
block|{
return|return
operator|new
name|LogicalExpression
argument_list|(
name|token
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isNullValue
argument_list|()
condition|)
block|{
return|return
operator|new
name|NullExpression
argument_list|(
name|token
argument_list|)
return|;
block|}
comment|// by returning null, we will let the parser determine what to do
return|return
literal|null
return|;
block|}
comment|/**      * Removes any ignorable whitespace tokens.      *<p/>      * During the initial parsing (input -> tokens), then there may      * be excessive whitespace tokens, which can safely be removed,      * which makes the succeeding parsing easier.      */
DECL|method|removeIgnorableWhiteSpaceTokens ()
specifier|private
name|void
name|removeIgnorableWhiteSpaceTokens
parameter_list|()
block|{
comment|// white space can be removed if its not part of a quoted text
name|boolean
name|quote
init|=
literal|false
decl_stmt|;
name|Iterator
argument_list|<
name|SimpleToken
argument_list|>
name|it
init|=
name|tokens
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|SimpleToken
name|token
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isSingleQuote
argument_list|()
condition|)
block|{
name|quote
operator|=
operator|!
name|quote
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isWhitespace
argument_list|()
operator|&&
operator|!
name|quote
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Prepares binary expressions.      *<p/>      * This process prepares the binary expressions in the AST. This is done      * by linking the binary operator with both the right and left hand side      * nodes, to have the AST graph updated and prepared properly.      *<p/>      * So when the AST node is later used to create the {@link Predicate}s      * to be used by Camel then the AST graph has a linked and prepared      * graph of nodes which represent the input expression.      */
DECL|method|prepareBinaryExpressions ()
specifier|private
name|void
name|prepareBinaryExpressions
parameter_list|()
block|{
name|Stack
argument_list|<
name|SimpleNode
argument_list|>
name|stack
init|=
operator|new
name|Stack
argument_list|<
name|SimpleNode
argument_list|>
argument_list|()
decl_stmt|;
name|SimpleNode
name|left
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|left
operator|==
literal|null
condition|)
block|{
name|left
operator|=
name|i
operator|>
literal|0
condition|?
name|nodes
operator|.
name|get
argument_list|(
name|i
operator|-
literal|1
argument_list|)
else|:
literal|null
expr_stmt|;
block|}
name|SimpleNode
name|token
init|=
name|nodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|SimpleNode
name|right
init|=
name|i
operator|<
name|nodes
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|?
name|nodes
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|token
operator|instanceof
name|BinaryExpression
condition|)
block|{
name|BinaryExpression
name|binary
init|=
operator|(
name|BinaryExpression
operator|)
name|token
decl_stmt|;
comment|// remember the binary operator
name|String
name|operator
init|=
name|binary
operator|.
name|getOperator
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|left
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SimpleParserException
argument_list|(
literal|"Binary operator "
operator|+
name|operator
operator|+
literal|" has no left hand side token"
argument_list|,
name|token
operator|.
name|getToken
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|binary
operator|.
name|acceptLeftNode
argument_list|(
name|left
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SimpleParserException
argument_list|(
literal|"Binary operator "
operator|+
name|operator
operator|+
literal|" does not support left hand side token "
operator|+
name|left
operator|.
name|getToken
argument_list|()
argument_list|,
name|token
operator|.
name|getToken
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|right
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SimpleParserException
argument_list|(
literal|"Binary operator "
operator|+
name|operator
operator|+
literal|" has no right hand side token"
argument_list|,
name|token
operator|.
name|getToken
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|binary
operator|.
name|acceptRightNode
argument_list|(
name|right
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SimpleParserException
argument_list|(
literal|"Binary operator "
operator|+
name|operator
operator|+
literal|" does not support right hand side token "
operator|+
name|right
operator|.
name|getToken
argument_list|()
argument_list|,
name|token
operator|.
name|getToken
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|)
throw|;
block|}
comment|// pop previous as we need to replace it with this binary operator
name|stack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|token
argument_list|)
expr_stmt|;
comment|// advantage after the right hand side
name|i
operator|++
expr_stmt|;
comment|// this token is now the left for the next loop
name|left
operator|=
name|token
expr_stmt|;
block|}
else|else
block|{
comment|// clear left
name|left
operator|=
literal|null
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
block|}
name|nodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|nodes
operator|.
name|addAll
argument_list|(
name|stack
argument_list|)
expr_stmt|;
block|}
comment|/**      * Prepares logical expressions.      *<p/>      * This process prepares the logical expressions in the AST. This is done      * by linking the logical operator with both the right and left hand side      * nodes, to have the AST graph updated and prepared properly.      *<p/>      * So when the AST node is later used to create the {@link Predicate}s      * to be used by Camel then the AST graph has a linked and prepared      * graph of nodes which represent the input expression.      */
DECL|method|prepareLogicalExpressions ()
specifier|private
name|void
name|prepareLogicalExpressions
parameter_list|()
block|{
name|Stack
argument_list|<
name|SimpleNode
argument_list|>
name|stack
init|=
operator|new
name|Stack
argument_list|<
name|SimpleNode
argument_list|>
argument_list|()
decl_stmt|;
name|SimpleNode
name|left
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|left
operator|==
literal|null
condition|)
block|{
name|left
operator|=
name|i
operator|>
literal|0
condition|?
name|nodes
operator|.
name|get
argument_list|(
name|i
operator|-
literal|1
argument_list|)
else|:
literal|null
expr_stmt|;
block|}
name|SimpleNode
name|token
init|=
name|nodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|SimpleNode
name|right
init|=
name|i
operator|<
name|nodes
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|?
name|nodes
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|token
operator|instanceof
name|LogicalExpression
condition|)
block|{
name|LogicalExpression
name|logical
init|=
operator|(
name|LogicalExpression
operator|)
name|token
decl_stmt|;
comment|// remember the logical operator
name|String
name|operator
init|=
name|logical
operator|.
name|getOperator
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|left
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SimpleParserException
argument_list|(
literal|"Logical operator "
operator|+
name|operator
operator|+
literal|" has no left hand side token"
argument_list|,
name|token
operator|.
name|getToken
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|logical
operator|.
name|acceptLeftNode
argument_list|(
name|left
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SimpleParserException
argument_list|(
literal|"Logical operator "
operator|+
name|operator
operator|+
literal|" does not support left hand side token "
operator|+
name|left
operator|.
name|getToken
argument_list|()
argument_list|,
name|token
operator|.
name|getToken
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|right
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SimpleParserException
argument_list|(
literal|"Logical operator "
operator|+
name|operator
operator|+
literal|" has no right hand side token"
argument_list|,
name|token
operator|.
name|getToken
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|logical
operator|.
name|acceptRightNode
argument_list|(
name|right
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SimpleParserException
argument_list|(
literal|"Logical operator "
operator|+
name|operator
operator|+
literal|" does not support right hand side token "
operator|+
name|left
operator|.
name|getToken
argument_list|()
argument_list|,
name|token
operator|.
name|getToken
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|)
throw|;
block|}
comment|// pop previous as we need to replace it with this binary operator
name|stack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|token
argument_list|)
expr_stmt|;
comment|// advantage after the right hand side
name|i
operator|++
expr_stmt|;
comment|// this token is now the left for the next loop
name|left
operator|=
name|token
expr_stmt|;
block|}
else|else
block|{
comment|// clear left
name|left
operator|=
literal|null
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
block|}
name|nodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|nodes
operator|.
name|addAll
argument_list|(
name|stack
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates the {@link Predicate}s from the AST nodes.      *      * @return the created {@link Predicate}s, is never<tt>null</tt>.      */
DECL|method|createPredicates ()
specifier|private
name|List
argument_list|<
name|Predicate
argument_list|>
name|createPredicates
parameter_list|()
block|{
name|List
argument_list|<
name|Predicate
argument_list|>
name|answer
init|=
operator|new
name|ArrayList
argument_list|<
name|Predicate
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SimpleNode
name|node
range|:
name|nodes
control|)
block|{
name|Expression
name|exp
init|=
name|node
operator|.
name|createExpression
argument_list|(
name|expression
argument_list|)
decl_stmt|;
if|if
condition|(
name|exp
operator|!=
literal|null
condition|)
block|{
name|Predicate
name|predicate
init|=
name|PredicateBuilder
operator|.
name|toPredicate
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|answer
operator|.
name|add
argument_list|(
name|predicate
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
comment|// --------------------------------------------------------------
comment|// grammar
comment|// --------------------------------------------------------------
comment|// the predicate parser understands a lot more than the expression parser
comment|// - single quoted = block of nodes enclosed by single quotes
comment|// - double quoted = block of nodes enclosed by double quotes
comment|// - single quoted with functions = block of nodes enclosed by single quotes allowing embedded functions
comment|// - double quoted with functions = block of nodes enclosed by double quotes allowing embedded functions
comment|// - function = simple functions such as ${body} etc
comment|// - numeric = numeric value
comment|// - boolean = boolean value
comment|// - null = null value
comment|// - unary operator = operator attached to the left hand side node
comment|// - binary operator = operator attached to both the left and right hand side nodes
comment|// - logical operator = operator attached to both the left and right hand side nodes
DECL|method|singleQuotedLiteralWithFunctionsText ()
specifier|protected
name|boolean
name|singleQuotedLiteralWithFunctionsText
parameter_list|()
block|{
if|if
condition|(
name|accept
argument_list|(
name|TokenType
operator|.
name|singleQuote
argument_list|)
condition|)
block|{
name|nextToken
argument_list|(
name|TokenType
operator|.
name|singleQuote
argument_list|,
name|TokenType
operator|.
name|eol
argument_list|,
name|TokenType
operator|.
name|functionStart
argument_list|,
name|TokenType
operator|.
name|functionEnd
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isSingleQuote
argument_list|()
operator|&&
operator|!
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isEol
argument_list|()
condition|)
block|{
comment|// we need to loop until we find the ending single quote, or the eol
name|nextToken
argument_list|(
name|TokenType
operator|.
name|singleQuote
argument_list|,
name|TokenType
operator|.
name|eol
argument_list|,
name|TokenType
operator|.
name|functionStart
argument_list|,
name|TokenType
operator|.
name|functionEnd
argument_list|)
expr_stmt|;
block|}
name|expect
argument_list|(
name|TokenType
operator|.
name|singleQuote
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|singleQuotedLiteralText ()
specifier|protected
name|boolean
name|singleQuotedLiteralText
parameter_list|()
block|{
if|if
condition|(
name|accept
argument_list|(
name|TokenType
operator|.
name|singleQuote
argument_list|)
condition|)
block|{
name|nextToken
argument_list|(
name|TokenType
operator|.
name|singleQuote
argument_list|,
name|TokenType
operator|.
name|eol
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isSingleQuote
argument_list|()
operator|&&
operator|!
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isEol
argument_list|()
condition|)
block|{
comment|// we need to loop until we find the ending single quote, or the eol
name|nextToken
argument_list|(
name|TokenType
operator|.
name|singleQuote
argument_list|,
name|TokenType
operator|.
name|eol
argument_list|)
expr_stmt|;
block|}
name|expect
argument_list|(
name|TokenType
operator|.
name|singleQuote
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|doubleQuotedLiteralWithFunctionsText ()
specifier|protected
name|boolean
name|doubleQuotedLiteralWithFunctionsText
parameter_list|()
block|{
if|if
condition|(
name|accept
argument_list|(
name|TokenType
operator|.
name|doubleQuote
argument_list|)
condition|)
block|{
name|nextToken
argument_list|(
name|TokenType
operator|.
name|doubleQuote
argument_list|,
name|TokenType
operator|.
name|eol
argument_list|,
name|TokenType
operator|.
name|functionStart
argument_list|,
name|TokenType
operator|.
name|functionEnd
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isDoubleQuote
argument_list|()
operator|&&
operator|!
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isEol
argument_list|()
condition|)
block|{
comment|// we need to loop until we find the ending double quote, or the eol
name|nextToken
argument_list|(
name|TokenType
operator|.
name|doubleQuote
argument_list|,
name|TokenType
operator|.
name|eol
argument_list|,
name|TokenType
operator|.
name|functionStart
argument_list|,
name|TokenType
operator|.
name|functionEnd
argument_list|)
expr_stmt|;
block|}
name|expect
argument_list|(
name|TokenType
operator|.
name|doubleQuote
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|doubleQuotedLiteralText ()
specifier|protected
name|boolean
name|doubleQuotedLiteralText
parameter_list|()
block|{
if|if
condition|(
name|accept
argument_list|(
name|TokenType
operator|.
name|doubleQuote
argument_list|)
condition|)
block|{
name|nextToken
argument_list|(
name|TokenType
operator|.
name|doubleQuote
argument_list|,
name|TokenType
operator|.
name|eol
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isDoubleQuote
argument_list|()
operator|&&
operator|!
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isEol
argument_list|()
condition|)
block|{
comment|// we need to loop until we find the ending double quote, or the eol
name|nextToken
argument_list|(
name|TokenType
operator|.
name|doubleQuote
argument_list|,
name|TokenType
operator|.
name|eol
argument_list|)
expr_stmt|;
block|}
name|expect
argument_list|(
name|TokenType
operator|.
name|doubleQuote
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|functionText ()
specifier|protected
name|boolean
name|functionText
parameter_list|()
block|{
if|if
condition|(
name|accept
argument_list|(
name|TokenType
operator|.
name|functionStart
argument_list|)
condition|)
block|{
name|nextToken
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isFunctionEnd
argument_list|()
operator|&&
operator|!
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isEol
argument_list|()
condition|)
block|{
if|if
condition|(
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isFunctionStart
argument_list|()
condition|)
block|{
comment|// embedded function
name|functionText
argument_list|()
expr_stmt|;
block|}
comment|// we need to loop until we find the ending function quote, an embedded function, or the eol
name|nextToken
argument_list|()
expr_stmt|;
block|}
comment|// if its not an embedded function then we expect the end token
if|if
condition|(
operator|!
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isFunctionStart
argument_list|()
condition|)
block|{
name|expect
argument_list|(
name|TokenType
operator|.
name|functionEnd
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|unaryOperator ()
specifier|protected
name|boolean
name|unaryOperator
parameter_list|()
block|{
if|if
condition|(
name|accept
argument_list|(
name|TokenType
operator|.
name|unaryOperator
argument_list|)
condition|)
block|{
name|nextToken
argument_list|()
expr_stmt|;
comment|// there should be a whitespace after the operator
name|expect
argument_list|(
name|TokenType
operator|.
name|whiteSpace
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|binaryOperator ()
specifier|protected
name|boolean
name|binaryOperator
parameter_list|()
block|{
if|if
condition|(
name|accept
argument_list|(
name|TokenType
operator|.
name|binaryOperator
argument_list|)
condition|)
block|{
comment|// remember the binary operator
name|BinaryOperatorType
name|operatorType
init|=
name|BinaryOperatorType
operator|.
name|asOperator
argument_list|(
name|token
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|nextToken
argument_list|()
expr_stmt|;
comment|// there should be at least one whitespace after the operator
name|expectAndAcceptMore
argument_list|(
name|TokenType
operator|.
name|whiteSpace
argument_list|)
expr_stmt|;
comment|// okay a binary operator may not support all kind if preceding parameters, so we need to limit this
name|BinaryOperatorType
operator|.
name|ParameterType
index|[]
name|types
init|=
name|BinaryOperatorType
operator|.
name|supportedParameterTypes
argument_list|(
name|operatorType
argument_list|)
decl_stmt|;
comment|// based on the parameter types the binary operator support, we need to set this state into
comment|// the following booleans so we know how to proceed in the grammar
name|boolean
name|literalWithFunctionsSupported
init|=
literal|false
decl_stmt|;
name|boolean
name|literalSupported
init|=
literal|false
decl_stmt|;
name|boolean
name|functionSupported
init|=
literal|false
decl_stmt|;
name|boolean
name|numericSupported
init|=
literal|false
decl_stmt|;
name|boolean
name|booleanSupported
init|=
literal|false
decl_stmt|;
name|boolean
name|nullSupported
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|types
operator|==
literal|null
operator|||
name|types
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|literalWithFunctionsSupported
operator|=
literal|true
expr_stmt|;
comment|// favor literal with functions over literals without functions
name|literalSupported
operator|=
literal|false
expr_stmt|;
name|functionSupported
operator|=
literal|true
expr_stmt|;
name|numericSupported
operator|=
literal|true
expr_stmt|;
name|booleanSupported
operator|=
literal|true
expr_stmt|;
name|nullSupported
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|BinaryOperatorType
operator|.
name|ParameterType
name|parameterType
range|:
name|types
control|)
block|{
name|literalSupported
operator||=
name|parameterType
operator|.
name|isLiteralSupported
argument_list|()
expr_stmt|;
name|literalWithFunctionsSupported
operator||=
name|parameterType
operator|.
name|isLiteralWithFunctionSupport
argument_list|()
expr_stmt|;
name|functionSupported
operator||=
name|parameterType
operator|.
name|isFunctionSupport
argument_list|()
expr_stmt|;
name|nullSupported
operator||=
name|parameterType
operator|.
name|isNumericValueSupported
argument_list|()
expr_stmt|;
name|booleanSupported
operator||=
name|parameterType
operator|.
name|isBooleanValueSupported
argument_list|()
expr_stmt|;
name|nullSupported
operator||=
name|parameterType
operator|.
name|isNullValueSupported
argument_list|()
expr_stmt|;
block|}
block|}
comment|// then we proceed in the grammar according to the parameter types supported by the given binary operator
comment|//CHECKSTYLE:OFF
if|if
condition|(
operator|(
name|literalWithFunctionsSupported
operator|&&
name|singleQuotedLiteralWithFunctionsText
argument_list|()
operator|)
operator|||
operator|(
name|literalWithFunctionsSupported
operator|&&
name|doubleQuotedLiteralWithFunctionsText
argument_list|()
operator|)
operator|||
operator|(
name|literalSupported
operator|&&
name|singleQuotedLiteralText
argument_list|()
operator|)
operator|||
operator|(
name|literalSupported
operator|&&
name|doubleQuotedLiteralText
argument_list|()
operator|)
operator|||
operator|(
name|functionSupported
operator|&&
name|functionText
argument_list|()
operator|)
operator|||
operator|(
name|numericSupported
operator|&&
name|numericValue
argument_list|()
operator|)
operator|||
operator|(
name|booleanSupported
operator|&&
name|booleanValue
argument_list|()
operator|)
operator|||
operator|(
name|nullSupported
operator|&&
name|nullValue
argument_list|()
operator|)
condition|)
block|{
comment|// then after the right hand side value, there should be a whitespace if there is more tokens
name|nextToken
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isEol
argument_list|()
condition|)
block|{
name|expect
argument_list|(
name|TokenType
operator|.
name|whiteSpace
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|SimpleParserException
argument_list|(
literal|"Binary operator "
operator|+
name|operatorType
operator|+
literal|" does not support token "
operator|+
name|token
argument_list|,
name|token
operator|.
name|getIndex
argument_list|()
argument_list|)
throw|;
block|}
comment|//CHECKSTYLE:ON
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|logicalOperator ()
specifier|protected
name|boolean
name|logicalOperator
parameter_list|()
block|{
if|if
condition|(
name|accept
argument_list|(
name|TokenType
operator|.
name|logicalOperator
argument_list|)
condition|)
block|{
comment|// remember the logical operator
name|LogicalOperatorType
name|operatorType
init|=
name|LogicalOperatorType
operator|.
name|asOperator
argument_list|(
name|token
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|nextToken
argument_list|()
expr_stmt|;
comment|// there should be at least one whitespace after the operator
name|expectAndAcceptMore
argument_list|(
name|TokenType
operator|.
name|whiteSpace
argument_list|)
expr_stmt|;
comment|// then we expect either some quoted text, another function, or a numeric, boolean or null value
if|if
condition|(
name|singleQuotedLiteralWithFunctionsText
argument_list|()
operator|||
name|doubleQuotedLiteralWithFunctionsText
argument_list|()
operator|||
name|functionText
argument_list|()
operator|||
name|numericValue
argument_list|()
operator|||
name|booleanValue
argument_list|()
operator|||
name|nullValue
argument_list|()
condition|)
block|{
comment|// then after the right hand side value, there should be a whitespace if there is more tokens
name|nextToken
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|token
operator|.
name|getType
argument_list|()
operator|.
name|isEol
argument_list|()
condition|)
block|{
name|expect
argument_list|(
name|TokenType
operator|.
name|whiteSpace
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|SimpleParserException
argument_list|(
literal|"Logical operator "
operator|+
name|operatorType
operator|+
literal|" does not support token "
operator|+
name|token
argument_list|,
name|token
operator|.
name|getIndex
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|numericValue ()
specifier|protected
name|boolean
name|numericValue
parameter_list|()
block|{
return|return
name|accept
argument_list|(
name|TokenType
operator|.
name|numericValue
argument_list|)
return|;
comment|// no other tokens to check so do not use nextToken
block|}
DECL|method|booleanValue ()
specifier|protected
name|boolean
name|booleanValue
parameter_list|()
block|{
return|return
name|accept
argument_list|(
name|TokenType
operator|.
name|booleanValue
argument_list|)
return|;
comment|// no other tokens to check so do not use nextToken
block|}
DECL|method|nullValue ()
specifier|protected
name|boolean
name|nullValue
parameter_list|()
block|{
return|return
name|accept
argument_list|(
name|TokenType
operator|.
name|nullValue
argument_list|)
return|;
comment|// no other tokens to check so do not use nextToken
block|}
block|}
end_class

end_unit

