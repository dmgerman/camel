begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.builder.xml
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|xml
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentLinkedQueue
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|namespace
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|dom
operator|.
name|DOMSource
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPath
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathConstants
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathExpression
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathExpressionException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathFactoryConfigurationException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathFunction
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathFunctionException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathFunctionResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|InputSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Expression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|NoTypeConversionAvailableException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|RuntimeExpressionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|WrappedFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|bean
operator|.
name|BeanInvocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|impl
operator|.
name|DefaultExchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|Language
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|NamespaceAware
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ExchangeHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|IOHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|MessageHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ObjectHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|xml
operator|.
name|Namespaces
operator|.
name|DEFAULT_NAMESPACE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|xml
operator|.
name|Namespaces
operator|.
name|FUNCTION_NAMESPACE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|xml
operator|.
name|Namespaces
operator|.
name|IN_NAMESPACE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|xml
operator|.
name|Namespaces
operator|.
name|OUT_NAMESPACE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|xml
operator|.
name|Namespaces
operator|.
name|isMatchingNamespaceOrEmptyNamespace
import|;
end_import

begin_comment
comment|/**  * Creates an XPath expression builder which creates a nodeset result by default.  * If you want to evaluate a String expression then call {@link #stringResult()}  *<p/>  * An XPath object is not thread-safe and not reentrant. In other words, it is the application's responsibility to make  * sure that one XPath object is not used from more than one thread at any given time, and while the evaluate method  * is invoked, applications may not recursively call the evaluate method.  *<p/>  * This implementation is thread safe by using thread locals and pooling to allow concurrency  *  * @see XPathConstants#NODESET  */
end_comment

begin_class
DECL|class|XPathBuilder
specifier|public
class|class
name|XPathBuilder
implements|implements
name|Expression
implements|,
name|Predicate
implements|,
name|NamespaceAware
implements|,
name|Service
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
specifier|transient
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|XPathBuilder
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|SAXON_OBJECT_MODEL_URI
specifier|private
specifier|static
specifier|final
name|String
name|SAXON_OBJECT_MODEL_URI
init|=
literal|"http://saxon.sf.net/jaxp/xpath/om"
decl_stmt|;
DECL|field|OBTAIN_ALL_NS_XPATH
specifier|private
specifier|static
specifier|final
name|String
name|OBTAIN_ALL_NS_XPATH
init|=
literal|"//*/namespace::*"
decl_stmt|;
DECL|field|defaultXPathFactory
specifier|private
specifier|static
name|XPathFactory
name|defaultXPathFactory
decl_stmt|;
DECL|field|pool
specifier|private
specifier|final
name|Queue
argument_list|<
name|XPathExpression
argument_list|>
name|pool
init|=
operator|new
name|ConcurrentLinkedQueue
argument_list|<
name|XPathExpression
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|poolLogNamespaces
specifier|private
specifier|final
name|Queue
argument_list|<
name|XPathExpression
argument_list|>
name|poolLogNamespaces
init|=
operator|new
name|ConcurrentLinkedQueue
argument_list|<
name|XPathExpression
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|text
specifier|private
specifier|final
name|String
name|text
decl_stmt|;
DECL|field|exchange
specifier|private
specifier|final
name|ThreadLocal
argument_list|<
name|Exchange
argument_list|>
name|exchange
init|=
operator|new
name|ThreadLocal
argument_list|<
name|Exchange
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|variableResolver
specifier|private
specifier|final
name|MessageVariableResolver
name|variableResolver
init|=
operator|new
name|MessageVariableResolver
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
DECL|field|xpathFactory
specifier|private
name|XPathFactory
name|xpathFactory
decl_stmt|;
DECL|field|documentType
specifier|private
name|Class
argument_list|<
name|?
argument_list|>
name|documentType
init|=
name|Document
operator|.
name|class
decl_stmt|;
comment|// For some reason the default expression of "a/b" on a document such as
comment|//<a><b>1</b><b>2</b></a>
comment|// will evaluate as just "1" by default which is bizarre. So by default
comment|// let's assume XPath expressions result in nodesets.
DECL|field|resultType
specifier|private
name|Class
argument_list|<
name|?
argument_list|>
name|resultType
decl_stmt|;
DECL|field|resultQName
specifier|private
name|QName
name|resultQName
init|=
name|XPathConstants
operator|.
name|NODESET
decl_stmt|;
DECL|field|objectModelUri
specifier|private
name|String
name|objectModelUri
decl_stmt|;
DECL|field|namespaceContext
specifier|private
name|DefaultNamespaceContext
name|namespaceContext
decl_stmt|;
DECL|field|logNamespaces
specifier|private
name|boolean
name|logNamespaces
decl_stmt|;
DECL|field|functionResolver
specifier|private
name|XPathFunctionResolver
name|functionResolver
decl_stmt|;
DECL|field|bodyFunction
specifier|private
name|XPathFunction
name|bodyFunction
decl_stmt|;
DECL|field|headerFunction
specifier|private
name|XPathFunction
name|headerFunction
decl_stmt|;
DECL|field|outBodyFunction
specifier|private
name|XPathFunction
name|outBodyFunction
decl_stmt|;
DECL|field|outHeaderFunction
specifier|private
name|XPathFunction
name|outHeaderFunction
decl_stmt|;
DECL|field|propertiesFunction
specifier|private
name|XPathFunction
name|propertiesFunction
decl_stmt|;
DECL|field|simpleFunction
specifier|private
name|XPathFunction
name|simpleFunction
decl_stmt|;
comment|/**      * The name of the header we want to apply the XPath expression to, which when set will cause      * the xpath to be evaluated on the required header, otherwise it will be applied to the body      */
DECL|field|headerName
specifier|private
name|String
name|headerName
decl_stmt|;
comment|/**      * @param text The XPath expression      */
DECL|method|XPathBuilder (String text)
specifier|public
name|XPathBuilder
parameter_list|(
name|String
name|text
parameter_list|)
block|{
name|this
operator|.
name|text
operator|=
name|text
expr_stmt|;
block|}
comment|/**      * @param text The XPath expression      * @return A new XPathBuilder object      */
DECL|method|xpath (String text)
specifier|public
specifier|static
name|XPathBuilder
name|xpath
parameter_list|(
name|String
name|text
parameter_list|)
block|{
return|return
operator|new
name|XPathBuilder
argument_list|(
name|text
argument_list|)
return|;
block|}
comment|/**      * @param text The XPath expression      * @param resultType The result type that the XPath expression will return.      * @return A new XPathBuilder object      */
DECL|method|xpath (String text, Class<?> resultType)
specifier|public
specifier|static
name|XPathBuilder
name|xpath
parameter_list|(
name|String
name|text
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|resultType
parameter_list|)
block|{
name|XPathBuilder
name|builder
init|=
operator|new
name|XPathBuilder
argument_list|(
name|text
argument_list|)
decl_stmt|;
name|builder
operator|.
name|setResultType
argument_list|(
name|resultType
argument_list|)
expr_stmt|;
return|return
name|builder
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"XPath: "
operator|+
name|text
return|;
block|}
DECL|method|matches (Exchange exchange)
specifier|public
name|boolean
name|matches
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
try|try
block|{
name|Object
name|booleanResult
init|=
name|evaluateAs
argument_list|(
name|exchange
argument_list|,
name|XPathConstants
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
return|return
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|Boolean
operator|.
name|class
argument_list|,
name|booleanResult
argument_list|)
return|;
block|}
finally|finally
block|{
comment|// remove the thread local after usage
name|this
operator|.
name|exchange
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|evaluate (Exchange exchange, Class<T> type)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|evaluate
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
try|try
block|{
name|Object
name|result
init|=
name|evaluate
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
return|return
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|type
argument_list|,
name|result
argument_list|)
return|;
block|}
finally|finally
block|{
comment|// remove the thread local after usage
name|this
operator|.
name|exchange
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Matches the given xpath using the provided body.      *      * @param context the camel context      * @param body    the body      * @return<tt>true</tt> if matches,<tt>false</tt> otherwise      */
DECL|method|matches (CamelContext context, Object body)
specifier|public
name|boolean
name|matches
parameter_list|(
name|CamelContext
name|context
parameter_list|,
name|Object
name|body
parameter_list|)
block|{
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|context
argument_list|,
literal|"CamelContext"
argument_list|)
expr_stmt|;
comment|// create a dummy Exchange to use during matching
name|Exchange
name|dummy
init|=
operator|new
name|DefaultExchange
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|dummy
operator|.
name|getIn
argument_list|()
operator|.
name|setBody
argument_list|(
name|body
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|matches
argument_list|(
name|dummy
argument_list|)
return|;
block|}
finally|finally
block|{
comment|// remove the thread local after usage
name|exchange
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Evaluates the given xpath using the provided body.      *      * @param context the camel context      * @param body    the body      * @param type    the type to return      * @return result of the evaluation      */
DECL|method|evaluate (CamelContext context, Object body, Class<T> type)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|evaluate
parameter_list|(
name|CamelContext
name|context
parameter_list|,
name|Object
name|body
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|context
argument_list|,
literal|"CamelContext"
argument_list|)
expr_stmt|;
comment|// create a dummy Exchange to use during evaluation
name|Exchange
name|dummy
init|=
operator|new
name|DefaultExchange
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|dummy
operator|.
name|getIn
argument_list|()
operator|.
name|setBody
argument_list|(
name|body
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|evaluate
argument_list|(
name|dummy
argument_list|,
name|type
argument_list|)
return|;
block|}
finally|finally
block|{
comment|// remove the thread local after usage
name|exchange
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Evaluates the given xpath using the provided body as a String return type.      *      * @param context the camel context      * @param body    the body      * @return result of the evaluation      */
DECL|method|evaluate (CamelContext context, Object body)
specifier|public
name|String
name|evaluate
parameter_list|(
name|CamelContext
name|context
parameter_list|,
name|Object
name|body
parameter_list|)
block|{
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|context
argument_list|,
literal|"CamelContext"
argument_list|)
expr_stmt|;
comment|// create a dummy Exchange to use during evaluation
name|Exchange
name|dummy
init|=
operator|new
name|DefaultExchange
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|dummy
operator|.
name|getIn
argument_list|()
operator|.
name|setBody
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|setResultQName
argument_list|(
name|XPathConstants
operator|.
name|STRING
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|evaluate
argument_list|(
name|dummy
argument_list|,
name|String
operator|.
name|class
argument_list|)
return|;
block|}
finally|finally
block|{
comment|// remove the thread local after usage
name|this
operator|.
name|exchange
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Builder methods
comment|// -------------------------------------------------------------------------
comment|/**      * Sets the expression result type to boolean      *      * @return the current builder      */
DECL|method|booleanResult ()
specifier|public
name|XPathBuilder
name|booleanResult
parameter_list|()
block|{
name|resultQName
operator|=
name|XPathConstants
operator|.
name|BOOLEAN
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets the expression result type to boolean      *      * @return the current builder      */
DECL|method|nodeResult ()
specifier|public
name|XPathBuilder
name|nodeResult
parameter_list|()
block|{
name|resultQName
operator|=
name|XPathConstants
operator|.
name|NODE
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets the expression result type to boolean      *      * @return the current builder      */
DECL|method|nodeSetResult ()
specifier|public
name|XPathBuilder
name|nodeSetResult
parameter_list|()
block|{
name|resultQName
operator|=
name|XPathConstants
operator|.
name|NODESET
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets the expression result type to boolean      *      * @return the current builder      */
DECL|method|numberResult ()
specifier|public
name|XPathBuilder
name|numberResult
parameter_list|()
block|{
name|resultQName
operator|=
name|XPathConstants
operator|.
name|NUMBER
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets the expression result type to boolean      *      * @return the current builder      */
DECL|method|stringResult ()
specifier|public
name|XPathBuilder
name|stringResult
parameter_list|()
block|{
name|resultQName
operator|=
name|XPathConstants
operator|.
name|STRING
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets the expression result type to boolean      *      * @return the current builder      */
DECL|method|resultType (Class<?> resultType)
specifier|public
name|XPathBuilder
name|resultType
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|resultType
parameter_list|)
block|{
name|setResultType
argument_list|(
name|resultType
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets the object model URI to use      *      * @return the current builder      */
DECL|method|objectModel (String uri)
specifier|public
name|XPathBuilder
name|objectModel
parameter_list|(
name|String
name|uri
parameter_list|)
block|{
comment|// TODO: Careful! Setting the Object Model URI this way will set the *Default* XPath Factory, which since is a static field,
comment|// will set the XPath Factory system-wide. Decide what to do, as changing this behaviour can break compatibility. Provided the setObjectModel which changes
comment|// this instance's XPath Factory rather than the static field
name|this
operator|.
name|objectModelUri
operator|=
name|uri
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Configures to use Saxon as the XPathFactory which allows you to use XPath 2.0 functions      * which may not be part of the build in JDK XPath parser.      *      * @return the current builder      */
DECL|method|saxon ()
specifier|public
name|XPathBuilder
name|saxon
parameter_list|()
block|{
name|this
operator|.
name|objectModelUri
operator|=
name|SAXON_OBJECT_MODEL_URI
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets the {@link XPathFunctionResolver} instance to use on these XPath      * expressions      *      * @return the current builder      */
DECL|method|functionResolver (XPathFunctionResolver functionResolver)
specifier|public
name|XPathBuilder
name|functionResolver
parameter_list|(
name|XPathFunctionResolver
name|functionResolver
parameter_list|)
block|{
name|this
operator|.
name|functionResolver
operator|=
name|functionResolver
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Registers the namespace prefix and URI with the builder so that the      * prefix can be used in XPath expressions      *      * @param prefix is the namespace prefix that can be used in the XPath      *               expressions      * @param uri    is the namespace URI to which the prefix refers      * @return the current builder      */
DECL|method|namespace (String prefix, String uri)
specifier|public
name|XPathBuilder
name|namespace
parameter_list|(
name|String
name|prefix
parameter_list|,
name|String
name|uri
parameter_list|)
block|{
name|getNamespaceContext
argument_list|()
operator|.
name|add
argument_list|(
name|prefix
argument_list|,
name|uri
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Registers namespaces with the builder so that the registered      * prefixes can be used in XPath expressions      *      * @param namespaces is namespaces object that should be used in the      *                   XPath expression      * @return the current builder      */
DECL|method|namespaces (Namespaces namespaces)
specifier|public
name|XPathBuilder
name|namespaces
parameter_list|(
name|Namespaces
name|namespaces
parameter_list|)
block|{
name|namespaces
operator|.
name|configure
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Registers a variable (in the global namespace) which can be referred to      * from XPath expressions      *      * @param name  name of variable      * @param value value of variable      * @return the current builder      */
DECL|method|variable (String name, Object value)
specifier|public
name|XPathBuilder
name|variable
parameter_list|(
name|String
name|name
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|getVariableResolver
argument_list|()
operator|.
name|addVariable
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Configures the document type to use.      *<p/>      * The document type controls which kind of Class Camel should convert the payload      * to before doing the xpath evaluation.      *<p/>      * For example you can set it to {@link InputSource} to use SAX streams.      * By default Camel uses {@link Document} as the type.      *      * @param documentType the document type      * @return the current builder      */
DECL|method|documentType (Class<?> documentType)
specifier|public
name|XPathBuilder
name|documentType
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|documentType
parameter_list|)
block|{
name|setDocumentType
argument_list|(
name|documentType
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Configures to use the provided XPath factory.      *<p/>      * Can be used to use Saxon instead of the build in factory from the JDK.      *      * @param xpathFactory the xpath factory to use      * @return the current builder.      */
DECL|method|factory (XPathFactory xpathFactory)
specifier|public
name|XPathBuilder
name|factory
parameter_list|(
name|XPathFactory
name|xpathFactory
parameter_list|)
block|{
name|setXPathFactory
argument_list|(
name|xpathFactory
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Activates trace logging of all discovered namespaces in the message - to simplify debugging namespace-related issues      *<p/>      * Namespaces are printed in Hashmap style<code>{xmlns:prefix=[namespaceURI], xmlns:prefix=[namespaceURI]}</code>.      *<p/>      * The implicit XML namespace is omitted (http://www.w3.org/XML/1998/namespace).      * XML allows for namespace prefixes to be redefined/overridden due to hierarchical scoping, i.e. prefix abc can be mapped to http://abc.com,      * and deeper in the document it can be mapped to http://def.com. When two prefixes are detected which are equal but are mapped to different      * namespace URIs, Camel will show all namespaces URIs it is mapped to in an array-style.      *<p/>      * This feature is disabled by default.      *      * @return the current builder.      */
DECL|method|logNamespaces ()
specifier|public
name|XPathBuilder
name|logNamespaces
parameter_list|()
block|{
name|setLogNamespaces
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|// Properties
comment|// -------------------------------------------------------------------------
DECL|method|getXPathFactory ()
specifier|public
name|XPathFactory
name|getXPathFactory
parameter_list|()
throws|throws
name|XPathFactoryConfigurationException
block|{
if|if
condition|(
name|xpathFactory
operator|!=
literal|null
condition|)
block|{
return|return
name|xpathFactory
return|;
block|}
if|if
condition|(
name|objectModelUri
operator|!=
literal|null
condition|)
block|{
name|xpathFactory
operator|=
name|XPathFactory
operator|.
name|newInstance
argument_list|(
name|objectModelUri
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Using objectModelUri "
operator|+
name|objectModelUri
operator|+
literal|" when created XPathFactory {}"
argument_list|,
name|defaultXPathFactory
argument_list|)
expr_stmt|;
return|return
name|xpathFactory
return|;
block|}
if|if
condition|(
name|defaultXPathFactory
operator|==
literal|null
condition|)
block|{
name|initDefaultXPathFactory
argument_list|()
expr_stmt|;
block|}
return|return
name|defaultXPathFactory
return|;
block|}
DECL|method|setXPathFactory (XPathFactory xpathFactory)
specifier|public
name|void
name|setXPathFactory
parameter_list|(
name|XPathFactory
name|xpathFactory
parameter_list|)
block|{
name|this
operator|.
name|xpathFactory
operator|=
name|xpathFactory
expr_stmt|;
block|}
DECL|method|getDocumentType ()
specifier|public
name|Class
argument_list|<
name|?
argument_list|>
name|getDocumentType
parameter_list|()
block|{
return|return
name|documentType
return|;
block|}
DECL|method|setDocumentType (Class<?> documentType)
specifier|public
name|void
name|setDocumentType
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|documentType
parameter_list|)
block|{
name|this
operator|.
name|documentType
operator|=
name|documentType
expr_stmt|;
block|}
DECL|method|getText ()
specifier|public
name|String
name|getText
parameter_list|()
block|{
return|return
name|text
return|;
block|}
DECL|method|getResultQName ()
specifier|public
name|QName
name|getResultQName
parameter_list|()
block|{
return|return
name|resultQName
return|;
block|}
DECL|method|setResultQName (QName resultQName)
specifier|public
name|void
name|setResultQName
parameter_list|(
name|QName
name|resultQName
parameter_list|)
block|{
name|this
operator|.
name|resultQName
operator|=
name|resultQName
expr_stmt|;
block|}
DECL|method|getHeaderName ()
specifier|public
name|String
name|getHeaderName
parameter_list|()
block|{
return|return
name|headerName
return|;
block|}
DECL|method|setHeaderName (String headerName)
specifier|public
name|void
name|setHeaderName
parameter_list|(
name|String
name|headerName
parameter_list|)
block|{
name|this
operator|.
name|headerName
operator|=
name|headerName
expr_stmt|;
block|}
DECL|method|getNamespaceContext ()
specifier|public
name|DefaultNamespaceContext
name|getNamespaceContext
parameter_list|()
block|{
if|if
condition|(
name|namespaceContext
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|DefaultNamespaceContext
name|defaultNamespaceContext
init|=
operator|new
name|DefaultNamespaceContext
argument_list|(
name|getXPathFactory
argument_list|()
argument_list|)
decl_stmt|;
name|populateDefaultNamespaces
argument_list|(
name|defaultNamespaceContext
argument_list|)
expr_stmt|;
name|namespaceContext
operator|=
name|defaultNamespaceContext
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|XPathFactoryConfigurationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeExpressionException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|namespaceContext
return|;
block|}
DECL|method|setNamespaceContext (DefaultNamespaceContext namespaceContext)
specifier|public
name|void
name|setNamespaceContext
parameter_list|(
name|DefaultNamespaceContext
name|namespaceContext
parameter_list|)
block|{
name|this
operator|.
name|namespaceContext
operator|=
name|namespaceContext
expr_stmt|;
block|}
DECL|method|getFunctionResolver ()
specifier|public
name|XPathFunctionResolver
name|getFunctionResolver
parameter_list|()
block|{
return|return
name|functionResolver
return|;
block|}
DECL|method|setFunctionResolver (XPathFunctionResolver functionResolver)
specifier|public
name|void
name|setFunctionResolver
parameter_list|(
name|XPathFunctionResolver
name|functionResolver
parameter_list|)
block|{
name|this
operator|.
name|functionResolver
operator|=
name|functionResolver
expr_stmt|;
block|}
DECL|method|setNamespaces (Map<String, String> namespaces)
specifier|public
name|void
name|setNamespaces
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|namespaces
parameter_list|)
block|{
name|getNamespaceContext
argument_list|()
operator|.
name|setNamespaces
argument_list|(
name|namespaces
argument_list|)
expr_stmt|;
block|}
DECL|method|getBodyFunction ()
specifier|public
name|XPathFunction
name|getBodyFunction
parameter_list|()
block|{
if|if
condition|(
name|bodyFunction
operator|==
literal|null
condition|)
block|{
name|bodyFunction
operator|=
operator|new
name|XPathFunction
argument_list|()
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
specifier|public
name|Object
name|evaluate
parameter_list|(
name|List
name|list
parameter_list|)
throws|throws
name|XPathFunctionException
block|{
if|if
condition|(
name|exchange
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|exchange
operator|.
name|get
argument_list|()
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|()
return|;
block|}
block|}
expr_stmt|;
block|}
return|return
name|bodyFunction
return|;
block|}
DECL|method|setBodyFunction (XPathFunction bodyFunction)
specifier|public
name|void
name|setBodyFunction
parameter_list|(
name|XPathFunction
name|bodyFunction
parameter_list|)
block|{
name|this
operator|.
name|bodyFunction
operator|=
name|bodyFunction
expr_stmt|;
block|}
DECL|method|getHeaderFunction ()
specifier|public
name|XPathFunction
name|getHeaderFunction
parameter_list|()
block|{
if|if
condition|(
name|headerFunction
operator|==
literal|null
condition|)
block|{
name|headerFunction
operator|=
operator|new
name|XPathFunction
argument_list|()
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
specifier|public
name|Object
name|evaluate
parameter_list|(
name|List
name|list
parameter_list|)
throws|throws
name|XPathFunctionException
block|{
if|if
condition|(
name|exchange
operator|!=
literal|null
operator|&&
operator|!
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Object
name|value
init|=
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|String
name|text
init|=
name|exchange
operator|.
name|get
argument_list|()
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|String
operator|.
name|class
argument_list|,
name|value
argument_list|)
decl_stmt|;
return|return
name|exchange
operator|.
name|get
argument_list|()
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|text
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
expr_stmt|;
block|}
return|return
name|headerFunction
return|;
block|}
DECL|method|setHeaderFunction (XPathFunction headerFunction)
specifier|public
name|void
name|setHeaderFunction
parameter_list|(
name|XPathFunction
name|headerFunction
parameter_list|)
block|{
name|this
operator|.
name|headerFunction
operator|=
name|headerFunction
expr_stmt|;
block|}
DECL|method|getOutBodyFunction ()
specifier|public
name|XPathFunction
name|getOutBodyFunction
parameter_list|()
block|{
if|if
condition|(
name|outBodyFunction
operator|==
literal|null
condition|)
block|{
name|outBodyFunction
operator|=
operator|new
name|XPathFunction
argument_list|()
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
specifier|public
name|Object
name|evaluate
parameter_list|(
name|List
name|list
parameter_list|)
throws|throws
name|XPathFunctionException
block|{
if|if
condition|(
name|exchange
operator|.
name|get
argument_list|()
operator|!=
literal|null
operator|&&
name|exchange
operator|.
name|get
argument_list|()
operator|.
name|hasOut
argument_list|()
condition|)
block|{
return|return
name|exchange
operator|.
name|get
argument_list|()
operator|.
name|getOut
argument_list|()
operator|.
name|getBody
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
expr_stmt|;
block|}
return|return
name|outBodyFunction
return|;
block|}
DECL|method|setOutBodyFunction (XPathFunction outBodyFunction)
specifier|public
name|void
name|setOutBodyFunction
parameter_list|(
name|XPathFunction
name|outBodyFunction
parameter_list|)
block|{
name|this
operator|.
name|outBodyFunction
operator|=
name|outBodyFunction
expr_stmt|;
block|}
DECL|method|getOutHeaderFunction ()
specifier|public
name|XPathFunction
name|getOutHeaderFunction
parameter_list|()
block|{
if|if
condition|(
name|outHeaderFunction
operator|==
literal|null
condition|)
block|{
name|outHeaderFunction
operator|=
operator|new
name|XPathFunction
argument_list|()
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
specifier|public
name|Object
name|evaluate
parameter_list|(
name|List
name|list
parameter_list|)
throws|throws
name|XPathFunctionException
block|{
if|if
condition|(
name|exchange
operator|.
name|get
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Object
name|value
init|=
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|String
name|text
init|=
name|exchange
operator|.
name|get
argument_list|()
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|String
operator|.
name|class
argument_list|,
name|value
argument_list|)
decl_stmt|;
return|return
name|exchange
operator|.
name|get
argument_list|()
operator|.
name|getOut
argument_list|()
operator|.
name|getHeader
argument_list|(
name|text
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
expr_stmt|;
block|}
return|return
name|outHeaderFunction
return|;
block|}
DECL|method|setOutHeaderFunction (XPathFunction outHeaderFunction)
specifier|public
name|void
name|setOutHeaderFunction
parameter_list|(
name|XPathFunction
name|outHeaderFunction
parameter_list|)
block|{
name|this
operator|.
name|outHeaderFunction
operator|=
name|outHeaderFunction
expr_stmt|;
block|}
DECL|method|getPropertiesFunction ()
specifier|public
name|XPathFunction
name|getPropertiesFunction
parameter_list|()
block|{
if|if
condition|(
name|propertiesFunction
operator|==
literal|null
condition|)
block|{
name|propertiesFunction
operator|=
operator|new
name|XPathFunction
argument_list|()
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
specifier|public
name|Object
name|evaluate
parameter_list|(
name|List
name|list
parameter_list|)
throws|throws
name|XPathFunctionException
block|{
if|if
condition|(
name|exchange
operator|!=
literal|null
operator|&&
operator|!
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Object
name|value
init|=
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|String
name|text
init|=
name|exchange
operator|.
name|get
argument_list|()
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|String
operator|.
name|class
argument_list|,
name|value
argument_list|)
decl_stmt|;
try|try
block|{
comment|// use the property placeholder resolver to lookup the property for us
name|Object
name|answer
init|=
name|exchange
operator|.
name|get
argument_list|()
operator|.
name|getContext
argument_list|()
operator|.
name|resolvePropertyPlaceholders
argument_list|(
literal|"{{"
operator|+
name|text
operator|+
literal|"}}"
argument_list|)
decl_stmt|;
return|return
name|answer
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XPathFunctionException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
expr_stmt|;
block|}
return|return
name|propertiesFunction
return|;
block|}
DECL|method|setPropertiesFunction (XPathFunction propertiesFunction)
specifier|public
name|void
name|setPropertiesFunction
parameter_list|(
name|XPathFunction
name|propertiesFunction
parameter_list|)
block|{
name|this
operator|.
name|propertiesFunction
operator|=
name|propertiesFunction
expr_stmt|;
block|}
DECL|method|getSimpleFunction ()
specifier|public
name|XPathFunction
name|getSimpleFunction
parameter_list|()
block|{
if|if
condition|(
name|simpleFunction
operator|==
literal|null
condition|)
block|{
name|simpleFunction
operator|=
operator|new
name|XPathFunction
argument_list|()
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
specifier|public
name|Object
name|evaluate
parameter_list|(
name|List
name|list
parameter_list|)
throws|throws
name|XPathFunctionException
block|{
if|if
condition|(
name|exchange
operator|!=
literal|null
operator|&&
operator|!
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Object
name|value
init|=
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|String
name|text
init|=
name|exchange
operator|.
name|get
argument_list|()
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|String
operator|.
name|class
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|Language
name|simple
init|=
name|exchange
operator|.
name|get
argument_list|()
operator|.
name|getContext
argument_list|()
operator|.
name|resolveLanguage
argument_list|(
literal|"simple"
argument_list|)
decl_stmt|;
name|Expression
name|exp
init|=
name|simple
operator|.
name|createExpression
argument_list|(
name|text
argument_list|)
decl_stmt|;
name|Object
name|answer
init|=
name|exp
operator|.
name|evaluate
argument_list|(
name|exchange
operator|.
name|get
argument_list|()
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|answer
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
expr_stmt|;
block|}
return|return
name|simpleFunction
return|;
block|}
DECL|method|setSimpleFunction (XPathFunction simpleFunction)
specifier|public
name|void
name|setSimpleFunction
parameter_list|(
name|XPathFunction
name|simpleFunction
parameter_list|)
block|{
name|this
operator|.
name|simpleFunction
operator|=
name|simpleFunction
expr_stmt|;
block|}
DECL|method|getResultType ()
specifier|public
name|Class
argument_list|<
name|?
argument_list|>
name|getResultType
parameter_list|()
block|{
return|return
name|resultType
return|;
block|}
DECL|method|setResultType (Class<?> resultType)
specifier|public
name|void
name|setResultType
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|resultType
parameter_list|)
block|{
name|this
operator|.
name|resultType
operator|=
name|resultType
expr_stmt|;
if|if
condition|(
name|Number
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|resultType
argument_list|)
condition|)
block|{
name|numberResult
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|String
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|resultType
argument_list|)
condition|)
block|{
name|stringResult
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Boolean
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|resultType
argument_list|)
condition|)
block|{
name|booleanResult
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Node
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|resultType
argument_list|)
condition|)
block|{
name|nodeResult
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NodeList
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|resultType
argument_list|)
condition|)
block|{
name|nodeSetResult
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|setLogNamespaces (boolean logNamespaces)
specifier|public
name|void
name|setLogNamespaces
parameter_list|(
name|boolean
name|logNamespaces
parameter_list|)
block|{
name|this
operator|.
name|logNamespaces
operator|=
name|logNamespaces
expr_stmt|;
block|}
DECL|method|isLogNamespaces ()
specifier|public
name|boolean
name|isLogNamespaces
parameter_list|()
block|{
return|return
name|logNamespaces
return|;
block|}
DECL|method|getObjectModelUri ()
specifier|public
name|String
name|getObjectModelUri
parameter_list|()
block|{
return|return
name|objectModelUri
return|;
block|}
comment|/**      * Enables Saxon on this particular XPath expression, as {@link #saxon()} sets the default static XPathFactory which may have already been initialised      * by previous XPath expressions      */
DECL|method|enableSaxon ()
specifier|public
name|void
name|enableSaxon
parameter_list|()
block|{
name|this
operator|.
name|setObjectModelUri
argument_list|(
name|SAXON_OBJECT_MODEL_URI
argument_list|)
expr_stmt|;
block|}
DECL|method|setObjectModelUri (String objectModelUri)
specifier|public
name|void
name|setObjectModelUri
parameter_list|(
name|String
name|objectModelUri
parameter_list|)
block|{
name|this
operator|.
name|objectModelUri
operator|=
name|objectModelUri
expr_stmt|;
block|}
comment|// Implementation methods
comment|// -------------------------------------------------------------------------
DECL|method|evaluate (Exchange exchange)
specifier|protected
name|Object
name|evaluate
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|Object
name|answer
init|=
name|evaluateAs
argument_list|(
name|exchange
argument_list|,
name|resultQName
argument_list|)
decl_stmt|;
if|if
condition|(
name|resultType
operator|!=
literal|null
condition|)
block|{
return|return
name|ExchangeHelper
operator|.
name|convertToType
argument_list|(
name|exchange
argument_list|,
name|resultType
argument_list|,
name|answer
argument_list|)
return|;
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Evaluates the expression as the given result type      */
DECL|method|evaluateAs (Exchange exchange, QName resultQName)
specifier|protected
name|Object
name|evaluateAs
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|QName
name|resultQName
parameter_list|)
block|{
comment|// pool a pre compiled expression from pool
name|XPathExpression
name|xpathExpression
init|=
name|pool
operator|.
name|poll
argument_list|()
decl_stmt|;
if|if
condition|(
name|xpathExpression
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Creating new XPathExpression as none was available from pool"
argument_list|)
expr_stmt|;
comment|// no avail in pool then create one
try|try
block|{
name|xpathExpression
operator|=
name|createXPathExpression
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|XPathExpressionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InvalidXPathExpression
argument_list|(
name|getText
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeExpressionException
argument_list|(
literal|"Cannot create xpath expression"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Acquired XPathExpression from pool"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|logNamespaces
operator|&&
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|logNamespaces
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
return|return
name|doInEvaluateAs
argument_list|(
name|xpathExpression
argument_list|,
name|exchange
argument_list|,
name|resultQName
argument_list|)
return|;
block|}
finally|finally
block|{
comment|// release it back to the pool
name|pool
operator|.
name|add
argument_list|(
name|xpathExpression
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Released XPathExpression back to pool"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|logNamespaces (Exchange exchange)
specifier|private
name|void
name|logNamespaces
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|InputStream
name|is
init|=
literal|null
decl_stmt|;
name|NodeList
name|answer
init|=
literal|null
decl_stmt|;
name|XPathExpression
name|xpathExpression
init|=
literal|null
decl_stmt|;
try|try
block|{
name|xpathExpression
operator|=
name|poolLogNamespaces
operator|.
name|poll
argument_list|()
expr_stmt|;
if|if
condition|(
name|xpathExpression
operator|==
literal|null
condition|)
block|{
name|xpathExpression
operator|=
name|createTraceNamespaceExpression
argument_list|()
expr_stmt|;
block|}
comment|// prepare the input
name|Object
name|document
decl_stmt|;
if|if
condition|(
name|isInputStreamNeeded
argument_list|(
name|exchange
argument_list|)
condition|)
block|{
name|is
operator|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|(
name|InputStream
operator|.
name|class
argument_list|)
expr_stmt|;
name|document
operator|=
name|getDocument
argument_list|(
name|exchange
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Object
name|body
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|()
decl_stmt|;
name|document
operator|=
name|getDocument
argument_list|(
name|exchange
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
comment|// fetch all namespaces
if|if
condition|(
name|document
operator|instanceof
name|InputSource
condition|)
block|{
name|InputSource
name|inputSource
init|=
operator|(
name|InputSource
operator|)
name|document
decl_stmt|;
name|answer
operator|=
operator|(
name|NodeList
operator|)
name|xpathExpression
operator|.
name|evaluate
argument_list|(
name|inputSource
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|document
operator|instanceof
name|DOMSource
condition|)
block|{
name|DOMSource
name|source
init|=
operator|(
name|DOMSource
operator|)
name|document
decl_stmt|;
name|answer
operator|=
operator|(
name|NodeList
operator|)
name|xpathExpression
operator|.
name|evaluate
argument_list|(
name|source
operator|.
name|getNode
argument_list|()
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|answer
operator|=
operator|(
name|NodeList
operator|)
name|xpathExpression
operator|.
name|evaluate
argument_list|(
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to trace discovered namespaces in XPath expression"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// IOHelper can handle if is is null
name|IOHelper
operator|.
name|close
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|poolLogNamespaces
operator|.
name|add
argument_list|(
name|xpathExpression
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|logDiscoveredNamespaces
argument_list|(
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|logDiscoveredNamespaces (NodeList namespaces)
specifier|private
name|void
name|logDiscoveredNamespaces
parameter_list|(
name|NodeList
name|namespaces
parameter_list|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|>
name|map
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|namespaces
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|n
init|=
name|namespaces
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|.
name|getNodeName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"xmlns:xml"
argument_list|)
condition|)
block|{
comment|// skip the implicit XML namespace as it provides no value
continue|continue;
block|}
name|String
name|prefix
init|=
name|namespaces
operator|.
name|item
argument_list|(
name|i
argument_list|)
operator|.
name|getNodeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"xmlns"
argument_list|)
condition|)
block|{
name|prefix
operator|=
literal|"DEFAULT"
expr_stmt|;
block|}
comment|// add to map
if|if
condition|(
operator|!
name|map
operator|.
name|containsKey
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|prefix
argument_list|,
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|map
operator|.
name|get
argument_list|(
name|prefix
argument_list|)
operator|.
name|add
argument_list|(
name|namespaces
operator|.
name|item
argument_list|(
name|i
argument_list|)
operator|.
name|getNodeValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Namespaces discovered in message: {}."
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|doInEvaluateAs (XPathExpression xpathExpression, Exchange exchange, QName resultQName)
specifier|protected
name|Object
name|doInEvaluateAs
parameter_list|(
name|XPathExpression
name|xpathExpression
parameter_list|,
name|Exchange
name|exchange
parameter_list|,
name|QName
name|resultQName
parameter_list|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Evaluating exchange: {} as: {}"
argument_list|,
name|exchange
argument_list|,
name|resultQName
argument_list|)
expr_stmt|;
name|Object
name|answer
decl_stmt|;
comment|// set exchange and variable resolver as thread locals for concurrency
name|this
operator|.
name|exchange
operator|.
name|set
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
comment|// the underlying input stream, which we need to close to avoid locking files or other resources
name|InputStream
name|is
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Object
name|document
decl_stmt|;
comment|// Check if we need to apply the XPath expression to a header
if|if
condition|(
name|ObjectHelper
operator|.
name|isNotEmpty
argument_list|(
name|getHeaderName
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|headerName
init|=
name|getHeaderName
argument_list|()
decl_stmt|;
comment|// only convert to input stream if really needed
if|if
condition|(
name|isInputStreamNeeded
argument_list|(
name|exchange
argument_list|,
name|headerName
argument_list|)
condition|)
block|{
name|is
operator|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|headerName
argument_list|,
name|InputStream
operator|.
name|class
argument_list|)
expr_stmt|;
name|document
operator|=
name|getDocument
argument_list|(
name|exchange
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Object
name|headerObject
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|getHeaderName
argument_list|()
argument_list|)
decl_stmt|;
name|document
operator|=
name|getDocument
argument_list|(
name|exchange
argument_list|,
name|headerObject
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// only convert to input stream if really needed
if|if
condition|(
name|isInputStreamNeeded
argument_list|(
name|exchange
argument_list|)
condition|)
block|{
name|is
operator|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|(
name|InputStream
operator|.
name|class
argument_list|)
expr_stmt|;
name|document
operator|=
name|getDocument
argument_list|(
name|exchange
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Object
name|body
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|()
decl_stmt|;
name|document
operator|=
name|getDocument
argument_list|(
name|exchange
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|resultQName
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|document
operator|instanceof
name|InputSource
condition|)
block|{
name|InputSource
name|inputSource
init|=
operator|(
name|InputSource
operator|)
name|document
decl_stmt|;
name|answer
operator|=
name|xpathExpression
operator|.
name|evaluate
argument_list|(
name|inputSource
argument_list|,
name|resultQName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|document
operator|instanceof
name|DOMSource
condition|)
block|{
name|DOMSource
name|source
init|=
operator|(
name|DOMSource
operator|)
name|document
decl_stmt|;
name|answer
operator|=
name|xpathExpression
operator|.
name|evaluate
argument_list|(
name|source
operator|.
name|getNode
argument_list|()
argument_list|,
name|resultQName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|answer
operator|=
name|xpathExpression
operator|.
name|evaluate
argument_list|(
name|document
argument_list|,
name|resultQName
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|document
operator|instanceof
name|InputSource
condition|)
block|{
name|InputSource
name|inputSource
init|=
operator|(
name|InputSource
operator|)
name|document
decl_stmt|;
name|answer
operator|=
name|xpathExpression
operator|.
name|evaluate
argument_list|(
name|inputSource
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|document
operator|instanceof
name|DOMSource
condition|)
block|{
name|DOMSource
name|source
init|=
operator|(
name|DOMSource
operator|)
name|document
decl_stmt|;
name|answer
operator|=
name|xpathExpression
operator|.
name|evaluate
argument_list|(
name|source
operator|.
name|getNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|answer
operator|=
name|xpathExpression
operator|.
name|evaluate
argument_list|(
name|document
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|XPathExpressionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InvalidXPathExpression
argument_list|(
name|getText
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
comment|// IOHelper can handle if is is null
name|IOHelper
operator|.
name|close
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Done evaluating exchange: {} as: {} with result: {}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|exchange
block|,
name|resultQName
block|,
name|answer
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
DECL|method|createXPathExpression ()
specifier|protected
specifier|synchronized
name|XPathExpression
name|createXPathExpression
parameter_list|()
throws|throws
name|XPathExpressionException
throws|,
name|XPathFactoryConfigurationException
block|{
comment|// XPathFactory is not thread safe
name|XPath
name|xPath
init|=
name|getXPathFactory
argument_list|()
operator|.
name|newXPath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|logNamespaces
operator|&&
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Creating new XPath expression in pool. Namespaces on XPath expression: {}"
argument_list|,
name|getNamespaceContext
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|logNamespaces
operator|&&
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Creating new XPath expression in pool. Namespaces on XPath expression: {}"
argument_list|,
name|getNamespaceContext
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|xPath
operator|.
name|setNamespaceContext
argument_list|(
name|getNamespaceContext
argument_list|()
argument_list|)
expr_stmt|;
name|xPath
operator|.
name|setXPathVariableResolver
argument_list|(
name|getVariableResolver
argument_list|()
argument_list|)
expr_stmt|;
name|XPathFunctionResolver
name|parentResolver
init|=
name|getFunctionResolver
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentResolver
operator|==
literal|null
condition|)
block|{
name|parentResolver
operator|=
name|xPath
operator|.
name|getXPathFunctionResolver
argument_list|()
expr_stmt|;
block|}
name|xPath
operator|.
name|setXPathFunctionResolver
argument_list|(
name|createDefaultFunctionResolver
argument_list|(
name|parentResolver
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|xPath
operator|.
name|compile
argument_list|(
name|text
argument_list|)
return|;
block|}
DECL|method|createTraceNamespaceExpression ()
specifier|protected
specifier|synchronized
name|XPathExpression
name|createTraceNamespaceExpression
parameter_list|()
throws|throws
name|XPathFactoryConfigurationException
throws|,
name|XPathExpressionException
block|{
comment|// XPathFactory is not thread safe
name|XPath
name|xPath
init|=
name|getXPathFactory
argument_list|()
operator|.
name|newXPath
argument_list|()
decl_stmt|;
return|return
name|xPath
operator|.
name|compile
argument_list|(
name|OBTAIN_ALL_NS_XPATH
argument_list|)
return|;
block|}
comment|/**      * Populate a number of standard prefixes if they are not already there      */
DECL|method|populateDefaultNamespaces (DefaultNamespaceContext context)
specifier|protected
name|void
name|populateDefaultNamespaces
parameter_list|(
name|DefaultNamespaceContext
name|context
parameter_list|)
block|{
name|setNamespaceIfNotPresent
argument_list|(
name|context
argument_list|,
literal|"in"
argument_list|,
name|IN_NAMESPACE
argument_list|)
expr_stmt|;
name|setNamespaceIfNotPresent
argument_list|(
name|context
argument_list|,
literal|"out"
argument_list|,
name|OUT_NAMESPACE
argument_list|)
expr_stmt|;
name|setNamespaceIfNotPresent
argument_list|(
name|context
argument_list|,
literal|"env"
argument_list|,
name|Namespaces
operator|.
name|ENVIRONMENT_VARIABLES
argument_list|)
expr_stmt|;
name|setNamespaceIfNotPresent
argument_list|(
name|context
argument_list|,
literal|"system"
argument_list|,
name|Namespaces
operator|.
name|SYSTEM_PROPERTIES_NAMESPACE
argument_list|)
expr_stmt|;
name|setNamespaceIfNotPresent
argument_list|(
name|context
argument_list|,
literal|"function"
argument_list|,
name|Namespaces
operator|.
name|FUNCTION_NAMESPACE
argument_list|)
expr_stmt|;
block|}
DECL|method|setNamespaceIfNotPresent (DefaultNamespaceContext context, String prefix, String uri)
specifier|protected
name|void
name|setNamespaceIfNotPresent
parameter_list|(
name|DefaultNamespaceContext
name|context
parameter_list|,
name|String
name|prefix
parameter_list|,
name|String
name|uri
parameter_list|)
block|{
if|if
condition|(
name|context
operator|!=
literal|null
condition|)
block|{
name|String
name|current
init|=
name|context
operator|.
name|getNamespaceURI
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
name|context
operator|.
name|add
argument_list|(
name|prefix
argument_list|,
name|uri
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|createDefaultFunctionResolver (final XPathFunctionResolver parent)
specifier|protected
name|XPathFunctionResolver
name|createDefaultFunctionResolver
parameter_list|(
specifier|final
name|XPathFunctionResolver
name|parent
parameter_list|)
block|{
return|return
operator|new
name|XPathFunctionResolver
argument_list|()
block|{
specifier|public
name|XPathFunction
name|resolveFunction
parameter_list|(
name|QName
name|qName
parameter_list|,
name|int
name|argumentCount
parameter_list|)
block|{
name|XPathFunction
name|answer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|parent
operator|.
name|resolveFunction
argument_list|(
name|qName
argument_list|,
name|argumentCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|isMatchingNamespaceOrEmptyNamespace
argument_list|(
name|qName
operator|.
name|getNamespaceURI
argument_list|()
argument_list|,
name|IN_NAMESPACE
argument_list|)
operator|||
name|isMatchingNamespaceOrEmptyNamespace
argument_list|(
name|qName
operator|.
name|getNamespaceURI
argument_list|()
argument_list|,
name|DEFAULT_NAMESPACE
argument_list|)
condition|)
block|{
name|String
name|localPart
init|=
name|qName
operator|.
name|getLocalPart
argument_list|()
decl_stmt|;
if|if
condition|(
name|localPart
operator|.
name|equals
argument_list|(
literal|"body"
argument_list|)
operator|&&
name|argumentCount
operator|==
literal|0
condition|)
block|{
return|return
name|getBodyFunction
argument_list|()
return|;
block|}
if|if
condition|(
name|localPart
operator|.
name|equals
argument_list|(
literal|"header"
argument_list|)
operator|&&
name|argumentCount
operator|==
literal|1
condition|)
block|{
return|return
name|getHeaderFunction
argument_list|()
return|;
block|}
block|}
if|if
condition|(
name|isMatchingNamespaceOrEmptyNamespace
argument_list|(
name|qName
operator|.
name|getNamespaceURI
argument_list|()
argument_list|,
name|OUT_NAMESPACE
argument_list|)
condition|)
block|{
name|String
name|localPart
init|=
name|qName
operator|.
name|getLocalPart
argument_list|()
decl_stmt|;
if|if
condition|(
name|localPart
operator|.
name|equals
argument_list|(
literal|"body"
argument_list|)
operator|&&
name|argumentCount
operator|==
literal|0
condition|)
block|{
return|return
name|getOutBodyFunction
argument_list|()
return|;
block|}
if|if
condition|(
name|localPart
operator|.
name|equals
argument_list|(
literal|"header"
argument_list|)
operator|&&
name|argumentCount
operator|==
literal|1
condition|)
block|{
return|return
name|getOutHeaderFunction
argument_list|()
return|;
block|}
block|}
if|if
condition|(
name|isMatchingNamespaceOrEmptyNamespace
argument_list|(
name|qName
operator|.
name|getNamespaceURI
argument_list|()
argument_list|,
name|FUNCTION_NAMESPACE
argument_list|)
condition|)
block|{
name|String
name|localPart
init|=
name|qName
operator|.
name|getLocalPart
argument_list|()
decl_stmt|;
if|if
condition|(
name|localPart
operator|.
name|equals
argument_list|(
literal|"properties"
argument_list|)
operator|&&
name|argumentCount
operator|==
literal|1
condition|)
block|{
return|return
name|getPropertiesFunction
argument_list|()
return|;
block|}
if|if
condition|(
name|localPart
operator|.
name|equals
argument_list|(
literal|"simple"
argument_list|)
operator|&&
name|argumentCount
operator|==
literal|1
condition|)
block|{
return|return
name|getSimpleFunction
argument_list|()
return|;
block|}
block|}
block|}
return|return
name|answer
return|;
block|}
block|}
return|;
block|}
comment|/**      * Checks whether we need an {@link InputStream} to access the message body.      *<p/>      * Depending on the content in the message body, we may not need to convert      * to {@link InputStream}.      *      * @param exchange the current exchange      * @return<tt>true</tt> to convert to {@link InputStream} beforehand converting afterwards.      */
DECL|method|isInputStreamNeeded (Exchange exchange)
specifier|protected
name|boolean
name|isInputStreamNeeded
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|Object
name|body
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|()
decl_stmt|;
return|return
name|isInputStreamNeededForObject
argument_list|(
name|exchange
argument_list|,
name|body
argument_list|)
return|;
block|}
comment|/**      * Checks whether we need an {@link InputStream} to access the message header.      *<p/>      * Depending on the content in the message header, we may not need to convert      * to {@link InputStream}.      *      * @param exchange the current exchange      * @return<tt>true</tt> to convert to {@link InputStream} beforehand converting afterwards.      */
DECL|method|isInputStreamNeeded (Exchange exchange, String headerName)
specifier|protected
name|boolean
name|isInputStreamNeeded
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|headerName
parameter_list|)
block|{
name|Object
name|header
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|headerName
argument_list|)
decl_stmt|;
return|return
name|isInputStreamNeededForObject
argument_list|(
name|exchange
argument_list|,
name|header
argument_list|)
return|;
block|}
comment|/**      * Checks whether we need an {@link InputStream} to access this object      *<p/>      * Depending on the content in the object, we may not need to convert      * to {@link InputStream}.      *      * @param exchange the current exchange      * @return<tt>true</tt> to convert to {@link InputStream} beforehand converting afterwards.      */
DECL|method|isInputStreamNeededForObject (Exchange exchange, Object obj)
specifier|protected
name|boolean
name|isInputStreamNeededForObject
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|obj
operator|instanceof
name|WrappedFile
condition|)
block|{
name|obj
operator|=
operator|(
operator|(
name|WrappedFile
argument_list|<
name|?
argument_list|>
operator|)
name|obj
operator|)
operator|.
name|getFile
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|obj
operator|instanceof
name|File
condition|)
block|{
comment|// input stream is needed for File to avoid locking the file in case of errors etc
return|return
literal|true
return|;
block|}
comment|// input stream is not needed otherwise
return|return
literal|false
return|;
block|}
comment|/**      * Strategy method to extract the document from the exchange.      */
DECL|method|getDocument (Exchange exchange, Object body)
specifier|protected
name|Object
name|getDocument
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|body
parameter_list|)
block|{
try|try
block|{
return|return
name|doGetDocument
argument_list|(
name|exchange
argument_list|,
name|body
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|ObjectHelper
operator|.
name|wrapRuntimeCamelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
comment|// call the reset if the in message body is StreamCache
name|MessageHelper
operator|.
name|resetStreamCache
argument_list|(
name|exchange
operator|.
name|getIn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doGetDocument (Exchange exchange, Object body)
specifier|protected
name|Object
name|doGetDocument
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|body
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|body
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Object
name|answer
init|=
literal|null
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|type
init|=
name|getDocumentType
argument_list|()
decl_stmt|;
name|Exception
name|cause
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
comment|// try to get the body as the desired type
try|try
block|{
name|answer
operator|=
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|type
argument_list|,
name|exchange
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// we want to store the caused exception, if we could not convert
name|cause
operator|=
name|e
expr_stmt|;
block|}
block|}
comment|// okay we can try to remedy the failed conversion by some special types
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
comment|// let's try coercing some common types into something JAXP work with the best for special types
if|if
condition|(
name|body
operator|instanceof
name|WrappedFile
condition|)
block|{
comment|// special for files so we can work with them out of the box
name|InputStream
name|is
init|=
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|InputStream
operator|.
name|class
argument_list|,
name|body
argument_list|)
decl_stmt|;
name|answer
operator|=
operator|new
name|InputSource
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|body
operator|instanceof
name|BeanInvocation
condition|)
block|{
comment|// if its a null bean invocation then handle that specially
name|BeanInvocation
name|bi
init|=
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|BeanInvocation
operator|.
name|class
argument_list|,
name|body
argument_list|)
decl_stmt|;
if|if
condition|(
name|bi
operator|.
name|getArgs
argument_list|()
operator|!=
literal|null
operator|&&
name|bi
operator|.
name|getArgs
argument_list|()
operator|.
name|length
operator|==
literal|1
operator|&&
name|bi
operator|.
name|getArgs
argument_list|()
index|[
literal|0
index|]
operator|==
literal|null
condition|)
block|{
comment|// its a null argument from the bean invocation so use null as answer
name|answer
operator|=
literal|null
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|body
operator|instanceof
name|String
condition|)
block|{
name|answer
operator|=
operator|new
name|InputSource
argument_list|(
operator|new
name|StringReader
argument_list|(
operator|(
name|String
operator|)
name|body
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|type
operator|==
literal|null
operator|&&
name|answer
operator|==
literal|null
condition|)
block|{
comment|// fallback to get the body as is
name|answer
operator|=
name|body
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
comment|// there was a type, and we could not convert to it, then fail
if|if
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
throw|throw
name|cause
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|NoTypeConversionAvailableException
argument_list|(
name|body
argument_list|,
name|type
argument_list|)
throw|;
block|}
block|}
return|return
name|answer
return|;
block|}
DECL|method|getVariableResolver ()
specifier|private
name|MessageVariableResolver
name|getVariableResolver
parameter_list|()
block|{
return|return
name|variableResolver
return|;
block|}
DECL|method|start ()
specifier|public
name|void
name|start
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|xpathFactory
operator|==
literal|null
condition|)
block|{
name|initDefaultXPathFactory
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|stop ()
specifier|public
name|void
name|stop
parameter_list|()
throws|throws
name|Exception
block|{
name|pool
operator|.
name|clear
argument_list|()
expr_stmt|;
name|poolLogNamespaces
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|initDefaultXPathFactory ()
specifier|protected
specifier|synchronized
name|void
name|initDefaultXPathFactory
parameter_list|()
throws|throws
name|XPathFactoryConfigurationException
block|{
if|if
condition|(
name|defaultXPathFactory
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|objectModelUri
operator|!=
literal|null
condition|)
block|{
name|defaultXPathFactory
operator|=
name|XPathFactory
operator|.
name|newInstance
argument_list|(
name|objectModelUri
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Using objectModelUri "
operator|+
name|objectModelUri
operator|+
literal|" when created XPathFactory {}"
argument_list|,
name|defaultXPathFactory
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|defaultXPathFactory
operator|==
literal|null
condition|)
block|{
comment|// read system property and see if there is a factory set
name|Properties
name|properties
init|=
name|System
operator|.
name|getProperties
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|prop
range|:
name|properties
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
operator|(
name|String
operator|)
name|prop
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|startsWith
argument_list|(
name|XPathFactory
operator|.
name|DEFAULT_PROPERTY_NAME
argument_list|)
condition|)
block|{
name|String
name|uri
init|=
name|ObjectHelper
operator|.
name|after
argument_list|(
name|key
argument_list|,
literal|":"
argument_list|)
decl_stmt|;
if|if
condition|(
name|uri
operator|!=
literal|null
condition|)
block|{
name|defaultXPathFactory
operator|=
name|XPathFactory
operator|.
name|newInstance
argument_list|(
name|uri
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Using system property {} with value {} when created XPathFactory {}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|key
block|,
name|uri
block|,
name|defaultXPathFactory
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|defaultXPathFactory
operator|=
name|XPathFactory
operator|.
name|newInstance
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Created default XPathFactory {}"
argument_list|,
name|defaultXPathFactory
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

