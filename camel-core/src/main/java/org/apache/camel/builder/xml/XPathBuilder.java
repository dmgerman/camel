begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.builder.xml
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|xml
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentLinkedQueue
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|namespace
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|dom
operator|.
name|DOMSource
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|sax
operator|.
name|SAXSource
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPath
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathConstants
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathExpression
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathExpressionException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathFactoryConfigurationException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathFunction
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathFunctionException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|xpath
operator|.
name|XPathFunctionResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|InputSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContextAware
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Expression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|NoTypeConversionAvailableException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|RuntimeExpressionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|WrappedFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|converter
operator|.
name|jaxp
operator|.
name|ThreadSafeNodeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|impl
operator|.
name|DefaultExchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|Language
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|NamespaceAware
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|ServiceSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ExchangeHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|IOHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|MessageHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ObjectHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|StringHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|xml
operator|.
name|Namespaces
operator|.
name|DEFAULT_NAMESPACE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|xml
operator|.
name|Namespaces
operator|.
name|FUNCTION_NAMESPACE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|xml
operator|.
name|Namespaces
operator|.
name|IN_NAMESPACE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|xml
operator|.
name|Namespaces
operator|.
name|OUT_NAMESPACE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|xml
operator|.
name|Namespaces
operator|.
name|isMatchingNamespaceOrEmptyNamespace
import|;
end_import

begin_comment
comment|/**  * Creates an XPath expression builder which creates a nodeset result by  * default. If you want to evaluate a String expression then call  * {@link #stringResult()}  *<p/>  * An XPath object is not thread-safe and not reentrant. In other words, it is  * the application's responsibility to make sure that one XPath object is not  * used from more than one thread at any given time, and while the evaluate  * method is invoked, applications may not recursively call the evaluate method.  *<p/>  * This implementation is thread safe by using thread locals and pooling to  * allow concurrency.  *<p/>  *<b>Important:</b> After configuring the {@link XPathBuilder} its advised to  * invoke {@link #start()} to prepare the builder before using; though the  * builder will auto-start on first use.  *  * @see XPathConstants#NODESET  */
end_comment

begin_class
DECL|class|XPathBuilder
specifier|public
class|class
name|XPathBuilder
extends|extends
name|ServiceSupport
implements|implements
name|CamelContextAware
implements|,
name|Expression
implements|,
name|Predicate
implements|,
name|NamespaceAware
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|XPathBuilder
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|SAXON_OBJECT_MODEL_URI
specifier|private
specifier|static
specifier|final
name|String
name|SAXON_OBJECT_MODEL_URI
init|=
literal|"http://saxon.sf.net/jaxp/xpath/om"
decl_stmt|;
DECL|field|SAXON_FACTORY_CLASS_NAME
specifier|private
specifier|static
specifier|final
name|String
name|SAXON_FACTORY_CLASS_NAME
init|=
literal|"net.sf.saxon.xpath.XPathFactoryImpl"
decl_stmt|;
DECL|field|OBTAIN_ALL_NS_XPATH
specifier|private
specifier|static
specifier|final
name|String
name|OBTAIN_ALL_NS_XPATH
init|=
literal|"//*/namespace::*"
decl_stmt|;
DECL|field|defaultXPathFactory
specifier|private
specifier|static
specifier|volatile
name|XPathFactory
name|defaultXPathFactory
decl_stmt|;
DECL|field|camelContext
specifier|private
name|CamelContext
name|camelContext
decl_stmt|;
DECL|field|pool
specifier|private
specifier|final
name|Queue
argument_list|<
name|XPathExpression
argument_list|>
name|pool
init|=
operator|new
name|ConcurrentLinkedQueue
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|poolLogNamespaces
specifier|private
specifier|final
name|Queue
argument_list|<
name|XPathExpression
argument_list|>
name|poolLogNamespaces
init|=
operator|new
name|ConcurrentLinkedQueue
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|text
specifier|private
specifier|final
name|String
name|text
decl_stmt|;
DECL|field|exchange
specifier|private
specifier|final
name|ThreadLocal
argument_list|<
name|Exchange
argument_list|>
name|exchange
init|=
operator|new
name|ThreadLocal
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|variableResolver
specifier|private
specifier|final
name|MessageVariableResolver
name|variableResolver
init|=
operator|new
name|MessageVariableResolver
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
DECL|field|namespaces
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|namespaces
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|threadSafety
specifier|private
name|boolean
name|threadSafety
decl_stmt|;
DECL|field|xpathFactory
specifier|private
specifier|volatile
name|XPathFactory
name|xpathFactory
decl_stmt|;
DECL|field|documentType
specifier|private
specifier|volatile
name|Class
argument_list|<
name|?
argument_list|>
name|documentType
init|=
name|Document
operator|.
name|class
decl_stmt|;
comment|// For some reason the default expression of "a/b" on a document such as
comment|//<a><b>1</b><b>2</b></a>
comment|// will evaluate as just "1" by default which is bizarre. So by default
comment|// let's assume XPath expressions result in nodesets.
DECL|field|resultType
specifier|private
specifier|volatile
name|Class
argument_list|<
name|?
argument_list|>
name|resultType
decl_stmt|;
DECL|field|resultQName
specifier|private
specifier|volatile
name|QName
name|resultQName
init|=
name|XPathConstants
operator|.
name|NODESET
decl_stmt|;
DECL|field|objectModelUri
specifier|private
specifier|volatile
name|String
name|objectModelUri
decl_stmt|;
DECL|field|factoryClassName
specifier|private
specifier|volatile
name|String
name|factoryClassName
decl_stmt|;
DECL|field|namespaceContext
specifier|private
specifier|volatile
name|DefaultNamespaceContext
name|namespaceContext
decl_stmt|;
DECL|field|logNamespaces
specifier|private
specifier|volatile
name|boolean
name|logNamespaces
decl_stmt|;
DECL|field|functionResolver
specifier|private
specifier|volatile
name|XPathFunctionResolver
name|functionResolver
decl_stmt|;
DECL|field|bodyFunction
specifier|private
specifier|volatile
name|XPathFunction
name|bodyFunction
decl_stmt|;
DECL|field|headerFunction
specifier|private
specifier|volatile
name|XPathFunction
name|headerFunction
decl_stmt|;
DECL|field|outBodyFunction
specifier|private
specifier|volatile
name|XPathFunction
name|outBodyFunction
decl_stmt|;
DECL|field|outHeaderFunction
specifier|private
specifier|volatile
name|XPathFunction
name|outHeaderFunction
decl_stmt|;
DECL|field|propertiesFunction
specifier|private
specifier|volatile
name|XPathFunction
name|propertiesFunction
decl_stmt|;
DECL|field|simpleFunction
specifier|private
specifier|volatile
name|XPathFunction
name|simpleFunction
decl_stmt|;
comment|/**      * The name of the header we want to apply the XPath expression to, which      * when set will cause the xpath to be evaluated on the required header,      * otherwise it will be applied to the body      */
DECL|field|headerName
specifier|private
specifier|volatile
name|String
name|headerName
decl_stmt|;
comment|/**      * @param text The XPath expression      */
DECL|method|XPathBuilder (String text)
specifier|public
name|XPathBuilder
parameter_list|(
name|String
name|text
parameter_list|)
block|{
name|this
operator|.
name|text
operator|=
name|text
expr_stmt|;
block|}
comment|/**      * @param text The XPath expression      * @return A new XPathBuilder object      */
DECL|method|xpath (String text)
specifier|public
specifier|static
name|XPathBuilder
name|xpath
parameter_list|(
name|String
name|text
parameter_list|)
block|{
return|return
operator|new
name|XPathBuilder
argument_list|(
name|text
argument_list|)
return|;
block|}
comment|/**      * @param text The XPath expression      * @param resultType The result type that the XPath expression will return.      * @return A new XPathBuilder object      */
DECL|method|xpath (String text, Class<?> resultType)
specifier|public
specifier|static
name|XPathBuilder
name|xpath
parameter_list|(
name|String
name|text
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|resultType
parameter_list|)
block|{
name|XPathBuilder
name|builder
init|=
operator|new
name|XPathBuilder
argument_list|(
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
name|resultType
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setResultType
argument_list|(
name|resultType
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"XPath: "
operator|+
name|text
return|;
block|}
annotation|@
name|Override
DECL|method|getCamelContext ()
specifier|public
name|CamelContext
name|getCamelContext
parameter_list|()
block|{
return|return
name|camelContext
return|;
block|}
annotation|@
name|Override
DECL|method|setCamelContext (CamelContext camelContext)
specifier|public
name|void
name|setCamelContext
parameter_list|(
name|CamelContext
name|camelContext
parameter_list|)
block|{
name|this
operator|.
name|camelContext
operator|=
name|camelContext
expr_stmt|;
block|}
DECL|method|matches (Exchange exchange)
specifier|public
name|boolean
name|matches
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
try|try
block|{
name|Object
name|booleanResult
init|=
name|evaluateAs
argument_list|(
name|exchange
argument_list|,
name|XPathConstants
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
return|return
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|Boolean
operator|.
name|class
argument_list|,
name|booleanResult
argument_list|)
return|;
block|}
finally|finally
block|{
comment|// remove the thread local after usage
name|this
operator|.
name|exchange
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|evaluate (Exchange exchange, Class<T> type)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|evaluate
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
try|try
block|{
name|Object
name|result
init|=
name|evaluate
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
return|return
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|type
argument_list|,
name|exchange
argument_list|,
name|result
argument_list|)
return|;
block|}
finally|finally
block|{
comment|// remove the thread local after usage
name|this
operator|.
name|exchange
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Matches the given xpath using the provided body.      *      * @param context the camel context      * @param body the body      * @return<tt>true</tt> if matches,<tt>false</tt> otherwise      */
DECL|method|matches (CamelContext context, Object body)
specifier|public
name|boolean
name|matches
parameter_list|(
name|CamelContext
name|context
parameter_list|,
name|Object
name|body
parameter_list|)
block|{
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|context
argument_list|,
literal|"CamelContext"
argument_list|)
expr_stmt|;
comment|// create a dummy Exchange to use during matching
name|Exchange
name|dummy
init|=
operator|new
name|DefaultExchange
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|dummy
operator|.
name|getIn
argument_list|()
operator|.
name|setBody
argument_list|(
name|body
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|matches
argument_list|(
name|dummy
argument_list|)
return|;
block|}
finally|finally
block|{
comment|// remove the thread local after usage
name|exchange
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Evaluates the given xpath using the provided body.      *<p/>      * The evaluation uses by default      * {@link javax.xml.xpath.XPathConstants#NODESET} as the type used during      * xpath evaluation. The output from xpath is then afterwards type converted      * using Camel's type converter to the given type.      *<p/>      * If you want to evaluate xpath using a different type, then call      * {@link #setResultType(Class)} prior to calling this evaluate method.      *      * @param context the camel context      * @param body the body      * @param type the type to return      * @return result of the evaluation      */
DECL|method|evaluate (CamelContext context, Object body, Class<T> type)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|evaluate
parameter_list|(
name|CamelContext
name|context
parameter_list|,
name|Object
name|body
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|context
argument_list|,
literal|"CamelContext"
argument_list|)
expr_stmt|;
comment|// create a dummy Exchange to use during evaluation
name|Exchange
name|dummy
init|=
operator|new
name|DefaultExchange
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|dummy
operator|.
name|getIn
argument_list|()
operator|.
name|setBody
argument_list|(
name|body
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|evaluate
argument_list|(
name|dummy
argument_list|,
name|type
argument_list|)
return|;
block|}
finally|finally
block|{
comment|// remove the thread local after usage
name|exchange
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Evaluates the given xpath using the provided body as a String return      * type.      *      * @param context the camel context      * @param body the body      * @return result of the evaluation      */
DECL|method|evaluate (CamelContext context, Object body)
specifier|public
name|String
name|evaluate
parameter_list|(
name|CamelContext
name|context
parameter_list|,
name|Object
name|body
parameter_list|)
block|{
name|ObjectHelper
operator|.
name|notNull
argument_list|(
name|context
argument_list|,
literal|"CamelContext"
argument_list|)
expr_stmt|;
comment|// create a dummy Exchange to use during evaluation
name|Exchange
name|dummy
init|=
operator|new
name|DefaultExchange
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|dummy
operator|.
name|getIn
argument_list|()
operator|.
name|setBody
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|setResultQName
argument_list|(
name|XPathConstants
operator|.
name|STRING
argument_list|)
expr_stmt|;
name|setResultType
argument_list|(
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|evaluate
argument_list|(
name|dummy
argument_list|,
name|String
operator|.
name|class
argument_list|)
return|;
block|}
finally|finally
block|{
comment|// remove the thread local after usage
name|this
operator|.
name|exchange
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Builder methods
comment|// -------------------------------------------------------------------------
comment|/**      * Sets the expression result type to {@link XPathConstants#BOOLEAN}      *      * @return the current builder      */
DECL|method|booleanResult ()
specifier|public
name|XPathBuilder
name|booleanResult
parameter_list|()
block|{
name|resultQName
operator|=
name|XPathConstants
operator|.
name|BOOLEAN
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets the expression result type to {@link XPathConstants#NODE}      *      * @return the current builder      */
DECL|method|nodeResult ()
specifier|public
name|XPathBuilder
name|nodeResult
parameter_list|()
block|{
name|resultQName
operator|=
name|XPathConstants
operator|.
name|NODE
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets the expression result type to {@link XPathConstants#NODESET}      *      * @return the current builder      */
DECL|method|nodeSetResult ()
specifier|public
name|XPathBuilder
name|nodeSetResult
parameter_list|()
block|{
name|resultQName
operator|=
name|XPathConstants
operator|.
name|NODESET
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets the expression result type to {@link XPathConstants#NUMBER}      *      * @return the current builder      */
DECL|method|numberResult ()
specifier|public
name|XPathBuilder
name|numberResult
parameter_list|()
block|{
name|resultQName
operator|=
name|XPathConstants
operator|.
name|NUMBER
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets the expression result type to {@link XPathConstants#STRING}      *      * @return the current builder      */
DECL|method|stringResult ()
specifier|public
name|XPathBuilder
name|stringResult
parameter_list|()
block|{
name|resultQName
operator|=
name|XPathConstants
operator|.
name|STRING
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets the expression result type to the given {@code resultType}      *      * @return the current builder      */
DECL|method|resultType (Class<?> resultType)
specifier|public
name|XPathBuilder
name|resultType
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|resultType
parameter_list|)
block|{
name|setResultType
argument_list|(
name|resultType
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets the object model URI to use      *      * @return the current builder      */
DECL|method|objectModel (String uri)
specifier|public
name|XPathBuilder
name|objectModel
parameter_list|(
name|String
name|uri
parameter_list|)
block|{
comment|// Careful! Setting the Object Model URI this way will set the *Default*
comment|// XPath Factory, which since is a static field,
comment|// will set the XPath Factory system-wide. Decide what to do, as
comment|// changing this behaviour can break compatibility. Provided the
comment|// setObjectModel which changes
comment|// this instance's XPath Factory rather than the static field
name|this
operator|.
name|objectModelUri
operator|=
name|uri
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets the factory class name to use      *      * @return the current builder      */
DECL|method|factoryClassName (String factoryClassName)
specifier|public
name|XPathBuilder
name|factoryClassName
parameter_list|(
name|String
name|factoryClassName
parameter_list|)
block|{
name|this
operator|.
name|factoryClassName
operator|=
name|factoryClassName
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Configures to use Saxon as the XPathFactory which allows you to use XPath      * 2.0 functions which may not be part of the build in JDK XPath parser.      *      * @return the current builder      */
DECL|method|saxon ()
specifier|public
name|XPathBuilder
name|saxon
parameter_list|()
block|{
name|this
operator|.
name|objectModelUri
operator|=
name|SAXON_OBJECT_MODEL_URI
expr_stmt|;
name|this
operator|.
name|factoryClassName
operator|=
name|SAXON_FACTORY_CLASS_NAME
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets the {@link XPathFunctionResolver} instance to use on these XPath      * expressions      *      * @return the current builder      */
DECL|method|functionResolver (XPathFunctionResolver functionResolver)
specifier|public
name|XPathBuilder
name|functionResolver
parameter_list|(
name|XPathFunctionResolver
name|functionResolver
parameter_list|)
block|{
name|this
operator|.
name|functionResolver
operator|=
name|functionResolver
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Registers the namespace prefix and URI with the builder so that the      * prefix can be used in XPath expressions      *      * @param prefix is the namespace prefix that can be used in the XPath      *            expressions      * @param uri is the namespace URI to which the prefix refers      * @return the current builder      */
DECL|method|namespace (String prefix, String uri)
specifier|public
name|XPathBuilder
name|namespace
parameter_list|(
name|String
name|prefix
parameter_list|,
name|String
name|uri
parameter_list|)
block|{
name|namespaces
operator|.
name|put
argument_list|(
name|prefix
argument_list|,
name|uri
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Registers namespaces with the builder so that the registered prefixes can      * be used in XPath expressions      *      * @param namespaces is namespaces object that should be used in the XPath      *            expression      * @return the current builder      */
DECL|method|namespaces (Namespaces namespaces)
specifier|public
name|XPathBuilder
name|namespaces
parameter_list|(
name|Namespaces
name|namespaces
parameter_list|)
block|{
name|namespaces
operator|.
name|configure
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Registers a variable (in the global namespace) which can be referred to      * from XPath expressions      *      * @param name name of variable      * @param value value of variable      * @return the current builder      */
DECL|method|variable (String name, Object value)
specifier|public
name|XPathBuilder
name|variable
parameter_list|(
name|String
name|name
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|getVariableResolver
argument_list|()
operator|.
name|addVariable
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Configures the document type to use.      *<p/>      * The document type controls which kind of Class Camel should convert the      * payload to before doing the xpath evaluation.      *<p/>      * For example you can set it to {@link InputSource} to use SAX streams. By      * default Camel uses {@link Document} as the type.      *      * @param documentType the document type      * @return the current builder      */
DECL|method|documentType (Class<?> documentType)
specifier|public
name|XPathBuilder
name|documentType
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|documentType
parameter_list|)
block|{
name|setDocumentType
argument_list|(
name|documentType
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Configures to use the provided XPath factory.      *<p/>      * Can be used to use Saxon instead of the build in factory from the JDK.      *      * @param xpathFactory the xpath factory to use      * @return the current builder.      */
DECL|method|factory (XPathFactory xpathFactory)
specifier|public
name|XPathBuilder
name|factory
parameter_list|(
name|XPathFactory
name|xpathFactory
parameter_list|)
block|{
name|setXPathFactory
argument_list|(
name|xpathFactory
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Activates trace logging of all discovered namespaces in the message - to      * simplify debugging namespace-related issues      *<p/>      * Namespaces are printed in Hashmap style      *<code>{xmlns:prefix=[namespaceURI], xmlns:prefix=[namespaceURI]}</code>.      *<p/>      * The implicit XML namespace is omitted      * (http://www.w3.org/XML/1998/namespace). XML allows for namespace prefixes      * to be redefined/overridden due to hierarchical scoping, i.e. prefix abc      * can be mapped to http://abc.com, and deeper in the document it can be      * mapped to http://def.com. When two prefixes are detected which are equal      * but are mapped to different namespace URIs, Camel will show all      * namespaces URIs it is mapped to in an array-style.      *<p/>      * This feature is disabled by default.      *      * @return the current builder.      */
DECL|method|logNamespaces ()
specifier|public
name|XPathBuilder
name|logNamespaces
parameter_list|()
block|{
name|setLogNamespaces
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Whether to enable thread-safety for the returned result of the xpath      * expression. This applies to when using NODESET as the result type, and      * the returned set has multiple elements. In this situation there can be      * thread-safety issues if you process the NODESET concurrently such as from      * a Camel Splitter EIP in parallel processing mode. This option prevents      * concurrency issues by doing defensive copies of the nodes.      *<p/>      * It is recommended to turn this option on if you are using camel-saxon or      * Saxon in your application. Saxon has thread-safety issues which can be      * prevented by turning this option on.      *<p/>      * Thread-safety is disabled by default      *      * @return the current builder.      */
DECL|method|threadSafety (boolean threadSafety)
specifier|public
name|XPathBuilder
name|threadSafety
parameter_list|(
name|boolean
name|threadSafety
parameter_list|)
block|{
name|setThreadSafety
argument_list|(
name|threadSafety
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|// Properties
comment|// -------------------------------------------------------------------------
comment|/**      * Gets the xpath factory, can be<tt>null</tt> if no custom factory has      * been assigned.      *<p/>      * A default factory will be assigned (if no custom assigned) when either      * starting this builder or on first evaluation.      *      * @return the factory, or<tt>null</tt> if this builder has not been      *         started/used before.      */
DECL|method|getXPathFactory ()
specifier|public
name|XPathFactory
name|getXPathFactory
parameter_list|()
block|{
return|return
name|xpathFactory
return|;
block|}
DECL|method|setXPathFactory (XPathFactory xpathFactory)
specifier|public
name|void
name|setXPathFactory
parameter_list|(
name|XPathFactory
name|xpathFactory
parameter_list|)
block|{
name|this
operator|.
name|xpathFactory
operator|=
name|xpathFactory
expr_stmt|;
block|}
DECL|method|getDocumentType ()
specifier|public
name|Class
argument_list|<
name|?
argument_list|>
name|getDocumentType
parameter_list|()
block|{
return|return
name|documentType
return|;
block|}
DECL|method|setDocumentType (Class<?> documentType)
specifier|public
name|void
name|setDocumentType
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|documentType
parameter_list|)
block|{
name|this
operator|.
name|documentType
operator|=
name|documentType
expr_stmt|;
block|}
DECL|method|getText ()
specifier|public
name|String
name|getText
parameter_list|()
block|{
return|return
name|text
return|;
block|}
DECL|method|getResultQName ()
specifier|public
name|QName
name|getResultQName
parameter_list|()
block|{
return|return
name|resultQName
return|;
block|}
DECL|method|setResultQName (QName resultQName)
specifier|public
name|void
name|setResultQName
parameter_list|(
name|QName
name|resultQName
parameter_list|)
block|{
name|this
operator|.
name|resultQName
operator|=
name|resultQName
expr_stmt|;
block|}
DECL|method|getHeaderName ()
specifier|public
name|String
name|getHeaderName
parameter_list|()
block|{
return|return
name|headerName
return|;
block|}
DECL|method|setHeaderName (String headerName)
specifier|public
name|void
name|setHeaderName
parameter_list|(
name|String
name|headerName
parameter_list|)
block|{
name|this
operator|.
name|headerName
operator|=
name|headerName
expr_stmt|;
block|}
DECL|method|isThreadSafety ()
specifier|public
name|boolean
name|isThreadSafety
parameter_list|()
block|{
return|return
name|threadSafety
return|;
block|}
DECL|method|setThreadSafety (boolean threadSafety)
specifier|public
name|void
name|setThreadSafety
parameter_list|(
name|boolean
name|threadSafety
parameter_list|)
block|{
name|this
operator|.
name|threadSafety
operator|=
name|threadSafety
expr_stmt|;
block|}
comment|/**      * Gets the namespace context, can be<tt>null</tt> if no custom context has      * been assigned.      *<p/>      * A default context will be assigned (if no custom assigned) when either      * starting this builder or on first evaluation.      *      * @return the context, or<tt>null</tt> if this builder has not been      *         started/used before.      */
DECL|method|getNamespaceContext ()
specifier|public
name|DefaultNamespaceContext
name|getNamespaceContext
parameter_list|()
block|{
return|return
name|namespaceContext
return|;
block|}
DECL|method|setNamespaceContext (DefaultNamespaceContext namespaceContext)
specifier|public
name|void
name|setNamespaceContext
parameter_list|(
name|DefaultNamespaceContext
name|namespaceContext
parameter_list|)
block|{
name|this
operator|.
name|namespaceContext
operator|=
name|namespaceContext
expr_stmt|;
block|}
DECL|method|getFunctionResolver ()
specifier|public
name|XPathFunctionResolver
name|getFunctionResolver
parameter_list|()
block|{
return|return
name|functionResolver
return|;
block|}
DECL|method|setFunctionResolver (XPathFunctionResolver functionResolver)
specifier|public
name|void
name|setFunctionResolver
parameter_list|(
name|XPathFunctionResolver
name|functionResolver
parameter_list|)
block|{
name|this
operator|.
name|functionResolver
operator|=
name|functionResolver
expr_stmt|;
block|}
DECL|method|setNamespaces (Map<String, String> namespaces)
specifier|public
name|void
name|setNamespaces
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|namespaces
parameter_list|)
block|{
name|this
operator|.
name|namespaces
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|namespaces
operator|.
name|putAll
argument_list|(
name|namespaces
argument_list|)
expr_stmt|;
block|}
DECL|method|getNamespaces ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getNamespaces
parameter_list|()
block|{
return|return
name|namespaces
return|;
block|}
comment|/**      * Gets the {@link XPathFunction} for getting the input message body.      *<p/>      * A default function will be assigned (if no custom assigned) when either      * starting this builder or on first evaluation.      *      * @return the function, or<tt>null</tt> if this builder has not been      *         started/used before.      */
DECL|method|getBodyFunction ()
specifier|public
name|XPathFunction
name|getBodyFunction
parameter_list|()
block|{
return|return
name|bodyFunction
return|;
block|}
DECL|method|createBodyFunction ()
specifier|private
name|XPathFunction
name|createBodyFunction
parameter_list|()
block|{
return|return
operator|new
name|XPathFunction
argument_list|()
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
specifier|public
name|Object
name|evaluate
parameter_list|(
name|List
name|list
parameter_list|)
throws|throws
name|XPathFunctionException
block|{
return|return
name|exchange
operator|.
name|get
argument_list|()
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|()
return|;
block|}
block|}
return|;
block|}
DECL|method|setBodyFunction (XPathFunction bodyFunction)
specifier|public
name|void
name|setBodyFunction
parameter_list|(
name|XPathFunction
name|bodyFunction
parameter_list|)
block|{
name|this
operator|.
name|bodyFunction
operator|=
name|bodyFunction
expr_stmt|;
block|}
comment|/**      * Gets the {@link XPathFunction} for getting the input message header.      *<p/>      * A default function will be assigned (if no custom assigned) when either      * starting this builder or on first evaluation.      *      * @return the function, or<tt>null</tt> if this builder has not been      *         started/used before.      */
DECL|method|getHeaderFunction ()
specifier|public
name|XPathFunction
name|getHeaderFunction
parameter_list|()
block|{
return|return
name|headerFunction
return|;
block|}
DECL|method|createHeaderFunction ()
specifier|private
name|XPathFunction
name|createHeaderFunction
parameter_list|()
block|{
return|return
operator|new
name|XPathFunction
argument_list|()
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
specifier|public
name|Object
name|evaluate
parameter_list|(
name|List
name|list
parameter_list|)
throws|throws
name|XPathFunctionException
block|{
if|if
condition|(
operator|!
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Object
name|value
init|=
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|String
name|text
init|=
name|exchange
operator|.
name|get
argument_list|()
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|String
operator|.
name|class
argument_list|,
name|value
argument_list|)
decl_stmt|;
return|return
name|exchange
operator|.
name|get
argument_list|()
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|text
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
return|;
block|}
DECL|method|setHeaderFunction (XPathFunction headerFunction)
specifier|public
name|void
name|setHeaderFunction
parameter_list|(
name|XPathFunction
name|headerFunction
parameter_list|)
block|{
name|this
operator|.
name|headerFunction
operator|=
name|headerFunction
expr_stmt|;
block|}
comment|/**      * Gets the {@link XPathFunction} for getting the output message body.      *<p/>      * A default function will be assigned (if no custom assigned) when either      * starting this builder or on first evaluation.      *      * @return the function, or<tt>null</tt> if this builder has not been      *         started/used before.      */
DECL|method|getOutBodyFunction ()
specifier|public
name|XPathFunction
name|getOutBodyFunction
parameter_list|()
block|{
return|return
name|outBodyFunction
return|;
block|}
DECL|method|createOutBodyFunction ()
specifier|private
name|XPathFunction
name|createOutBodyFunction
parameter_list|()
block|{
return|return
operator|new
name|XPathFunction
argument_list|()
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
specifier|public
name|Object
name|evaluate
parameter_list|(
name|List
name|list
parameter_list|)
throws|throws
name|XPathFunctionException
block|{
if|if
condition|(
name|exchange
operator|.
name|get
argument_list|()
operator|!=
literal|null
operator|&&
name|exchange
operator|.
name|get
argument_list|()
operator|.
name|hasOut
argument_list|()
condition|)
block|{
return|return
name|exchange
operator|.
name|get
argument_list|()
operator|.
name|getOut
argument_list|()
operator|.
name|getBody
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
return|;
block|}
DECL|method|setOutBodyFunction (XPathFunction outBodyFunction)
specifier|public
name|void
name|setOutBodyFunction
parameter_list|(
name|XPathFunction
name|outBodyFunction
parameter_list|)
block|{
name|this
operator|.
name|outBodyFunction
operator|=
name|outBodyFunction
expr_stmt|;
block|}
comment|/**      * Gets the {@link XPathFunction} for getting the output message header.      *<p/>      * A default function will be assigned (if no custom assigned) when either      * starting this builder or on first evaluation.      *      * @return the function, or<tt>null</tt> if this builder has not been      *         started/used before.      */
DECL|method|getOutHeaderFunction ()
specifier|public
name|XPathFunction
name|getOutHeaderFunction
parameter_list|()
block|{
return|return
name|outHeaderFunction
return|;
block|}
DECL|method|createOutHeaderFunction ()
specifier|private
name|XPathFunction
name|createOutHeaderFunction
parameter_list|()
block|{
return|return
operator|new
name|XPathFunction
argument_list|()
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
specifier|public
name|Object
name|evaluate
parameter_list|(
name|List
name|list
parameter_list|)
throws|throws
name|XPathFunctionException
block|{
if|if
condition|(
name|exchange
operator|.
name|get
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Object
name|value
init|=
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|String
name|text
init|=
name|exchange
operator|.
name|get
argument_list|()
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|String
operator|.
name|class
argument_list|,
name|value
argument_list|)
decl_stmt|;
return|return
name|exchange
operator|.
name|get
argument_list|()
operator|.
name|getOut
argument_list|()
operator|.
name|getHeader
argument_list|(
name|text
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
return|;
block|}
DECL|method|setOutHeaderFunction (XPathFunction outHeaderFunction)
specifier|public
name|void
name|setOutHeaderFunction
parameter_list|(
name|XPathFunction
name|outHeaderFunction
parameter_list|)
block|{
name|this
operator|.
name|outHeaderFunction
operator|=
name|outHeaderFunction
expr_stmt|;
block|}
comment|/**      * Gets the {@link XPathFunction} for getting the exchange properties.      *<p/>      * A default function will be assigned (if no custom assigned) when either      * starting this builder or on first evaluation.      *      * @return the function, or<tt>null</tt> if this builder has not been      *         started/used before.      */
DECL|method|getPropertiesFunction ()
specifier|public
name|XPathFunction
name|getPropertiesFunction
parameter_list|()
block|{
return|return
name|propertiesFunction
return|;
block|}
DECL|method|createPropertiesFunction ()
specifier|private
name|XPathFunction
name|createPropertiesFunction
parameter_list|()
block|{
return|return
operator|new
name|XPathFunction
argument_list|()
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
specifier|public
name|Object
name|evaluate
parameter_list|(
name|List
name|list
parameter_list|)
throws|throws
name|XPathFunctionException
block|{
if|if
condition|(
operator|!
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Object
name|value
init|=
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|String
name|text
init|=
name|exchange
operator|.
name|get
argument_list|()
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|String
operator|.
name|class
argument_list|,
name|value
argument_list|)
decl_stmt|;
try|try
block|{
comment|// use the property placeholder resolver to lookup
comment|// the property for us
name|Object
name|answer
init|=
name|exchange
operator|.
name|get
argument_list|()
operator|.
name|getContext
argument_list|()
operator|.
name|resolvePropertyPlaceholders
argument_list|(
literal|"{{"
operator|+
name|text
operator|+
literal|"}}"
argument_list|)
decl_stmt|;
return|return
name|answer
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XPathFunctionException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
return|;
block|}
DECL|method|setPropertiesFunction (XPathFunction propertiesFunction)
specifier|public
name|void
name|setPropertiesFunction
parameter_list|(
name|XPathFunction
name|propertiesFunction
parameter_list|)
block|{
name|this
operator|.
name|propertiesFunction
operator|=
name|propertiesFunction
expr_stmt|;
block|}
comment|/**      * Gets the {@link XPathFunction} for executing      *<a href="http://camel.apache.org/simple">simple</a> language as xpath      * function.      *<p/>      * A default function will be assigned (if no custom assigned) when either      * starting this builder or on first evaluation.      *      * @return the function, or<tt>null</tt> if this builder has not been      *         started/used before.      */
DECL|method|getSimpleFunction ()
specifier|public
name|XPathFunction
name|getSimpleFunction
parameter_list|()
block|{
return|return
name|simpleFunction
return|;
block|}
DECL|method|createSimpleFunction ()
specifier|private
name|XPathFunction
name|createSimpleFunction
parameter_list|()
block|{
return|return
operator|new
name|XPathFunction
argument_list|()
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
specifier|public
name|Object
name|evaluate
parameter_list|(
name|List
name|list
parameter_list|)
throws|throws
name|XPathFunctionException
block|{
if|if
condition|(
operator|!
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Object
name|value
init|=
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|String
name|text
init|=
name|exchange
operator|.
name|get
argument_list|()
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|String
operator|.
name|class
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|Language
name|simple
init|=
name|exchange
operator|.
name|get
argument_list|()
operator|.
name|getContext
argument_list|()
operator|.
name|resolveLanguage
argument_list|(
literal|"simple"
argument_list|)
decl_stmt|;
name|Expression
name|exp
init|=
name|simple
operator|.
name|createExpression
argument_list|(
name|text
argument_list|)
decl_stmt|;
name|Object
name|answer
init|=
name|exp
operator|.
name|evaluate
argument_list|(
name|exchange
operator|.
name|get
argument_list|()
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|answer
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
return|;
block|}
DECL|method|setSimpleFunction (XPathFunction simpleFunction)
specifier|public
name|void
name|setSimpleFunction
parameter_list|(
name|XPathFunction
name|simpleFunction
parameter_list|)
block|{
name|this
operator|.
name|simpleFunction
operator|=
name|simpleFunction
expr_stmt|;
block|}
DECL|method|getResultType ()
specifier|public
name|Class
argument_list|<
name|?
argument_list|>
name|getResultType
parameter_list|()
block|{
return|return
name|resultType
return|;
block|}
DECL|method|setResultType (Class<?> resultType)
specifier|public
name|void
name|setResultType
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|resultType
parameter_list|)
block|{
name|this
operator|.
name|resultType
operator|=
name|resultType
expr_stmt|;
if|if
condition|(
name|Number
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|resultType
argument_list|)
condition|)
block|{
name|numberResult
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|String
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|resultType
argument_list|)
condition|)
block|{
name|stringResult
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Boolean
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|resultType
argument_list|)
condition|)
block|{
name|booleanResult
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Node
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|resultType
argument_list|)
condition|)
block|{
name|nodeResult
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NodeList
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|resultType
argument_list|)
condition|)
block|{
name|nodeSetResult
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|setLogNamespaces (boolean logNamespaces)
specifier|public
name|void
name|setLogNamespaces
parameter_list|(
name|boolean
name|logNamespaces
parameter_list|)
block|{
name|this
operator|.
name|logNamespaces
operator|=
name|logNamespaces
expr_stmt|;
block|}
DECL|method|isLogNamespaces ()
specifier|public
name|boolean
name|isLogNamespaces
parameter_list|()
block|{
return|return
name|logNamespaces
return|;
block|}
comment|/**      * Enables Saxon on this particular XPath expression, as {@link #saxon()}      * sets the default static XPathFactory which may have already been      * initialised by previous XPath expressions      */
DECL|method|enableSaxon ()
specifier|public
name|void
name|enableSaxon
parameter_list|()
block|{
name|this
operator|.
name|setObjectModelUri
argument_list|(
name|SAXON_OBJECT_MODEL_URI
argument_list|)
expr_stmt|;
name|this
operator|.
name|setFactoryClassName
argument_list|(
name|SAXON_FACTORY_CLASS_NAME
argument_list|)
expr_stmt|;
block|}
DECL|method|getObjectModelUri ()
specifier|public
name|String
name|getObjectModelUri
parameter_list|()
block|{
return|return
name|objectModelUri
return|;
block|}
DECL|method|setObjectModelUri (String objectModelUri)
specifier|public
name|void
name|setObjectModelUri
parameter_list|(
name|String
name|objectModelUri
parameter_list|)
block|{
name|this
operator|.
name|objectModelUri
operator|=
name|objectModelUri
expr_stmt|;
block|}
DECL|method|getFactoryClassName ()
specifier|public
name|String
name|getFactoryClassName
parameter_list|()
block|{
return|return
name|factoryClassName
return|;
block|}
DECL|method|setFactoryClassName (String factoryClassName)
specifier|public
name|void
name|setFactoryClassName
parameter_list|(
name|String
name|factoryClassName
parameter_list|)
block|{
name|this
operator|.
name|factoryClassName
operator|=
name|factoryClassName
expr_stmt|;
block|}
comment|// Implementation methods
comment|// -------------------------------------------------------------------------
DECL|method|evaluate (Exchange exchange)
specifier|protected
name|Object
name|evaluate
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|Object
name|answer
init|=
name|evaluateAs
argument_list|(
name|exchange
argument_list|,
name|resultQName
argument_list|)
decl_stmt|;
if|if
condition|(
name|resultType
operator|!=
literal|null
condition|)
block|{
return|return
name|ExchangeHelper
operator|.
name|convertToType
argument_list|(
name|exchange
argument_list|,
name|resultType
argument_list|,
name|answer
argument_list|)
return|;
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Evaluates the expression as the given result type      */
DECL|method|evaluateAs (Exchange exchange, QName resultQName)
specifier|protected
name|Object
name|evaluateAs
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|QName
name|resultQName
parameter_list|)
block|{
comment|// pool a pre compiled expression from pool
name|XPathExpression
name|xpathExpression
init|=
name|pool
operator|.
name|poll
argument_list|()
decl_stmt|;
if|if
condition|(
name|xpathExpression
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Creating new XPathExpression as none was available from pool"
argument_list|)
expr_stmt|;
comment|// no avail in pool then create one
try|try
block|{
name|xpathExpression
operator|=
name|createXPathExpression
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|XPathExpressionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InvalidXPathExpression
argument_list|(
name|getText
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeExpressionException
argument_list|(
literal|"Cannot create xpath expression"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Acquired XPathExpression from pool"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|logNamespaces
operator|&&
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|logNamespaces
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
return|return
name|doInEvaluateAs
argument_list|(
name|xpathExpression
argument_list|,
name|exchange
argument_list|,
name|resultQName
argument_list|)
return|;
block|}
finally|finally
block|{
comment|// release it back to the pool
name|pool
operator|.
name|add
argument_list|(
name|xpathExpression
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Released XPathExpression back to pool"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|logNamespaces (Exchange exchange)
specifier|private
name|void
name|logNamespaces
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|InputStream
name|is
init|=
literal|null
decl_stmt|;
name|NodeList
name|answer
init|=
literal|null
decl_stmt|;
name|XPathExpression
name|xpathExpression
init|=
literal|null
decl_stmt|;
try|try
block|{
name|xpathExpression
operator|=
name|poolLogNamespaces
operator|.
name|poll
argument_list|()
expr_stmt|;
if|if
condition|(
name|xpathExpression
operator|==
literal|null
condition|)
block|{
name|xpathExpression
operator|=
name|createTraceNamespaceExpression
argument_list|()
expr_stmt|;
block|}
comment|// prepare the input
name|Object
name|document
decl_stmt|;
if|if
condition|(
name|isInputStreamNeeded
argument_list|(
name|exchange
argument_list|)
condition|)
block|{
name|is
operator|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|(
name|InputStream
operator|.
name|class
argument_list|)
expr_stmt|;
name|document
operator|=
name|getDocument
argument_list|(
name|exchange
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Object
name|body
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|()
decl_stmt|;
name|document
operator|=
name|getDocument
argument_list|(
name|exchange
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
comment|// fetch all namespaces
if|if
condition|(
name|document
operator|instanceof
name|InputSource
condition|)
block|{
name|InputSource
name|inputSource
init|=
operator|(
name|InputSource
operator|)
name|document
decl_stmt|;
name|answer
operator|=
operator|(
name|NodeList
operator|)
name|xpathExpression
operator|.
name|evaluate
argument_list|(
name|inputSource
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|document
operator|instanceof
name|DOMSource
condition|)
block|{
name|DOMSource
name|source
init|=
operator|(
name|DOMSource
operator|)
name|document
decl_stmt|;
name|answer
operator|=
operator|(
name|NodeList
operator|)
name|xpathExpression
operator|.
name|evaluate
argument_list|(
name|source
operator|.
name|getNode
argument_list|()
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|document
operator|instanceof
name|SAXSource
condition|)
block|{
name|SAXSource
name|source
init|=
operator|(
name|SAXSource
operator|)
name|document
decl_stmt|;
comment|// since its a SAXSource it may not return an NodeList (for
comment|// example if using Saxon)
name|Object
name|result
init|=
name|xpathExpression
operator|.
name|evaluate
argument_list|(
name|source
operator|.
name|getInputSource
argument_list|()
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|instanceof
name|NodeList
condition|)
block|{
name|answer
operator|=
operator|(
name|NodeList
operator|)
name|result
expr_stmt|;
block|}
else|else
block|{
name|answer
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
name|answer
operator|=
operator|(
name|NodeList
operator|)
name|xpathExpression
operator|.
name|evaluate
argument_list|(
name|document
argument_list|,
name|XPathConstants
operator|.
name|NODESET
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to trace discovered namespaces in XPath expression"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// IOHelper can handle if is is null
name|IOHelper
operator|.
name|close
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|poolLogNamespaces
operator|.
name|add
argument_list|(
name|xpathExpression
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|logDiscoveredNamespaces
argument_list|(
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|logDiscoveredNamespaces (NodeList namespaces)
specifier|private
name|void
name|logDiscoveredNamespaces
parameter_list|(
name|NodeList
name|namespaces
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|>
name|map
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|namespaces
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|n
init|=
name|namespaces
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|.
name|getNodeName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"xmlns:xml"
argument_list|)
condition|)
block|{
comment|// skip the implicit XML namespace as it provides no value
continue|continue;
block|}
name|String
name|prefix
init|=
name|namespaces
operator|.
name|item
argument_list|(
name|i
argument_list|)
operator|.
name|getNodeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"xmlns"
argument_list|)
condition|)
block|{
name|prefix
operator|=
literal|"DEFAULT"
expr_stmt|;
block|}
comment|// add to map
if|if
condition|(
operator|!
name|map
operator|.
name|containsKey
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|prefix
argument_list|,
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|map
operator|.
name|get
argument_list|(
name|prefix
argument_list|)
operator|.
name|add
argument_list|(
name|namespaces
operator|.
name|item
argument_list|(
name|i
argument_list|)
operator|.
name|getNodeValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Namespaces discovered in message: {}."
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|doInEvaluateAs (XPathExpression xpathExpression, Exchange exchange, QName resultQName)
specifier|protected
name|Object
name|doInEvaluateAs
parameter_list|(
name|XPathExpression
name|xpathExpression
parameter_list|,
name|Exchange
name|exchange
parameter_list|,
name|QName
name|resultQName
parameter_list|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Evaluating exchange: {} as: {}"
argument_list|,
name|exchange
argument_list|,
name|resultQName
argument_list|)
expr_stmt|;
name|Object
name|answer
decl_stmt|;
comment|// set exchange and variable resolver as thread locals for concurrency
name|this
operator|.
name|exchange
operator|.
name|set
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
comment|// the underlying input stream, which we need to close to avoid locking
comment|// files or other resources
name|InputStream
name|is
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Object
name|document
decl_stmt|;
comment|// Check if we need to apply the XPath expression to a header
if|if
condition|(
name|ObjectHelper
operator|.
name|isNotEmpty
argument_list|(
name|getHeaderName
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|headerName
init|=
name|getHeaderName
argument_list|()
decl_stmt|;
comment|// only convert to input stream if really needed
if|if
condition|(
name|isInputStreamNeeded
argument_list|(
name|exchange
argument_list|,
name|headerName
argument_list|)
condition|)
block|{
name|is
operator|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|headerName
argument_list|,
name|InputStream
operator|.
name|class
argument_list|)
expr_stmt|;
name|document
operator|=
name|getDocument
argument_list|(
name|exchange
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Object
name|headerObject
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|getHeaderName
argument_list|()
argument_list|)
decl_stmt|;
name|document
operator|=
name|getDocument
argument_list|(
name|exchange
argument_list|,
name|headerObject
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// only convert to input stream if really needed
if|if
condition|(
name|isInputStreamNeeded
argument_list|(
name|exchange
argument_list|)
condition|)
block|{
name|is
operator|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|(
name|InputStream
operator|.
name|class
argument_list|)
expr_stmt|;
name|document
operator|=
name|getDocument
argument_list|(
name|exchange
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Object
name|body
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|()
decl_stmt|;
name|document
operator|=
name|getDocument
argument_list|(
name|exchange
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|resultQName
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|document
operator|instanceof
name|InputSource
condition|)
block|{
name|InputSource
name|inputSource
init|=
operator|(
name|InputSource
operator|)
name|document
decl_stmt|;
name|answer
operator|=
name|xpathExpression
operator|.
name|evaluate
argument_list|(
name|inputSource
argument_list|,
name|resultQName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|document
operator|instanceof
name|DOMSource
condition|)
block|{
name|DOMSource
name|source
init|=
operator|(
name|DOMSource
operator|)
name|document
decl_stmt|;
name|answer
operator|=
name|xpathExpression
operator|.
name|evaluate
argument_list|(
name|source
operator|.
name|getNode
argument_list|()
argument_list|,
name|resultQName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|answer
operator|=
name|xpathExpression
operator|.
name|evaluate
argument_list|(
name|document
argument_list|,
name|resultQName
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|document
operator|instanceof
name|InputSource
condition|)
block|{
name|InputSource
name|inputSource
init|=
operator|(
name|InputSource
operator|)
name|document
decl_stmt|;
name|answer
operator|=
name|xpathExpression
operator|.
name|evaluate
argument_list|(
name|inputSource
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|document
operator|instanceof
name|DOMSource
condition|)
block|{
name|DOMSource
name|source
init|=
operator|(
name|DOMSource
operator|)
name|document
decl_stmt|;
name|answer
operator|=
name|xpathExpression
operator|.
name|evaluate
argument_list|(
name|source
operator|.
name|getNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|answer
operator|=
name|xpathExpression
operator|.
name|evaluate
argument_list|(
name|document
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|XPathExpressionException
name|e
parameter_list|)
block|{
name|String
name|message
init|=
name|getText
argument_list|()
decl_stmt|;
if|if
condition|(
name|ObjectHelper
operator|.
name|isNotEmpty
argument_list|(
name|getHeaderName
argument_list|()
argument_list|)
condition|)
block|{
name|message
operator|=
name|message
operator|+
literal|" with headerName "
operator|+
name|getHeaderName
argument_list|()
expr_stmt|;
block|}
throw|throw
operator|new
name|InvalidXPathExpression
argument_list|(
name|message
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
comment|// IOHelper can handle if is is null
name|IOHelper
operator|.
name|close
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|threadSafety
operator|&&
name|answer
operator|!=
literal|null
operator|&&
name|answer
operator|instanceof
name|NodeList
condition|)
block|{
try|try
block|{
name|NodeList
name|list
init|=
operator|(
name|NodeList
operator|)
name|answer
decl_stmt|;
comment|// when the result is NodeList and it has 2+ elements then its
comment|// not thread-safe to use concurrently
comment|// and we need to clone each node and build a thread-safe list
comment|// to be used instead
name|boolean
name|threadSafetyNeeded
init|=
name|list
operator|.
name|getLength
argument_list|()
operator|>=
literal|2
decl_stmt|;
if|if
condition|(
name|threadSafetyNeeded
condition|)
block|{
name|answer
operator|=
operator|new
name|ThreadSafeNodeList
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created thread-safe result from: {} as: {}"
argument_list|,
name|list
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|answer
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|ObjectHelper
operator|.
name|wrapRuntimeCamelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Done evaluating exchange: {} as: {} with result: {}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|exchange
block|,
name|resultQName
block|,
name|answer
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|answer
return|;
block|}
comment|/**      * Creates a new xpath expression as there we no available in the pool.      *<p/>      * This implementation must be synchronized to ensure thread safety, as this      * XPathBuilder instance may not have been started prior to being used.      */
DECL|method|createXPathExpression ()
specifier|protected
specifier|synchronized
name|XPathExpression
name|createXPathExpression
parameter_list|()
throws|throws
name|XPathExpressionException
throws|,
name|XPathFactoryConfigurationException
block|{
comment|// ensure we are started
try|try
block|{
name|start
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeExpressionException
argument_list|(
literal|"Error starting XPathBuilder"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// XPathFactory is not thread safe
name|XPath
name|xPath
init|=
name|getXPathFactory
argument_list|()
operator|.
name|newXPath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|logNamespaces
operator|&&
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Creating new XPath expression in pool. Namespaces on XPath expression: {}"
argument_list|,
name|getNamespaceContext
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|logNamespaces
operator|&&
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Creating new XPath expression in pool. Namespaces on XPath expression: {}"
argument_list|,
name|getNamespaceContext
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|xPath
operator|.
name|setNamespaceContext
argument_list|(
name|getNamespaceContext
argument_list|()
argument_list|)
expr_stmt|;
name|xPath
operator|.
name|setXPathVariableResolver
argument_list|(
name|getVariableResolver
argument_list|()
argument_list|)
expr_stmt|;
name|XPathFunctionResolver
name|parentResolver
init|=
name|getFunctionResolver
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentResolver
operator|==
literal|null
condition|)
block|{
name|parentResolver
operator|=
name|xPath
operator|.
name|getXPathFunctionResolver
argument_list|()
expr_stmt|;
block|}
name|xPath
operator|.
name|setXPathFunctionResolver
argument_list|(
name|createDefaultFunctionResolver
argument_list|(
name|parentResolver
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|xPath
operator|.
name|compile
argument_list|(
name|text
argument_list|)
return|;
block|}
DECL|method|createTraceNamespaceExpression ()
specifier|protected
specifier|synchronized
name|XPathExpression
name|createTraceNamespaceExpression
parameter_list|()
throws|throws
name|XPathFactoryConfigurationException
throws|,
name|XPathExpressionException
block|{
comment|// XPathFactory is not thread safe
name|XPath
name|xPath
init|=
name|getXPathFactory
argument_list|()
operator|.
name|newXPath
argument_list|()
decl_stmt|;
return|return
name|xPath
operator|.
name|compile
argument_list|(
name|OBTAIN_ALL_NS_XPATH
argument_list|)
return|;
block|}
DECL|method|createNamespaceContext (XPathFactory factory)
specifier|protected
name|DefaultNamespaceContext
name|createNamespaceContext
parameter_list|(
name|XPathFactory
name|factory
parameter_list|)
block|{
name|DefaultNamespaceContext
name|context
init|=
operator|new
name|DefaultNamespaceContext
argument_list|(
name|factory
argument_list|)
decl_stmt|;
name|populateDefaultNamespaces
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|context
return|;
block|}
comment|/**      * Populate a number of standard prefixes if they are not already there      */
DECL|method|populateDefaultNamespaces (DefaultNamespaceContext context)
specifier|protected
name|void
name|populateDefaultNamespaces
parameter_list|(
name|DefaultNamespaceContext
name|context
parameter_list|)
block|{
name|setNamespaceIfNotPresent
argument_list|(
name|context
argument_list|,
literal|"in"
argument_list|,
name|IN_NAMESPACE
argument_list|)
expr_stmt|;
name|setNamespaceIfNotPresent
argument_list|(
name|context
argument_list|,
literal|"out"
argument_list|,
name|OUT_NAMESPACE
argument_list|)
expr_stmt|;
name|setNamespaceIfNotPresent
argument_list|(
name|context
argument_list|,
literal|"env"
argument_list|,
name|Namespaces
operator|.
name|ENVIRONMENT_VARIABLES
argument_list|)
expr_stmt|;
name|setNamespaceIfNotPresent
argument_list|(
name|context
argument_list|,
literal|"system"
argument_list|,
name|Namespaces
operator|.
name|SYSTEM_PROPERTIES_NAMESPACE
argument_list|)
expr_stmt|;
name|setNamespaceIfNotPresent
argument_list|(
name|context
argument_list|,
literal|"function"
argument_list|,
name|Namespaces
operator|.
name|FUNCTION_NAMESPACE
argument_list|)
expr_stmt|;
block|}
DECL|method|setNamespaceIfNotPresent (DefaultNamespaceContext context, String prefix, String uri)
specifier|protected
name|void
name|setNamespaceIfNotPresent
parameter_list|(
name|DefaultNamespaceContext
name|context
parameter_list|,
name|String
name|prefix
parameter_list|,
name|String
name|uri
parameter_list|)
block|{
if|if
condition|(
name|context
operator|!=
literal|null
condition|)
block|{
name|String
name|current
init|=
name|context
operator|.
name|getNamespaceURI
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
name|context
operator|.
name|add
argument_list|(
name|prefix
argument_list|,
name|uri
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|createDefaultFunctionResolver (final XPathFunctionResolver parent)
specifier|protected
name|XPathFunctionResolver
name|createDefaultFunctionResolver
parameter_list|(
specifier|final
name|XPathFunctionResolver
name|parent
parameter_list|)
block|{
return|return
operator|new
name|XPathFunctionResolver
argument_list|()
block|{
specifier|public
name|XPathFunction
name|resolveFunction
parameter_list|(
name|QName
name|qName
parameter_list|,
name|int
name|argumentCount
parameter_list|)
block|{
name|XPathFunction
name|answer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|answer
operator|=
name|parent
operator|.
name|resolveFunction
argument_list|(
name|qName
argument_list|,
name|argumentCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|isMatchingNamespaceOrEmptyNamespace
argument_list|(
name|qName
operator|.
name|getNamespaceURI
argument_list|()
argument_list|,
name|IN_NAMESPACE
argument_list|)
operator|||
name|isMatchingNamespaceOrEmptyNamespace
argument_list|(
name|qName
operator|.
name|getNamespaceURI
argument_list|()
argument_list|,
name|DEFAULT_NAMESPACE
argument_list|)
condition|)
block|{
name|String
name|localPart
init|=
name|qName
operator|.
name|getLocalPart
argument_list|()
decl_stmt|;
if|if
condition|(
name|localPart
operator|.
name|equals
argument_list|(
literal|"body"
argument_list|)
operator|&&
name|argumentCount
operator|==
literal|0
condition|)
block|{
return|return
name|getBodyFunction
argument_list|()
return|;
block|}
if|if
condition|(
name|localPart
operator|.
name|equals
argument_list|(
literal|"header"
argument_list|)
operator|&&
name|argumentCount
operator|==
literal|1
condition|)
block|{
return|return
name|getHeaderFunction
argument_list|()
return|;
block|}
block|}
if|if
condition|(
name|isMatchingNamespaceOrEmptyNamespace
argument_list|(
name|qName
operator|.
name|getNamespaceURI
argument_list|()
argument_list|,
name|OUT_NAMESPACE
argument_list|)
condition|)
block|{
name|String
name|localPart
init|=
name|qName
operator|.
name|getLocalPart
argument_list|()
decl_stmt|;
if|if
condition|(
name|localPart
operator|.
name|equals
argument_list|(
literal|"body"
argument_list|)
operator|&&
name|argumentCount
operator|==
literal|0
condition|)
block|{
return|return
name|getOutBodyFunction
argument_list|()
return|;
block|}
if|if
condition|(
name|localPart
operator|.
name|equals
argument_list|(
literal|"header"
argument_list|)
operator|&&
name|argumentCount
operator|==
literal|1
condition|)
block|{
return|return
name|getOutHeaderFunction
argument_list|()
return|;
block|}
block|}
if|if
condition|(
name|isMatchingNamespaceOrEmptyNamespace
argument_list|(
name|qName
operator|.
name|getNamespaceURI
argument_list|()
argument_list|,
name|FUNCTION_NAMESPACE
argument_list|)
condition|)
block|{
name|String
name|localPart
init|=
name|qName
operator|.
name|getLocalPart
argument_list|()
decl_stmt|;
if|if
condition|(
name|localPart
operator|.
name|equals
argument_list|(
literal|"properties"
argument_list|)
operator|&&
name|argumentCount
operator|==
literal|1
condition|)
block|{
return|return
name|getPropertiesFunction
argument_list|()
return|;
block|}
if|if
condition|(
name|localPart
operator|.
name|equals
argument_list|(
literal|"simple"
argument_list|)
operator|&&
name|argumentCount
operator|==
literal|1
condition|)
block|{
return|return
name|getSimpleFunction
argument_list|()
return|;
block|}
block|}
block|}
return|return
name|answer
return|;
block|}
block|}
return|;
block|}
comment|/**      * Checks whether we need an {@link InputStream} to access the message body.      *<p/>      * Depending on the content in the message body, we may not need to convert      * to {@link InputStream}.      *      * @param exchange the current exchange      * @return<tt>true</tt> to convert to {@link InputStream} beforehand      *         converting afterwards.      */
DECL|method|isInputStreamNeeded (Exchange exchange)
specifier|protected
name|boolean
name|isInputStreamNeeded
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|Object
name|body
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|()
decl_stmt|;
return|return
name|isInputStreamNeededForObject
argument_list|(
name|exchange
argument_list|,
name|body
argument_list|)
return|;
block|}
comment|/**      * Checks whether we need an {@link InputStream} to access the message      * header.      *<p/>      * Depending on the content in the message header, we may not need to      * convert to {@link InputStream}.      *      * @param exchange the current exchange      * @return<tt>true</tt> to convert to {@link InputStream} beforehand      *         converting afterwards.      */
DECL|method|isInputStreamNeeded (Exchange exchange, String headerName)
specifier|protected
name|boolean
name|isInputStreamNeeded
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|String
name|headerName
parameter_list|)
block|{
name|Object
name|header
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeader
argument_list|(
name|headerName
argument_list|)
decl_stmt|;
return|return
name|isInputStreamNeededForObject
argument_list|(
name|exchange
argument_list|,
name|header
argument_list|)
return|;
block|}
comment|/**      * Checks whether we need an {@link InputStream} to access this object      *<p/>      * Depending on the content in the object, we may not need to convert to      * {@link InputStream}.      *      * @param exchange the current exchange      * @return<tt>true</tt> to convert to {@link InputStream} beforehand      *         converting afterwards.      */
DECL|method|isInputStreamNeededForObject (Exchange exchange, Object obj)
specifier|protected
name|boolean
name|isInputStreamNeededForObject
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|obj
operator|instanceof
name|WrappedFile
condition|)
block|{
name|obj
operator|=
operator|(
operator|(
name|WrappedFile
argument_list|<
name|?
argument_list|>
operator|)
name|obj
operator|)
operator|.
name|getFile
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|obj
operator|instanceof
name|File
condition|)
block|{
comment|// input stream is needed for File to avoid locking the file in case
comment|// of errors etc
return|return
literal|true
return|;
block|}
comment|// input stream is not needed otherwise
return|return
literal|false
return|;
block|}
comment|/**      * Strategy method to extract the document from the exchange.      */
DECL|method|getDocument (Exchange exchange, Object body)
specifier|protected
name|Object
name|getDocument
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|body
parameter_list|)
block|{
try|try
block|{
return|return
name|doGetDocument
argument_list|(
name|exchange
argument_list|,
name|body
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|ObjectHelper
operator|.
name|wrapRuntimeCamelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
comment|// call the reset if the in message body is StreamCache
name|MessageHelper
operator|.
name|resetStreamCache
argument_list|(
name|exchange
operator|.
name|getIn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doGetDocument (Exchange exchange, Object body)
specifier|protected
name|Object
name|doGetDocument
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|body
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|body
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Object
name|answer
init|=
literal|null
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|type
init|=
name|getDocumentType
argument_list|()
decl_stmt|;
name|Exception
name|cause
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
comment|// try to get the body as the desired type
try|try
block|{
name|answer
operator|=
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|convertTo
argument_list|(
name|type
argument_list|,
name|exchange
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// we want to store the caused exception, if we could not
comment|// convert
name|cause
operator|=
name|e
expr_stmt|;
block|}
block|}
if|if
condition|(
name|type
operator|==
literal|null
operator|&&
name|answer
operator|==
literal|null
condition|)
block|{
comment|// fallback to get the body as is
name|answer
operator|=
name|body
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|answer
operator|==
literal|null
condition|)
block|{
comment|// there was a type, and we could not convert to it, then fail
if|if
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
throw|throw
name|cause
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|NoTypeConversionAvailableException
argument_list|(
name|body
argument_list|,
name|type
argument_list|)
throw|;
block|}
block|}
return|return
name|answer
return|;
block|}
DECL|method|getVariableResolver ()
specifier|private
name|MessageVariableResolver
name|getVariableResolver
parameter_list|()
block|{
return|return
name|variableResolver
return|;
block|}
annotation|@
name|Override
DECL|method|doStart ()
specifier|public
name|void
name|doStart
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|xpathFactory
operator|==
literal|null
condition|)
block|{
name|xpathFactory
operator|=
name|createXPathFactory
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|namespaceContext
operator|==
literal|null
condition|)
block|{
name|namespaceContext
operator|=
name|createNamespaceContext
argument_list|(
name|xpathFactory
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|namespaces
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|namespaceContext
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// create default functions if no custom assigned
if|if
condition|(
name|bodyFunction
operator|==
literal|null
condition|)
block|{
name|bodyFunction
operator|=
name|createBodyFunction
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|headerFunction
operator|==
literal|null
condition|)
block|{
name|headerFunction
operator|=
name|createHeaderFunction
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|outBodyFunction
operator|==
literal|null
condition|)
block|{
name|outBodyFunction
operator|=
name|createOutBodyFunction
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|outHeaderFunction
operator|==
literal|null
condition|)
block|{
name|outHeaderFunction
operator|=
name|createOutHeaderFunction
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|propertiesFunction
operator|==
literal|null
condition|)
block|{
name|propertiesFunction
operator|=
name|createPropertiesFunction
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|simpleFunction
operator|==
literal|null
condition|)
block|{
name|simpleFunction
operator|=
name|createSimpleFunction
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|doStop ()
specifier|public
name|void
name|doStop
parameter_list|()
throws|throws
name|Exception
block|{
name|pool
operator|.
name|clear
argument_list|()
expr_stmt|;
name|poolLogNamespaces
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|createXPathFactory ()
specifier|protected
specifier|synchronized
name|XPathFactory
name|createXPathFactory
parameter_list|()
throws|throws
name|XPathFactoryConfigurationException
block|{
if|if
condition|(
name|objectModelUri
operator|!=
literal|null
condition|)
block|{
name|String
name|xpathFactoryClassName
init|=
name|factoryClassName
decl_stmt|;
if|if
condition|(
name|objectModelUri
operator|.
name|equals
argument_list|(
name|SAXON_OBJECT_MODEL_URI
argument_list|)
operator|&&
operator|(
name|xpathFactoryClassName
operator|==
literal|null
operator|||
name|SAXON_FACTORY_CLASS_NAME
operator|.
name|equals
argument_list|(
name|xpathFactoryClassName
argument_list|)
operator|)
condition|)
block|{
comment|// from Saxon 9.7 onwards you should favour to create the class
comment|// directly
comment|// https://www.saxonica.com/html/documentation/xpath-api/jaxp-xpath/factory.html
try|try
block|{
if|if
condition|(
name|camelContext
operator|!=
literal|null
condition|)
block|{
name|Class
argument_list|<
name|XPathFactory
argument_list|>
name|clazz
init|=
name|camelContext
operator|.
name|getClassResolver
argument_list|()
operator|.
name|resolveClass
argument_list|(
name|SAXON_FACTORY_CLASS_NAME
argument_list|,
name|XPathFactory
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|clazz
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating Saxon XPathFactory using class: {})"
argument_list|,
name|clazz
argument_list|)
expr_stmt|;
name|xpathFactory
operator|=
name|camelContext
operator|.
name|getInjector
argument_list|()
operator|.
name|newInstance
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Created Saxon XPathFactory: {}"
argument_list|,
name|xpathFactory
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Attempted to create Saxon XPathFactory by creating a new instance of "
operator|+
name|SAXON_FACTORY_CLASS_NAME
operator|+
literal|" failed. Will fallback and create XPathFactory using JDK API. This exception is ignored (stacktrace in DEBUG logging level)."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Error creating Saxon XPathFactory. This exception is ignored."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|xpathFactory
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating XPathFactory from objectModelUri: {}"
argument_list|,
name|objectModelUri
argument_list|)
expr_stmt|;
name|xpathFactory
operator|=
name|ObjectHelper
operator|.
name|isEmpty
argument_list|(
name|xpathFactoryClassName
argument_list|)
condition|?
name|XPathFactory
operator|.
name|newInstance
argument_list|(
name|objectModelUri
argument_list|)
else|:
name|XPathFactory
operator|.
name|newInstance
argument_list|(
name|objectModelUri
argument_list|,
name|xpathFactoryClassName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Created XPathFactory: {} from objectModelUri: {}"
argument_list|,
name|xpathFactory
argument_list|,
name|objectModelUri
argument_list|)
expr_stmt|;
block|}
return|return
name|xpathFactory
return|;
block|}
if|if
condition|(
name|defaultXPathFactory
operator|==
literal|null
condition|)
block|{
name|defaultXPathFactory
operator|=
name|createDefaultXPathFactory
argument_list|()
expr_stmt|;
block|}
return|return
name|defaultXPathFactory
return|;
block|}
DECL|method|createDefaultXPathFactory ()
specifier|protected
specifier|static
name|XPathFactory
name|createDefaultXPathFactory
parameter_list|()
throws|throws
name|XPathFactoryConfigurationException
block|{
name|XPathFactory
name|factory
init|=
literal|null
decl_stmt|;
comment|// read system property and see if there is a factory set
name|Properties
name|properties
init|=
name|System
operator|.
name|getProperties
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|prop
range|:
name|properties
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
operator|(
name|String
operator|)
name|prop
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|startsWith
argument_list|(
name|XPathFactory
operator|.
name|DEFAULT_PROPERTY_NAME
argument_list|)
condition|)
block|{
name|String
name|uri
init|=
name|StringHelper
operator|.
name|after
argument_list|(
name|key
argument_list|,
literal|":"
argument_list|)
decl_stmt|;
if|if
condition|(
name|uri
operator|!=
literal|null
condition|)
block|{
name|factory
operator|=
name|XPathFactory
operator|.
name|newInstance
argument_list|(
name|uri
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Using system property {} with value {} when created default XPathFactory {}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|key
block|,
name|uri
block|,
name|factory
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|factory
operator|==
literal|null
condition|)
block|{
name|factory
operator|=
name|XPathFactory
operator|.
name|newInstance
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Created default XPathFactory {}"
argument_list|,
name|factory
argument_list|)
expr_stmt|;
block|}
return|return
name|factory
return|;
block|}
block|}
end_class

end_unit

