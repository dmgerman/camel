begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.builder.xml
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
operator|.
name|xml
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ArrayBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|ParserConfigurationException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamReader
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|ErrorListener
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|Source
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|Templates
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|Transformer
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|TransformerConfigurationException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|TransformerFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|URIResolver
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|dom
operator|.
name|DOMSource
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|sax
operator|.
name|SAXSource
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|stax
operator|.
name|StAXSource
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|stream
operator|.
name|StreamSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|ExpectedBodyTypeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Processor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|RuntimeTransformException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|TypeConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|converter
operator|.
name|jaxp
operator|.
name|StaxSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|converter
operator|.
name|jaxp
operator|.
name|XmlConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|converter
operator|.
name|jaxp
operator|.
name|XmlErrorListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|SynchronizationAdapter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ExchangeHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|IOHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ObjectHelper
operator|.
name|notNull
import|;
end_import

begin_comment
comment|/**  * Creates a<a href="http://camel.apache.org/processor.html">Processor</a>  * which performs an XSLT transformation of the IN message body.  *<p/>  * Will by default output the result as a String. You can chose which kind of output  * you want using the<tt>outputXXX</tt> methods.  *  * @version   */
end_comment

begin_class
DECL|class|XsltBuilder
specifier|public
class|class
name|XsltBuilder
implements|implements
name|Processor
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|XsltBuilder
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|parameters
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|parameters
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|converter
specifier|private
name|XmlConverter
name|converter
init|=
operator|new
name|XmlConverter
argument_list|()
decl_stmt|;
DECL|field|template
specifier|private
name|Templates
name|template
decl_stmt|;
DECL|field|transformers
specifier|private
specifier|volatile
name|BlockingQueue
argument_list|<
name|Transformer
argument_list|>
name|transformers
decl_stmt|;
DECL|field|resultHandlerFactory
specifier|private
name|ResultHandlerFactory
name|resultHandlerFactory
init|=
operator|new
name|StringResultHandlerFactory
argument_list|()
decl_stmt|;
DECL|field|failOnNullBody
specifier|private
name|boolean
name|failOnNullBody
init|=
literal|true
decl_stmt|;
DECL|field|uriResolver
specifier|private
name|URIResolver
name|uriResolver
decl_stmt|;
DECL|field|deleteOutputFile
specifier|private
name|boolean
name|deleteOutputFile
decl_stmt|;
DECL|field|errorListener
specifier|private
name|ErrorListener
name|errorListener
init|=
operator|new
name|XsltErrorListener
argument_list|()
decl_stmt|;
DECL|field|allowStAX
specifier|private
name|boolean
name|allowStAX
init|=
literal|true
decl_stmt|;
DECL|method|XsltBuilder ()
specifier|public
name|XsltBuilder
parameter_list|()
block|{     }
DECL|method|XsltBuilder (Templates templates)
specifier|public
name|XsltBuilder
parameter_list|(
name|Templates
name|templates
parameter_list|)
block|{
name|this
operator|.
name|template
operator|=
name|templates
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"XSLT["
operator|+
name|template
operator|+
literal|"]"
return|;
block|}
DECL|method|process (Exchange exchange)
specifier|public
name|void
name|process
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
throws|throws
name|Exception
block|{
name|notNull
argument_list|(
name|getTemplate
argument_list|()
argument_list|,
literal|"template"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDeleteOutputFile
argument_list|()
condition|)
block|{
comment|// add on completion so we can delete the file when the Exchange is done
name|String
name|fileName
init|=
name|ExchangeHelper
operator|.
name|getMandatoryHeader
argument_list|(
name|exchange
argument_list|,
name|Exchange
operator|.
name|XSLT_FILE_NAME
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
name|exchange
operator|.
name|addOnCompletion
argument_list|(
operator|new
name|XsltBuilderOnCompletion
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Transformer
name|transformer
init|=
name|getTransformer
argument_list|()
decl_stmt|;
name|configureTransformer
argument_list|(
name|transformer
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
name|transformer
operator|.
name|setErrorListener
argument_list|(
operator|new
name|DefaultTransformErrorHandler
argument_list|()
argument_list|)
expr_stmt|;
name|ResultHandler
name|resultHandler
init|=
name|resultHandlerFactory
operator|.
name|createResult
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
name|Result
name|result
init|=
name|resultHandler
operator|.
name|getResult
argument_list|()
decl_stmt|;
name|exchange
operator|.
name|setProperty
argument_list|(
literal|"isXalanTransformer"
argument_list|,
name|isXalanTransformer
argument_list|(
name|transformer
argument_list|)
argument_list|)
expr_stmt|;
comment|// let's copy the headers before we invoke the transform in case they modify them
name|Message
name|out
init|=
name|exchange
operator|.
name|getOut
argument_list|()
decl_stmt|;
name|out
operator|.
name|copyFrom
argument_list|(
name|exchange
operator|.
name|getIn
argument_list|()
argument_list|)
expr_stmt|;
comment|// the underlying input stream, which we need to close to avoid locking files or other resources
name|InputStream
name|is
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Source
name|source
decl_stmt|;
comment|// only convert to input stream if really needed
if|if
condition|(
name|isInputStreamNeeded
argument_list|(
name|exchange
argument_list|)
condition|)
block|{
name|is
operator|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|(
name|InputStream
operator|.
name|class
argument_list|)
expr_stmt|;
name|source
operator|=
name|getSource
argument_list|(
name|exchange
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Object
name|body
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|()
decl_stmt|;
name|source
operator|=
name|getSource
argument_list|(
name|exchange
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"Using {} as source"
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|transformer
operator|.
name|transform
argument_list|(
name|source
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Transform complete with result {}"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|resultHandler
operator|.
name|setBody
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// clean up the setting on the exchange
name|releaseTransformer
argument_list|(
name|transformer
argument_list|)
expr_stmt|;
comment|// IOHelper can handle if is is null
name|IOHelper
operator|.
name|close
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|isXalanTransformer (Transformer transformer)
name|boolean
name|isXalanTransformer
parameter_list|(
name|Transformer
name|transformer
parameter_list|)
block|{
return|return
name|transformer
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"org.apache.xalan.transformer"
argument_list|)
return|;
block|}
comment|// Builder methods
comment|// -------------------------------------------------------------------------
comment|/**      * Creates an XSLT processor using the given templates instance      */
DECL|method|xslt (Templates templates)
specifier|public
specifier|static
name|XsltBuilder
name|xslt
parameter_list|(
name|Templates
name|templates
parameter_list|)
block|{
return|return
operator|new
name|XsltBuilder
argument_list|(
name|templates
argument_list|)
return|;
block|}
comment|/**      * Creates an XSLT processor using the given XSLT source      */
DECL|method|xslt (Source xslt)
specifier|public
specifier|static
name|XsltBuilder
name|xslt
parameter_list|(
name|Source
name|xslt
parameter_list|)
throws|throws
name|TransformerConfigurationException
block|{
name|notNull
argument_list|(
name|xslt
argument_list|,
literal|"xslt"
argument_list|)
expr_stmt|;
name|XsltBuilder
name|answer
init|=
operator|new
name|XsltBuilder
argument_list|()
decl_stmt|;
name|answer
operator|.
name|setTransformerSource
argument_list|(
name|xslt
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
comment|/**      * Creates an XSLT processor using the given XSLT source      */
DECL|method|xslt (File xslt)
specifier|public
specifier|static
name|XsltBuilder
name|xslt
parameter_list|(
name|File
name|xslt
parameter_list|)
throws|throws
name|TransformerConfigurationException
block|{
name|notNull
argument_list|(
name|xslt
argument_list|,
literal|"xslt"
argument_list|)
expr_stmt|;
return|return
name|xslt
argument_list|(
operator|new
name|StreamSource
argument_list|(
name|xslt
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Creates an XSLT processor using the given XSLT source      */
DECL|method|xslt (URL xslt)
specifier|public
specifier|static
name|XsltBuilder
name|xslt
parameter_list|(
name|URL
name|xslt
parameter_list|)
throws|throws
name|TransformerConfigurationException
throws|,
name|IOException
block|{
name|notNull
argument_list|(
name|xslt
argument_list|,
literal|"xslt"
argument_list|)
expr_stmt|;
return|return
name|xslt
argument_list|(
name|xslt
operator|.
name|openStream
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Creates an XSLT processor using the given XSLT source      */
DECL|method|xslt (InputStream xslt)
specifier|public
specifier|static
name|XsltBuilder
name|xslt
parameter_list|(
name|InputStream
name|xslt
parameter_list|)
throws|throws
name|TransformerConfigurationException
throws|,
name|IOException
block|{
name|notNull
argument_list|(
name|xslt
argument_list|,
literal|"xslt"
argument_list|)
expr_stmt|;
return|return
name|xslt
argument_list|(
operator|new
name|StreamSource
argument_list|(
name|xslt
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Sets the output as being a byte[]      */
DECL|method|outputBytes ()
specifier|public
name|XsltBuilder
name|outputBytes
parameter_list|()
block|{
name|setResultHandlerFactory
argument_list|(
operator|new
name|StreamResultHandlerFactory
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets the output as being a String      */
DECL|method|outputString ()
specifier|public
name|XsltBuilder
name|outputString
parameter_list|()
block|{
name|setResultHandlerFactory
argument_list|(
operator|new
name|StringResultHandlerFactory
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets the output as being a DOM      */
DECL|method|outputDOM ()
specifier|public
name|XsltBuilder
name|outputDOM
parameter_list|()
block|{
name|setResultHandlerFactory
argument_list|(
operator|new
name|DomResultHandlerFactory
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets the output as being a File where the filename      * must be provided in the {@link Exchange#XSLT_FILE_NAME} header.      */
DECL|method|outputFile ()
specifier|public
name|XsltBuilder
name|outputFile
parameter_list|()
block|{
name|setResultHandlerFactory
argument_list|(
operator|new
name|FileResultHandlerFactory
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Should the output file be deleted when the {@link Exchange} is done.      *<p/>      * This option should only be used if you use {@link #outputFile()} as well.      */
DECL|method|deleteOutputFile ()
specifier|public
name|XsltBuilder
name|deleteOutputFile
parameter_list|()
block|{
name|this
operator|.
name|deleteOutputFile
operator|=
literal|true
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|parameter (String name, Object value)
specifier|public
name|XsltBuilder
name|parameter
parameter_list|(
name|String
name|name
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|parameters
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets a custom URI resolver to be used      */
DECL|method|uriResolver (URIResolver uriResolver)
specifier|public
name|XsltBuilder
name|uriResolver
parameter_list|(
name|URIResolver
name|uriResolver
parameter_list|)
block|{
name|setUriResolver
argument_list|(
name|uriResolver
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Enables to allow using StAX.      *<p/>      * When enabled StAX is preferred as the first choice as {@link Source}.      */
DECL|method|allowStAX ()
specifier|public
name|XsltBuilder
name|allowStAX
parameter_list|()
block|{
name|setAllowStAX
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Used for caching {@link Transformer}s.      *<p/>      * By default no caching is in use.      *      * @param numberToCache  the maximum number of transformers to cache      */
DECL|method|transformerCacheSize (int numberToCache)
specifier|public
name|XsltBuilder
name|transformerCacheSize
parameter_list|(
name|int
name|numberToCache
parameter_list|)
block|{
if|if
condition|(
name|numberToCache
operator|>
literal|0
condition|)
block|{
name|transformers
operator|=
operator|new
name|ArrayBlockingQueue
argument_list|<
name|Transformer
argument_list|>
argument_list|(
name|numberToCache
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|transformers
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/**      * Uses a custom {@link javax.xml.transform.ErrorListener}.      */
DECL|method|errorListener (ErrorListener errorListener)
specifier|public
name|XsltBuilder
name|errorListener
parameter_list|(
name|ErrorListener
name|errorListener
parameter_list|)
block|{
name|setErrorListener
argument_list|(
name|errorListener
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|// Properties
comment|// -------------------------------------------------------------------------
DECL|method|getParameters ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getParameters
parameter_list|()
block|{
return|return
name|parameters
return|;
block|}
DECL|method|setParameters (Map<String, Object> parameters)
specifier|public
name|void
name|setParameters
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|parameters
parameter_list|)
block|{
name|this
operator|.
name|parameters
operator|=
name|parameters
expr_stmt|;
block|}
DECL|method|setTemplate (Templates template)
specifier|public
name|void
name|setTemplate
parameter_list|(
name|Templates
name|template
parameter_list|)
block|{
name|this
operator|.
name|template
operator|=
name|template
expr_stmt|;
if|if
condition|(
name|transformers
operator|!=
literal|null
condition|)
block|{
name|transformers
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getTemplate ()
specifier|public
name|Templates
name|getTemplate
parameter_list|()
block|{
return|return
name|template
return|;
block|}
DECL|method|isFailOnNullBody ()
specifier|public
name|boolean
name|isFailOnNullBody
parameter_list|()
block|{
return|return
name|failOnNullBody
return|;
block|}
DECL|method|setFailOnNullBody (boolean failOnNullBody)
specifier|public
name|void
name|setFailOnNullBody
parameter_list|(
name|boolean
name|failOnNullBody
parameter_list|)
block|{
name|this
operator|.
name|failOnNullBody
operator|=
name|failOnNullBody
expr_stmt|;
block|}
DECL|method|getResultHandlerFactory ()
specifier|public
name|ResultHandlerFactory
name|getResultHandlerFactory
parameter_list|()
block|{
return|return
name|resultHandlerFactory
return|;
block|}
DECL|method|setResultHandlerFactory (ResultHandlerFactory resultHandlerFactory)
specifier|public
name|void
name|setResultHandlerFactory
parameter_list|(
name|ResultHandlerFactory
name|resultHandlerFactory
parameter_list|)
block|{
name|this
operator|.
name|resultHandlerFactory
operator|=
name|resultHandlerFactory
expr_stmt|;
block|}
DECL|method|isAllowStAX ()
specifier|public
name|boolean
name|isAllowStAX
parameter_list|()
block|{
return|return
name|allowStAX
return|;
block|}
DECL|method|setAllowStAX (boolean allowStAX)
specifier|public
name|void
name|setAllowStAX
parameter_list|(
name|boolean
name|allowStAX
parameter_list|)
block|{
name|this
operator|.
name|allowStAX
operator|=
name|allowStAX
expr_stmt|;
block|}
comment|/**      * Sets the XSLT transformer from a Source      *      * @param source  the source      * @throws TransformerConfigurationException is thrown if creating a XSLT transformer failed.      */
DECL|method|setTransformerSource (Source source)
specifier|public
name|void
name|setTransformerSource
parameter_list|(
name|Source
name|source
parameter_list|)
throws|throws
name|TransformerConfigurationException
block|{
name|TransformerFactory
name|factory
init|=
name|converter
operator|.
name|getTransformerFactory
argument_list|()
decl_stmt|;
name|factory
operator|.
name|setErrorListener
argument_list|(
name|errorListener
argument_list|)
expr_stmt|;
if|if
condition|(
name|getUriResolver
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|factory
operator|.
name|setURIResolver
argument_list|(
name|getUriResolver
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Check that the call to newTemplates() returns a valid template instance.
comment|// In case of an xslt parse error, it will return null and we should stop the
comment|// deployment and raise an exception as the route will not be setup properly.
name|Templates
name|templates
init|=
name|factory
operator|.
name|newTemplates
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|templates
operator|!=
literal|null
condition|)
block|{
name|setTemplate
argument_list|(
name|templates
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|TransformerConfigurationException
argument_list|(
literal|"Error creating XSLT template. "
operator|+
literal|"This is most likely be caused by a XML parse error. "
operator|+
literal|"Please verify your XSLT file configured."
argument_list|)
throw|;
block|}
block|}
comment|/**      * Sets the XSLT transformer from a File      */
DECL|method|setTransformerFile (File xslt)
specifier|public
name|void
name|setTransformerFile
parameter_list|(
name|File
name|xslt
parameter_list|)
throws|throws
name|TransformerConfigurationException
block|{
name|setTransformerSource
argument_list|(
operator|new
name|StreamSource
argument_list|(
name|xslt
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sets the XSLT transformer from a URL      */
DECL|method|setTransformerURL (URL url)
specifier|public
name|void
name|setTransformerURL
parameter_list|(
name|URL
name|url
parameter_list|)
throws|throws
name|TransformerConfigurationException
throws|,
name|IOException
block|{
name|notNull
argument_list|(
name|url
argument_list|,
literal|"url"
argument_list|)
expr_stmt|;
name|setTransformerInputStream
argument_list|(
name|url
operator|.
name|openStream
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sets the XSLT transformer from the given input stream      */
DECL|method|setTransformerInputStream (InputStream in)
specifier|public
name|void
name|setTransformerInputStream
parameter_list|(
name|InputStream
name|in
parameter_list|)
throws|throws
name|TransformerConfigurationException
throws|,
name|IOException
block|{
name|notNull
argument_list|(
name|in
argument_list|,
literal|"InputStream"
argument_list|)
expr_stmt|;
name|setTransformerSource
argument_list|(
operator|new
name|StreamSource
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|getConverter ()
specifier|public
name|XmlConverter
name|getConverter
parameter_list|()
block|{
return|return
name|converter
return|;
block|}
DECL|method|setConverter (XmlConverter converter)
specifier|public
name|void
name|setConverter
parameter_list|(
name|XmlConverter
name|converter
parameter_list|)
block|{
name|this
operator|.
name|converter
operator|=
name|converter
expr_stmt|;
block|}
DECL|method|getUriResolver ()
specifier|public
name|URIResolver
name|getUriResolver
parameter_list|()
block|{
return|return
name|uriResolver
return|;
block|}
DECL|method|setUriResolver (URIResolver uriResolver)
specifier|public
name|void
name|setUriResolver
parameter_list|(
name|URIResolver
name|uriResolver
parameter_list|)
block|{
name|this
operator|.
name|uriResolver
operator|=
name|uriResolver
expr_stmt|;
block|}
DECL|method|isDeleteOutputFile ()
specifier|public
name|boolean
name|isDeleteOutputFile
parameter_list|()
block|{
return|return
name|deleteOutputFile
return|;
block|}
DECL|method|setDeleteOutputFile (boolean deleteOutputFile)
specifier|public
name|void
name|setDeleteOutputFile
parameter_list|(
name|boolean
name|deleteOutputFile
parameter_list|)
block|{
name|this
operator|.
name|deleteOutputFile
operator|=
name|deleteOutputFile
expr_stmt|;
block|}
DECL|method|getErrorListener ()
specifier|public
name|ErrorListener
name|getErrorListener
parameter_list|()
block|{
return|return
name|errorListener
return|;
block|}
DECL|method|setErrorListener (ErrorListener errorListener)
specifier|public
name|void
name|setErrorListener
parameter_list|(
name|ErrorListener
name|errorListener
parameter_list|)
block|{
name|this
operator|.
name|errorListener
operator|=
name|errorListener
expr_stmt|;
block|}
comment|// Implementation methods
comment|// -------------------------------------------------------------------------
DECL|method|releaseTransformer (Transformer transformer)
specifier|private
name|void
name|releaseTransformer
parameter_list|(
name|Transformer
name|transformer
parameter_list|)
block|{
if|if
condition|(
name|transformers
operator|!=
literal|null
condition|)
block|{
name|transformer
operator|.
name|reset
argument_list|()
expr_stmt|;
name|transformers
operator|.
name|offer
argument_list|(
name|transformer
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getTransformer ()
specifier|private
name|Transformer
name|getTransformer
parameter_list|()
throws|throws
name|TransformerConfigurationException
block|{
name|Transformer
name|t
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|transformers
operator|!=
literal|null
condition|)
block|{
name|t
operator|=
name|transformers
operator|.
name|poll
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
literal|null
condition|)
block|{
name|t
operator|=
name|getTemplate
argument_list|()
operator|.
name|newTransformer
argument_list|()
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
comment|/**      * Checks whether we need an {@link InputStream} to access the message body.      *<p/>      * Depending on the content in the message body, we may not need to convert      * to {@link InputStream}.      *      * @param exchange the current exchange      * @return<tt>true</tt> to convert to {@link InputStream} beforehand converting to {@link Source} afterwards.      */
DECL|method|isInputStreamNeeded (Exchange exchange)
specifier|protected
name|boolean
name|isInputStreamNeeded
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|Object
name|body
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|()
decl_stmt|;
if|if
condition|(
name|body
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|body
operator|instanceof
name|InputStream
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|body
operator|instanceof
name|Source
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|body
operator|instanceof
name|String
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|body
operator|instanceof
name|byte
index|[]
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|body
operator|instanceof
name|Node
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverterRegistry
argument_list|()
operator|.
name|lookup
argument_list|(
name|Source
operator|.
name|class
argument_list|,
name|body
operator|.
name|getClass
argument_list|()
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|//there is a direct and hopefully optimized converter to Source
return|return
literal|false
return|;
block|}
comment|// yes an input stream is needed
return|return
literal|true
return|;
block|}
comment|/**      * Converts the inbound body to a {@link Source}, if the body is<b>not</b> already a {@link Source}.      *<p/>      * This implementation will prefer to source in the following order:      *<ul>      *<li>StAX - Is StAX is allowed</li>      *<li>SAX - SAX as 2nd choice</li>      *<li>Stream - Stream as 3rd choice</li>      *<li>DOM - DOM as 4th choice</li>      *</ul>      */
DECL|method|getSource (Exchange exchange, Object body)
specifier|protected
name|Source
name|getSource
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Object
name|body
parameter_list|)
block|{
name|Boolean
name|isXalanTransformer
init|=
name|exchange
operator|.
name|getProperty
argument_list|(
literal|"isXalanTransformer"
argument_list|,
name|Boolean
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// body may already be a source
if|if
condition|(
name|body
operator|instanceof
name|Source
condition|)
block|{
return|return
operator|(
name|Source
operator|)
name|body
return|;
block|}
name|Source
name|source
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|body
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|isAllowStAX
argument_list|()
condition|)
block|{
if|if
condition|(
name|isXalanTransformer
condition|)
block|{
name|XMLStreamReader
name|reader
init|=
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|tryConvertTo
argument_list|(
name|XMLStreamReader
operator|.
name|class
argument_list|,
name|exchange
argument_list|,
name|body
argument_list|)
decl_stmt|;
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
comment|// create a new SAXSource with stax parser API
name|source
operator|=
operator|new
name|StaxSource
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|source
operator|=
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|tryConvertTo
argument_list|(
name|StAXSource
operator|.
name|class
argument_list|,
name|exchange
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|source
operator|==
literal|null
condition|)
block|{
comment|// then try SAX
name|source
operator|=
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|tryConvertTo
argument_list|(
name|SAXSource
operator|.
name|class
argument_list|,
name|exchange
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|source
operator|==
literal|null
condition|)
block|{
comment|// then try stream
name|source
operator|=
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|tryConvertTo
argument_list|(
name|StreamSource
operator|.
name|class
argument_list|,
name|exchange
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|source
operator|==
literal|null
condition|)
block|{
comment|// and fallback to DOM
name|source
operator|=
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverter
argument_list|()
operator|.
name|tryConvertTo
argument_list|(
name|DOMSource
operator|.
name|class
argument_list|,
name|exchange
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
comment|// as the TypeConverterRegistry will look up source the converter differently if the type converter is loaded different
comment|// now we just put the call of source converter at last
if|if
condition|(
name|source
operator|==
literal|null
condition|)
block|{
name|TypeConverter
name|tc
init|=
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getTypeConverterRegistry
argument_list|()
operator|.
name|lookup
argument_list|(
name|Source
operator|.
name|class
argument_list|,
name|body
operator|.
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|tc
operator|!=
literal|null
condition|)
block|{
name|source
operator|=
name|tc
operator|.
name|convertTo
argument_list|(
name|Source
operator|.
name|class
argument_list|,
name|exchange
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|source
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|isFailOnNullBody
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ExpectedBodyTypeException
argument_list|(
name|exchange
argument_list|,
name|Source
operator|.
name|class
argument_list|)
throw|;
block|}
else|else
block|{
try|try
block|{
name|source
operator|=
name|converter
operator|.
name|toDOMSource
argument_list|(
name|converter
operator|.
name|createDocument
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParserConfigurationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeTransformException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|source
return|;
block|}
comment|/**      * Configures the transformer with exchange specific parameters      */
DECL|method|configureTransformer (Transformer transformer, Exchange exchange)
specifier|protected
name|void
name|configureTransformer
parameter_list|(
name|Transformer
name|transformer
parameter_list|,
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
name|uriResolver
operator|==
literal|null
condition|)
block|{
name|uriResolver
operator|=
operator|new
name|XsltUriResolver
argument_list|(
name|exchange
operator|.
name|getContext
argument_list|()
operator|.
name|getClassResolver
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|transformer
operator|.
name|setURIResolver
argument_list|(
name|uriResolver
argument_list|)
expr_stmt|;
name|transformer
operator|.
name|setErrorListener
argument_list|(
operator|new
name|XmlErrorListener
argument_list|()
argument_list|)
expr_stmt|;
name|transformer
operator|.
name|clearParameters
argument_list|()
expr_stmt|;
name|addParameters
argument_list|(
name|transformer
argument_list|,
name|exchange
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
name|addParameters
argument_list|(
name|transformer
argument_list|,
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getHeaders
argument_list|()
argument_list|)
expr_stmt|;
name|addParameters
argument_list|(
name|transformer
argument_list|,
name|getParameters
argument_list|()
argument_list|)
expr_stmt|;
name|transformer
operator|.
name|setParameter
argument_list|(
literal|"exchange"
argument_list|,
name|exchange
argument_list|)
expr_stmt|;
name|transformer
operator|.
name|setParameter
argument_list|(
literal|"in"
argument_list|,
name|exchange
operator|.
name|getIn
argument_list|()
argument_list|)
expr_stmt|;
name|transformer
operator|.
name|setParameter
argument_list|(
literal|"out"
argument_list|,
name|exchange
operator|.
name|getOut
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|addParameters (Transformer transformer, Map<String, Object> map)
specifier|protected
name|void
name|addParameters
parameter_list|(
name|Transformer
name|transformer
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|map
parameter_list|)
block|{
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|propertyEntries
init|=
name|map
operator|.
name|entrySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|propertyEntries
control|)
block|{
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Object
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Transformer set parameter {} -> {}"
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|transformer
operator|.
name|setParameter
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|XsltBuilderOnCompletion
specifier|private
specifier|static
specifier|final
class|class
name|XsltBuilderOnCompletion
extends|extends
name|SynchronizationAdapter
block|{
DECL|field|fileName
specifier|private
specifier|final
name|String
name|fileName
decl_stmt|;
DECL|method|XsltBuilderOnCompletion (String fileName)
specifier|private
name|XsltBuilderOnCompletion
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
name|this
operator|.
name|fileName
operator|=
name|fileName
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onDone (Exchange exchange)
specifier|public
name|void
name|onDone
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|FileUtil
operator|.
name|deleteFile
argument_list|(
operator|new
name|File
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"XsltBuilderOnCompletion"
return|;
block|}
block|}
block|}
end_class

end_unit

