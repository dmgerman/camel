begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.builder
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|builder
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|CamelContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Endpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Expression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|Producer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|RuntimeCamelException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|direct
operator|.
name|DirectEndpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|component
operator|.
name|mock
operator|.
name|MockEndpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|CamelEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|CamelEvent
operator|.
name|ExchangeCompletedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|CamelEvent
operator|.
name|ExchangeCreatedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|CamelEvent
operator|.
name|ExchangeFailedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|spi
operator|.
name|CamelEvent
operator|.
name|ExchangeSentEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|EndpointHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|EventNotifierSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|ServiceHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|ObjectHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|StringHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * A builder to build an expression based on {@link org.apache.camel.spi.EventNotifier} notifications  * about {@link Exchange} being routed.  *<p/>  * This builder can be used for testing purposes where you want to know when a test is supposed to be done.  * The idea is that you can build an expression that explains when the test is done. For example when Camel  * have finished routing 5 messages. You can then in your test await for this condition to occur.  */
end_comment

begin_class
DECL|class|NotifyBuilder
specifier|public
class|class
name|NotifyBuilder
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|NotifyBuilder
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|context
specifier|private
specifier|final
name|CamelContext
name|context
decl_stmt|;
comment|// notifier to hook into Camel to listen for events
DECL|field|eventNotifier
specifier|private
specifier|final
name|EventNotifierSupport
name|eventNotifier
decl_stmt|;
comment|// the predicates build with this builder
DECL|field|predicates
specifier|private
specifier|final
name|List
argument_list|<
name|EventPredicateHolder
argument_list|>
name|predicates
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// latch to be used to signal predicates matches
DECL|field|latch
specifier|private
name|CountDownLatch
name|latch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// the current state while building an event predicate where we use a stack and the operation
DECL|field|stack
specifier|private
specifier|final
name|List
argument_list|<
name|EventPredicate
argument_list|>
name|stack
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|operation
specifier|private
name|EventOperation
name|operation
decl_stmt|;
DECL|field|created
specifier|private
name|boolean
name|created
decl_stmt|;
comment|// keep state of how many wereSentTo we have added
DECL|field|wereSentToIndex
specifier|private
name|int
name|wereSentToIndex
decl_stmt|;
comment|// computed value whether all the predicates matched
DECL|field|matches
specifier|private
specifier|volatile
name|boolean
name|matches
decl_stmt|;
comment|/**      * Creates a new builder.      *      * @param context the Camel context      */
DECL|method|NotifyBuilder (CamelContext context)
specifier|public
name|NotifyBuilder
parameter_list|(
name|CamelContext
name|context
parameter_list|)
block|{
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|eventNotifier
operator|=
operator|new
name|ExchangeNotifier
argument_list|()
expr_stmt|;
try|try
block|{
name|ServiceHelper
operator|.
name|startService
argument_list|(
name|eventNotifier
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|RuntimeCamelException
operator|.
name|wrapRuntimeCamelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|context
operator|.
name|getManagementStrategy
argument_list|()
operator|.
name|addEventNotifier
argument_list|(
name|eventNotifier
argument_list|)
expr_stmt|;
block|}
comment|/**      * Optionally a<tt>from</tt> endpoint which means that this expression should only be based      * on {@link Exchange} which is originated from the particular endpoint(s).      *      * @param endpointUri uri of endpoint or pattern (see the EndpointHelper javadoc)      * @return the builder      * @see EndpointHelper#matchEndpoint(org.apache.camel.CamelContext, String, String)      */
DECL|method|from (final String endpointUri)
specifier|public
name|NotifyBuilder
name|from
parameter_list|(
specifier|final
name|String
name|endpointUri
parameter_list|)
block|{
name|stack
operator|.
name|add
argument_list|(
operator|new
name|EventPredicateSupport
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|isAbstract
parameter_list|()
block|{
comment|// is abstract as its a filter
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|onExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
comment|// filter non matching exchanges
return|return
name|EndpointHelper
operator|.
name|matchEndpoint
argument_list|(
name|context
argument_list|,
name|exchange
operator|.
name|getFromEndpoint
argument_list|()
operator|.
name|getEndpointUri
argument_list|()
argument_list|,
name|endpointUri
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|matches
parameter_list|()
block|{
comment|// should be true as we use the onExchange to filter
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"from("
operator|+
name|endpointUri
operator|+
literal|")"
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Optionally a<tt>from</tt> route which means that this expression should only be based      * on {@link Exchange} which is originated from the particular route(s).      *      * @param routeId id of route or pattern (see the EndpointHelper javadoc)      * @return the builder      * @see EndpointHelper#matchEndpoint(org.apache.camel.CamelContext, String, String)      */
DECL|method|fromRoute (final String routeId)
specifier|public
name|NotifyBuilder
name|fromRoute
parameter_list|(
specifier|final
name|String
name|routeId
parameter_list|)
block|{
name|stack
operator|.
name|add
argument_list|(
operator|new
name|EventPredicateSupport
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|isAbstract
parameter_list|()
block|{
comment|// is abstract as its a filter
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|onExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|String
name|id
init|=
name|EndpointHelper
operator|.
name|getRouteIdFromEndpoint
argument_list|(
name|exchange
operator|.
name|getFromEndpoint
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
name|id
operator|=
name|exchange
operator|.
name|getFromRouteId
argument_list|()
expr_stmt|;
block|}
comment|// filter non matching exchanges
return|return
name|EndpointHelper
operator|.
name|matchPattern
argument_list|(
name|id
argument_list|,
name|routeId
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|matches
parameter_list|()
block|{
comment|// should be true as we use the onExchange to filter
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"fromRoute("
operator|+
name|routeId
operator|+
literal|")"
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|fromRoutesOnly ()
specifier|private
name|NotifyBuilder
name|fromRoutesOnly
parameter_list|()
block|{
comment|// internal and should always be in top of stack
name|stack
operator|.
name|add
argument_list|(
literal|0
argument_list|,
operator|new
name|EventPredicateSupport
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|isAbstract
parameter_list|()
block|{
comment|// is abstract as its a filter
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|onExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
comment|// always accept direct endpoints as they are a special case as it will create the UoW beforehand
comment|// and just continue to route that on the consumer side, which causes the EventNotifier not to
comment|// emit events when the consumer received the exchange, as its already done. For example by
comment|// ProducerTemplate which creates the UoW before producing messages.
if|if
condition|(
name|exchange
operator|.
name|getFromEndpoint
argument_list|()
operator|instanceof
name|DirectEndpoint
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|EndpointHelper
operator|.
name|matchPattern
argument_list|(
name|exchange
operator|.
name|getFromRouteId
argument_list|()
argument_list|,
literal|"*"
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|matches
parameter_list|()
block|{
comment|// should be true as we use the onExchange to filter
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
comment|// we dont want any to string output as this is an internal predicate to match only from routes
return|return
literal|""
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Optionally a filter to only allow matching {@link Exchange} to be used for matching.      *      * @param predicate the predicate to use for the filter      * @return the builder      */
DECL|method|filter (final Predicate predicate)
specifier|public
name|NotifyBuilder
name|filter
parameter_list|(
specifier|final
name|Predicate
name|predicate
parameter_list|)
block|{
name|stack
operator|.
name|add
argument_list|(
operator|new
name|EventPredicateSupport
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|isAbstract
parameter_list|()
block|{
comment|// is abstract as its a filter
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|onExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
comment|// filter non matching exchanges
return|return
name|predicate
operator|.
name|matches
argument_list|(
name|exchange
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|matches
parameter_list|()
block|{
comment|// should be true as we use the onExchange to filter
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"filter("
operator|+
name|predicate
operator|+
literal|")"
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Optionally a filter to only allow matching {@link Exchange} to be used for matching.      *      * @return the builder      */
DECL|method|filter ()
specifier|public
name|ExpressionClauseSupport
argument_list|<
name|NotifyBuilder
argument_list|>
name|filter
parameter_list|()
block|{
specifier|final
name|ExpressionClauseSupport
argument_list|<
name|NotifyBuilder
argument_list|>
name|clause
init|=
operator|new
name|ExpressionClauseSupport
argument_list|<>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|stack
operator|.
name|add
argument_list|(
operator|new
name|EventPredicateSupport
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|isAbstract
parameter_list|()
block|{
comment|// is abstract as its a filter
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|onExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
comment|// filter non matching exchanges
name|Expression
name|exp
init|=
name|clause
operator|.
name|createExpression
argument_list|(
name|exchange
operator|.
name|getContext
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|exp
operator|.
name|evaluate
argument_list|(
name|exchange
argument_list|,
name|Boolean
operator|.
name|class
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|matches
parameter_list|()
block|{
comment|// should be true as we use the onExchange to filter
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"filter("
operator|+
name|clause
operator|+
literal|")"
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|clause
return|;
block|}
comment|/**      * Optionally a<tt>sent to</tt> endpoint which means that this expression should only be based      * on {@link Exchange} which has been sent to the given endpoint uri.      *<p/>      * Notice the {@link Exchange} may have been sent to other endpoints as well. This condition will match      * if the {@link Exchange} has been sent at least once to the given endpoint.      *      * @param endpointUri uri of endpoint or pattern (see the EndpointHelper javadoc)      * @return the builder      * @see EndpointHelper#matchEndpoint(org.apache.camel.CamelContext, String, String)      */
DECL|method|wereSentTo (final String endpointUri)
specifier|public
name|NotifyBuilder
name|wereSentTo
parameter_list|(
specifier|final
name|String
name|endpointUri
parameter_list|)
block|{
comment|// insert in start of stack but after the previous wereSentTo
name|stack
operator|.
name|add
argument_list|(
name|wereSentToIndex
operator|++
argument_list|,
operator|new
name|EventPredicateSupport
argument_list|()
block|{
specifier|private
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|sentTo
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|isAbstract
parameter_list|()
block|{
comment|// is abstract as its a filter
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeSent
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Endpoint
name|endpoint
parameter_list|,
name|long
name|timeTaken
parameter_list|)
block|{
if|if
condition|(
name|EndpointHelper
operator|.
name|matchEndpoint
argument_list|(
name|context
argument_list|,
name|endpoint
operator|.
name|getEndpointUri
argument_list|()
argument_list|,
name|endpointUri
argument_list|)
condition|)
block|{
name|sentTo
operator|.
name|put
argument_list|(
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|,
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|onExchange
argument_list|(
name|exchange
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|onExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
comment|// filter only when sentTo
name|String
name|sent
init|=
name|sentTo
operator|.
name|get
argument_list|(
name|exchange
operator|.
name|getExchangeId
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|sent
operator|!=
literal|null
return|;
block|}
specifier|public
name|boolean
name|matches
parameter_list|()
block|{
comment|// should be true as we use the onExchange to filter
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|sentTo
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"wereSentTo("
operator|+
name|endpointUri
operator|+
literal|")"
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets a condition when<tt>number</tt> of {@link Exchange} has been received.      *<p/>      * The number matching is<i>at least</i> based which means that if more messages received      * it will match also.      *      * @param number at least number of messages      * @return the builder      */
DECL|method|whenReceived (final int number)
specifier|public
name|NotifyBuilder
name|whenReceived
parameter_list|(
specifier|final
name|int
name|number
parameter_list|)
block|{
name|stack
operator|.
name|add
argument_list|(
operator|new
name|EventPredicateSupport
argument_list|()
block|{
specifier|private
name|AtomicInteger
name|current
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeCreated
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|current
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|matches
parameter_list|()
block|{
return|return
name|current
operator|.
name|get
argument_list|()
operator|>=
name|number
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|current
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"whenReceived("
operator|+
name|number
operator|+
literal|")"
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets a condition when<tt>number</tt> of {@link Exchange} is done being processed.      *<p/>      * The number matching is<i>at least</i> based which means that if more messages received      * it will match also.      *<p/>      * The difference between<i>done</i> and<i>completed</i> is that done can also include failed      * messages, where as completed is only successful processed messages.      *      * @param number at least number of messages      * @return the builder      */
DECL|method|whenDone (final int number)
specifier|public
name|NotifyBuilder
name|whenDone
parameter_list|(
specifier|final
name|int
name|number
parameter_list|)
block|{
name|stack
operator|.
name|add
argument_list|(
operator|new
name|EventPredicateSupport
argument_list|()
block|{
specifier|private
specifier|final
name|AtomicInteger
name|current
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeCompleted
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|current
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeFailed
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|current
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|matches
parameter_list|()
block|{
return|return
name|current
operator|.
name|get
argument_list|()
operator|>=
name|number
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|current
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"whenDone("
operator|+
name|number
operator|+
literal|")"
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets a condition when tne<tt>n'th</tt> (by index) {@link Exchange} is done being processed.      *<p/>      * The difference between<i>done</i> and<i>completed</i> is that done can also include failed      * messages, where as completed is only successful processed messages.      *      * @param index the message by index to be done      * @return the builder      */
DECL|method|whenDoneByIndex (final int index)
specifier|public
name|NotifyBuilder
name|whenDoneByIndex
parameter_list|(
specifier|final
name|int
name|index
parameter_list|)
block|{
name|stack
operator|.
name|add
argument_list|(
operator|new
name|EventPredicateSupport
argument_list|()
block|{
specifier|private
name|AtomicInteger
name|current
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
specifier|private
name|String
name|id
decl_stmt|;
specifier|private
name|AtomicBoolean
name|done
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeCreated
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
name|current
operator|.
name|get
argument_list|()
operator|==
name|index
condition|)
block|{
name|id
operator|=
name|exchange
operator|.
name|getExchangeId
argument_list|()
expr_stmt|;
block|}
name|current
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeCompleted
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
name|exchange
operator|.
name|getExchangeId
argument_list|()
operator|.
name|equals
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|done
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeFailed
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
name|exchange
operator|.
name|getExchangeId
argument_list|()
operator|.
name|equals
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|done
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|matches
parameter_list|()
block|{
return|return
name|done
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|current
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|id
operator|=
literal|null
expr_stmt|;
name|done
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"whenDoneByIndex("
operator|+
name|index
operator|+
literal|")"
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets a condition when<tt>number</tt> of {@link Exchange} has been completed.      *<p/>      * The number matching is<i>at least</i> based which means that if more messages received      * it will match also.      *<p/>      * The difference between<i>done</i> and<i>completed</i> is that done can also include failed      * messages, where as completed is only successful processed messages.      *      * @param number at least number of messages      * @return the builder      */
DECL|method|whenCompleted (final int number)
specifier|public
name|NotifyBuilder
name|whenCompleted
parameter_list|(
specifier|final
name|int
name|number
parameter_list|)
block|{
name|stack
operator|.
name|add
argument_list|(
operator|new
name|EventPredicateSupport
argument_list|()
block|{
specifier|private
name|AtomicInteger
name|current
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeCompleted
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|current
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|matches
parameter_list|()
block|{
return|return
name|current
operator|.
name|get
argument_list|()
operator|>=
name|number
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|current
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"whenCompleted("
operator|+
name|number
operator|+
literal|")"
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets a condition when<tt>number</tt> of {@link Exchange} has failed.      *<p/>      * The number matching is<i>at least</i> based which means that if more messages received      * it will match also.      *      * @param number at least number of messages      * @return the builder      */
DECL|method|whenFailed (final int number)
specifier|public
name|NotifyBuilder
name|whenFailed
parameter_list|(
specifier|final
name|int
name|number
parameter_list|)
block|{
name|stack
operator|.
name|add
argument_list|(
operator|new
name|EventPredicateSupport
argument_list|()
block|{
specifier|private
name|AtomicInteger
name|current
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeFailed
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|current
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|matches
parameter_list|()
block|{
return|return
name|current
operator|.
name|get
argument_list|()
operator|>=
name|number
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|current
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"whenFailed("
operator|+
name|number
operator|+
literal|")"
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets a condition when<tt>number</tt> of {@link Exchange} is done being processed.      *<p/>      * messages, where as completed is only successful processed messages.      *      * @param number exactly number of messages      * @return the builder      */
DECL|method|whenExactlyDone (final int number)
specifier|public
name|NotifyBuilder
name|whenExactlyDone
parameter_list|(
specifier|final
name|int
name|number
parameter_list|)
block|{
name|stack
operator|.
name|add
argument_list|(
operator|new
name|EventPredicateSupport
argument_list|()
block|{
specifier|private
name|AtomicInteger
name|current
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeCompleted
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|current
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeFailed
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|current
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|matches
parameter_list|()
block|{
return|return
name|current
operator|.
name|get
argument_list|()
operator|==
name|number
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|current
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"whenExactlyDone("
operator|+
name|number
operator|+
literal|")"
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets a condition when<tt>number</tt> of {@link Exchange} has been completed.      *<p/>      * The difference between<i>done</i> and<i>completed</i> is that done can also include failed      * messages, where as completed is only successful processed messages.      *      * @param number exactly number of messages      * @return the builder      */
DECL|method|whenExactlyCompleted (final int number)
specifier|public
name|NotifyBuilder
name|whenExactlyCompleted
parameter_list|(
specifier|final
name|int
name|number
parameter_list|)
block|{
name|stack
operator|.
name|add
argument_list|(
operator|new
name|EventPredicateSupport
argument_list|()
block|{
specifier|private
name|AtomicInteger
name|current
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeCompleted
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|current
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|matches
parameter_list|()
block|{
return|return
name|current
operator|.
name|get
argument_list|()
operator|==
name|number
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|current
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"whenExactlyCompleted("
operator|+
name|number
operator|+
literal|")"
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets a condition when<tt>number</tt> of {@link Exchange} has failed.      *      * @param number exactly number of messages      * @return the builder      */
DECL|method|whenExactlyFailed (final int number)
specifier|public
name|NotifyBuilder
name|whenExactlyFailed
parameter_list|(
specifier|final
name|int
name|number
parameter_list|)
block|{
name|stack
operator|.
name|add
argument_list|(
operator|new
name|EventPredicateSupport
argument_list|()
block|{
specifier|private
name|AtomicInteger
name|current
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeFailed
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
name|current
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|matches
parameter_list|()
block|{
return|return
name|current
operator|.
name|get
argument_list|()
operator|==
name|number
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|current
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"whenExactlyFailed("
operator|+
name|number
operator|+
literal|")"
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets a condition that<b>any received</b> {@link Exchange} should match the {@link Predicate}      *      * @param predicate the predicate      * @return the builder      */
DECL|method|whenAnyReceivedMatches (final Predicate predicate)
specifier|public
name|NotifyBuilder
name|whenAnyReceivedMatches
parameter_list|(
specifier|final
name|Predicate
name|predicate
parameter_list|)
block|{
return|return
name|doWhenAnyMatches
argument_list|(
name|predicate
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Sets a condition that<b>any done</b> {@link Exchange} should match the {@link Predicate}      *      * @param predicate the predicate      * @return the builder      */
DECL|method|whenAnyDoneMatches (final Predicate predicate)
specifier|public
name|NotifyBuilder
name|whenAnyDoneMatches
parameter_list|(
specifier|final
name|Predicate
name|predicate
parameter_list|)
block|{
return|return
name|doWhenAnyMatches
argument_list|(
name|predicate
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|doWhenAnyMatches (final Predicate predicate, final boolean received)
specifier|private
name|NotifyBuilder
name|doWhenAnyMatches
parameter_list|(
specifier|final
name|Predicate
name|predicate
parameter_list|,
specifier|final
name|boolean
name|received
parameter_list|)
block|{
name|stack
operator|.
name|add
argument_list|(
operator|new
name|EventPredicateSupport
argument_list|()
block|{
specifier|private
specifier|final
name|AtomicBoolean
name|matches
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeCompleted
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
operator|!
name|received
operator|&&
operator|!
name|matches
operator|.
name|get
argument_list|()
condition|)
block|{
name|matches
operator|.
name|set
argument_list|(
name|predicate
operator|.
name|matches
argument_list|(
name|exchange
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeFailed
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
operator|!
name|received
operator|&&
operator|!
name|matches
operator|.
name|get
argument_list|()
condition|)
block|{
name|matches
operator|.
name|set
argument_list|(
name|predicate
operator|.
name|matches
argument_list|(
name|exchange
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeCreated
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
name|received
operator|&&
operator|!
name|matches
operator|.
name|get
argument_list|()
condition|)
block|{
name|matches
operator|.
name|set
argument_list|(
name|predicate
operator|.
name|matches
argument_list|(
name|exchange
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|matches
parameter_list|()
block|{
return|return
name|matches
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|matches
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|received
condition|)
block|{
return|return
literal|"whenAnyReceivedMatches("
operator|+
name|predicate
operator|+
literal|")"
return|;
block|}
else|else
block|{
return|return
literal|"whenAnyDoneMatches("
operator|+
name|predicate
operator|+
literal|")"
return|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets a condition that<b>all received</b> {@link Exchange} should match the {@link Predicate}      *      * @param predicate the predicate      * @return the builder      */
DECL|method|whenAllReceivedMatches (final Predicate predicate)
specifier|public
name|NotifyBuilder
name|whenAllReceivedMatches
parameter_list|(
specifier|final
name|Predicate
name|predicate
parameter_list|)
block|{
return|return
name|doWhenAllMatches
argument_list|(
name|predicate
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Sets a condition that<b>all done</b> {@link Exchange} should match the {@link Predicate}      *      * @param predicate the predicate      * @return the builder      */
DECL|method|whenAllDoneMatches (final Predicate predicate)
specifier|public
name|NotifyBuilder
name|whenAllDoneMatches
parameter_list|(
specifier|final
name|Predicate
name|predicate
parameter_list|)
block|{
return|return
name|doWhenAllMatches
argument_list|(
name|predicate
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|doWhenAllMatches (final Predicate predicate, final boolean received)
specifier|private
name|NotifyBuilder
name|doWhenAllMatches
parameter_list|(
specifier|final
name|Predicate
name|predicate
parameter_list|,
specifier|final
name|boolean
name|received
parameter_list|)
block|{
name|stack
operator|.
name|add
argument_list|(
operator|new
name|EventPredicateSupport
argument_list|()
block|{
specifier|private
specifier|final
name|AtomicBoolean
name|matches
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeCompleted
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
operator|!
name|received
operator|&&
name|matches
operator|.
name|get
argument_list|()
condition|)
block|{
name|matches
operator|.
name|set
argument_list|(
name|predicate
operator|.
name|matches
argument_list|(
name|exchange
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeFailed
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
operator|!
name|received
operator|&&
name|matches
operator|.
name|get
argument_list|()
condition|)
block|{
name|matches
operator|.
name|set
argument_list|(
name|predicate
operator|.
name|matches
argument_list|(
name|exchange
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeCreated
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
name|received
operator|&&
name|matches
operator|.
name|get
argument_list|()
condition|)
block|{
name|matches
operator|.
name|set
argument_list|(
name|predicate
operator|.
name|matches
argument_list|(
name|exchange
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|matches
parameter_list|()
block|{
return|return
name|matches
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|matches
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|received
condition|)
block|{
return|return
literal|"whenAllReceivedMatches("
operator|+
name|predicate
operator|+
literal|")"
return|;
block|}
else|else
block|{
return|return
literal|"whenAllDoneMatches("
operator|+
name|predicate
operator|+
literal|")"
return|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets a condition when the provided mock is satisfied based on {@link Exchange}      * being sent to it when they are<b>done</b>.      *<p/>      * The idea is that you can use Mock for setting fine grained expectations      * and then use that together with this builder. The mock provided does<b>NOT</b>      * have to already exist in the route. You can just create a new pseudo mock      * and this builder will send the done {@link Exchange} to it. So its like      * adding the mock to the end of your route(s).      *      * @param mock the mock      * @return the builder      */
DECL|method|whenDoneSatisfied (final MockEndpoint mock)
specifier|public
name|NotifyBuilder
name|whenDoneSatisfied
parameter_list|(
specifier|final
name|MockEndpoint
name|mock
parameter_list|)
block|{
return|return
name|doWhenSatisfied
argument_list|(
name|mock
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Sets a condition when the provided mock is satisfied based on {@link Exchange}      * being sent to it when they are<b>received</b>.      *<p/>      * The idea is that you can use Mock for setting fine grained expectations      * and then use that together with this builder. The mock provided does<b>NOT</b>      * have to already exist in the route. You can just create a new pseudo mock      * and this builder will send the done {@link Exchange} to it. So its like      * adding the mock to the end of your route(s).      *      * @param mock the mock      * @return the builder      */
DECL|method|whenReceivedSatisfied (final MockEndpoint mock)
specifier|public
name|NotifyBuilder
name|whenReceivedSatisfied
parameter_list|(
specifier|final
name|MockEndpoint
name|mock
parameter_list|)
block|{
return|return
name|doWhenSatisfied
argument_list|(
name|mock
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|doWhenSatisfied (final MockEndpoint mock, final boolean received)
specifier|private
name|NotifyBuilder
name|doWhenSatisfied
parameter_list|(
specifier|final
name|MockEndpoint
name|mock
parameter_list|,
specifier|final
name|boolean
name|received
parameter_list|)
block|{
name|stack
operator|.
name|add
argument_list|(
operator|new
name|EventPredicateSupport
argument_list|()
block|{
specifier|private
name|Producer
name|producer
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeCreated
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
name|received
condition|)
block|{
name|sendToMock
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeFailed
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
operator|!
name|received
condition|)
block|{
name|sendToMock
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeCompleted
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
operator|!
name|received
condition|)
block|{
name|sendToMock
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|sendToMock
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
comment|// send the exchange when its completed to the mock
try|try
block|{
if|if
condition|(
name|producer
operator|==
literal|null
condition|)
block|{
name|producer
operator|=
name|mock
operator|.
name|createProducer
argument_list|()
expr_stmt|;
block|}
name|producer
operator|.
name|process
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|RuntimeCamelException
operator|.
name|wrapRuntimeCamelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|public
name|boolean
name|matches
parameter_list|()
block|{
try|try
block|{
return|return
name|mock
operator|.
name|await
argument_list|(
literal|0
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
name|RuntimeCamelException
operator|.
name|wrapRuntimeCamelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|mock
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|received
condition|)
block|{
return|return
literal|"whenReceivedSatisfied("
operator|+
name|mock
operator|+
literal|")"
return|;
block|}
else|else
block|{
return|return
literal|"whenDoneSatisfied("
operator|+
name|mock
operator|+
literal|")"
return|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets a condition when the provided mock is<b>not</b> satisfied based on {@link Exchange}      * being sent to it when they are<b>received</b>.      *<p/>      * The idea is that you can use Mock for setting fine grained expectations      * and then use that together with this builder. The mock provided does<b>NOT</b>      * have to already exist in the route. You can just create a new pseudo mock      * and this builder will send the done {@link Exchange} to it. So its like      * adding the mock to the end of your route(s).      *      * @param mock the mock      * @return the builder      */
DECL|method|whenReceivedNotSatisfied (final MockEndpoint mock)
specifier|public
name|NotifyBuilder
name|whenReceivedNotSatisfied
parameter_list|(
specifier|final
name|MockEndpoint
name|mock
parameter_list|)
block|{
return|return
name|doWhenNotSatisfied
argument_list|(
name|mock
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Sets a condition when the provided mock is<b>not</b> satisfied based on {@link Exchange}      * being sent to it when they are<b>done</b>.      *<p/>      * The idea is that you can use Mock for setting fine grained expectations      * and then use that together with this builder. The mock provided does<b>NOT</b>      * have to already exist in the route. You can just create a new pseudo mock      * and this builder will send the done {@link Exchange} to it. So its like      * adding the mock to the end of your route(s).      *      * @param mock the mock      * @return the builder      */
DECL|method|whenDoneNotSatisfied (final MockEndpoint mock)
specifier|public
name|NotifyBuilder
name|whenDoneNotSatisfied
parameter_list|(
specifier|final
name|MockEndpoint
name|mock
parameter_list|)
block|{
return|return
name|doWhenNotSatisfied
argument_list|(
name|mock
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|doWhenNotSatisfied (final MockEndpoint mock, final boolean received)
specifier|private
name|NotifyBuilder
name|doWhenNotSatisfied
parameter_list|(
specifier|final
name|MockEndpoint
name|mock
parameter_list|,
specifier|final
name|boolean
name|received
parameter_list|)
block|{
name|stack
operator|.
name|add
argument_list|(
operator|new
name|EventPredicateSupport
argument_list|()
block|{
specifier|private
name|Producer
name|producer
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeCreated
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
name|received
condition|)
block|{
name|sendToMock
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeFailed
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
operator|!
name|received
condition|)
block|{
name|sendToMock
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeCompleted
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
operator|!
name|received
condition|)
block|{
name|sendToMock
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|sendToMock
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
comment|// send the exchange when its completed to the mock
try|try
block|{
if|if
condition|(
name|producer
operator|==
literal|null
condition|)
block|{
name|producer
operator|=
name|mock
operator|.
name|createProducer
argument_list|()
expr_stmt|;
block|}
name|producer
operator|.
name|process
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|RuntimeCamelException
operator|.
name|wrapRuntimeCamelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|public
name|boolean
name|matches
parameter_list|()
block|{
try|try
block|{
return|return
operator|!
name|mock
operator|.
name|await
argument_list|(
literal|0
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
name|RuntimeCamelException
operator|.
name|wrapRuntimeCamelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|mock
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|received
condition|)
block|{
return|return
literal|"whenReceivedNotSatisfied("
operator|+
name|mock
operator|+
literal|")"
return|;
block|}
else|else
block|{
return|return
literal|"whenDoneNotSatisfied("
operator|+
name|mock
operator|+
literal|")"
return|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Sets a condition that the bodies is expected to be<b>received</b> in the order as well.      *<p/>      * This condition will discard any additional messages. If you need a more strict condition      * then use {@link #whenExactBodiesReceived(Object...)}      *      * @param bodies the expected bodies      * @return the builder      * @see #whenExactBodiesReceived(Object...)      */
DECL|method|whenBodiesReceived (Object... bodies)
specifier|public
name|NotifyBuilder
name|whenBodiesReceived
parameter_list|(
name|Object
modifier|...
name|bodies
parameter_list|)
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|bodyList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|bodyList
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|bodies
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|doWhenBodies
argument_list|(
name|bodyList
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Sets a condition that the bodies is expected to be<b>done</b> in the order as well.      *<p/>      * This condition will discard any additional messages. If you need a more strict condition      * then use {@link #whenExactBodiesDone(Object...)}      *      * @param bodies the expected bodies      * @return the builder      * @see #whenExactBodiesDone(Object...)      */
DECL|method|whenBodiesDone (Object... bodies)
specifier|public
name|NotifyBuilder
name|whenBodiesDone
parameter_list|(
name|Object
modifier|...
name|bodies
parameter_list|)
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|bodyList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|bodyList
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|bodies
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|doWhenBodies
argument_list|(
name|bodyList
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Sets a condition that the bodies is expected to be<b>received</b> in the order as well.      *<p/>      * This condition is strict which means that it only expect that exact number of bodies      *      * @param bodies the expected bodies      * @return the builder      * @see #whenBodiesReceived(Object...)      */
DECL|method|whenExactBodiesReceived (Object... bodies)
specifier|public
name|NotifyBuilder
name|whenExactBodiesReceived
parameter_list|(
name|Object
modifier|...
name|bodies
parameter_list|)
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|bodyList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|bodyList
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|bodies
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|doWhenBodies
argument_list|(
name|bodyList
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Sets a condition that the bodies is expected to be<b>done</b> in the order as well.      *<p/>      * This condition is strict which means that it only expect that exact number of bodies      *      * @param bodies the expected bodies      * @return the builder      * @see #whenExactBodiesDone(Object...)      */
DECL|method|whenExactBodiesDone (Object... bodies)
specifier|public
name|NotifyBuilder
name|whenExactBodiesDone
parameter_list|(
name|Object
modifier|...
name|bodies
parameter_list|)
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|bodyList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|bodyList
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|bodies
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|doWhenBodies
argument_list|(
name|bodyList
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|doWhenBodies (final List<?> bodies, final boolean received, final boolean exact)
specifier|private
name|NotifyBuilder
name|doWhenBodies
parameter_list|(
specifier|final
name|List
argument_list|<
name|?
argument_list|>
name|bodies
parameter_list|,
specifier|final
name|boolean
name|received
parameter_list|,
specifier|final
name|boolean
name|exact
parameter_list|)
block|{
name|stack
operator|.
name|add
argument_list|(
operator|new
name|EventPredicateSupport
argument_list|()
block|{
specifier|private
specifier|volatile
name|boolean
name|matches
decl_stmt|;
specifier|private
specifier|final
name|AtomicInteger
name|current
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeCreated
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
name|received
condition|)
block|{
name|matchBody
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeFailed
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
operator|!
name|received
condition|)
block|{
name|matchBody
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|onExchangeCompleted
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
operator|!
name|received
condition|)
block|{
name|matchBody
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|matchBody
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
if|if
condition|(
name|current
operator|.
name|incrementAndGet
argument_list|()
operator|>
name|bodies
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// out of bounds
return|return;
block|}
name|Object
name|actual
init|=
name|exchange
operator|.
name|getIn
argument_list|()
operator|.
name|getBody
argument_list|()
decl_stmt|;
name|Object
name|expected
init|=
name|bodies
operator|.
name|get
argument_list|(
name|current
operator|.
name|get
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|matches
operator|=
name|ObjectHelper
operator|.
name|equal
argument_list|(
name|expected
argument_list|,
name|actual
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|matches
parameter_list|()
block|{
if|if
condition|(
name|exact
condition|)
block|{
return|return
name|matches
operator|&&
name|current
operator|.
name|get
argument_list|()
operator|==
name|bodies
operator|.
name|size
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|matches
operator|&&
name|current
operator|.
name|get
argument_list|()
operator|>=
name|bodies
operator|.
name|size
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|matches
operator|=
literal|false
expr_stmt|;
name|current
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|received
condition|)
block|{
return|return
literal|""
operator|+
operator|(
name|exact
condition|?
literal|"whenExactBodiesReceived("
else|:
literal|"whenBodiesReceived("
operator|)
operator|+
name|bodies
operator|+
literal|")"
return|;
block|}
else|else
block|{
return|return
literal|""
operator|+
operator|(
name|exact
condition|?
literal|"whenExactBodiesDone("
else|:
literal|"whenBodiesDone("
operator|)
operator|+
name|bodies
operator|+
literal|")"
return|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Prepares to append an additional expression using the<i>and</i> operator.      *      * @return the builder      */
DECL|method|and ()
specifier|public
name|NotifyBuilder
name|and
parameter_list|()
block|{
name|doCreate
argument_list|(
name|EventOperation
operator|.
name|and
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Prepares to append an additional expression using the<i>or</i> operator.      *      * @return the builder      */
DECL|method|or ()
specifier|public
name|NotifyBuilder
name|or
parameter_list|()
block|{
name|doCreate
argument_list|(
name|EventOperation
operator|.
name|or
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Prepares to append an additional expression using the<i>not</i> operator.      *      * @return the builder      */
DECL|method|not ()
specifier|public
name|NotifyBuilder
name|not
parameter_list|()
block|{
name|doCreate
argument_list|(
name|EventOperation
operator|.
name|not
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Creates the expression this builder should use for matching.      *<p/>      * You must call this method when you are finished building the expressions.      *      * @return the created builder ready for matching      */
DECL|method|create ()
specifier|public
name|NotifyBuilder
name|create
parameter_list|()
block|{
name|doCreate
argument_list|(
name|EventOperation
operator|.
name|and
argument_list|)
expr_stmt|;
if|if
condition|(
name|eventNotifier
operator|.
name|isStopped
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"A destroyed NotifyBuilder cannot be re-created."
argument_list|)
throw|;
block|}
name|created
operator|=
literal|true
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * De-registers this builder from its {@link CamelContext}.      *<p/>      * Once destroyed, this instance will not function again.      */
DECL|method|destroy ()
specifier|public
name|void
name|destroy
parameter_list|()
block|{
name|context
operator|.
name|getManagementStrategy
argument_list|()
operator|.
name|removeEventNotifier
argument_list|(
name|eventNotifier
argument_list|)
expr_stmt|;
try|try
block|{
name|ServiceHelper
operator|.
name|stopService
argument_list|(
name|eventNotifier
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|RuntimeCamelException
operator|.
name|wrapRuntimeCamelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|created
operator|=
literal|false
expr_stmt|;
block|}
comment|/**      * Does all the expression match?      *<p/>      * This operation will return immediately which means it can be used for testing at this very moment.      *      * @return<tt>true</tt> if matching,<tt>false</tt> otherwise      */
DECL|method|matches ()
specifier|public
name|boolean
name|matches
parameter_list|()
block|{
if|if
condition|(
operator|!
name|created
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"NotifyBuilder has not been created. Invoke the create() method before matching."
argument_list|)
throw|;
block|}
return|return
name|matches
return|;
block|}
comment|/**      * Does all the expression match?      *<p/>      * This operation will wait until the match is<tt>true</tt> or otherwise a timeout occur      * which means<tt>false</tt> will be returned.      *      * @param timeout  the timeout value      * @param timeUnit the time unit      * @return<tt>true</tt> if matching,<tt>false</tt> otherwise due to timeout      */
DECL|method|matches (long timeout, TimeUnit timeUnit)
specifier|public
name|boolean
name|matches
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
if|if
condition|(
operator|!
name|created
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"NotifyBuilder has not been created. Invoke the create() method before matching."
argument_list|)
throw|;
block|}
try|try
block|{
name|latch
operator|.
name|await
argument_list|(
name|timeout
argument_list|,
name|timeUnit
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
name|RuntimeCamelException
operator|.
name|wrapRuntimeCamelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|matches
argument_list|()
return|;
block|}
comment|/**      * Does all the expressions match?      *<p/>      * This operation will wait until the match is<tt>true</tt> or otherwise a timeout occur      * which means<tt>false</tt> will be returned.      *<p/>      * The timeout value is by default 10 seconds. But it will use the highest<i>maximum result wait time</i>      * from the configured mocks, if such a value has been configured.      *<p/>      * This method is convenient to use in unit tests to have it adhere and wait      * as long as the mock endpoints.      *      * @return<tt>true</tt> if matching,<tt>false</tt> otherwise due to timeout      */
DECL|method|matchesMockWaitTime ()
specifier|public
name|boolean
name|matchesMockWaitTime
parameter_list|()
block|{
if|if
condition|(
operator|!
name|created
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"NotifyBuilder has not been created. Invoke the create() method before matching."
argument_list|)
throw|;
block|}
name|long
name|timeout
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Endpoint
name|endpoint
range|:
name|context
operator|.
name|getEndpoints
argument_list|()
control|)
block|{
if|if
condition|(
name|endpoint
operator|instanceof
name|MockEndpoint
condition|)
block|{
name|long
name|waitTime
init|=
operator|(
operator|(
name|MockEndpoint
operator|)
name|endpoint
operator|)
operator|.
name|getResultWaitTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|waitTime
operator|>
literal|0
condition|)
block|{
name|timeout
operator|=
name|Math
operator|.
name|max
argument_list|(
name|timeout
argument_list|,
name|waitTime
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// use 10 sec as default
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|timeout
operator|=
literal|10000
expr_stmt|;
block|}
return|return
name|matches
argument_list|(
name|timeout
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
return|;
block|}
comment|/**      * Resets the notifier.      */
DECL|method|reset ()
specifier|public
name|void
name|reset
parameter_list|()
block|{
for|for
control|(
name|EventPredicateHolder
name|predicate
range|:
name|predicates
control|)
block|{
name|predicate
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
name|latch
operator|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|matches
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|EventPredicateHolder
name|eventPredicateHolder
range|:
name|predicates
control|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|eventPredicateHolder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// a crude way of skipping the first invisible operation
return|return
name|StringHelper
operator|.
name|after
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|,
literal|"()."
argument_list|)
return|;
block|}
DECL|method|doCreate (EventOperation newOperation)
specifier|private
name|void
name|doCreate
parameter_list|(
name|EventOperation
name|newOperation
parameter_list|)
block|{
comment|// init operation depending on the newOperation
if|if
condition|(
name|operation
operator|==
literal|null
condition|)
block|{
comment|// if the first new operation is an or then this operation must be an or as well
comment|// otherwise it should be and based
name|operation
operator|=
name|newOperation
operator|==
name|EventOperation
operator|.
name|or
condition|?
name|EventOperation
operator|.
name|or
else|:
name|EventOperation
operator|.
name|and
expr_stmt|;
block|}
comment|// we have some predicates
if|if
condition|(
operator|!
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// we only want to match from routes, so skip for example events
comment|// which is triggered by producer templates etc.
name|fromRoutesOnly
argument_list|()
expr_stmt|;
comment|// the stack must have at least one non abstract
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|EventPredicate
name|predicate
range|:
name|stack
control|)
block|{
if|if
condition|(
operator|!
name|predicate
operator|.
name|isAbstract
argument_list|()
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"NotifyBuilder must contain at least one non-abstract predicate (such as whenDone)"
argument_list|)
throw|;
block|}
name|CompoundEventPredicate
name|compound
init|=
operator|new
name|CompoundEventPredicate
argument_list|(
name|stack
argument_list|)
decl_stmt|;
name|stack
operator|.
name|clear
argument_list|()
expr_stmt|;
name|predicates
operator|.
name|add
argument_list|(
operator|new
name|EventPredicateHolder
argument_list|(
name|operation
argument_list|,
name|compound
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|operation
operator|=
name|newOperation
expr_stmt|;
comment|// reset wereSentTo index position as this its a new group
name|wereSentToIndex
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * Notifier which hooks into Camel to listen for {@link Exchange} relevant events for this builder      */
DECL|class|ExchangeNotifier
specifier|private
specifier|final
class|class
name|ExchangeNotifier
extends|extends
name|EventNotifierSupport
block|{
DECL|method|notify (CamelEvent event)
specifier|public
name|void
name|notify
parameter_list|(
name|CamelEvent
name|event
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|event
operator|instanceof
name|ExchangeCreatedEvent
condition|)
block|{
name|onExchangeCreated
argument_list|(
operator|(
name|ExchangeCreatedEvent
operator|)
name|event
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|instanceof
name|ExchangeCompletedEvent
condition|)
block|{
name|onExchangeCompleted
argument_list|(
operator|(
name|ExchangeCompletedEvent
operator|)
name|event
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|instanceof
name|ExchangeFailedEvent
condition|)
block|{
name|onExchangeFailed
argument_list|(
operator|(
name|ExchangeFailedEvent
operator|)
name|event
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|instanceof
name|ExchangeSentEvent
condition|)
block|{
name|onExchangeSent
argument_list|(
operator|(
name|ExchangeSentEvent
operator|)
name|event
argument_list|)
expr_stmt|;
block|}
comment|// now compute whether we matched
name|computeMatches
argument_list|()
expr_stmt|;
block|}
DECL|method|isEnabled (CamelEvent event)
specifier|public
name|boolean
name|isEnabled
parameter_list|(
name|CamelEvent
name|event
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
DECL|method|onExchangeCreated (ExchangeCreatedEvent event)
specifier|private
name|void
name|onExchangeCreated
parameter_list|(
name|ExchangeCreatedEvent
name|event
parameter_list|)
block|{
for|for
control|(
name|EventPredicateHolder
name|predicate
range|:
name|predicates
control|)
block|{
name|predicate
operator|.
name|getPredicate
argument_list|()
operator|.
name|onExchangeCreated
argument_list|(
name|event
operator|.
name|getExchange
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|onExchangeCompleted (ExchangeCompletedEvent event)
specifier|private
name|void
name|onExchangeCompleted
parameter_list|(
name|ExchangeCompletedEvent
name|event
parameter_list|)
block|{
for|for
control|(
name|EventPredicateHolder
name|predicate
range|:
name|predicates
control|)
block|{
name|predicate
operator|.
name|getPredicate
argument_list|()
operator|.
name|onExchangeCompleted
argument_list|(
name|event
operator|.
name|getExchange
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|onExchangeFailed (ExchangeFailedEvent event)
specifier|private
name|void
name|onExchangeFailed
parameter_list|(
name|ExchangeFailedEvent
name|event
parameter_list|)
block|{
for|for
control|(
name|EventPredicateHolder
name|predicate
range|:
name|predicates
control|)
block|{
name|predicate
operator|.
name|getPredicate
argument_list|()
operator|.
name|onExchangeFailed
argument_list|(
name|event
operator|.
name|getExchange
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|onExchangeSent (ExchangeSentEvent event)
specifier|private
name|void
name|onExchangeSent
parameter_list|(
name|ExchangeSentEvent
name|event
parameter_list|)
block|{
for|for
control|(
name|EventPredicateHolder
name|predicate
range|:
name|predicates
control|)
block|{
name|predicate
operator|.
name|getPredicate
argument_list|()
operator|.
name|onExchangeSent
argument_list|(
name|event
operator|.
name|getExchange
argument_list|()
argument_list|,
name|event
operator|.
name|getEndpoint
argument_list|()
argument_list|,
name|event
operator|.
name|getTimeTaken
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|computeMatches ()
specifier|private
specifier|synchronized
name|void
name|computeMatches
parameter_list|()
block|{
comment|// use a temporary answer until we have computed the value to assign
name|Boolean
name|answer
init|=
literal|null
decl_stmt|;
for|for
control|(
name|EventPredicateHolder
name|holder
range|:
name|predicates
control|)
block|{
name|EventOperation
name|operation
init|=
name|holder
operator|.
name|getOperation
argument_list|()
decl_stmt|;
if|if
condition|(
name|EventOperation
operator|.
name|and
operator|==
name|operation
condition|)
block|{
if|if
condition|(
name|holder
operator|.
name|getPredicate
argument_list|()
operator|.
name|matches
argument_list|()
condition|)
block|{
name|answer
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|answer
operator|=
literal|false
expr_stmt|;
comment|// and break out since its an AND so it must match
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|EventOperation
operator|.
name|or
operator|==
name|operation
condition|)
block|{
if|if
condition|(
name|holder
operator|.
name|getPredicate
argument_list|()
operator|.
name|matches
argument_list|()
condition|)
block|{
name|answer
operator|=
literal|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|EventOperation
operator|.
name|not
operator|==
name|operation
condition|)
block|{
if|if
condition|(
name|holder
operator|.
name|getPredicate
argument_list|()
operator|.
name|matches
argument_list|()
condition|)
block|{
name|answer
operator|=
literal|false
expr_stmt|;
comment|// and break out since its a NOT so it must not match
break|break;
block|}
else|else
block|{
name|answer
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|// if we did compute a value then assign that
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|matches
operator|=
name|answer
expr_stmt|;
if|if
condition|(
name|matches
condition|)
block|{
comment|// signal completion
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|doStart ()
specifier|protected
name|void
name|doStart
parameter_list|()
throws|throws
name|Exception
block|{
comment|// we only care about Exchange events
name|setIgnoreCamelContextEvents
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|setIgnoreRouteEvents
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|setIgnoreServiceEvents
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
DECL|enum|EventOperation
specifier|private
enum|enum
name|EventOperation
block|{
DECL|enumConstant|and
DECL|enumConstant|or
DECL|enumConstant|not
name|and
block|,
name|or
block|,
name|not
block|}
DECL|interface|EventPredicate
specifier|private
interface|interface
name|EventPredicate
block|{
comment|/**          * Evaluates whether the predicate matched or not.          *          * @return<tt>true</tt> if matched,<tt>false</tt> otherwise          */
DECL|method|matches ()
name|boolean
name|matches
parameter_list|()
function_decl|;
comment|/**          * Resets the predicate          */
DECL|method|reset ()
name|void
name|reset
parameter_list|()
function_decl|;
comment|/**          * Whether the predicate is abstract          */
DECL|method|isAbstract ()
name|boolean
name|isAbstract
parameter_list|()
function_decl|;
comment|/**          * Callback for {@link Exchange} lifecycle          *          * @param exchange the exchange          * @return<tt>true</tt> to allow continue evaluating,<tt>false</tt> to stop immediately          */
DECL|method|onExchangeCreated (Exchange exchange)
name|boolean
name|onExchangeCreated
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
function_decl|;
comment|/**          * Callback for {@link Exchange} lifecycle          *          * @param exchange the exchange          * @return<tt>true</tt> to allow continue evaluating,<tt>false</tt> to stop immediately          */
DECL|method|onExchangeCompleted (Exchange exchange)
name|boolean
name|onExchangeCompleted
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
function_decl|;
comment|/**          * Callback for {@link Exchange} lifecycle          *          * @param exchange the exchange          * @return<tt>true</tt> to allow continue evaluating,<tt>false</tt> to stop immediately          */
DECL|method|onExchangeFailed (Exchange exchange)
name|boolean
name|onExchangeFailed
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
function_decl|;
comment|/**          * Callback for {@link Exchange} lifecycle          *          * @param exchange the exchange          * @param endpoint the endpoint sent to          * @param timeTaken time taken in millis to send the to endpoint          * @return<tt>true</tt> to allow continue evaluating,<tt>false</tt> to stop immediately          */
DECL|method|onExchangeSent (Exchange exchange, Endpoint endpoint, long timeTaken)
name|boolean
name|onExchangeSent
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Endpoint
name|endpoint
parameter_list|,
name|long
name|timeTaken
parameter_list|)
function_decl|;
block|}
DECL|class|EventPredicateSupport
specifier|private
specifier|abstract
class|class
name|EventPredicateSupport
implements|implements
name|EventPredicate
block|{
DECL|method|isAbstract ()
specifier|public
name|boolean
name|isAbstract
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
DECL|method|reset ()
specifier|public
name|void
name|reset
parameter_list|()
block|{
comment|// noop
block|}
DECL|method|onExchangeCreated (Exchange exchange)
specifier|public
name|boolean
name|onExchangeCreated
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|onExchange
argument_list|(
name|exchange
argument_list|)
return|;
block|}
DECL|method|onExchangeCompleted (Exchange exchange)
specifier|public
name|boolean
name|onExchangeCompleted
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|onExchange
argument_list|(
name|exchange
argument_list|)
return|;
block|}
DECL|method|onExchangeFailed (Exchange exchange)
specifier|public
name|boolean
name|onExchangeFailed
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|onExchange
argument_list|(
name|exchange
argument_list|)
return|;
block|}
DECL|method|onExchangeSent (Exchange exchange, Endpoint endpoint, long timeTaken)
specifier|public
name|boolean
name|onExchangeSent
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Endpoint
name|endpoint
parameter_list|,
name|long
name|timeTaken
parameter_list|)
block|{
comment|// no need to invoke onExchange as this is a special case when the Exchange
comment|// was sent to a specific endpoint
return|return
literal|true
return|;
block|}
DECL|method|onExchange (Exchange exchange)
specifier|public
name|boolean
name|onExchange
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/**      * To hold an operation and predicate      */
DECL|class|EventPredicateHolder
specifier|private
specifier|final
class|class
name|EventPredicateHolder
block|{
DECL|field|operation
specifier|private
specifier|final
name|EventOperation
name|operation
decl_stmt|;
DECL|field|predicate
specifier|private
specifier|final
name|EventPredicate
name|predicate
decl_stmt|;
DECL|method|EventPredicateHolder (EventOperation operation, EventPredicate predicate)
specifier|private
name|EventPredicateHolder
parameter_list|(
name|EventOperation
name|operation
parameter_list|,
name|EventPredicate
name|predicate
parameter_list|)
block|{
name|this
operator|.
name|operation
operator|=
name|operation
expr_stmt|;
name|this
operator|.
name|predicate
operator|=
name|predicate
expr_stmt|;
block|}
DECL|method|getOperation ()
specifier|public
name|EventOperation
name|getOperation
parameter_list|()
block|{
return|return
name|operation
return|;
block|}
DECL|method|getPredicate ()
specifier|public
name|EventPredicate
name|getPredicate
parameter_list|()
block|{
return|return
name|predicate
return|;
block|}
DECL|method|reset ()
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|predicate
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|operation
operator|.
name|name
argument_list|()
operator|+
literal|"()."
operator|+
name|predicate
return|;
block|}
block|}
comment|/**      * To hold multiple predicates which are part of same expression      */
DECL|class|CompoundEventPredicate
specifier|private
specifier|final
class|class
name|CompoundEventPredicate
implements|implements
name|EventPredicate
block|{
DECL|field|predicates
specifier|private
name|List
argument_list|<
name|EventPredicate
argument_list|>
name|predicates
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|CompoundEventPredicate (List<EventPredicate> predicates)
specifier|private
name|CompoundEventPredicate
parameter_list|(
name|List
argument_list|<
name|EventPredicate
argument_list|>
name|predicates
parameter_list|)
block|{
name|this
operator|.
name|predicates
operator|.
name|addAll
argument_list|(
name|predicates
argument_list|)
expr_stmt|;
block|}
DECL|method|isAbstract ()
specifier|public
name|boolean
name|isAbstract
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
DECL|method|matches ()
specifier|public
name|boolean
name|matches
parameter_list|()
block|{
for|for
control|(
name|EventPredicate
name|predicate
range|:
name|predicates
control|)
block|{
name|boolean
name|answer
init|=
name|predicate
operator|.
name|matches
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"matches() {} -> {}"
argument_list|,
name|predicate
argument_list|,
name|answer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|answer
condition|)
block|{
comment|// break at first false
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|reset ()
specifier|public
name|void
name|reset
parameter_list|()
block|{
for|for
control|(
name|EventPredicate
name|predicate
range|:
name|predicates
control|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"reset() {}"
argument_list|,
name|predicate
argument_list|)
expr_stmt|;
name|predicate
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|onExchangeCreated (Exchange exchange)
specifier|public
name|boolean
name|onExchangeCreated
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
for|for
control|(
name|EventPredicate
name|predicate
range|:
name|predicates
control|)
block|{
name|boolean
name|answer
init|=
name|predicate
operator|.
name|onExchangeCreated
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"onExchangeCreated() {} -> {}"
argument_list|,
name|predicate
argument_list|,
name|answer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|answer
condition|)
block|{
comment|// break at first false
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|onExchangeCompleted (Exchange exchange)
specifier|public
name|boolean
name|onExchangeCompleted
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
for|for
control|(
name|EventPredicate
name|predicate
range|:
name|predicates
control|)
block|{
name|boolean
name|answer
init|=
name|predicate
operator|.
name|onExchangeCompleted
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"onExchangeCompleted() {} -> {}"
argument_list|,
name|predicate
argument_list|,
name|answer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|answer
condition|)
block|{
comment|// break at first false
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|onExchangeFailed (Exchange exchange)
specifier|public
name|boolean
name|onExchangeFailed
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
for|for
control|(
name|EventPredicate
name|predicate
range|:
name|predicates
control|)
block|{
name|boolean
name|answer
init|=
name|predicate
operator|.
name|onExchangeFailed
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"onExchangeFailed() {} -> {}"
argument_list|,
name|predicate
argument_list|,
name|answer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|answer
condition|)
block|{
comment|// break at first false
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|onExchangeSent (Exchange exchange, Endpoint endpoint, long timeTaken)
specifier|public
name|boolean
name|onExchangeSent
parameter_list|(
name|Exchange
name|exchange
parameter_list|,
name|Endpoint
name|endpoint
parameter_list|,
name|long
name|timeTaken
parameter_list|)
block|{
for|for
control|(
name|EventPredicate
name|predicate
range|:
name|predicates
control|)
block|{
name|boolean
name|answer
init|=
name|predicate
operator|.
name|onExchangeSent
argument_list|(
name|exchange
argument_list|,
name|endpoint
argument_list|,
name|timeTaken
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"onExchangeSent() {} {} -> {}"
argument_list|,
name|endpoint
argument_list|,
name|predicate
argument_list|,
name|answer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|answer
condition|)
block|{
comment|// break at first false
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|EventPredicate
name|eventPredicate
range|:
name|predicates
control|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|eventPredicate
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

