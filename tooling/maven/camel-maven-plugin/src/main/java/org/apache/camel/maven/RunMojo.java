begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.maven
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|maven
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLClassLoader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|util
operator|.
name|CastUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|artifact
operator|.
name|Artifact
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|artifact
operator|.
name|factory
operator|.
name|ArtifactFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|artifact
operator|.
name|metadata
operator|.
name|ArtifactMetadataSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|artifact
operator|.
name|repository
operator|.
name|ArtifactRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|artifact
operator|.
name|resolver
operator|.
name|ArtifactResolutionResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|artifact
operator|.
name|resolver
operator|.
name|ArtifactResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|artifact
operator|.
name|resolver
operator|.
name|filter
operator|.
name|ArtifactFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|artifact
operator|.
name|resolver
operator|.
name|filter
operator|.
name|ExcludesArtifactFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|artifact
operator|.
name|versioning
operator|.
name|InvalidVersionSpecificationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|artifact
operator|.
name|versioning
operator|.
name|VersionRange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|model
operator|.
name|Dependency
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|model
operator|.
name|Exclusion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|plugin
operator|.
name|MojoExecutionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|plugin
operator|.
name|MojoFailureException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|project
operator|.
name|MavenProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|project
operator|.
name|MavenProjectBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|project
operator|.
name|artifact
operator|.
name|MavenMetadataSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|mojo
operator|.
name|exec
operator|.
name|AbstractExecMojo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|mojo
operator|.
name|exec
operator|.
name|ExecutableDependency
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|mojo
operator|.
name|exec
operator|.
name|Property
import|;
end_import

begin_comment
comment|/**  * Runs a CamelContext using any Spring or Blueprint XML configuration files found in  *<code>META-INF/spring/*.xml</code>, and<code>OSGI-INF/blueprint/*.xml</code>,  * and<code>camel-*.xml</code> and starting up the context.  *  * @goal run  * @requiresDependencyResolution runtime  * @execute phase="test-compile"  */
end_comment

begin_class
DECL|class|RunMojo
specifier|public
class|class
name|RunMojo
extends|extends
name|AbstractExecMojo
block|{
comment|// this code is based on a copy-and-paste of maven-exec-plugin
comment|//
comment|// If we could avoid the mega-cut-n-paste it would really really help!
comment|// ideally all I wanna do is auto-default 2 values!
comment|// namely the main and the command line arguments..
comment|/**      * The maven project.      *      * @parameter property="project"      * @required      * @readonly      */
DECL|field|project
specifier|protected
name|MavenProject
name|project
decl_stmt|;
comment|/**      * The duration to run the application for which by default is in      * milliseconds. A value<= 0 will run forever.      * Adding a s indicates seconds - eg "5s" means 5 seconds.      *      * @parameter property="camel.duration"      *            default-value="-1"      *      */
DECL|field|duration
specifier|protected
name|String
name|duration
decl_stmt|;
comment|/**      * The DOT output directory name used to generate the DOT diagram of the      * route definitions      *      * @parameter property="${project.build.directory}/site/cameldoc"      * @readonly      */
DECL|field|dotDir
specifier|protected
name|String
name|dotDir
decl_stmt|;
comment|/**      * Allows the DOT file generation to be enabled      *      * @parameter property="false"      */
DECL|field|useDot
specifier|protected
name|boolean
name|useDot
decl_stmt|;
comment|/**      * Whether to log the classpath when starting      *      * @parameter property="false"      */
DECL|field|logClasspath
specifier|protected
name|boolean
name|logClasspath
decl_stmt|;
comment|/**      * Whether to use Blueprint when running, instead of Spring      *      * @parameter property="camel.blueprint"      *            default-value="false"      */
DECL|field|useBlueprint
specifier|protected
name|boolean
name|useBlueprint
decl_stmt|;
comment|/**      * Whether to use CDI when running, instead of Spring      *      * @parameter property="camel.cdi"      *            default-value="false"      */
DECL|field|useCDI
specifier|protected
name|boolean
name|useCDI
decl_stmt|;
comment|/**      * @component      */
DECL|field|artifactResolver
specifier|private
name|ArtifactResolver
name|artifactResolver
decl_stmt|;
comment|/**      * @component      */
DECL|field|artifactFactory
specifier|private
name|ArtifactFactory
name|artifactFactory
decl_stmt|;
comment|/**      * @component      */
DECL|field|metadataSource
specifier|private
name|ArtifactMetadataSource
name|metadataSource
decl_stmt|;
comment|/**      * @parameter property="localRepository"      * @required      * @readonly      */
DECL|field|localRepository
specifier|private
name|ArtifactRepository
name|localRepository
decl_stmt|;
comment|/**      * @parameter property="project.remoteArtifactRepositories"      */
DECL|field|remoteRepositories
specifier|private
name|List
argument_list|<
name|?
argument_list|>
name|remoteRepositories
decl_stmt|;
comment|/**      * @component      */
DECL|field|projectBuilder
specifier|private
name|MavenProjectBuilder
name|projectBuilder
decl_stmt|;
comment|/**      * @parameter property="plugin.artifacts"      * @readonly      */
DECL|field|pluginDependencies
specifier|private
name|List
argument_list|<
name|Artifact
argument_list|>
name|pluginDependencies
decl_stmt|;
comment|/**      * Whether to enable the tracer or not      *      * @parameter property="camel.trace"      *            default-value="false"      * @required      */
DECL|field|trace
specifier|private
name|boolean
name|trace
decl_stmt|;
comment|/**      * Output all routes to the specified XML file      *      * @parameter property="camel.routesOutputFile"      */
DECL|field|routesOutputFile
specifier|private
name|String
name|routesOutputFile
decl_stmt|;
comment|/**      * The main class to execute.      *      * @parameter property="camel.mainClass"      */
DECL|field|mainClass
specifier|private
name|String
name|mainClass
decl_stmt|;
comment|/**      * The basedPackages that spring java config want to gets.      *      * @parameter property="camel.basedPackages"      */
DECL|field|basedPackages
specifier|private
name|String
name|basedPackages
decl_stmt|;
comment|/**      * The configClasses that spring java config want to gets.      *      * @parameter property="camel.configClasses"      */
DECL|field|configClasses
specifier|private
name|String
name|configClasses
decl_stmt|;
comment|/**      * The classpath based application context uri that spring want to gets.      *      * @parameter property="camel.applicationContextUri"      */
DECL|field|applicationContextUri
specifier|private
name|String
name|applicationContextUri
decl_stmt|;
comment|/**      * The filesystem based application context uri that spring want to gets.      *      * @parameter property="camel.fileApplicationContextUri"      */
DECL|field|fileApplicationContextUri
specifier|private
name|String
name|fileApplicationContextUri
decl_stmt|;
comment|/**      * The class arguments.      *      * @parameter property="camel.arguments"      */
DECL|field|arguments
specifier|private
name|String
index|[]
name|arguments
decl_stmt|;
comment|/**      * A list of system properties to be passed. Note: as the execution is not      * forked, some system properties required by the JVM cannot be passed here.      * Use MAVEN_OPTS or the exec:exec instead. See the user guide for more      * information.      *      * @parameter      */
DECL|field|systemProperties
specifier|private
name|Property
index|[]
name|systemProperties
decl_stmt|;
comment|/**      * Deprecated; this is not needed anymore. Indicates if mojo should be kept      * running after the mainclass terminates. Usefull for serverlike apps with      * deamonthreads.      *      * @parameter property="camel.keepAlive" default-value="false"      */
DECL|field|keepAlive
specifier|private
name|boolean
name|keepAlive
decl_stmt|;
comment|/**      * Indicates if the project dependencies should be used when executing the      * main class.      *      * @parameter property="camel.includeProjectDependencies"      *            default-value="true"      */
DECL|field|includeProjectDependencies
specifier|private
name|boolean
name|includeProjectDependencies
decl_stmt|;
comment|/**      * Indicates if this plugin's dependencies should be used when executing the      * main class.<p/> This is useful when project dependencies are not      * appropriate. Using only the plugin dependencies can be particularly      * useful when the project is not a java project. For example a mvn project      * using the csharp plugins only expects to see dotnet libraries as      * dependencies.      *      * @parameter property="camel.includePluginDependencies"      *            default-value="false"      */
DECL|field|includePluginDependencies
specifier|private
name|boolean
name|includePluginDependencies
decl_stmt|;
comment|/**      * If provided the ExecutableDependency identifies which of the plugin      * dependencies contains the executable class. This will have the affect of      * only including plugin dependencies required by the identified      * ExecutableDependency.<p/> If includeProjectDependencies is set to      *<code>true</code>, all of the project dependencies will be included on      * the executable's classpath. Whether a particular project dependency is a      * dependency of the identified ExecutableDependency will be irrelevant to      * its inclusion in the classpath.      *      * @parameter      * @optional      */
DECL|field|executableDependency
specifier|private
name|ExecutableDependency
name|executableDependency
decl_stmt|;
comment|/**      * Wether to interrupt/join and possibly stop the daemon threads upon      * quitting.<br/> If this is<code>false</code>, maven does nothing      * about the daemon threads. When maven has no more work to do, the VM will      * normally terminate any remaining daemon threads.      *<p>      * In certain cases (in particular if maven is embedded), you might need to      * keep this enabled to make sure threads are properly cleaned up to ensure      * they don't interfere with subsequent activity. In that case, see      * {@link #daemonThreadJoinTimeout} and      * {@link #stopUnresponsiveDaemonThreads} for further tuning.      *</p>      *      * @parameter property="camel.cleanupDaemonThreads" default-value="true"      */
DECL|field|cleanupDaemonThreads
specifier|private
name|boolean
name|cleanupDaemonThreads
decl_stmt|;
comment|/**      * This defines the number of milliseconds to wait for daemon threads to      * quit following their interruption.<br/> This is only taken into account      * if {@link #cleanupDaemonThreads} is<code>true</code>. A value&lt;=0      * means to not timeout (i.e. wait indefinitely for threads to finish).      * Following a timeout, a warning will be logged.      *<p>      * Note: properly coded threads<i>should</i> terminate upon interruption      * but some threads may prove problematic: as the VM does interrupt daemon      * threads, some code may not have been written to handle interruption      * properly. For example java.util.Timer is known to not handle      * interruptions in JDK&lt;= 1.6. So it is not possible for us to      * infinitely wait by default otherwise maven could hang. A sensible default      * value has been chosen, but this default value<i>may change</i> in the      * future based on user feedback.      *</p>      *      * @parameter property="camel.daemonThreadJoinTimeout"      *            default-value="15000"      */
DECL|field|daemonThreadJoinTimeout
specifier|private
name|long
name|daemonThreadJoinTimeout
decl_stmt|;
comment|/**      * Wether to call {@link Thread#stop()} following a timing out of waiting      * for an interrupted thread to finish. This is only taken into account if      * {@link #cleanupDaemonThreads} is<code>true</code> and the      * {@link #daemonThreadJoinTimeout} threshold has been reached for an      * uncooperative thread. If this is<code>false</code>, or if      * {@link Thread#stop()} fails to get the thread to stop, then a warning is      * logged and Maven will continue on while the affected threads (and related      * objects in memory) linger on. Consider setting this to<code>true</code>      * if you are invoking problematic code that you can't fix. An example is      * {@link java.util.Timer} which doesn't respond to interruption. To have      *<code>Timer</code> fixed, vote for<a      * href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6336543">this      * bug</a>.      *      * @parameter property="camel.stopUnresponsiveDaemonThreads"      *            default-value="false"      */
DECL|field|stopUnresponsiveDaemonThreads
specifier|private
name|boolean
name|stopUnresponsiveDaemonThreads
decl_stmt|;
comment|/**      * Deprecated this is not needed anymore.      *      * @parameter property="camel.killAfter" default-value="-1"      */
DECL|field|killAfter
specifier|private
name|long
name|killAfter
decl_stmt|;
DECL|field|originalSystemProperties
specifier|private
name|Properties
name|originalSystemProperties
decl_stmt|;
comment|/**      * Execute goal.      *      * @throws MojoExecutionException execution of the main class or one of the      *                 threads it generated failed.      * @throws MojoFailureException something bad happened...      */
DECL|method|execute ()
specifier|public
name|void
name|execute
parameter_list|()
throws|throws
name|MojoExecutionException
throws|,
name|MojoFailureException
block|{
name|boolean
name|usingSpringJavaConfigureMain
init|=
literal|false
decl_stmt|;
name|boolean
name|useCdiMain
init|=
name|useCDI
decl_stmt|;
name|boolean
name|usingBlueprintMain
init|=
name|useBlueprint
decl_stmt|;
if|if
condition|(
name|killAfter
operator|!=
operator|-
literal|1
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
literal|"Warning: killAfter is now deprecated. Do you need it ? Please comment on MEXEC-6."
argument_list|)
expr_stmt|;
block|}
comment|// lets create the command line arguments to pass in...
name|List
argument_list|<
name|String
argument_list|>
name|args
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|dotDir
operator|!=
literal|null
operator|&&
name|useDot
condition|)
block|{
name|args
operator|.
name|add
argument_list|(
literal|"-o"
argument_list|)
expr_stmt|;
name|args
operator|.
name|add
argument_list|(
name|dotDir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trace
condition|)
block|{
name|args
operator|.
name|add
argument_list|(
literal|"-t"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|routesOutputFile
operator|!=
literal|null
condition|)
block|{
name|args
operator|.
name|add
argument_list|(
literal|"-output"
argument_list|)
expr_stmt|;
name|args
operator|.
name|add
argument_list|(
name|routesOutputFile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|applicationContextUri
operator|!=
literal|null
condition|)
block|{
name|args
operator|.
name|add
argument_list|(
literal|"-ac"
argument_list|)
expr_stmt|;
name|args
operator|.
name|add
argument_list|(
name|applicationContextUri
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fileApplicationContextUri
operator|!=
literal|null
condition|)
block|{
name|args
operator|.
name|add
argument_list|(
literal|"-fa"
argument_list|)
expr_stmt|;
name|args
operator|.
name|add
argument_list|(
name|fileApplicationContextUri
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|configClasses
operator|!=
literal|null
condition|)
block|{
name|args
operator|.
name|add
argument_list|(
literal|"-cc"
argument_list|)
expr_stmt|;
name|args
operator|.
name|add
argument_list|(
name|configClasses
argument_list|)
expr_stmt|;
name|usingSpringJavaConfigureMain
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|basedPackages
operator|!=
literal|null
condition|)
block|{
name|args
operator|.
name|add
argument_list|(
literal|"-bp"
argument_list|)
expr_stmt|;
name|args
operator|.
name|add
argument_list|(
name|basedPackages
argument_list|)
expr_stmt|;
name|usingSpringJavaConfigureMain
operator|=
literal|true
expr_stmt|;
block|}
name|args
operator|.
name|add
argument_list|(
literal|"-d"
argument_list|)
expr_stmt|;
name|args
operator|.
name|add
argument_list|(
name|duration
argument_list|)
expr_stmt|;
if|if
condition|(
name|arguments
operator|!=
literal|null
condition|)
block|{
name|args
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|arguments
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|arguments
operator|=
operator|new
name|String
index|[
name|args
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|args
operator|.
name|toArray
argument_list|(
name|arguments
argument_list|)
expr_stmt|;
if|if
condition|(
name|usingSpringJavaConfigureMain
condition|)
block|{
name|mainClass
operator|=
literal|"org.apache.camel.spring.javaconfig.Main"
expr_stmt|;
name|getLog
argument_list|()
operator|.
name|info
argument_list|(
literal|"Using org.apache.camel.spring.javaconfig.Main to initiate a CamelContext"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|useCdiMain
condition|)
block|{
name|mainClass
operator|=
literal|"org.apache.camel.cdi.Main"
expr_stmt|;
comment|// must include plugin dependencies for blueprint
name|includePluginDependencies
operator|=
literal|true
expr_stmt|;
name|getLog
argument_list|()
operator|.
name|info
argument_list|(
literal|"Using "
operator|+
name|mainClass
operator|+
literal|" to initiate a CamelContext"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|usingBlueprintMain
condition|)
block|{
name|mainClass
operator|=
literal|"org.apache.camel.test.blueprint.Main"
expr_stmt|;
comment|// must include plugin dependencies for blueprint
name|includePluginDependencies
operator|=
literal|true
expr_stmt|;
name|getLog
argument_list|()
operator|.
name|info
argument_list|(
literal|"Using org.apache.camel.test.blueprint.Main to initiate a CamelContext"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mainClass
operator|!=
literal|null
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|info
argument_list|(
literal|"Using custom "
operator|+
name|mainClass
operator|+
literal|" to initiate a CamelContext"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// use spring by default
name|getLog
argument_list|()
operator|.
name|info
argument_list|(
literal|"Using org.apache.camel.spring.Main to initiate a CamelContext"
argument_list|)
expr_stmt|;
name|mainClass
operator|=
literal|"org.apache.camel.spring.Main"
expr_stmt|;
block|}
if|if
condition|(
name|getLog
argument_list|()
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|StringBuilder
name|msg
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"Invoking: "
argument_list|)
decl_stmt|;
name|msg
operator|.
name|append
argument_list|(
name|mainClass
argument_list|)
expr_stmt|;
name|msg
operator|.
name|append
argument_list|(
literal|".main("
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arguments
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|msg
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|msg
operator|.
name|append
argument_list|(
name|arguments
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|msg
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
name|IsolatedThreadGroup
name|threadGroup
init|=
operator|new
name|IsolatedThreadGroup
argument_list|(
name|mainClass
comment|/* name */
argument_list|)
decl_stmt|;
name|Thread
name|bootstrapThread
init|=
operator|new
name|Thread
argument_list|(
name|threadGroup
argument_list|,
operator|new
name|Runnable
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|Method
name|main
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getContextClassLoader
argument_list|()
operator|.
name|loadClass
argument_list|(
name|mainClass
argument_list|)
operator|.
name|getMethod
argument_list|(
literal|"main"
argument_list|,
operator|new
name|Class
index|[]
block|{
name|String
index|[]
operator|.
expr|class
block|}
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|main
operator|.
name|isAccessible
argument_list|()
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
literal|"Setting accessibility to true in order to invoke main()."
argument_list|)
expr_stmt|;
name|main
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|main
operator|.
name|invoke
argument_list|(
name|main
argument_list|,
operator|new
name|Object
index|[]
block|{
name|arguments
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// just pass it on
comment|// let it be printed so end users can see the exception on the console
name|getLog
argument_list|()
operator|.
name|error
argument_list|(
literal|"*************************************"
argument_list|)
expr_stmt|;
name|getLog
argument_list|()
operator|.
name|error
argument_list|(
literal|"Error occurred while running main from: "
operator|+
name|mainClass
argument_list|)
expr_stmt|;
name|getLog
argument_list|()
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|getLog
argument_list|()
operator|.
name|error
argument_list|(
literal|"*************************************"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getThreadGroup
argument_list|()
operator|.
name|uncaughtException
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|,
name|mainClass
operator|+
literal|".main()"
argument_list|)
decl_stmt|;
name|bootstrapThread
operator|.
name|setContextClassLoader
argument_list|(
name|getClassLoader
argument_list|()
argument_list|)
expr_stmt|;
name|setSystemProperties
argument_list|()
expr_stmt|;
name|bootstrapThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|joinNonDaemonThreads
argument_list|(
name|threadGroup
argument_list|)
expr_stmt|;
comment|// It's plausible that spontaneously a non-daemon thread might be
comment|// created as we try and shut down,
comment|// but it's too late since the termination condition (only daemon
comment|// threads) has been triggered.
if|if
condition|(
name|keepAlive
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
literal|"Warning: keepAlive is now deprecated and obsolete. Do you need it? Please comment on MEXEC-6."
argument_list|)
expr_stmt|;
name|waitFor
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cleanupDaemonThreads
condition|)
block|{
name|terminateThreads
argument_list|(
name|threadGroup
argument_list|)
expr_stmt|;
try|try
block|{
name|threadGroup
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalThreadStateException
name|e
parameter_list|)
block|{
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
literal|"Couldn't destroy threadgroup "
operator|+
name|threadGroup
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|originalSystemProperties
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|setProperties
argument_list|(
name|originalSystemProperties
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|threadGroup
init|)
block|{
if|if
condition|(
name|threadGroup
operator|.
name|uncaughtException
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|MojoExecutionException
argument_list|(
literal|null
argument_list|,
name|threadGroup
operator|.
name|uncaughtException
argument_list|)
throw|;
block|}
block|}
name|registerSourceRoots
argument_list|()
expr_stmt|;
block|}
DECL|class|IsolatedThreadGroup
class|class
name|IsolatedThreadGroup
extends|extends
name|ThreadGroup
block|{
DECL|field|uncaughtException
name|Throwable
name|uncaughtException
decl_stmt|;
comment|// synchronize access to this
DECL|method|IsolatedThreadGroup (String name)
specifier|public
name|IsolatedThreadGroup
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
DECL|method|uncaughtException (Thread thread, Throwable throwable)
specifier|public
name|void
name|uncaughtException
parameter_list|(
name|Thread
name|thread
parameter_list|,
name|Throwable
name|throwable
parameter_list|)
block|{
if|if
condition|(
name|throwable
operator|instanceof
name|ThreadDeath
condition|)
block|{
return|return;
comment|// harmless
block|}
name|boolean
name|doLog
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// only remember the first one
if|if
condition|(
name|uncaughtException
operator|==
literal|null
condition|)
block|{
name|uncaughtException
operator|=
name|throwable
expr_stmt|;
comment|// will be reported
comment|// eventually
block|}
else|else
block|{
name|doLog
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|doLog
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
literal|"an additional exception was thrown"
argument_list|,
name|throwable
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|joinNonDaemonThreads (ThreadGroup threadGroup)
specifier|private
name|void
name|joinNonDaemonThreads
parameter_list|(
name|ThreadGroup
name|threadGroup
parameter_list|)
block|{
name|boolean
name|foundNonDaemon
decl_stmt|;
do|do
block|{
name|foundNonDaemon
operator|=
literal|false
expr_stmt|;
name|Collection
argument_list|<
name|Thread
argument_list|>
name|threads
init|=
name|getActiveThreads
argument_list|(
name|threadGroup
argument_list|)
decl_stmt|;
for|for
control|(
name|Thread
name|thread
range|:
name|threads
control|)
block|{
if|if
condition|(
name|thread
operator|.
name|isDaemon
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|foundNonDaemon
operator|=
literal|true
expr_stmt|;
comment|// try again; maybe more threads were
comment|// created while we were busy
name|joinThread
argument_list|(
name|thread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|foundNonDaemon
condition|)
do|;
block|}
DECL|method|joinThread (Thread thread, long timeoutMsecs)
specifier|private
name|void
name|joinThread
parameter_list|(
name|Thread
name|thread
parameter_list|,
name|long
name|timeoutMsecs
parameter_list|)
block|{
try|try
block|{
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
literal|"joining on thread "
operator|+
name|thread
argument_list|)
expr_stmt|;
name|thread
operator|.
name|join
argument_list|(
name|timeoutMsecs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
comment|// good practice if don't throw
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
literal|"interrupted while joining against thread "
operator|+
name|thread
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// not
comment|// expected!
block|}
comment|// generally abnormal
if|if
condition|(
name|thread
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
literal|"thread "
operator|+
name|thread
operator|+
literal|" was interrupted but is still alive after waiting at least "
operator|+
name|timeoutMsecs
operator|+
literal|"msecs"
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
DECL|method|terminateThreads (ThreadGroup threadGroup)
specifier|private
name|void
name|terminateThreads
parameter_list|(
name|ThreadGroup
name|threadGroup
parameter_list|)
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Thread
argument_list|>
name|uncooperativeThreads
init|=
operator|new
name|HashSet
argument_list|<
name|Thread
argument_list|>
argument_list|()
decl_stmt|;
comment|// these were not responsive
comment|// to interruption
for|for
control|(
name|Collection
argument_list|<
name|Thread
argument_list|>
name|threads
init|=
name|getActiveThreads
argument_list|(
name|threadGroup
argument_list|)
init|;
operator|!
name|threads
operator|.
name|isEmpty
argument_list|()
condition|;
name|threads
operator|=
name|getActiveThreads
argument_list|(
name|threadGroup
argument_list|)
operator|,
name|threads
operator|.
name|removeAll
argument_list|(
name|uncooperativeThreads
argument_list|)
control|)
block|{
comment|// Interrupt all threads we know about as of this instant (harmless
comment|// if spuriously went dead (! isAlive())
comment|// or if something else interrupted it ( isInterrupted() ).
for|for
control|(
name|Thread
name|thread
range|:
name|threads
control|)
block|{
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
literal|"interrupting thread "
operator|+
name|thread
argument_list|)
expr_stmt|;
name|thread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
comment|// Now join with a timeout and call stop() (assuming flags are set
comment|// right)
for|for
control|(
name|Thread
name|thread
range|:
name|threads
control|)
block|{
if|if
condition|(
operator|!
name|thread
operator|.
name|isAlive
argument_list|()
condition|)
block|{
continue|continue;
comment|// and, presumably it won't show up in
comment|// getActiveThreads() next iteration
block|}
if|if
condition|(
name|daemonThreadJoinTimeout
operator|<=
literal|0
condition|)
block|{
name|joinThread
argument_list|(
name|thread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// waits until not alive; no timeout
continue|continue;
block|}
name|long
name|timeout
init|=
name|daemonThreadJoinTimeout
operator|-
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|)
decl_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
name|joinThread
argument_list|(
name|thread
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|thread
operator|.
name|isAlive
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|uncooperativeThreads
operator|.
name|add
argument_list|(
name|thread
argument_list|)
expr_stmt|;
comment|// ensure we don't process
comment|// again
if|if
condition|(
name|stopUnresponsiveDaemonThreads
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
literal|"thread "
operator|+
name|thread
operator|+
literal|" will be Thread.stop()'ed"
argument_list|)
expr_stmt|;
name|thread
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
literal|"thread "
operator|+
name|thread
operator|+
literal|" will linger despite being asked to die via interruption"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|uncooperativeThreads
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
literal|"NOTE: "
operator|+
name|uncooperativeThreads
operator|.
name|size
argument_list|()
operator|+
literal|" thread(s) did not finish despite being asked to "
operator|+
literal|" via interruption. This is not a problem with exec:java, it is a problem with the running code."
operator|+
literal|" Although not serious, it should be remedied."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|activeCount
init|=
name|threadGroup
operator|.
name|activeCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|activeCount
operator|!=
literal|0
condition|)
block|{
comment|// TODO this may be nothing; continue on anyway; perhaps don't
comment|// even log in future
name|Thread
index|[]
name|threadsArray
init|=
operator|new
name|Thread
index|[
literal|1
index|]
decl_stmt|;
name|threadGroup
operator|.
name|enumerate
argument_list|(
name|threadsArray
argument_list|)
expr_stmt|;
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
literal|"strange; "
operator|+
name|activeCount
operator|+
literal|" thread(s) still active in the group "
operator|+
name|threadGroup
operator|+
literal|" such as "
operator|+
name|threadsArray
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getActiveThreads (ThreadGroup threadGroup)
specifier|private
name|Collection
argument_list|<
name|Thread
argument_list|>
name|getActiveThreads
parameter_list|(
name|ThreadGroup
name|threadGroup
parameter_list|)
block|{
name|Thread
index|[]
name|threads
init|=
operator|new
name|Thread
index|[
name|threadGroup
operator|.
name|activeCount
argument_list|()
index|]
decl_stmt|;
name|int
name|numThreads
init|=
name|threadGroup
operator|.
name|enumerate
argument_list|(
name|threads
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|Thread
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|Thread
argument_list|>
argument_list|(
name|numThreads
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threads
operator|.
name|length
operator|&&
name|threads
index|[
name|i
index|]
operator|!=
literal|null
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|threads
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|// note: result should be modifiable
return|return
name|result
return|;
block|}
comment|/**      * Pass any given system properties to the java system properties.      */
DECL|method|setSystemProperties ()
specifier|private
name|void
name|setSystemProperties
parameter_list|()
block|{
if|if
condition|(
name|systemProperties
operator|!=
literal|null
condition|)
block|{
name|originalSystemProperties
operator|=
name|System
operator|.
name|getProperties
argument_list|()
expr_stmt|;
for|for
control|(
name|Property
name|systemProperty
range|:
name|systemProperties
control|)
block|{
name|String
name|value
init|=
name|systemProperty
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
name|systemProperty
operator|.
name|getKey
argument_list|()
argument_list|,
name|value
operator|==
literal|null
condition|?
literal|""
else|:
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Set up a classloader for the execution of the main class.      *      * @return the classloader      * @throws MojoExecutionException      */
DECL|method|getClassLoader ()
specifier|private
name|ClassLoader
name|getClassLoader
parameter_list|()
throws|throws
name|MojoExecutionException
block|{
name|List
argument_list|<
name|URL
argument_list|>
name|classpathURLs
init|=
operator|new
name|ArrayList
argument_list|<
name|URL
argument_list|>
argument_list|()
decl_stmt|;
comment|// project classpath must be first
name|this
operator|.
name|addRelevantProjectDependenciesToClasspath
argument_list|(
name|classpathURLs
argument_list|)
expr_stmt|;
comment|// and plugin classpath last
name|this
operator|.
name|addRelevantPluginDependenciesToClasspath
argument_list|(
name|classpathURLs
argument_list|)
expr_stmt|;
if|if
condition|(
name|logClasspath
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|info
argument_list|(
literal|"Classpath = "
operator|+
name|classpathURLs
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|URLClassLoader
argument_list|(
name|classpathURLs
operator|.
name|toArray
argument_list|(
operator|new
name|URL
index|[
name|classpathURLs
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Add any relevant project dependencies to the classpath. Indirectly takes      * includePluginDependencies and ExecutableDependency into consideration.      *      * @param path classpath of {@link java.net.URL} objects      * @throws MojoExecutionException      */
DECL|method|addRelevantPluginDependenciesToClasspath (List<URL> path)
specifier|private
name|void
name|addRelevantPluginDependenciesToClasspath
parameter_list|(
name|List
argument_list|<
name|URL
argument_list|>
name|path
parameter_list|)
throws|throws
name|MojoExecutionException
block|{
if|if
condition|(
name|hasCommandlineArgs
argument_list|()
condition|)
block|{
name|arguments
operator|=
name|parseCommandlineArgs
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|Iterator
argument_list|<
name|Artifact
argument_list|>
name|iter
init|=
name|this
operator|.
name|determineRelevantPluginDependencies
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Artifact
name|classPathElement
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// we must skip org.osgi.core, otherwise we get a
comment|// java.lang.NoClassDefFoundError: org.osgi.vendor.framework property not set
if|if
condition|(
name|classPathElement
operator|.
name|getArtifactId
argument_list|()
operator|.
name|equals
argument_list|(
literal|"org.osgi.core"
argument_list|)
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
literal|"Skipping org.osgi.core -> "
operator|+
name|classPathElement
operator|.
name|getGroupId
argument_list|()
operator|+
literal|"/"
operator|+
name|classPathElement
operator|.
name|getArtifactId
argument_list|()
operator|+
literal|"/"
operator|+
name|classPathElement
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
literal|"Adding plugin dependency artifact: "
operator|+
name|classPathElement
operator|.
name|getArtifactId
argument_list|()
operator|+
literal|" to classpath"
argument_list|)
expr_stmt|;
name|path
operator|.
name|add
argument_list|(
name|classPathElement
operator|.
name|getFile
argument_list|()
operator|.
name|toURI
argument_list|()
operator|.
name|toURL
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|MojoExecutionException
argument_list|(
literal|"Error during setting up classpath"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Add any relevant project dependencies to the classpath. Takes      * includeProjectDependencies into consideration.      *      * @param path classpath of {@link java.net.URL} objects      * @throws MojoExecutionException      */
DECL|method|addRelevantProjectDependenciesToClasspath (List<URL> path)
specifier|private
name|void
name|addRelevantProjectDependenciesToClasspath
parameter_list|(
name|List
argument_list|<
name|URL
argument_list|>
name|path
parameter_list|)
throws|throws
name|MojoExecutionException
block|{
if|if
condition|(
name|this
operator|.
name|includeProjectDependencies
condition|)
block|{
try|try
block|{
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
literal|"Project Dependencies will be included."
argument_list|)
expr_stmt|;
name|URL
name|mainClasses
init|=
operator|new
name|File
argument_list|(
name|project
operator|.
name|getBuild
argument_list|()
operator|.
name|getOutputDirectory
argument_list|()
argument_list|)
operator|.
name|toURI
argument_list|()
operator|.
name|toURL
argument_list|()
decl_stmt|;
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
literal|"Adding to classpath : "
operator|+
name|mainClasses
argument_list|)
expr_stmt|;
name|path
operator|.
name|add
argument_list|(
name|mainClasses
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Artifact
argument_list|>
name|dependencies
init|=
name|CastUtils
operator|.
name|cast
argument_list|(
name|project
operator|.
name|getArtifacts
argument_list|()
argument_list|)
decl_stmt|;
comment|// system scope dependencies are not returned by maven 2.0. See
comment|// MEXEC-17
name|dependencies
operator|.
name|addAll
argument_list|(
name|getAllNonTestScopedDependencies
argument_list|()
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Artifact
argument_list|>
name|iter
init|=
name|dependencies
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Artifact
name|classPathElement
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
literal|"Adding project dependency artifact: "
operator|+
name|classPathElement
operator|.
name|getArtifactId
argument_list|()
operator|+
literal|" to classpath"
argument_list|)
expr_stmt|;
name|File
name|file
init|=
name|classPathElement
operator|.
name|getFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|file
operator|!=
literal|null
condition|)
block|{
name|path
operator|.
name|add
argument_list|(
name|file
operator|.
name|toURI
argument_list|()
operator|.
name|toURL
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|MojoExecutionException
argument_list|(
literal|"Error during setting up classpath"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
literal|"Project Dependencies will be excluded."
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getAllNonTestScopedDependencies ()
specifier|private
name|Collection
argument_list|<
name|Artifact
argument_list|>
name|getAllNonTestScopedDependencies
parameter_list|()
throws|throws
name|MojoExecutionException
block|{
name|List
argument_list|<
name|Artifact
argument_list|>
name|answer
init|=
operator|new
name|ArrayList
argument_list|<
name|Artifact
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Artifact
name|artifact
range|:
name|getAllDependencies
argument_list|()
control|)
block|{
comment|// do not add test artifacts
if|if
condition|(
operator|!
name|artifact
operator|.
name|getScope
argument_list|()
operator|.
name|equals
argument_list|(
name|Artifact
operator|.
name|SCOPE_TEST
argument_list|)
condition|)
block|{
name|answer
operator|.
name|add
argument_list|(
name|artifact
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
comment|// generic method to retrieve all the transitive dependencies
DECL|method|getAllDependencies ()
specifier|private
name|Collection
argument_list|<
name|Artifact
argument_list|>
name|getAllDependencies
parameter_list|()
throws|throws
name|MojoExecutionException
block|{
name|List
argument_list|<
name|Artifact
argument_list|>
name|artifacts
init|=
operator|new
name|ArrayList
argument_list|<
name|Artifact
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|dependencies
init|=
name|project
operator|.
name|getDependencies
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|dependencies
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Dependency
name|dependency
init|=
operator|(
name|Dependency
operator|)
name|dependencies
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|groupId
init|=
name|dependency
operator|.
name|getGroupId
argument_list|()
decl_stmt|;
name|String
name|artifactId
init|=
name|dependency
operator|.
name|getArtifactId
argument_list|()
decl_stmt|;
name|VersionRange
name|versionRange
decl_stmt|;
try|try
block|{
name|versionRange
operator|=
name|VersionRange
operator|.
name|createFromVersionSpec
argument_list|(
name|dependency
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidVersionSpecificationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|MojoExecutionException
argument_list|(
literal|"unable to parse version"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|String
name|type
init|=
name|dependency
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
name|type
operator|=
literal|"jar"
expr_stmt|;
block|}
name|String
name|classifier
init|=
name|dependency
operator|.
name|getClassifier
argument_list|()
decl_stmt|;
name|boolean
name|optional
init|=
name|dependency
operator|.
name|isOptional
argument_list|()
decl_stmt|;
name|String
name|scope
init|=
name|dependency
operator|.
name|getScope
argument_list|()
decl_stmt|;
if|if
condition|(
name|scope
operator|==
literal|null
condition|)
block|{
name|scope
operator|=
name|Artifact
operator|.
name|SCOPE_COMPILE
expr_stmt|;
block|}
name|Artifact
name|art
init|=
name|this
operator|.
name|artifactFactory
operator|.
name|createDependencyArtifact
argument_list|(
name|groupId
argument_list|,
name|artifactId
argument_list|,
name|versionRange
argument_list|,
name|type
argument_list|,
name|classifier
argument_list|,
name|scope
argument_list|,
literal|null
argument_list|,
name|optional
argument_list|)
decl_stmt|;
if|if
condition|(
name|scope
operator|.
name|equalsIgnoreCase
argument_list|(
name|Artifact
operator|.
name|SCOPE_SYSTEM
argument_list|)
condition|)
block|{
name|art
operator|.
name|setFile
argument_list|(
operator|new
name|File
argument_list|(
name|dependency
operator|.
name|getSystemPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|exclusions
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|j
init|=
name|dependency
operator|.
name|getExclusions
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Exclusion
name|e
init|=
operator|(
name|Exclusion
operator|)
name|j
operator|.
name|next
argument_list|()
decl_stmt|;
name|exclusions
operator|.
name|add
argument_list|(
name|e
operator|.
name|getGroupId
argument_list|()
operator|+
literal|":"
operator|+
name|e
operator|.
name|getArtifactId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ArtifactFilter
name|newFilter
init|=
operator|new
name|ExcludesArtifactFilter
argument_list|(
name|exclusions
argument_list|)
decl_stmt|;
name|art
operator|.
name|setDependencyFilter
argument_list|(
name|newFilter
argument_list|)
expr_stmt|;
name|artifacts
operator|.
name|add
argument_list|(
name|art
argument_list|)
expr_stmt|;
block|}
return|return
name|artifacts
return|;
block|}
comment|/**      * Determine all plugin dependencies relevant to the executable. Takes      * includePlugins, and the executableDependency into consideration.      *      * @return a set of Artifact objects. (Empty set is returned if there are no      *         relevant plugin dependencies.)      * @throws MojoExecutionException      */
DECL|method|determineRelevantPluginDependencies ()
specifier|private
name|Set
argument_list|<
name|Artifact
argument_list|>
name|determineRelevantPluginDependencies
parameter_list|()
throws|throws
name|MojoExecutionException
block|{
name|Set
argument_list|<
name|Artifact
argument_list|>
name|relevantDependencies
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|includePluginDependencies
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|executableDependency
operator|==
literal|null
condition|)
block|{
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
literal|"All Plugin Dependencies will be included."
argument_list|)
expr_stmt|;
name|relevantDependencies
operator|=
operator|new
name|HashSet
argument_list|<
name|Artifact
argument_list|>
argument_list|(
name|this
operator|.
name|pluginDependencies
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
literal|"Selected plugin Dependencies will be included."
argument_list|)
expr_stmt|;
name|Artifact
name|executableArtifact
init|=
name|this
operator|.
name|findExecutableArtifact
argument_list|()
decl_stmt|;
name|Artifact
name|executablePomArtifact
init|=
name|this
operator|.
name|getExecutablePomArtifact
argument_list|(
name|executableArtifact
argument_list|)
decl_stmt|;
name|relevantDependencies
operator|=
name|this
operator|.
name|resolveExecutableDependencies
argument_list|(
name|executablePomArtifact
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|relevantDependencies
operator|=
name|Collections
operator|.
name|emptySet
argument_list|()
expr_stmt|;
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
literal|"Plugin Dependencies will be excluded."
argument_list|)
expr_stmt|;
block|}
return|return
name|relevantDependencies
return|;
block|}
comment|/**      * Get the artifact which refers to the POM of the executable artifact.      *      * @param executableArtifact this artifact refers to the actual assembly.      * @return an artifact which refers to the POM of the executable artifact.      */
DECL|method|getExecutablePomArtifact (Artifact executableArtifact)
specifier|private
name|Artifact
name|getExecutablePomArtifact
parameter_list|(
name|Artifact
name|executableArtifact
parameter_list|)
block|{
return|return
name|this
operator|.
name|artifactFactory
operator|.
name|createBuildArtifact
argument_list|(
name|executableArtifact
operator|.
name|getGroupId
argument_list|()
argument_list|,
name|executableArtifact
operator|.
name|getArtifactId
argument_list|()
argument_list|,
name|executableArtifact
operator|.
name|getVersion
argument_list|()
argument_list|,
literal|"pom"
argument_list|)
return|;
block|}
comment|/**      * Examine the plugin dependencies to find the executable artifact.      *      * @return an artifact which refers to the actual executable tool (not a POM)      * @throws MojoExecutionException      */
DECL|method|findExecutableArtifact ()
specifier|private
name|Artifact
name|findExecutableArtifact
parameter_list|()
throws|throws
name|MojoExecutionException
block|{
comment|// ILimitedArtifactIdentifier execToolAssembly =
comment|// this.getExecutableToolAssembly();
name|Artifact
name|executableTool
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Artifact
name|pluginDep
range|:
name|this
operator|.
name|pluginDependencies
control|)
block|{
if|if
condition|(
name|this
operator|.
name|executableDependency
operator|.
name|matches
argument_list|(
name|pluginDep
argument_list|)
condition|)
block|{
name|executableTool
operator|=
name|pluginDep
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|executableTool
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|MojoExecutionException
argument_list|(
literal|"No dependency of the plugin matches the specified executableDependency."
operator|+
literal|"  Specified executableToolAssembly is: "
operator|+
name|executableDependency
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|executableTool
return|;
block|}
DECL|method|resolveExecutableDependencies (Artifact executablePomArtifact)
specifier|private
name|Set
argument_list|<
name|Artifact
argument_list|>
name|resolveExecutableDependencies
parameter_list|(
name|Artifact
name|executablePomArtifact
parameter_list|)
throws|throws
name|MojoExecutionException
block|{
name|Set
argument_list|<
name|Artifact
argument_list|>
name|executableDependencies
decl_stmt|;
try|try
block|{
name|MavenProject
name|executableProject
init|=
name|this
operator|.
name|projectBuilder
operator|.
name|buildFromRepository
argument_list|(
name|executablePomArtifact
argument_list|,
name|this
operator|.
name|remoteRepositories
argument_list|,
name|this
operator|.
name|localRepository
argument_list|)
decl_stmt|;
comment|// get all of the dependencies for the executable project
name|List
argument_list|<
name|Artifact
argument_list|>
name|dependencies
init|=
name|CastUtils
operator|.
name|cast
argument_list|(
name|executableProject
operator|.
name|getDependencies
argument_list|()
argument_list|)
decl_stmt|;
comment|// make Artifacts of all the dependencies
name|Set
argument_list|<
name|Artifact
argument_list|>
name|dependencyArtifacts
init|=
name|CastUtils
operator|.
name|cast
argument_list|(
name|MavenMetadataSource
operator|.
name|createArtifacts
argument_list|(
name|this
operator|.
name|artifactFactory
argument_list|,
name|dependencies
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
comment|// not forgetting the Artifact of the project itself
name|dependencyArtifacts
operator|.
name|add
argument_list|(
name|executableProject
operator|.
name|getArtifact
argument_list|()
argument_list|)
expr_stmt|;
comment|// resolve all dependencies transitively to obtain a comprehensive
comment|// list of assemblies
name|ArtifactResolutionResult
name|result
init|=
name|artifactResolver
operator|.
name|resolveTransitively
argument_list|(
name|dependencyArtifacts
argument_list|,
name|executablePomArtifact
argument_list|,
name|Collections
operator|.
name|EMPTY_MAP
argument_list|,
name|this
operator|.
name|localRepository
argument_list|,
name|this
operator|.
name|remoteRepositories
argument_list|,
name|metadataSource
argument_list|,
literal|null
argument_list|,
name|Collections
operator|.
name|EMPTY_LIST
argument_list|)
decl_stmt|;
name|executableDependencies
operator|=
name|CastUtils
operator|.
name|cast
argument_list|(
name|result
operator|.
name|getArtifacts
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|MojoExecutionException
argument_list|(
literal|"Encountered problems resolving dependencies of the executable "
operator|+
literal|"in preparation for its execution."
argument_list|,
name|ex
argument_list|)
throw|;
block|}
return|return
name|executableDependencies
return|;
block|}
comment|/**      * Stop program execution for nn millis.      *      * @param millis the number of millis-seconds to wait for,<code>0</code>      *                stops program forever.      */
DECL|method|waitFor (long millis)
specifier|private
name|void
name|waitFor
parameter_list|(
name|long
name|millis
parameter_list|)
block|{
name|Object
name|lock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|lock
init|)
block|{
try|try
block|{
name|lock
operator|.
name|wait
argument_list|(
name|millis
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
comment|// good practice if don't throw
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
literal|"Spuriously interrupted while waiting for "
operator|+
name|millis
operator|+
literal|"ms"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

