begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.camel.support.component
package|package
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|support
operator|.
name|component
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|camel
operator|.
name|RuntimeCamelException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Helper class for working with {@link ApiMethod}.  */
end_comment

begin_class
DECL|class|ApiMethodHelper
specifier|public
specifier|final
class|class
name|ApiMethodHelper
parameter_list|<
name|T
extends|extends
name|Enum
parameter_list|<
name|T
parameter_list|>
operator|&
name|ApiMethod
parameter_list|>
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ApiMethodHelper
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// maps method name to ApiMethod
DECL|field|methodMap
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|methodMap
decl_stmt|;
comment|// maps method name to method arguments of the form Class type1, String name1, Class type2, String name2,...
DECL|field|argumentsMap
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
name|argumentsMap
decl_stmt|;
comment|// maps argument name to argument type
DECL|field|validArguments
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|validArguments
decl_stmt|;
comment|// maps aliases to actual method names
DECL|field|aliasesMap
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|aliasesMap
decl_stmt|;
comment|// nullable args
DECL|field|nullableArguments
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|nullableArguments
decl_stmt|;
comment|/**      * Create a helper to work with a {@link ApiMethod}, using optional method aliases.      * @param apiMethodEnum {@link ApiMethod} enumeration class      * @param aliases Aliases mapped to actual method names      * @param nullableArguments names of arguments that default to null value      */
DECL|method|ApiMethodHelper (Class<T> apiMethodEnum, Map<String, String> aliases, List<String> nullableArguments)
specifier|public
name|ApiMethodHelper
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|apiMethodEnum
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|aliases
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|nullableArguments
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|tmpMethodMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
name|tmpArgumentsMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|tmpValidArguments
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|tmpAliasesMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// validate ApiMethod Enum
if|if
condition|(
name|apiMethodEnum
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"ApiMethod enumeration cannot be null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|nullableArguments
operator|!=
literal|null
operator|&&
operator|!
name|nullableArguments
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|nullableArguments
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|nullableArguments
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|nullableArguments
operator|=
name|Collections
operator|.
name|emptyList
argument_list|()
expr_stmt|;
block|}
specifier|final
name|Map
argument_list|<
name|Pattern
argument_list|,
name|String
argument_list|>
name|aliasPatterns
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|alias
range|:
name|aliases
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|alias
operator|.
name|getKey
argument_list|()
operator|==
literal|null
operator|||
name|alias
operator|.
name|getValue
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Alias pattern and replacement cannot be null"
argument_list|)
throw|;
block|}
name|aliasPatterns
operator|.
name|put
argument_list|(
name|Pattern
operator|.
name|compile
argument_list|(
name|alias
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
name|alias
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing {}"
argument_list|,
name|apiMethodEnum
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|T
index|[]
name|methods
init|=
name|apiMethodEnum
operator|.
name|getEnumConstants
argument_list|()
decl_stmt|;
comment|// load lookup maps
for|for
control|(
name|T
name|method
range|:
name|methods
control|)
block|{
specifier|final
name|String
name|name
init|=
name|method
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// add method name aliases
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Pattern
argument_list|,
name|String
argument_list|>
name|aliasEntry
range|:
name|aliasPatterns
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|Matcher
name|matcher
init|=
name|aliasEntry
operator|.
name|getKey
argument_list|()
operator|.
name|matcher
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
comment|// add method name alias
name|String
name|alias
init|=
name|matcher
operator|.
name|replaceAll
argument_list|(
name|aliasEntry
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
comment|// convert first character to lowercase
assert|assert
name|alias
operator|.
name|length
argument_list|()
operator|>
literal|1
assert|;
specifier|final
name|char
name|firstChar
init|=
name|alias
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Character
operator|.
name|isLowerCase
argument_list|(
name|firstChar
argument_list|)
condition|)
block|{
specifier|final
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|Character
operator|.
name|toLowerCase
argument_list|(
name|firstChar
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|alias
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|alias
operator|=
name|builder
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|names
init|=
name|tmpAliasesMap
operator|.
name|get
argument_list|(
name|alias
argument_list|)
decl_stmt|;
if|if
condition|(
name|names
operator|==
literal|null
condition|)
block|{
name|names
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
name|tmpAliasesMap
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|names
argument_list|)
expr_stmt|;
block|}
name|names
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|// map method name to Enum
name|List
argument_list|<
name|T
argument_list|>
name|overloads
init|=
name|tmpMethodMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|overloads
operator|==
literal|null
condition|)
block|{
name|overloads
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|tmpMethodMap
operator|.
name|put
argument_list|(
name|method
operator|.
name|getName
argument_list|()
argument_list|,
name|overloads
argument_list|)
expr_stmt|;
block|}
name|overloads
operator|.
name|add
argument_list|(
name|method
argument_list|)
expr_stmt|;
comment|// add arguments for this method
name|List
argument_list|<
name|Object
argument_list|>
name|arguments
init|=
name|tmpArgumentsMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|arguments
operator|==
literal|null
condition|)
block|{
name|arguments
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|tmpArgumentsMap
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
block|}
comment|// process all arguments for this method
specifier|final
name|int
name|nArgs
init|=
name|method
operator|.
name|getArgNames
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|String
index|[]
name|argNames
init|=
name|method
operator|.
name|getArgNames
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|nArgs
index|]
argument_list|)
decl_stmt|;
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|argTypes
init|=
name|method
operator|.
name|getArgTypes
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|Class
index|[
name|nArgs
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nArgs
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|String
name|argName
init|=
name|argNames
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|argType
init|=
name|argTypes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|arguments
operator|.
name|contains
argument_list|(
name|argName
argument_list|)
condition|)
block|{
name|arguments
operator|.
name|add
argument_list|(
name|argType
argument_list|)
expr_stmt|;
name|arguments
operator|.
name|add
argument_list|(
name|argName
argument_list|)
expr_stmt|;
block|}
comment|// also collect argument names for all methods, and detect clashes here
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|previousType
init|=
name|tmpValidArguments
operator|.
name|get
argument_list|(
name|argName
argument_list|)
decl_stmt|;
if|if
condition|(
name|previousType
operator|!=
literal|null
operator|&&
name|previousType
operator|!=
name|argType
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Argument %s has ambiguous types (%s, %s) across methods!"
argument_list|,
name|name
argument_list|,
name|previousType
argument_list|,
name|argType
argument_list|)
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|previousType
operator|==
literal|null
condition|)
block|{
name|tmpValidArguments
operator|.
name|put
argument_list|(
name|argName
argument_list|,
name|argType
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// validate nullableArguments
if|if
condition|(
operator|!
name|tmpValidArguments
operator|.
name|keySet
argument_list|()
operator|.
name|containsAll
argument_list|(
name|this
operator|.
name|nullableArguments
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|unknowns
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|this
operator|.
name|nullableArguments
argument_list|)
decl_stmt|;
name|unknowns
operator|.
name|removeAll
argument_list|(
name|tmpValidArguments
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown nullable arguments "
operator|+
name|unknowns
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
comment|// validate aliases
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|tmpAliasesMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// look for aliases that match multiple methods
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|methodNames
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|methodNames
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// get mapped methods
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|aliasedMethods
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|methodName
range|:
name|methodNames
control|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|mappedMethods
init|=
name|tmpMethodMap
operator|.
name|get
argument_list|(
name|methodName
argument_list|)
decl_stmt|;
name|aliasedMethods
operator|.
name|addAll
argument_list|(
name|mappedMethods
argument_list|)
expr_stmt|;
block|}
comment|// look for argument overlap
for|for
control|(
name|T
name|method
range|:
name|aliasedMethods
control|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|argNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|method
operator|.
name|getArgNames
argument_list|()
argument_list|)
decl_stmt|;
name|argNames
operator|.
name|removeAll
argument_list|(
name|this
operator|.
name|nullableArguments
argument_list|)
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|T
argument_list|>
name|ambiguousMethods
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|otherMethod
range|:
name|aliasedMethods
control|)
block|{
if|if
condition|(
name|method
operator|!=
name|otherMethod
condition|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|otherArgsNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|otherMethod
operator|.
name|getArgNames
argument_list|()
argument_list|)
decl_stmt|;
name|otherArgsNames
operator|.
name|removeAll
argument_list|(
name|this
operator|.
name|nullableArguments
argument_list|)
expr_stmt|;
if|if
condition|(
name|argNames
operator|.
name|equals
argument_list|(
name|otherArgsNames
argument_list|)
condition|)
block|{
name|ambiguousMethods
operator|.
name|add
argument_list|(
name|method
argument_list|)
expr_stmt|;
name|ambiguousMethods
operator|.
name|add
argument_list|(
name|otherMethod
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|ambiguousMethods
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Ambiguous alias %s for methods %s"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|ambiguousMethods
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
block|}
name|this
operator|.
name|methodMap
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|tmpMethodMap
argument_list|)
expr_stmt|;
name|this
operator|.
name|argumentsMap
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|tmpArgumentsMap
argument_list|)
expr_stmt|;
name|this
operator|.
name|validArguments
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|tmpValidArguments
argument_list|)
expr_stmt|;
name|this
operator|.
name|aliasesMap
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|tmpAliasesMap
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found {} unique method names in {} methods"
argument_list|,
name|tmpMethodMap
operator|.
name|size
argument_list|()
argument_list|,
name|methods
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**      * Gets methods that match the given name and arguments.<p/>      * Note that the args list is a required subset of arguments for returned methods.      *      * @param name case sensitive method name or alias to lookup      * @return non-null unmodifiable list of methods that take all of the given arguments, empty if there is no match      */
DECL|method|getCandidateMethods (String name)
specifier|public
name|List
argument_list|<
name|ApiMethod
argument_list|>
name|getCandidateMethods
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|getCandidateMethods
argument_list|(
name|name
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Gets methods that match the given name and arguments.<p/>      * Note that the args list is a required subset of arguments for returned methods.      *      * @param name case sensitive method name or alias to lookup      * @param argNames unordered required argument names      * @return non-null unmodifiable list of methods that take all of the given arguments, empty if there is no match      */
DECL|method|getCandidateMethods (String name, Collection<String> argNames)
specifier|public
name|List
argument_list|<
name|ApiMethod
argument_list|>
name|getCandidateMethods
parameter_list|(
name|String
name|name
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|argNames
parameter_list|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|methods
init|=
name|methodMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|methods
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|aliasesMap
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|methods
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|method
range|:
name|aliasesMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
control|)
block|{
name|methods
operator|.
name|addAll
argument_list|(
name|methodMap
operator|.
name|get
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|methods
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No matching method for method {}"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
name|int
name|nArgs
init|=
name|argNames
operator|!=
literal|null
condition|?
name|argNames
operator|.
name|size
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|nArgs
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found {} methods for method {}"
argument_list|,
name|methods
operator|.
name|size
argument_list|()
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|methods
argument_list|)
return|;
block|}
else|else
block|{
specifier|final
name|List
argument_list|<
name|ApiMethod
argument_list|>
name|filteredSet
init|=
name|filterMethods
argument_list|(
name|methods
argument_list|,
name|MatchType
operator|.
name|SUBSET
argument_list|,
name|argNames
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found {} filtered methods for {}"
argument_list|,
name|filteredSet
operator|.
name|size
argument_list|()
argument_list|,
name|name
operator|+
name|argNames
operator|.
name|toString
argument_list|()
operator|.
name|replace
argument_list|(
literal|'['
argument_list|,
literal|'('
argument_list|)
operator|.
name|replace
argument_list|(
literal|']'
argument_list|,
literal|')'
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|filteredSet
return|;
block|}
block|}
comment|/**      * Filters a list of methods to those that take the given set of arguments.      *      * @param methods list of methods to filter      * @param matchType whether the arguments are an exact match, a subset or a super set of method args      * @return methods with arguments that satisfy the match type.<p/>      * For SUPER_SET match, if methods with exact match are found, methods that take a subset are ignored      */
DECL|method|filterMethods (List<? extends ApiMethod> methods, MatchType matchType)
specifier|public
name|List
argument_list|<
name|ApiMethod
argument_list|>
name|filterMethods
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|ApiMethod
argument_list|>
name|methods
parameter_list|,
name|MatchType
name|matchType
parameter_list|)
block|{
return|return
name|filterMethods
argument_list|(
name|methods
argument_list|,
name|matchType
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Filters a list of methods to those that take the given set of arguments.      *      * @param methods list of methods to filter      * @param matchType whether the arguments are an exact match, a subset or a super set of method args      * @param argNames argument names to filter the list      * @return methods with arguments that satisfy the match type.<p/>      * For SUPER_SET match, if methods with exact match are found, methods that take a subset are ignored      */
DECL|method|filterMethods (List<? extends ApiMethod> methods, MatchType matchType, Collection<String> argNames)
specifier|public
name|List
argument_list|<
name|ApiMethod
argument_list|>
name|filterMethods
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|ApiMethod
argument_list|>
name|methods
parameter_list|,
name|MatchType
name|matchType
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|argNames
parameter_list|)
block|{
comment|// original arguments
comment|// supplied arguments with missing nullable arguments
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|withNullableArgsList
decl_stmt|;
if|if
condition|(
operator|!
name|nullableArguments
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|withNullableArgsList
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|argNames
argument_list|)
expr_stmt|;
name|withNullableArgsList
operator|.
name|addAll
argument_list|(
name|nullableArguments
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|withNullableArgsList
operator|=
literal|null
expr_stmt|;
block|}
comment|// list of methods that have all args in the given names
name|List
argument_list|<
name|ApiMethod
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ApiMethod
argument_list|>
name|extraArgs
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|ApiMethod
argument_list|>
name|nullArgs
init|=
literal|null
decl_stmt|;
for|for
control|(
name|ApiMethod
name|method
range|:
name|methods
control|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|methodArgs
init|=
name|method
operator|.
name|getArgNames
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|matchType
condition|)
block|{
case|case
name|EXACT
case|:
comment|// method must take all args, and no more
if|if
condition|(
name|methodArgs
operator|.
name|containsAll
argument_list|(
name|argNames
argument_list|)
operator|&&
name|argNames
operator|.
name|containsAll
argument_list|(
name|methodArgs
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|method
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SUBSET
case|:
comment|// all args are required, method may take more
if|if
condition|(
name|methodArgs
operator|.
name|containsAll
argument_list|(
name|argNames
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|method
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
case|case
name|SUPER_SET
case|:
comment|// all method args must be present
if|if
condition|(
name|argNames
operator|.
name|containsAll
argument_list|(
name|methodArgs
argument_list|)
condition|)
block|{
if|if
condition|(
name|methodArgs
operator|.
name|containsAll
argument_list|(
name|argNames
argument_list|)
condition|)
block|{
comment|// prefer exact match to avoid unused args
name|result
operator|.
name|add
argument_list|(
name|method
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// if result is empty, add method to extra args list
if|if
condition|(
name|extraArgs
operator|==
literal|null
condition|)
block|{
name|extraArgs
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
comment|// method takes a subset, unused args
name|extraArgs
operator|.
name|add
argument_list|(
name|method
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|.
name|isEmpty
argument_list|()
operator|&&
name|extraArgs
operator|==
literal|null
condition|)
block|{
comment|// avoid looking for nullable args by checking for empty result and extraArgs
if|if
condition|(
name|withNullableArgsList
operator|!=
literal|null
operator|&&
name|withNullableArgsList
operator|.
name|containsAll
argument_list|(
name|methodArgs
argument_list|)
condition|)
block|{
if|if
condition|(
name|nullArgs
operator|==
literal|null
condition|)
block|{
name|nullArgs
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|nullArgs
operator|.
name|add
argument_list|(
name|method
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
name|List
argument_list|<
name|ApiMethod
argument_list|>
name|methodList
init|=
name|result
operator|.
name|isEmpty
argument_list|()
condition|?
name|extraArgs
operator|==
literal|null
condition|?
name|nullArgs
else|:
name|extraArgs
else|:
name|result
decl_stmt|;
comment|// preference order is exact match, matches with extra args, matches with null args
return|return
name|methodList
operator|!=
literal|null
condition|?
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|methodList
argument_list|)
else|:
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
comment|/**      * Gets argument types and names for all overloaded methods and aliases with the given name.      * @param name method name, either an exact name or an alias, exact matches are checked first      * @return list of arguments of the form Class type1, String name1, Class type2, String name2,...      */
DECL|method|getArguments (final String name)
specifier|public
name|List
argument_list|<
name|Object
argument_list|>
name|getArguments
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|arguments
init|=
name|argumentsMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|arguments
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|aliasesMap
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|arguments
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|method
range|:
name|aliasesMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
control|)
block|{
name|arguments
operator|.
name|addAll
argument_list|(
name|argumentsMap
operator|.
name|get
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|arguments
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|name
argument_list|)
throw|;
block|}
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|arguments
argument_list|)
return|;
block|}
comment|/**      * Get missing properties.      * @param methodName method name      * @param argNames available arguments      * @return Set of missing argument names      */
DECL|method|getMissingProperties (String methodName, Set<String> argNames)
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getMissingProperties
parameter_list|(
name|String
name|methodName
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|argNames
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|argsWithTypes
init|=
name|getArguments
argument_list|(
name|methodName
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|missingArgs
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|argsWithTypes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|+=
literal|2
control|)
block|{
specifier|final
name|String
name|name
init|=
operator|(
name|String
operator|)
name|argsWithTypes
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|argNames
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|missingArgs
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|missingArgs
return|;
block|}
comment|/**      * Returns alias map.      * @return alias names mapped to method names.      */
DECL|method|getAliases ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|getAliases
parameter_list|()
block|{
return|return
name|aliasesMap
return|;
block|}
comment|/**      * Returns argument types and names used by all methods.      * @return map with argument names as keys, and types as values      */
DECL|method|allArguments ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|allArguments
parameter_list|()
block|{
return|return
name|validArguments
return|;
block|}
comment|/**      * Returns argument names that can be set to null if not specified.      * @return list of argument names      */
DECL|method|getNullableArguments ()
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getNullableArguments
parameter_list|()
block|{
return|return
name|nullableArguments
return|;
block|}
comment|/**      * Get the type for the given argument name.      * @param argName argument name      * @return argument type      */
DECL|method|getType (String argName)
specifier|public
name|Class
argument_list|<
name|?
argument_list|>
name|getType
parameter_list|(
name|String
name|argName
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|type
init|=
name|validArguments
operator|.
name|get
argument_list|(
name|argName
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|argName
argument_list|)
throw|;
block|}
return|return
name|type
return|;
block|}
comment|// this method is always called with Enum value lists, so the cast inside is safe
comment|// the alternative of trying to convert ApiMethod and associated classes to generic classes would a bear!!!
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getHighestPriorityMethod (List<? extends ApiMethod> filteredMethods)
specifier|public
specifier|static
name|ApiMethod
name|getHighestPriorityMethod
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|ApiMethod
argument_list|>
name|filteredMethods
parameter_list|)
block|{
name|Comparable
argument_list|<
name|ApiMethod
argument_list|>
name|highest
init|=
literal|null
decl_stmt|;
for|for
control|(
name|ApiMethod
name|method
range|:
name|filteredMethods
control|)
block|{
if|if
condition|(
name|highest
operator|==
literal|null
operator|||
name|highest
operator|.
name|compareTo
argument_list|(
name|method
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|highest
operator|=
operator|(
name|Comparable
argument_list|<
name|ApiMethod
argument_list|>
operator|)
name|method
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ApiMethod
operator|)
name|highest
return|;
block|}
comment|/**      * Invokes given method with argument values from given properties.      *      * @param proxy Proxy object for invoke      * @param method method to invoke      * @param properties Map of arguments      * @return result of method invocation      * @throws org.apache.camel.RuntimeCamelException on errors      */
DECL|method|invokeMethod (Object proxy, ApiMethod method, Map<String, Object> properties)
specifier|public
specifier|static
name|Object
name|invokeMethod
parameter_list|(
name|Object
name|proxy
parameter_list|,
name|ApiMethod
name|method
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|properties
parameter_list|)
throws|throws
name|RuntimeCamelException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Invoking {} with arguments {}"
argument_list|,
name|method
operator|.
name|getName
argument_list|()
argument_list|,
name|properties
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|argNames
init|=
name|method
operator|.
name|getArgNames
argument_list|()
decl_stmt|;
specifier|final
name|Object
index|[]
name|values
init|=
operator|new
name|Object
index|[
name|argNames
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|argTypes
init|=
name|method
operator|.
name|getArgTypes
argument_list|()
decl_stmt|;
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|types
init|=
name|argTypes
operator|.
name|toArray
argument_list|(
operator|new
name|Class
index|[
name|argTypes
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|argNames
control|)
block|{
name|Object
name|value
init|=
name|properties
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|// is the parameter an array type?
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|types
index|[
name|index
index|]
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|type
init|=
name|types
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Collection
condition|)
block|{
comment|// convert collection to array
name|Collection
argument_list|<
name|?
argument_list|>
name|collection
init|=
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|value
decl_stmt|;
name|Object
name|array
init|=
name|Array
operator|.
name|newInstance
argument_list|(
name|type
operator|.
name|getComponentType
argument_list|()
argument_list|,
name|collection
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|array
operator|instanceof
name|Object
index|[]
condition|)
block|{
name|collection
operator|.
name|toArray
argument_list|(
operator|(
name|Object
index|[]
operator|)
name|array
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Object
name|el
range|:
name|collection
control|)
block|{
name|Array
operator|.
name|set
argument_list|(
name|array
argument_list|,
name|i
operator|++
argument_list|,
name|el
argument_list|)
expr_stmt|;
block|}
block|}
name|value
operator|=
name|array
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|getClass
argument_list|()
operator|.
name|isArray
argument_list|()
operator|&&
name|type
operator|.
name|getComponentType
argument_list|()
operator|.
name|isAssignableFrom
argument_list|(
name|value
operator|.
name|getClass
argument_list|()
operator|.
name|getComponentType
argument_list|()
argument_list|)
condition|)
block|{
comment|// convert derived array to super array if needed
if|if
condition|(
name|type
operator|.
name|getComponentType
argument_list|()
operator|!=
name|value
operator|.
name|getClass
argument_list|()
operator|.
name|getComponentType
argument_list|()
condition|)
block|{
specifier|final
name|int
name|size
init|=
name|Array
operator|.
name|getLength
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|Object
name|array
init|=
name|Array
operator|.
name|newInstance
argument_list|(
name|type
operator|.
name|getComponentType
argument_list|()
argument_list|,
name|size
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|Array
operator|.
name|set
argument_list|(
name|array
argument_list|,
name|i
argument_list|,
name|Array
operator|.
name|get
argument_list|(
name|value
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|array
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Cannot convert %s to %s"
argument_list|,
name|value
operator|.
name|getClass
argument_list|()
argument_list|,
name|type
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|values
index|[
name|index
operator|++
index|]
operator|=
name|value
expr_stmt|;
block|}
try|try
block|{
return|return
name|method
operator|.
name|getMethod
argument_list|()
operator|.
name|invoke
argument_list|(
name|proxy
argument_list|,
name|values
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|InvocationTargetException
condition|)
block|{
comment|// get API exception
specifier|final
name|Throwable
name|cause
init|=
name|e
operator|.
name|getCause
argument_list|()
decl_stmt|;
name|e
operator|=
operator|(
name|cause
operator|!=
literal|null
operator|)
condition|?
name|cause
else|:
name|e
expr_stmt|;
block|}
throw|throw
operator|new
name|RuntimeCamelException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Error invoking %s with %s: %s"
argument_list|,
name|method
operator|.
name|getName
argument_list|()
argument_list|,
name|properties
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|enum|MatchType
specifier|public
enum|enum
name|MatchType
block|{
DECL|enumConstant|EXACT
DECL|enumConstant|SUBSET
DECL|enumConstant|SUPER_SET
name|EXACT
block|,
name|SUBSET
block|,
name|SUPER_SET
block|}
block|}
end_class

end_unit

